"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/services/api.ts":
/*!*****************************!*\
  !*** ./src/services/api.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   confirmTransaction: function() { return /* binding */ confirmTransaction; },\n/* harmony export */   fetchFlightData: function() { return /* binding */ fetchFlightData; },\n/* harmony export */   getContractAddress: function() { return /* binding */ getContractAddress; },\n/* harmony export */   getFlightEventsFromChain: function() { return /* binding */ getFlightEventsFromChain; },\n/* harmony export */   prepareTransaction: function() { return /* binding */ prepareTransaction; },\n/* harmony export */   traceFlight: function() { return /* binding */ traceFlight; },\n/* harmony export */   verifyHash: function() { return /* binding */ verifyHash; }\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n// API Client configuration\nconst API_URL = process.env.NEXT_PUBLIC_API_URL || \"http://localhost:8000/api\";\nconst api = axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].create({\n    baseURL: API_URL,\n    headers: {\n        \"Content-Type\": \"application/json\"\n    }\n});\nconst fetchFlightData = async function(flightIdOrNumber) {\n    let retries = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;\n    for(let attempt = 0; attempt < retries; attempt++){\n        try {\n            console.log(\"Fetching flight data for: \".concat(flightIdOrNumber, \" (attempt \").concat(attempt + 1, \"/\").concat(retries, \")\"));\n            // Try to search by flight number first (handles both IDs and flight numbers)\n            const searchRes = await api.get(\"/search-flight/\".concat(flightIdOrNumber));\n            if (searchRes.data.found && searchRes.data.flight) {\n                const flight = searchRes.data.flight;\n                console.log(\"Flight found: ID=\".concat(flight.id, \", Number=\").concat(flight.flight_number));\n                // Fetch related data in parallel with timeout protection\n                try {\n                    var _eventsRes_value, _delayRes_value, _blockchainRes_value, _baselineRes_value;\n                    const fetchPromises = [\n                        api.get(\"/flight/\".concat(flight.id, \"/events\")).catch((e)=>({\n                                status: \"rejected\",\n                                reason: e\n                            })),\n                        api.get(\"/flight/\".concat(flight.id, \"/delay-analysis\")).catch((e)=>({\n                                status: \"rejected\",\n                                reason: e\n                            })),\n                        api.get(\"/flight/\".concat(flight.id, \"/blockchain-events\")).catch((e)=>({\n                                status: \"rejected\",\n                                reason: e\n                            })),\n                        api.get(\"/flight/\".concat(flight.id, \"/historical-baseline\")).catch((e)=>({\n                                status: \"rejected\",\n                                reason: e\n                            }))\n                    ];\n                    // Add timeout to prevent hanging\n                    const timeoutPromise = new Promise((_, reject)=>setTimeout(()=>reject(new Error(\"Data fetch timeout\")), 10000));\n                    const [eventsRes, delayRes, blockchainRes, baselineRes] = await Promise.race([\n                        Promise.allSettled(fetchPromises),\n                        timeoutPromise\n                    ]);\n                    // Handle results\n                    const events = (eventsRes === null || eventsRes === void 0 ? void 0 : eventsRes.status) === \"fulfilled\" ? eventsRes.value.data : (eventsRes === null || eventsRes === void 0 ? void 0 : (_eventsRes_value = eventsRes.value) === null || _eventsRes_value === void 0 ? void 0 : _eventsRes_value.data) || [];\n                    const delayAnalysis = (delayRes === null || delayRes === void 0 ? void 0 : delayRes.status) === \"fulfilled\" ? delayRes.value.data : (delayRes === null || delayRes === void 0 ? void 0 : (_delayRes_value = delayRes.value) === null || _delayRes_value === void 0 ? void 0 : _delayRes_value.data) || null;\n                    const blockchainEvents = (blockchainRes === null || blockchainRes === void 0 ? void 0 : blockchainRes.status) === \"fulfilled\" ? blockchainRes.value.data : (blockchainRes === null || blockchainRes === void 0 ? void 0 : (_blockchainRes_value = blockchainRes.value) === null || _blockchainRes_value === void 0 ? void 0 : _blockchainRes_value.data) || [];\n                    const historicalBaseline = (baselineRes === null || baselineRes === void 0 ? void 0 : baselineRes.status) === \"fulfilled\" ? baselineRes.value.data : (baselineRes === null || baselineRes === void 0 ? void 0 : (_baselineRes_value = baselineRes.value) === null || _baselineRes_value === void 0 ? void 0 : _baselineRes_value.data) || null;\n                    return {\n                        ...flight,\n                        events: Array.isArray(events) ? events : [],\n                        delayAnalysis: delayAnalysis,\n                        blockchainEvents: Array.isArray(blockchainEvents) ? blockchainEvents : [],\n                        historicalBaseline: historicalBaseline\n                    };\n                } catch (error) {\n                    // If flight exists but related data fails, still return the flight with empty arrays\n                    console.warn(\"Some flight data failed to load (using fallbacks):\", error.message);\n                    return {\n                        ...flight,\n                        events: [],\n                        delayAnalysis: null,\n                        blockchainEvents: [],\n                        historicalBaseline: null\n                    };\n                }\n            }\n            // If not found and we have retries left, wait and try again\n            if (attempt < retries - 1) {\n                console.log(\"Flight not found, retrying... (\".concat(attempt + 1, \"/\").concat(retries, \")\"));\n                await new Promise((resolve)=>setTimeout(resolve, 1000)); // Wait 1s between retries\n                continue;\n            }\n            throw new Error(searchRes.data.message || 'Flight \"'.concat(flightIdOrNumber, '\" not found'));\n        } catch (error) {\n            console.error(\"Flight fetch attempt \".concat(attempt + 1, \" failed:\"), error.message);\n            if (attempt === retries - 1) {\n                // Last attempt failed\n                throw error;\n            }\n            // Wait before retry\n            await new Promise((resolve)=>setTimeout(resolve, 1000));\n        }\n    }\n};\nconst verifyHash = async (hash)=>{\n    const res = await api.get(\"/blockchain/verify/\".concat(hash));\n    return res.data;\n};\nconst traceFlight = async (flightNumber)=>{\n    const res = await api.get(\"/search-flight/trace/\".concat(flightNumber));\n    return res.data;\n};\nconst prepareTransaction = async (eventId)=>{\n    const res = await api.get(\"/blockchain/prepare-transaction/\".concat(eventId));\n    return res.data;\n};\nconst getFlightEventsFromChain = async (flightNumber)=>{\n    const res = await api.get(\"/blockchain/flight-events/\".concat(flightNumber));\n    return res.data;\n};\nconst getContractAddress = async ()=>{\n    const res = await api.get(\"/blockchain/stats\");\n    return res.data.contract_address;\n};\nconst confirmTransaction = async (eventId, txHash, blockNumber)=>{\n    const res = await api.post(\"/blockchain/confirm-transaction\", {\n        event_id: eventId,\n        tx_hash: txHash,\n        block_number: blockNumber\n    });\n    return res.data;\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (api);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9hcGkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQTBCO0FBRTFCLDJCQUEyQjtBQUMzQixNQUFNQyxVQUFVQyxPQUFPQSxDQUFDQyxHQUFHLENBQUNDLG1CQUFtQixJQUFJO0FBRW5ELE1BQU1DLE1BQU1MLDZDQUFLQSxDQUFDTSxNQUFNLENBQUM7SUFDckJDLFNBQVNOO0lBQ1RPLFNBQVM7UUFDTCxnQkFBZ0I7SUFDcEI7QUFDSjtBQUVPLE1BQU1DLGtCQUFrQixlQUFPQztRQUEwQkMsMkVBQVU7SUFDdEUsSUFBSyxJQUFJQyxVQUFVLEdBQUdBLFVBQVVELFNBQVNDLFVBQVc7UUFDaEQsSUFBSTtZQUNBQyxRQUFRQyxHQUFHLENBQUMsNkJBQTBERixPQUE3QkYsa0JBQWlCLGNBQTJCQyxPQUFmQyxVQUFVLEdBQUUsS0FBVyxPQUFSRCxTQUFRO1lBRTdGLDZFQUE2RTtZQUM3RSxNQUFNSSxZQUFZLE1BQU1WLElBQUlXLEdBQUcsQ0FBQyxrQkFBbUMsT0FBakJOO1lBRWxELElBQUlLLFVBQVVFLElBQUksQ0FBQ0MsS0FBSyxJQUFJSCxVQUFVRSxJQUFJLENBQUNFLE1BQU0sRUFBRTtnQkFDL0MsTUFBTUEsU0FBU0osVUFBVUUsSUFBSSxDQUFDRSxNQUFNO2dCQUNwQ04sUUFBUUMsR0FBRyxDQUFDLG9CQUF5Q0ssT0FBckJBLE9BQU9DLEVBQUUsRUFBQyxhQUFnQyxPQUFyQkQsT0FBT0UsYUFBYTtnQkFFekUseURBQXlEO2dCQUN6RCxJQUFJO3dCQW1CMkVDLGtCQUNLQyxpQkFDYUMsc0JBQ0ZDO29CQXJCM0YsTUFBTUMsZ0JBQWdCO3dCQUNsQnJCLElBQUlXLEdBQUcsQ0FBQyxXQUFxQixPQUFWRyxPQUFPQyxFQUFFLEVBQUMsWUFBVU8sS0FBSyxDQUFDQyxDQUFBQSxJQUFNO2dDQUFFQyxRQUFRO2dDQUFZQyxRQUFRRjs0QkFBRTt3QkFDbkZ2QixJQUFJVyxHQUFHLENBQUMsV0FBcUIsT0FB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UjtRQUNWUyxTQUFTSjtRQUNUSyxjQUFjSjtJQUNsQjtJQUNBLE9BQU9WLElBQUluQyxJQUFJO0FBQ25CLEVBQUU7QUFFRiwrREFBZVosR0FBR0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc2VydmljZXMvYXBpLnRzPzk1NmUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcblxuLy8gQVBJIENsaWVudCBjb25maWd1cmF0aW9uXG5jb25zdCBBUElfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDo4MDAwL2FwaSc7XG5cbmNvbnN0IGFwaSA9IGF4aW9zLmNyZWF0ZSh7XG4gICAgYmFzZVVSTDogQVBJX1VSTCxcbiAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgfSxcbn0pO1xuXG5leHBvcnQgY29uc3QgZmV0Y2hGbGlnaHREYXRhID0gYXN5bmMgKGZsaWdodElkT3JOdW1iZXI6IHN0cmluZywgcmV0cmllcyA9IDMpID0+IHtcbiAgICBmb3IgKGxldCBhdHRlbXB0ID0gMDsgYXR0ZW1wdCA8IHJldHJpZXM7IGF0dGVtcHQrKykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYEZldGNoaW5nIGZsaWdodCBkYXRhIGZvcjogJHtmbGlnaHRJZE9yTnVtYmVyfSAoYXR0ZW1wdCAke2F0dGVtcHQgKyAxfS8ke3JldHJpZXN9KWApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBUcnkgdG8gc2VhcmNoIGJ5IGZsaWdodCBudW1iZXIgZmlyc3QgKGhhbmRsZXMgYm90aCBJRHMgYW5kIGZsaWdodCBudW1iZXJzKVxuICAgICAgICAgICAgY29uc3Qgc2VhcmNoUmVzID0gYXdhaXQgYXBpLmdldChgL3NlYXJjaC1mbGlnaHQvJHtmbGlnaHRJZE9yTnVtYmVyfWApO1xuXG4gICAgICAgICAgICBpZiAoc2VhcmNoUmVzLmRhdGEuZm91bmQgJiYgc2VhcmNoUmVzLmRhdGEuZmxpZ2h0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmxpZ2h0ID0gc2VhcmNoUmVzLmRhdGEuZmxpZ2h0O1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBGbGlnaHQgZm91bmQ6IElEPSR7ZmxpZ2h0LmlkfSwgTnVtYmVyPSR7ZmxpZ2h0LmZsaWdodF9udW1iZXJ9YCk7XG5cbiAgICAgICAgICAgICAgICAvLyBGZXRjaCByZWxhdGVkIGRhdGEgaW4gcGFyYWxsZWwgd2l0aCB0aW1lb3V0IHByb3RlY3Rpb25cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmZXRjaFByb21pc2VzID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBpLmdldChgL2ZsaWdodC8ke2ZsaWdodC5pZH0vZXZlbnRzYCkuY2F0Y2goZSA9PiAoeyBzdGF0dXM6ICdyZWplY3RlZCcsIHJlYXNvbjogZSB9KSksXG4gICAgICAgICAgICAgICAgICAgICAgICBhcGkuZ2V0KGAvZmxpZ2h0LyR7ZmxpZ2h0LmlkfS9kZWxheS1hbmFseXNpc2ApLmNhdGNoKGUgPT4gKHsgc3RhdHVzOiAncmVqZWN0ZWQnLCByZWFzb246IGUgfSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXBpLmdldChgL2ZsaWdodC8ke2ZsaWdodC5pZH0vYmxvY2tjaGFpbi1ldmVudHNgKS5jYXRjaChlID0+ICh7IHN0YXR1czogJ3JlamVjdGVkJywgcmVhc29uOiBlIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5nZXQoYC9mbGlnaHQvJHtmbGlnaHQuaWR9L2hpc3RvcmljYWwtYmFzZWxpbmVgKS5jYXRjaChlID0+ICh7IHN0YXR1czogJ3JlamVjdGVkJywgcmVhc29uOiBlIH0pKVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRpbWVvdXQgdG8gcHJldmVudCBoYW5naW5nXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVvdXRQcm9taXNlID0gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4gXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChuZXcgRXJyb3IoJ0RhdGEgZmV0Y2ggdGltZW91dCcpKSwgMTAwMDApXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBbZXZlbnRzUmVzLCBkZWxheVJlcywgYmxvY2tjaGFpblJlcywgYmFzZWxpbmVSZXNdID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFByb21pc2UuYWxsU2V0dGxlZChmZXRjaFByb21pc2VzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXRQcm9taXNlXG4gICAgICAgICAgICAgICAgICAgIF0pIGFzIGFueTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgcmVzdWx0c1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBldmVudHMgPSBldmVudHNSZXM/LnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcgPyBldmVudHNSZXMudmFsdWUuZGF0YSA6IChldmVudHNSZXM/LnZhbHVlPy5kYXRhIHx8IFtdKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVsYXlBbmFseXNpcyA9IGRlbGF5UmVzPy5zdGF0dXMgPT09ICdmdWxmaWxsZWQnID8gZGVsYXlSZXMudmFsdWUuZGF0YSA6IChkZWxheVJlcz8udmFsdWU/LmRhdGEgfHwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrY2hhaW5FdmVudHMgPSBibG9ja2NoYWluUmVzPy5zdGF0dXMgPT09ICdmdWxmaWxsZWQnID8gYmxvY2tjaGFpblJlcy52YWx1ZS5kYXRhIDogKGJsb2NrY2hhaW5SZXM/LnZhbHVlPy5kYXRhIHx8IFtdKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGlzdG9yaWNhbEJhc2VsaW5lID0gYmFzZWxpbmVSZXM/LnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcgPyBiYXNlbGluZVJlcy52YWx1ZS5kYXRhIDogKGJhc2VsaW5lUmVzPy52YWx1ZT8uZGF0YSB8fCBudWxsKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uZmxpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzOiBBcnJheS5pc0FycmF5KGV2ZW50cykgPyBldmVudHMgOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGF5QW5hbHlzaXM6IGRlbGF5QW5hbHlzaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja2NoYWluRXZlbnRzOiBBcnJheS5pc0FycmF5KGJsb2NrY2hhaW5FdmVudHMpID8gYmxvY2tjaGFpbkV2ZW50cyA6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGlzdG9yaWNhbEJhc2VsaW5lOiBoaXN0b3JpY2FsQmFzZWxpbmUsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBmbGlnaHQgZXhpc3RzIGJ1dCByZWxhdGVkIGRhdGEgZmFpbHMsIHN0aWxsIHJldHVybiB0aGUgZmxpZ2h0IHdpdGggZW1wdHkgYXJyYXlzXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignU29tZSBmbGlnaHQgZGF0YSBmYWlsZWQgdG8gbG9hZCAodXNpbmcgZmFsbGJhY2tzKTonLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmZsaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50czogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxheUFuYWx5c2lzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tjaGFpbkV2ZW50czogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBoaXN0b3JpY2FsQmFzZWxpbmU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBub3QgZm91bmQgYW5kIHdlIGhhdmUgcmV0cmllcyBsZWZ0LCB3YWl0IGFuZCB0cnkgYWdhaW5cbiAgICAgICAgICAgIGlmIChhdHRlbXB0IDwgcmV0cmllcyAtIDEpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRmxpZ2h0IG5vdCBmb3VuZCwgcmV0cnlpbmcuLi4gKCR7YXR0ZW1wdCArIDF9LyR7cmV0cmllc30pYCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKTsgLy8gV2FpdCAxcyBiZXR3ZWVuIHJldHJpZXNcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHNlYXJjaFJlcy5kYXRhLm1lc3NhZ2UgfHwgYEZsaWdodCBcIiR7ZmxpZ2h0SWRPck51bWJlcn1cIiBub3QgZm91bmRgKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRmxpZ2h0IGZldGNoIGF0dGVtcHQgJHthdHRlbXB0ICsgMX0gZmFpbGVkOmAsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKGF0dGVtcHQgPT09IHJldHJpZXMgLSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gTGFzdCBhdHRlbXB0IGZhaWxlZFxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2FpdCBiZWZvcmUgcmV0cnlcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5leHBvcnQgY29uc3QgdmVyaWZ5SGFzaCA9IGFzeW5jIChoYXNoOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkuZ2V0KGAvYmxvY2tjaGFpbi92ZXJpZnkvJHtoYXNofWApO1xuICAgIHJldHVybiByZXMuZGF0YTtcbn07XG5cbmV4cG9ydCBjb25zdCB0cmFjZUZsaWdodCA9IGFzeW5jIChmbGlnaHROdW1iZXI6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5nZXQoYC9zZWFyY2gtZmxpZ2h0L3RyYWNlLyR7ZmxpZ2h0TnVtYmVyfWApO1xuICAgIHJldHVybiByZXMuZGF0YTtcbn07XG5cbmV4cG9ydCBjb25zdCBwcmVwYXJlVHJhbnNhY3Rpb24gPSBhc3luYyAoZXZlbnRJZDogbnVtYmVyKSA9PiB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXBpLmdldChgL2Jsb2NrY2hhaW4vcHJlcGFyZS10cmFuc2FjdGlvbi8ke2V2ZW50SWR9YCk7XG4gICAgcmV0dXJuIHJlcy5kYXRhO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldEZsaWdodEV2ZW50c0Zyb21DaGFpbiA9IGFzeW5jIChmbGlnaHROdW1iZXI6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5nZXQoYC9ibG9ja2NoYWluL2ZsaWdodC1ldmVudHMvJHtmbGlnaHROdW1iZXJ9YCk7XG4gICAgcmV0dXJuIHJlcy5kYXRhO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldENvbnRyYWN0QWRkcmVzcyA9IGFzeW5jICgpID0+IHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkuZ2V0KCcvYmxvY2tjaGFpbi9zdGF0cycpO1xuICAgIHJldHVybiByZXMuZGF0YS5jb250cmFjdF9hZGRyZXNzO1xufTtcblxuZXhwb3J0IGNvbnN0IGNvbmZpcm1UcmFuc2FjdGlvbiA9IGFzeW5jIChldmVudElkOiBudW1iZXIsIHR4SGFzaDogc3RyaW5nLCBibG9ja051bWJlcj86IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaS5wb3N0KCcvYmxvY2tjaGFpbi9jb25maXJtLXRyYW5zYWN0aW9uJywge1xuICAgICAgICBldmVudF9pZDogZXZlbnRJZCxcbiAgICAgICAgdHhfaGFzaDogdHhIYXNoLFxuICAgICAgICBibG9ja19udW1iZXI6IGJsb2NrTnVtYmVyXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcy5kYXRhO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgYXBpO1xuIl0sIm5hbWVzIjpbImF4aW9zIiwiQVBJX1VSTCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfVVJMIiwiYXBpIiwiY3JlYXRlIiwiYmFzZVVSTCIsImhlYWRlcnMiLCJmZXRjaEZsaWdodERhdGEiLCJmbGlnaHRJZE9yTnVtYmVyIiwicmV0cmllcyIsImF0dGVtcHQiLCJjb25zb2xlIiwibG9nIiwic2VhcmNoUmVzIiwiZ2V0IiwiZGF0YSIsImZvdW5kIiwiZmxpZ2h0IiwiaWQiLCJmbGlnaHRfbnVtYmVyIiwiZXZlbnRzUmVzIiwiZGVsYXlSZXMiLCJibG9ja2NoYWluUmVzIiwiYmFzZWxpbmVSZXMiLCJmZXRjaFByb21pc2VzIiwiY2F0Y2giLCJlIiwic3RhdHVzIiwicmVhc29uIiwidGltZW91dFByb21pc2UiLCJQcm9taXNlIiwiXyIsInJlamVjdCIsInNldFRpbWVvdXQiLCJFcnJvciIsInJhY2UiLCJhbGxTZXR0bGVkIiwiZXZlbnRzIiwidmFsdWUiLCJkZWxheUFuYWx5c2lzIiwiYmxvY2tjaGFpbkV2ZW50cyIsImhpc3RvcmljYWxCYXNlbGluZSIsIkFycmF5IiwiaXNBcnJheSIsImVycm9yIiwid2FybiIsIm1lc3NhZ2UiLCJyZXNvbHZlIiwidmVyaWZ5SGFzaCIsImhhc2giLCJyZXMiLCJ0cmFjZUZsaWdodCIsImZsaWdodE51bWJlciIsInByZXBhcmVUcmFuc2FjdGlvbiIsImV2ZW50SWQiLCJnZXRGbGlnaHRFdmVudHNGcm9tQ2hhaW4iLCJnZXRDb250cmFjdEFkZHJlc3MiLCJjb250cmFjdF9hZGRyZXNzIiwiY29uZmlybVRyYW5zYWN0aW9uIiwidHhIYXNoIiwiYmxvY2tOdW1iZXIiLCJwb3N0IiwiZXZlbnRfaWQiLCJ0eF9oYXNoIiwiYmxvY2tfbnVtYmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/api.ts\n"));

/***/ })

});