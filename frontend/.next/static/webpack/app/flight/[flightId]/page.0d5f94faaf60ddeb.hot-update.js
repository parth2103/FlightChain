"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/flight/[flightId]/page",{

/***/ "(app-pages-browser)/./node_modules/antd/es/app/context.js":
/*!*********************************************!*\
  !*** ./node_modules/antd/es/app/context.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AppConfigContext: function() { return /* binding */ AppConfigContext; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nconst AppConfigContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext({});\nconst AppContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext({\n    message: {},\n    notification: {},\n    modal: {}\n});\n/* harmony default export */ __webpack_exports__[\"default\"] = (AppContext);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hbnRkL2VzL2FwcC9jb250ZXh0LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEwQjtBQUNuQixNQUFNQyxtQkFBbUIsV0FBVyxHQUFFRCwwREFBbUIsQ0FBQyxDQUFDLEdBQUc7QUFDckUsTUFBTUcsYUFBYSxXQUFXLEdBQUVILDBEQUFtQixDQUFDO0lBQ2xESSxTQUFTLENBQUM7SUFDVkMsY0FBYyxDQUFDO0lBQ2ZDLE9BQU8sQ0FBQztBQUNWO0FBQ0EsK0RBQWVILFVBQVVBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FudGQvZXMvYXBwL2NvbnRleHQuanM/ZWMyNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuZXhwb3J0IGNvbnN0IEFwcENvbmZpZ0NvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCh7fSk7XG5jb25zdCBBcHBDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICBtZXNzYWdlOiB7fSxcbiAgbm90aWZpY2F0aW9uOiB7fSxcbiAgbW9kYWw6IHt9XG59KTtcbmV4cG9ydCBkZWZhdWx0IEFwcENvbnRleHQ7Il0sIm5hbWVzIjpbIlJlYWN0IiwiQXBwQ29uZmlnQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJBcHBDb250ZXh0IiwibWVzc2FnZSIsIm5vdGlmaWNhdGlvbiIsIm1vZGFsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/antd/es/app/context.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/antd/es/message/PurePanel.js":
/*!***************************************************!*\
  !*** ./node_modules/antd/es/message/PurePanel.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PureContent: function() { return /* binding */ PureContent; },\n/* harmony export */   TypeIcon: function() { return /* binding */ TypeIcon; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ant_design_icons_es_icons_CheckCircleFilled__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ant-design/icons/es/icons/CheckCircleFilled */ \"(app-pages-browser)/./node_modules/@ant-design/icons/es/icons/CheckCircleFilled.js\");\n/* harmony import */ var _ant_design_icons_es_icons_CloseCircleFilled__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ant-design/icons/es/icons/CloseCircleFilled */ \"(app-pages-browser)/./node_modules/@ant-design/icons/es/icons/CloseCircleFilled.js\");\n/* harmony import */ var _ant_design_icons_es_icons_ExclamationCircleFilled__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ant-design/icons/es/icons/ExclamationCircleFilled */ \"(app-pages-browser)/./node_modules/@ant-design/icons/es/icons/ExclamationCircleFilled.js\");\n/* harmony import */ var _ant_design_icons_es_icons_InfoCircleFilled__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ant-design/icons/es/icons/InfoCircleFilled */ \"(app-pages-browser)/./node_modules/@ant-design/icons/es/icons/InfoCircleFilled.js\");\n/* harmony import */ var _ant_design_icons_es_icons_LoadingOutlined__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ant-design/icons/es/icons/LoadingOutlined */ \"(app-pages-browser)/./node_modules/@ant-design/icons/es/icons/LoadingOutlined.js\");\n/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classnames */ \"(app-pages-browser)/./node_modules/classnames/index.js\");\n/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var rc_notification__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rc-notification */ \"(app-pages-browser)/./node_modules/rc-notification/es/index.js\");\n/* harmony import */ var _config_provider__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../config-provider */ \"(app-pages-browser)/./node_modules/antd/es/config-provider/context.js\");\n/* harmony import */ var _config_provider_hooks_useCSSVarCls__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../config-provider/hooks/useCSSVarCls */ \"(app-pages-browser)/./node_modules/antd/es/config-provider/hooks/useCSSVarCls.js\");\n/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./style */ \"(app-pages-browser)/./node_modules/antd/es/message/style/index.js\");\n/* __next_internal_client_entry_do_not_use__ TypeIcon,PureContent,default auto */ var _s = $RefreshSig$();\nvar __rest = undefined && undefined.__rest || function(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n};\n\n\n\n\n\n\n\n\n\n\n\nconst TypeIcon = {\n    info: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_ant_design_icons_es_icons_InfoCircleFilled__WEBPACK_IMPORTED_MODULE_3__[\"default\"], null),\n    success: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_ant_design_icons_es_icons_CheckCircleFilled__WEBPACK_IMPORTED_MODULE_4__[\"default\"], null),\n    error: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_ant_design_icons_es_icons_CloseCircleFilled__WEBPACK_IMPORTED_MODULE_5__[\"default\"], null),\n    warning: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_ant_design_icons_es_icons_ExclamationCircleFilled__WEBPACK_IMPORTED_MODULE_6__[\"default\"], null),\n    loading: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_ant_design_icons_es_icons_LoadingOutlined__WEBPACK_IMPORTED_MODULE_7__[\"default\"], null)\n};\nconst PureContent = (param)=>{\n    let { prefixCls, type, icon, children } = param;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: classnames__WEBPACK_IMPORTED_MODULE_1___default()(\"\".concat(prefixCls, \"-custom-content\"), \"\".concat(prefixCls, \"-\").concat(type))\n    }, icon || TypeIcon[type], /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", null, children));\n};\n_c = PureContent;\n/** @private Internal Component. Do not use in your production. */ const PurePanel = (props)=>{\n    _s();\n    const { prefixCls: staticPrefixCls, className, type, icon, content } = props, restProps = __rest(props, [\n        \"prefixCls\",\n        \"className\",\n        \"type\",\n        \"icon\",\n        \"content\"\n    ]);\n    const { getPrefixCls } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(_config_provider__WEBPACK_IMPORTED_MODULE_8__.ConfigContext);\n    const prefixCls = staticPrefixCls || getPrefixCls(\"message\");\n    const rootCls = (0,_config_provider_hooks_useCSSVarCls__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(prefixCls);\n    const [wrapCSSVar, hashId, cssVarCls] = (0,_style__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(prefixCls, rootCls);\n    return wrapCSSVar(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(rc_notification__WEBPACK_IMPORTED_MODULE_2__.Notice, Object.assign({}, restProps, {\n        prefixCls: prefixCls,\n        className: classnames__WEBPACK_IMPORTED_MODULE_1___default()(className, hashId, \"\".concat(prefixCls, \"-notice-pure-panel\"), cssVarCls, rootCls),\n        eventKey: \"pure\",\n        duration: null,\n        content: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PureContent, {\n            prefixCls: prefixCls,\n            type: type,\n            icon: icon\n        }, content)\n    })));\n};\n_s(PurePanel, \"8LLuSnePge7vg8whte4MxRV/pwA=\", false, function() {\n    return [\n        _config_provider_hooks_useCSSVarCls__WEBPACK_IMPORTED_MODULE_9__[\"default\"],\n        _style__WEBPACK_IMPORTED_MODULE_10__[\"default\"]\n    ];\n});\n_c1 = PurePanel;\n/* harmony default export */ __webpack_exports__[\"default\"] = (PurePanel);\nvar _c, _c1;\n$RefreshReg$(_c, \"PureContent\");\n$RefreshReg$(_c1, \"PurePanel\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hbnRkL2VzL21lc3NhZ2UvUHVyZVBhbmVsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQSxJQUFJQSxTQUFTLFNBQUksSUFBSSxTQUFJLENBQUNBLE1BQU0sSUFBSSxTQUFVQyxDQUFDLEVBQUVDLENBQUM7SUFDaEQsSUFBSUMsSUFBSSxDQUFDO0lBQ1QsSUFBSyxJQUFJQyxLQUFLSCxFQUFHLElBQUlJLE9BQU9DLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNQLEdBQUdHLE1BQU1GLEVBQUVPLE9BQU8sQ0FBQ0wsS0FBSyxHQUFHRCxDQUFDLENBQUNDLEVBQUUsR0FBR0gsQ0FBQyxDQUFDRyxFQUFFO0lBQ2hHLElBQUlILEtBQUssUUFBUSxPQUFPSSxPQUFPSyxxQkFBcUIsS0FBSyxZQUFZLElBQUssSUFBSUMsSUFBSSxHQUFHUCxJQUFJQyxPQUFPSyxxQkFBcUIsQ0FBQ1QsSUFBSVUsSUFBSVAsRUFBRVEsTUFBTSxFQUFFRCxJQUFLO1FBQzNJLElBQUlULEVBQUVPLE9BQU8sQ0FBQ0wsQ0FBQyxDQUFDTyxFQUFFLElBQUksS0FBS04sT0FBT0MsU0FBUyxDQUFDTyxvQkFBb0IsQ0FBQ0wsSUFBSSxDQUFDUCxHQUFHRyxDQUFDLENBQUNPLEVBQUUsR0FBR1IsQ0FBQyxDQUFDQyxDQUFDLENBQUNPLEVBQUUsQ0FBQyxHQUFHVixDQUFDLENBQUNHLENBQUMsQ0FBQ08sRUFBRSxDQUFDO0lBQ25HO0lBQ0EsT0FBT1I7QUFDVDtBQUMrQjtBQUM4QztBQUNBO0FBQ1k7QUFDZDtBQUNGO0FBQ3JDO0FBQ0s7QUFDVTtBQUNjO0FBQ2xDO0FBQ3hCLE1BQU1zQixXQUFXO0lBQ3RCQyxNQUFNLFdBQVcsR0FBRVosZ0RBQW1CLENBQUNJLG1GQUFnQkEsRUFBRTtJQUN6RFUsU0FBUyxXQUFXLEdBQUVkLGdEQUFtQixDQUFDQyxvRkFBaUJBLEVBQUU7SUFDN0RjLE9BQU8sV0FBVyxHQUFFZixnREFBbUIsQ0FBQ0Usb0ZBQWlCQSxFQUFFO0lBQzNEYyxTQUFTLFdBQVcsR0FBRWhCLGdEQUFtQixDQUFDRywwRkFBdUJBLEVBQUU7SUFDbkVjLFNBQVMsV0FBVyxHQUFFakIsZ0RBQW1CLENBQUNLLGtGQUFlQSxFQUFFO0FBQzdELEVBQUU7QUFDSyxNQUFNYSxjQUFjO1FBQUMsRUFDMUJDLFNBQVMsRUFDVEMsSUFBSSxFQUNKQyxJQUFJLEVBQ0pDLFFBQVEsRUFDVDtXQUFNLFdBQVcsR0FBRXRCLGdEQUFtQixDQUFDLE9BQU87UUFDN0N1QixXQUFXakIsaURBQVVBLENBQUMsR0FBYSxPQUFWYSxXQUFVLG9CQUFrQixHQUFnQkMsT0FBYkQsV0FBVSxLQUFRLE9BQUxDO0lBQ3ZFLEdBQUdDLFFBQVFWLFFBQVEsQ0FBQ1MsS0FBSyxFQUFFLFdBQVcsR0FBRXBCLGdEQUFtQixDQUFDLFFBQVEsTUFBTXNCO0VBQVk7S0FQekVKO0FBUWIsZ0VBQWdFLEdBQ2hFLE1BQU1NLFlBQVlDLENBQUFBOztJQUNoQixNQUFNLEVBQ0ZOLFdBQVdPLGVBQWUsRUFDMUJILFNBQVMsRUFDVEgsSUFBSSxFQUNKQyxJQUFJLEVBQ0pNLE9BQU8sRUFDUixHQUFHRixPQUNKRyxZQUFZMUMsT0FBT3VDLE9BQU87UUFBQztRQUFhO1FBQWE7UUFBUTtRQUFRO0tBQVU7SUFDakYsTUFBTSxFQUNKSSxZQUFZLEVBQ2IsR0FBRzdCLDZDQUFnQixDQUFDUSwyREFBYUE7SUFDbEMsTUFBTVcsWUFBWU8sbUJBQW1CRyxhQUFhO0lBQ2xELE1BQU1FLFVBQVV0QiwrRUFBWUEsQ0FBQ1U7SUFDN0IsTUFBTSxDQUFDYSxZQUFZQyxRQUFRQyxVQUFVLEdBQUd4QixtREFBUUEsQ0FBQ1MsV0FBV1k7SUFDNUQsT0FBT0MsV0FBVyxXQUFXLEdBQUVoQyxnREFBbUIsQ0FBQ08sbURBQU1BLEVBQUVoQixPQUFPNEMsTUFBTSxDQUFDLENBQUMsR0FBR1AsV0FBVztRQUN0RlQsV0FBV0E7UUFDWEksV0FBV2pCLGlEQUFVQSxDQUFDaUIsV0FBV1UsUUFBUSxHQUFhLE9BQVZkLFdBQVUsdUJBQXFCZSxXQUFXSDtRQUN0RkssVUFBVTtRQUNWQyxVQUFVO1FBQ1ZWLFNBQVMsV0FBVyxHQUFFM0IsZ0RBQW1CLENBQUNrQixhQUFhO1lBQ3JEQyxXQUFXQTtZQUNYQyxNQUFNQTtZQUNOQyxNQUFNQTtRQUNSLEdBQUdNO0lBQ0w7QUFDRjtHQTFCTUg7O1FBYVlmLDJFQUFZQTtRQUNZQywrQ0FBUUE7OztNQWQ1Q2M7QUEyQk4sK0RBQWVBLFNBQVNBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FudGQvZXMvbWVzc2FnZS9QdXJlUGFuZWwuanM/NDlmMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxudmFyIF9fcmVzdCA9IHRoaXMgJiYgdGhpcy5fX3Jlc3QgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgdmFyIHQgPSB7fTtcbiAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApIHRbcF0gPSBzW3BdO1xuICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpIHRbcFtpXV0gPSBzW3BbaV1dO1xuICB9XG4gIHJldHVybiB0O1xufTtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBDaGVja0NpcmNsZUZpbGxlZCBmcm9tIFwiQGFudC1kZXNpZ24vaWNvbnMvZXMvaWNvbnMvQ2hlY2tDaXJjbGVGaWxsZWRcIjtcbmltcG9ydCBDbG9zZUNpcmNsZUZpbGxlZCBmcm9tIFwiQGFudC1kZXNpZ24vaWNvbnMvZXMvaWNvbnMvQ2xvc2VDaXJjbGVGaWxsZWRcIjtcbmltcG9ydCBFeGNsYW1hdGlvbkNpcmNsZUZpbGxlZCBmcm9tIFwiQGFudC1kZXNpZ24vaWNvbnMvZXMvaWNvbnMvRXhjbGFtYXRpb25DaXJjbGVGaWxsZWRcIjtcbmltcG9ydCBJbmZvQ2lyY2xlRmlsbGVkIGZyb20gXCJAYW50LWRlc2lnbi9pY29ucy9lcy9pY29ucy9JbmZvQ2lyY2xlRmlsbGVkXCI7XG5pbXBvcnQgTG9hZGluZ091dGxpbmVkIGZyb20gXCJAYW50LWRlc2lnbi9pY29ucy9lcy9pY29ucy9Mb2FkaW5nT3V0bGluZWRcIjtcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHsgTm90aWNlIH0gZnJvbSAncmMtbm90aWZpY2F0aW9uJztcbmltcG9ydCB7IENvbmZpZ0NvbnRleHQgfSBmcm9tICcuLi9jb25maWctcHJvdmlkZXInO1xuaW1wb3J0IHVzZUNTU1ZhckNscyBmcm9tICcuLi9jb25maWctcHJvdmlkZXIvaG9va3MvdXNlQ1NTVmFyQ2xzJztcbmltcG9ydCB1c2VTdHlsZSBmcm9tICcuL3N0eWxlJztcbmV4cG9ydCBjb25zdCBUeXBlSWNvbiA9IHtcbiAgaW5mbzogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoSW5mb0NpcmNsZUZpbGxlZCwgbnVsbCksXG4gIHN1Y2Nlc3M6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENoZWNrQ2lyY2xlRmlsbGVkLCBudWxsKSxcbiAgZXJyb3I6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENsb3NlQ2lyY2xlRmlsbGVkLCBudWxsKSxcbiAgd2FybmluZzogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRXhjbGFtYXRpb25DaXJjbGVGaWxsZWQsIG51bGwpLFxuICBsb2FkaW5nOiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChMb2FkaW5nT3V0bGluZWQsIG51bGwpXG59O1xuZXhwb3J0IGNvbnN0IFB1cmVDb250ZW50ID0gKHtcbiAgcHJlZml4Q2xzLFxuICB0eXBlLFxuICBpY29uLFxuICBjaGlsZHJlblxufSkgPT4gKC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgY2xhc3NOYW1lOiBjbGFzc05hbWVzKGAke3ByZWZpeENsc30tY3VzdG9tLWNvbnRlbnRgLCBgJHtwcmVmaXhDbHN9LSR7dHlwZX1gKVxufSwgaWNvbiB8fCBUeXBlSWNvblt0eXBlXSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsIGNoaWxkcmVuKSkpO1xuLyoqIEBwcml2YXRlIEludGVybmFsIENvbXBvbmVudC4gRG8gbm90IHVzZSBpbiB5b3VyIHByb2R1Y3Rpb24uICovXG5jb25zdCBQdXJlUGFuZWwgPSBwcm9wcyA9PiB7XG4gIGNvbnN0IHtcbiAgICAgIHByZWZpeENsczogc3RhdGljUHJlZml4Q2xzLFxuICAgICAgY2xhc3NOYW1lLFxuICAgICAgdHlwZSxcbiAgICAgIGljb24sXG4gICAgICBjb250ZW50XG4gICAgfSA9IHByb3BzLFxuICAgIHJlc3RQcm9wcyA9IF9fcmVzdChwcm9wcywgW1wicHJlZml4Q2xzXCIsIFwiY2xhc3NOYW1lXCIsIFwidHlwZVwiLCBcImljb25cIiwgXCJjb250ZW50XCJdKTtcbiAgY29uc3Qge1xuICAgIGdldFByZWZpeENsc1xuICB9ID0gUmVhY3QudXNlQ29udGV4dChDb25maWdDb250ZXh0KTtcbiAgY29uc3QgcHJlZml4Q2xzID0gc3RhdGljUHJlZml4Q2xzIHx8IGdldFByZWZpeENscygnbWVzc2FnZScpO1xuICBjb25zdCByb290Q2xzID0gdXNlQ1NTVmFyQ2xzKHByZWZpeENscyk7XG4gIGNvbnN0IFt3cmFwQ1NTVmFyLCBoYXNoSWQsIGNzc1ZhckNsc10gPSB1c2VTdHlsZShwcmVmaXhDbHMsIHJvb3RDbHMpO1xuICByZXR1cm4gd3JhcENTU1ZhcigvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChOb3RpY2UsIE9iamVjdC5hc3NpZ24oe30sIHJlc3RQcm9wcywge1xuICAgIHByZWZpeENsczogcHJlZml4Q2xzLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lcyhjbGFzc05hbWUsIGhhc2hJZCwgYCR7cHJlZml4Q2xzfS1ub3RpY2UtcHVyZS1wYW5lbGAsIGNzc1ZhckNscywgcm9vdENscyksXG4gICAgZXZlbnRLZXk6IFwicHVyZVwiLFxuICAgIGR1cmF0aW9uOiBudWxsLFxuICAgIGNvbnRlbnQ6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFB1cmVDb250ZW50LCB7XG4gICAgICBwcmVmaXhDbHM6IHByZWZpeENscyxcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBpY29uOiBpY29uXG4gICAgfSwgY29udGVudClcbiAgfSkpKTtcbn07XG5leHBvcnQgZGVmYXVsdCBQdXJlUGFuZWw7Il0sIm5hbWVzIjpbIl9fcmVzdCIsInMiLCJlIiwidCIsInAiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpbmRleE9mIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiaSIsImxlbmd0aCIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiUmVhY3QiLCJDaGVja0NpcmNsZUZpbGxlZCIsIkNsb3NlQ2lyY2xlRmlsbGVkIiwiRXhjbGFtYXRpb25DaXJjbGVGaWxsZWQiLCJJbmZvQ2lyY2xlRmlsbGVkIiwiTG9hZGluZ091dGxpbmVkIiwiY2xhc3NOYW1lcyIsIk5vdGljZSIsIkNvbmZpZ0NvbnRleHQiLCJ1c2VDU1NWYXJDbHMiLCJ1c2VTdHlsZSIsIlR5cGVJY29uIiwiaW5mbyIsImNyZWF0ZUVsZW1lbnQiLCJzdWNjZXNzIiwiZXJyb3IiLCJ3YXJuaW5nIiwibG9hZGluZyIsIlB1cmVDb250ZW50IiwicHJlZml4Q2xzIiwidHlwZSIsImljb24iLCJjaGlsZHJlbiIsImNsYXNzTmFtZSIsIlB1cmVQYW5lbCIsInByb3BzIiwic3RhdGljUHJlZml4Q2xzIiwiY29udGVudCIsInJlc3RQcm9wcyIsImdldFByZWZpeENscyIsInVzZUNvbnRleHQiLCJyb290Q2xzIiwid3JhcENTU1ZhciIsImhhc2hJZCIsImNzc1ZhckNscyIsImFzc2lnbiIsImV2ZW50S2V5IiwiZHVyYXRpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/antd/es/message/PurePanel.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/antd/es/message/index.js":
/*!***********************************************!*\
  !*** ./node_modules/antd/es/message/index.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   actDestroy: function() { return /* binding */ actDestroy; },\n/* harmony export */   actWrapper: function() { return /* binding */ actWrapper; }\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/toConsumableArray */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _app_context__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../app/context */ \"(app-pages-browser)/./node_modules/antd/es/app/context.js\");\n/* harmony import */ var _config_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../config-provider */ \"(app-pages-browser)/./node_modules/antd/es/config-provider/context.js\");\n/* harmony import */ var _config_provider__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../config-provider */ \"(app-pages-browser)/./node_modules/antd/es/config-provider/index.js\");\n/* harmony import */ var _config_provider_UnstableContext__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../config-provider/UnstableContext */ \"(app-pages-browser)/./node_modules/antd/es/config-provider/UnstableContext.js\");\n/* harmony import */ var _PurePanel__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./PurePanel */ \"(app-pages-browser)/./node_modules/antd/es/message/PurePanel.js\");\n/* harmony import */ var _useMessage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./useMessage */ \"(app-pages-browser)/./node_modules/antd/es/message/useMessage.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./util */ \"(app-pages-browser)/./node_modules/antd/es/message/util.js\");\n/* __next_internal_client_entry_do_not_use__ actWrapper,actDestroy,default auto */ var _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\n\n\n\n\nlet message = null;\nlet act = (callback)=>callback();\nlet taskQueue = [];\nlet defaultGlobalConfig = {};\nfunction getGlobalContext() {\n    const { getContainer, duration, rtl, maxCount, top } = defaultGlobalConfig;\n    const mergedContainer = (getContainer === null || getContainer === void 0 ? void 0 : getContainer()) || document.body;\n    return {\n        getContainer: ()=>mergedContainer,\n        duration,\n        rtl,\n        maxCount,\n        top\n    };\n}\nconst GlobalHolder = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef(_s((props, ref)=>{\n    _s();\n    const { messageConfig, sync } = props;\n    const { getPrefixCls } = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(_config_provider__WEBPACK_IMPORTED_MODULE_2__.ConfigContext);\n    const prefixCls = defaultGlobalConfig.prefixCls || getPrefixCls(\"message\");\n    const appConfig = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(_app_context__WEBPACK_IMPORTED_MODULE_3__.AppConfigContext);\n    const [api, holder] = (0,_useMessage__WEBPACK_IMPORTED_MODULE_4__.useInternalMessage)(Object.assign(Object.assign(Object.assign({}, messageConfig), {\n        prefixCls\n    }), appConfig.message));\n    react__WEBPACK_IMPORTED_MODULE_1___default().useImperativeHandle(ref, ()=>{\n        const instance = Object.assign({}, api);\n        Object.keys(instance).forEach((method)=>{\n            instance[method] = function() {\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                sync();\n                return api[method].apply(api, args);\n            };\n        });\n        return {\n            instance,\n            sync\n        };\n    });\n    return holder;\n}, \"AZUDHK3JGH89Pxyg/tSuLUlZRrY=\", false, function() {\n    return [\n        _useMessage__WEBPACK_IMPORTED_MODULE_4__.useInternalMessage\n    ];\n}));\n_c = GlobalHolder;\nconst GlobalHolderWrapper = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef(_s1((_, ref)=>{\n    _s1();\n    const [messageConfig, setMessageConfig] = react__WEBPACK_IMPORTED_MODULE_1___default().useState(getGlobalContext);\n    const sync = ()=>{\n        setMessageConfig(getGlobalContext);\n    };\n    react__WEBPACK_IMPORTED_MODULE_1___default().useEffect(sync, []);\n    const global = (0,_config_provider__WEBPACK_IMPORTED_MODULE_5__.globalConfig)();\n    const rootPrefixCls = global.getRootPrefixCls();\n    const rootIconPrefixCls = global.getIconPrefixCls();\n    const theme = global.getTheme();\n    const dom = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(GlobalHolder, {\n        ref: ref,\n        sync: sync,\n        messageConfig: messageConfig\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_config_provider__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n        prefixCls: rootPrefixCls,\n        iconPrefixCls: rootIconPrefixCls,\n        theme: theme\n    }, global.holderRender ? global.holderRender(dom) : dom);\n}, \"z44LFFY5v4spIRd7tQbAzpU55pY=\"));\n_c1 = GlobalHolderWrapper;\nconst flushMessageQueue = ()=>{\n    if (!message) {\n        const holderFragment = document.createDocumentFragment();\n        const newMessage = {\n            fragment: holderFragment\n        };\n        message = newMessage;\n        // Delay render to avoid sync issue\n        act(()=>{\n            const reactRender = (0,_config_provider_UnstableContext__WEBPACK_IMPORTED_MODULE_6__.unstableSetRender)();\n            reactRender(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(GlobalHolderWrapper, {\n                ref: (node)=>{\n                    const { instance, sync } = node || {};\n                    // React 18 test env will throw if call immediately in ref\n                    Promise.resolve().then(()=>{\n                        if (!newMessage.instance && instance) {\n                            newMessage.instance = instance;\n                            newMessage.sync = sync;\n                            flushMessageQueue();\n                        }\n                    });\n                }\n            }), holderFragment);\n        });\n        return;\n    }\n    // Notification not ready\n    if (!message.instance) {\n        return;\n    }\n    // >>> Execute task\n    taskQueue.forEach((task)=>{\n        const { type, skipped } = task;\n        // Only `skipped` when user call notice but cancel it immediately\n        // and instance not ready\n        if (!skipped) {\n            switch(type){\n                case \"open\":\n                    {\n                        act(()=>{\n                            const closeFn = message.instance.open(Object.assign(Object.assign({}, defaultGlobalConfig), task.config));\n                            closeFn === null || closeFn === void 0 ? void 0 : closeFn.then(task.resolve);\n                            task.setCloseFn(closeFn);\n                        });\n                        break;\n                    }\n                case \"destroy\":\n                    act(()=>{\n                        message === null || message === void 0 ? void 0 : message.instance.destroy(task.key);\n                    });\n                    break;\n                // Other type open\n                default:\n                    {\n                        act(()=>{\n                            var _message$instance;\n                            const closeFn = (_message$instance = message.instance)[type].apply(_message$instance, (0,_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(task.args));\n                            closeFn === null || closeFn === void 0 ? void 0 : closeFn.then(task.resolve);\n                            task.setCloseFn(closeFn);\n                        });\n                    }\n            }\n        }\n    });\n    // Clean up\n    taskQueue = [];\n};\n// ==============================================================================\n// ==                                  Export                                  ==\n// ==============================================================================\nfunction setMessageGlobalConfig(config) {\n    defaultGlobalConfig = Object.assign(Object.assign({}, defaultGlobalConfig), config);\n    // Trigger sync for it\n    act(()=>{\n        var _a;\n        (_a = message === null || message === void 0 ? void 0 : message.sync) === null || _a === void 0 ? void 0 : _a.call(message);\n    });\n}\nfunction open(config) {\n    const result = (0,_util__WEBPACK_IMPORTED_MODULE_7__.wrapPromiseFn)((resolve)=>{\n        let closeFn;\n        const task = {\n            type: \"open\",\n            config,\n            resolve,\n            setCloseFn: (fn)=>{\n                closeFn = fn;\n            }\n        };\n        taskQueue.push(task);\n        return ()=>{\n            if (closeFn) {\n                act(()=>{\n                    closeFn();\n                });\n            } else {\n                task.skipped = true;\n            }\n        };\n    });\n    flushMessageQueue();\n    return result;\n}\nfunction typeOpen(type, args) {\n    const global = (0,_config_provider__WEBPACK_IMPORTED_MODULE_5__.globalConfig)();\n    if ( true && !global.holderRender) {\n        (0,_config_provider__WEBPACK_IMPORTED_MODULE_5__.warnContext)(\"message\");\n    }\n    const result = (0,_util__WEBPACK_IMPORTED_MODULE_7__.wrapPromiseFn)((resolve)=>{\n        let closeFn;\n        const task = {\n            type,\n            args,\n            resolve,\n            setCloseFn: (fn)=>{\n                closeFn = fn;\n            }\n        };\n        taskQueue.push(task);\n        return ()=>{\n            if (closeFn) {\n                act(()=>{\n                    closeFn();\n                });\n            } else {\n                task.skipped = true;\n            }\n        };\n    });\n    flushMessageQueue();\n    return result;\n}\nconst destroy = (key)=>{\n    taskQueue.push({\n        type: \"destroy\",\n        key\n    });\n    flushMessageQueue();\n};\nconst methods = [\n    \"success\",\n    \"info\",\n    \"warning\",\n    \"error\",\n    \"loading\"\n];\nconst baseStaticMethods = {\n    open,\n    destroy,\n    config: setMessageGlobalConfig,\n    useMessage: _useMessage__WEBPACK_IMPORTED_MODULE_4__[\"default\"],\n    _InternalPanelDoNotUseOrYouWillBeFired: _PurePanel__WEBPACK_IMPORTED_MODULE_8__[\"default\"]\n};\nconst staticMethods = baseStaticMethods;\nmethods.forEach((type)=>{\n    staticMethods[type] = function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return typeOpen(type, args);\n    };\n});\n// ==============================================================================\n// ==                                   Test                                   ==\n// ==============================================================================\nconst noop = ()=>{};\nlet _actWrapper = noop;\nif (false) {}\nconst actWrapper = _actWrapper;\n\nlet _actDestroy = noop;\nif (false) {}\nconst actDestroy = _actDestroy;\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (staticMethods);\nvar _c, _c1;\n$RefreshReg$(_c, \"GlobalHolder\");\n$RefreshReg$(_c1, \"GlobalHolderWrapper\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hbnRkL2VzL21lc3NhZ2UvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUU4RTtBQUNwQztBQUNRO0FBQzRDO0FBQ3ZCO0FBQ25DO0FBQzBCO0FBQ3ZCO0FBQ3ZDLElBQUlhLFVBQVU7QUFDZCxJQUFJQyxNQUFNQyxDQUFBQSxXQUFZQTtBQUN0QixJQUFJQyxZQUFZLEVBQUU7QUFDbEIsSUFBSUMsc0JBQXNCLENBQUM7QUFDM0IsU0FBU0M7SUFDUCxNQUFNLEVBQ0pDLFlBQVksRUFDWkMsUUFBUSxFQUNSQyxHQUFHLEVBQ0hDLFFBQVEsRUFDUkMsR0FBRyxFQUNKLEdBQUdOO0lBQ0osTUFBTU8sa0JBQWtCLENBQUNMLGlCQUFpQixRQUFRQSxpQkFBaUIsS0FBSyxJQUFJLEtBQUssSUFBSUEsY0FBYSxLQUFNTSxTQUFTQyxJQUFJO0lBQ3JILE9BQU87UUFDTFAsY0FBYyxJQUFNSztRQUNwQko7UUFDQUM7UUFDQUM7UUFDQUM7SUFDRjtBQUNGO0FBQ0EsTUFBTUksZUFBZSxXQUFXLEdBQUUxQix1REFBZ0IsSUFBQyxDQUFDNEIsT0FBT0M7O0lBQ3pELE1BQU0sRUFDSkMsYUFBYSxFQUNiQyxJQUFJLEVBQ0wsR0FBR0g7SUFDSixNQUFNLEVBQ0pJLFlBQVksRUFDYixHQUFHL0IsaURBQVVBLENBQUNHLDJEQUFhQTtJQUM1QixNQUFNNkIsWUFBWWpCLG9CQUFvQmlCLFNBQVMsSUFBSUQsYUFBYTtJQUNoRSxNQUFNRSxZQUFZakMsaURBQVVBLENBQUNDLDBEQUFnQkE7SUFDN0MsTUFBTSxDQUFDaUMsS0FBS0MsT0FBTyxHQUFHMUIsK0RBQWtCQSxDQUFDMkIsT0FBT0MsTUFBTSxDQUFDRCxPQUFPQyxNQUFNLENBQUNELE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUdSLGdCQUFnQjtRQUNyR0c7SUFDRixJQUFJQyxVQUFVdEIsT0FBTztJQUNyQlosZ0VBQXlCLENBQUM2QixLQUFLO1FB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QUFDcEQ7QUFDQSxpRkFBaUY7QUFDakYsaUZBQWlGO0FBQ2pGLGlGQUFpRjtBQUNqRixNQUFNa0QsT0FBTyxLQUFPO0FBQ3BCLElBQUlDLGNBQWNEO0FBQ2xCLElBQUlMLEtBQXlCLEVBQVEsRUFJcEM7QUFDRCxNQUFNUSxhQUFhRjtBQUNHO0FBQ3RCLElBQUlHLGNBQWNKO0FBQ2xCLElBQUlMLEtBQXlCLEVBQVEsRUFJcEM7QUFDRCxNQUFNVSxhQUFhRDtBQUNHO0FBQ3RCLCtEQUFlTCxhQUFhQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hbnRkL2VzL21lc3NhZ2UvaW5kZXguanM/MTkxOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IF90b0NvbnN1bWFibGVBcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Db25zdW1hYmxlQXJyYXlcIjtcbmltcG9ydCBSZWFjdCwgeyB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQXBwQ29uZmlnQ29udGV4dCB9IGZyb20gJy4uL2FwcC9jb250ZXh0JztcbmltcG9ydCBDb25maWdQcm92aWRlciwgeyBDb25maWdDb250ZXh0LCBnbG9iYWxDb25maWcsIHdhcm5Db250ZXh0IH0gZnJvbSAnLi4vY29uZmlnLXByb3ZpZGVyJztcbmltcG9ydCB7IHVuc3RhYmxlU2V0UmVuZGVyIH0gZnJvbSAnLi4vY29uZmlnLXByb3ZpZGVyL1Vuc3RhYmxlQ29udGV4dCc7XG5pbXBvcnQgUHVyZVBhbmVsIGZyb20gJy4vUHVyZVBhbmVsJztcbmltcG9ydCB1c2VNZXNzYWdlLCB7IHVzZUludGVybmFsTWVzc2FnZSB9IGZyb20gJy4vdXNlTWVzc2FnZSc7XG5pbXBvcnQgeyB3cmFwUHJvbWlzZUZuIH0gZnJvbSAnLi91dGlsJztcbmxldCBtZXNzYWdlID0gbnVsbDtcbmxldCBhY3QgPSBjYWxsYmFjayA9PiBjYWxsYmFjaygpO1xubGV0IHRhc2tRdWV1ZSA9IFtdO1xubGV0IGRlZmF1bHRHbG9iYWxDb25maWcgPSB7fTtcbmZ1bmN0aW9uIGdldEdsb2JhbENvbnRleHQoKSB7XG4gIGNvbnN0IHtcbiAgICBnZXRDb250YWluZXIsXG4gICAgZHVyYXRpb24sXG4gICAgcnRsLFxuICAgIG1heENvdW50LFxuICAgIHRvcFxuICB9ID0gZGVmYXVsdEdsb2JhbENvbmZpZztcbiAgY29uc3QgbWVyZ2VkQ29udGFpbmVyID0gKGdldENvbnRhaW5lciA9PT0gbnVsbCB8fCBnZXRDb250YWluZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdldENvbnRhaW5lcigpKSB8fCBkb2N1bWVudC5ib2R5O1xuICByZXR1cm4ge1xuICAgIGdldENvbnRhaW5lcjogKCkgPT4gbWVyZ2VkQ29udGFpbmVyLFxuICAgIGR1cmF0aW9uLFxuICAgIHJ0bCxcbiAgICBtYXhDb3VudCxcbiAgICB0b3BcbiAgfTtcbn1cbmNvbnN0IEdsb2JhbEhvbGRlciA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBtZXNzYWdlQ29uZmlnLFxuICAgIHN5bmNcbiAgfSA9IHByb3BzO1xuICBjb25zdCB7XG4gICAgZ2V0UHJlZml4Q2xzXG4gIH0gPSB1c2VDb250ZXh0KENvbmZpZ0NvbnRleHQpO1xuICBjb25zdCBwcmVmaXhDbHMgPSBkZWZhdWx0R2xvYmFsQ29uZmlnLnByZWZpeENscyB8fCBnZXRQcmVmaXhDbHMoJ21lc3NhZ2UnKTtcbiAgY29uc3QgYXBwQ29uZmlnID0gdXNlQ29udGV4dChBcHBDb25maWdDb250ZXh0KTtcbiAgY29uc3QgW2FwaSwgaG9sZGVyXSA9IHVzZUludGVybmFsTWVzc2FnZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbWVzc2FnZUNvbmZpZyksIHtcbiAgICBwcmVmaXhDbHNcbiAgfSksIGFwcENvbmZpZy5tZXNzYWdlKSk7XG4gIFJlYWN0LnVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCAoKSA9PiB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBPYmplY3QuYXNzaWduKHt9LCBhcGkpO1xuICAgIE9iamVjdC5rZXlzKGluc3RhbmNlKS5mb3JFYWNoKG1ldGhvZCA9PiB7XG4gICAgICBpbnN0YW5jZVttZXRob2RdID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgc3luYygpO1xuICAgICAgICByZXR1cm4gYXBpW21ldGhvZF0uYXBwbHkoYXBpLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluc3RhbmNlLFxuICAgICAgc3luY1xuICAgIH07XG4gIH0pO1xuICByZXR1cm4gaG9sZGVyO1xufSk7XG5jb25zdCBHbG9iYWxIb2xkZXJXcmFwcGVyID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKF8sIHJlZikgPT4ge1xuICBjb25zdCBbbWVzc2FnZUNvbmZpZywgc2V0TWVzc2FnZUNvbmZpZ10gPSBSZWFjdC51c2VTdGF0ZShnZXRHbG9iYWxDb250ZXh0KTtcbiAgY29uc3Qgc3luYyA9ICgpID0+IHtcbiAgICBzZXRNZXNzYWdlQ29uZmlnKGdldEdsb2JhbENvbnRleHQpO1xuICB9O1xuICBSZWFjdC51c2VFZmZlY3Qoc3luYywgW10pO1xuICBjb25zdCBnbG9iYWwgPSBnbG9iYWxDb25maWcoKTtcbiAgY29uc3Qgcm9vdFByZWZpeENscyA9IGdsb2JhbC5nZXRSb290UHJlZml4Q2xzKCk7XG4gIGNvbnN0IHJvb3RJY29uUHJlZml4Q2xzID0gZ2xvYmFsLmdldEljb25QcmVmaXhDbHMoKTtcbiAgY29uc3QgdGhlbWUgPSBnbG9iYWwuZ2V0VGhlbWUoKTtcbiAgY29uc3QgZG9tID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoR2xvYmFsSG9sZGVyLCB7XG4gICAgcmVmOiByZWYsXG4gICAgc3luYzogc3luYyxcbiAgICBtZXNzYWdlQ29uZmlnOiBtZXNzYWdlQ29uZmlnXG4gIH0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ29uZmlnUHJvdmlkZXIsIHtcbiAgICBwcmVmaXhDbHM6IHJvb3RQcmVmaXhDbHMsXG4gICAgaWNvblByZWZpeENsczogcm9vdEljb25QcmVmaXhDbHMsXG4gICAgdGhlbWU6IHRoZW1lXG4gIH0sIGdsb2JhbC5ob2xkZXJSZW5kZXIgPyBnbG9iYWwuaG9sZGVyUmVuZGVyKGRvbSkgOiBkb20pO1xufSk7XG5jb25zdCBmbHVzaE1lc3NhZ2VRdWV1ZSA9ICgpID0+IHtcbiAgaWYgKCFtZXNzYWdlKSB7XG4gICAgY29uc3QgaG9sZGVyRnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgY29uc3QgbmV3TWVzc2FnZSA9IHtcbiAgICAgIGZyYWdtZW50OiBob2xkZXJGcmFnbWVudFxuICAgIH07XG4gICAgbWVzc2FnZSA9IG5ld01lc3NhZ2U7XG4gICAgLy8gRGVsYXkgcmVuZGVyIHRvIGF2b2lkIHN5bmMgaXNzdWVcbiAgICBhY3QoKCkgPT4ge1xuICAgICAgY29uc3QgcmVhY3RSZW5kZXIgPSB1bnN0YWJsZVNldFJlbmRlcigpO1xuICAgICAgcmVhY3RSZW5kZXIoLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoR2xvYmFsSG9sZGVyV3JhcHBlciwge1xuICAgICAgICByZWY6IG5vZGUgPT4ge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgc3luY1xuICAgICAgICAgIH0gPSBub2RlIHx8IHt9O1xuICAgICAgICAgIC8vIFJlYWN0IDE4IHRlc3QgZW52IHdpbGwgdGhyb3cgaWYgY2FsbCBpbW1lZGlhdGVseSBpbiByZWZcbiAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmICghbmV3TWVzc2FnZS5pbnN0YW5jZSAmJiBpbnN0YW5jZSkge1xuICAgICAgICAgICAgICBuZXdNZXNzYWdlLmluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgICAgICAgICAgIG5ld01lc3NhZ2Uuc3luYyA9IHN5bmM7XG4gICAgICAgICAgICAgIGZsdXNoTWVzc2FnZVF1ZXVlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pLCBob2xkZXJGcmFnbWVudCk7XG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIE5vdGlmaWNhdGlvbiBub3QgcmVhZHlcbiAgaWYgKCFtZXNzYWdlLmluc3RhbmNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vID4+PiBFeGVjdXRlIHRhc2tcbiAgdGFza1F1ZXVlLmZvckVhY2godGFzayA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZSxcbiAgICAgIHNraXBwZWRcbiAgICB9ID0gdGFzaztcbiAgICAvLyBPbmx5IGBza2lwcGVkYCB3aGVuIHVzZXIgY2FsbCBub3RpY2UgYnV0IGNhbmNlbCBpdCBpbW1lZGlhdGVseVxuICAgIC8vIGFuZCBpbnN0YW5jZSBub3QgcmVhZHlcbiAgICBpZiAoIXNraXBwZWQpIHtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdvcGVuJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBhY3QoKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBjbG9zZUZuID0gbWVzc2FnZS5pbnN0YW5jZS5vcGVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdEdsb2JhbENvbmZpZyksIHRhc2suY29uZmlnKSk7XG4gICAgICAgICAgICAgIGNsb3NlRm4gPT09IG51bGwgfHwgY2xvc2VGbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2xvc2VGbi50aGVuKHRhc2sucmVzb2x2ZSk7XG4gICAgICAgICAgICAgIHRhc2suc2V0Q2xvc2VGbihjbG9zZUZuKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdkZXN0cm95JzpcbiAgICAgICAgICBhY3QoKCkgPT4ge1xuICAgICAgICAgICAgbWVzc2FnZSA9PT0gbnVsbCB8fCBtZXNzYWdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtZXNzYWdlLmluc3RhbmNlLmRlc3Ryb3kodGFzay5rZXkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBPdGhlciB0eXBlIG9wZW5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBhY3QoKCkgPT4ge1xuICAgICAgICAgICAgICB2YXIgX21lc3NhZ2UkaW5zdGFuY2U7XG4gICAgICAgICAgICAgIGNvbnN0IGNsb3NlRm4gPSAoX21lc3NhZ2UkaW5zdGFuY2UgPSBtZXNzYWdlLmluc3RhbmNlKVt0eXBlXS5hcHBseShfbWVzc2FnZSRpbnN0YW5jZSwgX3RvQ29uc3VtYWJsZUFycmF5KHRhc2suYXJncykpO1xuICAgICAgICAgICAgICBjbG9zZUZuID09PSBudWxsIHx8IGNsb3NlRm4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsb3NlRm4udGhlbih0YXNrLnJlc29sdmUpO1xuICAgICAgICAgICAgICB0YXNrLnNldENsb3NlRm4oY2xvc2VGbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgLy8gQ2xlYW4gdXBcbiAgdGFza1F1ZXVlID0gW107XG59O1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyA9PSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFeHBvcnQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPT1cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuZnVuY3Rpb24gc2V0TWVzc2FnZUdsb2JhbENvbmZpZyhjb25maWcpIHtcbiAgZGVmYXVsdEdsb2JhbENvbmZpZyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdEdsb2JhbENvbmZpZyksIGNvbmZpZyk7XG4gIC8vIFRyaWdnZXIgc3luYyBmb3IgaXRcbiAgYWN0KCgpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgKF9hID0gbWVzc2FnZSA9PT0gbnVsbCB8fCBtZXNzYWdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtZXNzYWdlLnN5bmMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKG1lc3NhZ2UpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIG9wZW4oY29uZmlnKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHdyYXBQcm9taXNlRm4ocmVzb2x2ZSA9PiB7XG4gICAgbGV0IGNsb3NlRm47XG4gICAgY29uc3QgdGFzayA9IHtcbiAgICAgIHR5cGU6ICdvcGVuJyxcbiAgICAgIGNvbmZpZyxcbiAgICAgIHJlc29sdmUsXG4gICAgICBzZXRDbG9zZUZuOiBmbiA9PiB7XG4gICAgICAgIGNsb3NlRm4gPSBmbjtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRhc2tRdWV1ZS5wdXNoKHRhc2spO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoY2xvc2VGbikge1xuICAgICAgICBhY3QoKCkgPT4ge1xuICAgICAgICAgIGNsb3NlRm4oKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXNrLnNraXBwZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuICBmbHVzaE1lc3NhZ2VRdWV1ZSgpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdHlwZU9wZW4odHlwZSwgYXJncykge1xuICBjb25zdCBnbG9iYWwgPSBnbG9iYWxDb25maWcoKTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWdsb2JhbC5ob2xkZXJSZW5kZXIpIHtcbiAgICB3YXJuQ29udGV4dCgnbWVzc2FnZScpO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IHdyYXBQcm9taXNlRm4ocmVzb2x2ZSA9PiB7XG4gICAgbGV0IGNsb3NlRm47XG4gICAgY29uc3QgdGFzayA9IHtcbiAgICAgIHR5cGUsXG4gICAgICBhcmdzLFxuICAgICAgcmVzb2x2ZSxcbiAgICAgIHNldENsb3NlRm46IGZuID0+IHtcbiAgICAgICAgY2xvc2VGbiA9IGZuO1xuICAgICAgfVxuICAgIH07XG4gICAgdGFza1F1ZXVlLnB1c2godGFzayk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChjbG9zZUZuKSB7XG4gICAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgICAgY2xvc2VGbigpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhc2suc2tpcHBlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG4gIGZsdXNoTWVzc2FnZVF1ZXVlKCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBkZXN0cm95ID0ga2V5ID0+IHtcbiAgdGFza1F1ZXVlLnB1c2goe1xuICAgIHR5cGU6ICdkZXN0cm95JyxcbiAgICBrZXlcbiAgfSk7XG4gIGZsdXNoTWVzc2FnZVF1ZXVlKCk7XG59O1xuY29uc3QgbWV0aG9kcyA9IFsnc3VjY2VzcycsICdpbmZvJywgJ3dhcm5pbmcnLCAnZXJyb3InLCAnbG9hZGluZyddO1xuY29uc3QgYmFzZVN0YXRpY01ldGhvZHMgPSB7XG4gIG9wZW4sXG4gIGRlc3Ryb3ksXG4gIGNvbmZpZzogc2V0TWVzc2FnZUdsb2JhbENvbmZpZyxcbiAgdXNlTWVzc2FnZSxcbiAgX0ludGVybmFsUGFuZWxEb05vdFVzZU9yWW91V2lsbEJlRmlyZWQ6IFB1cmVQYW5lbFxufTtcbmNvbnN0IHN0YXRpY01ldGhvZHMgPSBiYXNlU3RhdGljTWV0aG9kcztcbm1ldGhvZHMuZm9yRWFjaCh0eXBlID0+IHtcbiAgc3RhdGljTWV0aG9kc1t0eXBlXSA9ICguLi5hcmdzKSA9PiB0eXBlT3Blbih0eXBlLCBhcmdzKTtcbn0pO1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyA9PSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGVzdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPT1cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xubGV0IF9hY3RXcmFwcGVyID0gbm9vcDtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnKSB7XG4gIF9hY3RXcmFwcGVyID0gd3JhcHBlciA9PiB7XG4gICAgYWN0ID0gd3JhcHBlcjtcbiAgfTtcbn1cbmNvbnN0IGFjdFdyYXBwZXIgPSBfYWN0V3JhcHBlcjtcbmV4cG9ydCB7IGFjdFdyYXBwZXIgfTtcbmxldCBfYWN0RGVzdHJveSA9IG5vb3A7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICd0ZXN0Jykge1xuICBfYWN0RGVzdHJveSA9ICgpID0+IHtcbiAgICBtZXNzYWdlID0gbnVsbDtcbiAgfTtcbn1cbmNvbnN0IGFjdERlc3Ryb3kgPSBfYWN0RGVzdHJveTtcbmV4cG9ydCB7IGFjdERlc3Ryb3kgfTtcbmV4cG9ydCBkZWZhdWx0IHN0YXRpY01ldGhvZHM7Il0sIm5hbWVzIjpbIl90b0NvbnN1bWFibGVBcnJheSIsIlJlYWN0IiwidXNlQ29udGV4dCIsIkFwcENvbmZpZ0NvbnRleHQiLCJDb25maWdQcm92aWRlciIsIkNvbmZpZ0NvbnRleHQiLCJnbG9iYWxDb25maWciLCJ3YXJuQ29udGV4dCIsInVuc3RhYmxlU2V0UmVuZGVyIiwiUHVyZVBhbmVsIiwidXNlTWVzc2FnZSIsInVzZUludGVybmFsTWVzc2FnZSIsIndyYXBQcm9taXNlRm4iLCJtZXNzYWdlIiwiYWN0IiwiY2FsbGJhY2siLCJ0YXNrUXVldWUiLCJkZWZhdWx0R2xvYmFsQ29uZmlnIiwiZ2V0R2xvYmFsQ29udGV4dCIsImdldENvbnRhaW5lciIsImR1cmF0aW9uIiwicnRsIiwibWF4Q291bnQiLCJ0b3AiLCJtZXJnZWRDb250YWluZXIiLCJkb2N1bWVudCIsImJvZHkiLCJHbG9iYWxIb2xkZXIiLCJmb3J3YXJkUmVmIiwicHJvcHMiLCJyZWYiLCJtZXNzYWdlQ29uZmlnIiwic3luYyIsImdldFByZWZpeENscyIsInByZWZpeENscyIsImFwcENvbmZpZyIsImFwaSIsImhvbGRlciIsIk9iamVjdCIsImFzc2lnbiIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJpbnN0YW5jZSIsImtleXMiLCJmb3JFYWNoIiwibWV0aG9kIiwiYXJncyIsImFwcGx5IiwiR2xvYmFsSG9sZGVyV3JhcHBlciIsIl8iLCJzZXRNZXNzYWdlQ29uZmlnIiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJnbG9iYWwiLCJyb290UHJlZml4Q2xzIiwiZ2V0Um9vdFByZWZpeENscyIsInJvb3RJY29uUHJlZml4Q2xzIiwiZ2V0SWNvblByZWZpeENscyIsInRoZW1lIiwiZ2V0VGhlbWUiLCJkb20iLCJjcmVhdGVFbGVtZW50IiwiaWNvblByZWZpeENscyIsImhvbGRlclJlbmRlciIsImZsdXNoTWVzc2FnZVF1ZXVlIiwiaG9sZGVyRnJhZ21lbnQiLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50IiwibmV3TWVzc2FnZSIsImZyYWdtZW50IiwicmVhY3RSZW5kZXIiLCJub2RlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwidGFzayIsInR5cGUiLCJza2lwcGVkIiwiY2xvc2VGbiIsIm9wZW4iLCJjb25maWciLCJzZXRDbG9zZUZuIiwiZGVzdHJveSIsImtleSIsIl9tZXNzYWdlJGluc3RhbmNlIiwic2V0TWVzc2FnZUdsb2JhbENvbmZpZyIsIl9hIiwiY2FsbCIsInJlc3VsdCIsImZuIiwicHVzaCIsInR5cGVPcGVuIiwicHJvY2VzcyIsIm1ldGhvZHMiLCJiYXNlU3RhdGljTWV0aG9kcyIsIl9JbnRlcm5hbFBhbmVsRG9Ob3RVc2VPcllvdVdpbGxCZUZpcmVkIiwic3RhdGljTWV0aG9kcyIsIm5vb3AiLCJfYWN0V3JhcHBlciIsIndyYXBwZXIiLCJhY3RXcmFwcGVyIiwiX2FjdERlc3Ryb3kiLCJhY3REZXN0cm95Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/antd/es/message/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/antd/es/message/style/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/antd/es/message/style/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   prepareComponentToken: function() { return /* binding */ prepareComponentToken; }\n/* harmony export */ });\n/* harmony import */ var _ant_design_cssinjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ant-design/cssinjs */ \"(app-pages-browser)/./node_modules/antd/node_modules/@ant-design/cssinjs/es/index.js\");\n/* harmony import */ var _util_hooks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../_util/hooks */ \"(app-pages-browser)/./node_modules/antd/es/_util/hooks/useZIndex.js\");\n/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../style */ \"(app-pages-browser)/./node_modules/antd/es/style/index.js\");\n/* harmony import */ var _theme_internal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../theme/internal */ \"(app-pages-browser)/./node_modules/antd/es/theme/util/genStyleUtils.js\");\n/* harmony import */ var _theme_internal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../theme/internal */ \"(app-pages-browser)/./node_modules/@ant-design/cssinjs-utils/es/index.js\");\n\n\n\n\nconst genMessageStyle = (token)=>{\n    const { componentCls, iconCls, boxShadow, colorText, colorSuccess, colorError, colorWarning, colorInfo, fontSizeLG, motionEaseInOutCirc, motionDurationSlow, marginXS, paddingXS, borderRadiusLG, zIndexPopup, // Custom token\n    contentPadding, contentBg } = token;\n    const noticeCls = \"\".concat(componentCls, \"-notice\");\n    const messageMoveIn = new _ant_design_cssinjs__WEBPACK_IMPORTED_MODULE_0__.Keyframes(\"MessageMoveIn\", {\n        \"0%\": {\n            padding: 0,\n            transform: \"translateY(-100%)\",\n            opacity: 0\n        },\n        \"100%\": {\n            padding: paddingXS,\n            transform: \"translateY(0)\",\n            opacity: 1\n        }\n    });\n    const messageMoveOut = new _ant_design_cssinjs__WEBPACK_IMPORTED_MODULE_0__.Keyframes(\"MessageMoveOut\", {\n        \"0%\": {\n            maxHeight: token.height,\n            padding: paddingXS,\n            opacity: 1\n        },\n        \"100%\": {\n            maxHeight: 0,\n            padding: 0,\n            opacity: 0\n        }\n    });\n    const noticeStyle = {\n        padding: paddingXS,\n        textAlign: \"center\",\n        [\"\".concat(componentCls, \"-custom-content\")]: {\n            display: \"flex\",\n            alignItems: \"center\"\n        },\n        [\"\".concat(componentCls, \"-custom-content > \").concat(iconCls)]: {\n            marginInlineEnd: marginXS,\n            // affected by ltr or rtl\n            fontSize: fontSizeLG\n        },\n        [\"\".concat(noticeCls, \"-content\")]: {\n            display: \"inline-block\",\n            padding: contentPadding,\n            background: contentBg,\n            borderRadius: borderRadiusLG,\n            boxShadow,\n            pointerEvents: \"all\"\n        },\n        [\"\".concat(componentCls, \"-success > \").concat(iconCls)]: {\n            color: colorSuccess\n        },\n        [\"\".concat(componentCls, \"-error > \").concat(iconCls)]: {\n            color: colorError\n        },\n        [\"\".concat(componentCls, \"-warning > \").concat(iconCls)]: {\n            color: colorWarning\n        },\n        [\"\".concat(componentCls, \"-info > \").concat(iconCls, \",\\n      \").concat(componentCls, \"-loading > \").concat(iconCls)]: {\n            color: colorInfo\n        }\n    };\n    return [\n        // ============================ Holder ============================\n        {\n            [componentCls]: Object.assign(Object.assign({}, (0,_style__WEBPACK_IMPORTED_MODULE_1__.resetComponent)(token)), {\n                color: colorText,\n                position: \"fixed\",\n                top: marginXS,\n                width: \"100%\",\n                pointerEvents: \"none\",\n                zIndex: zIndexPopup,\n                [\"\".concat(componentCls, \"-move-up\")]: {\n                    animationFillMode: \"forwards\"\n                },\n                [\"\\n        \".concat(componentCls, \"-move-up-appear,\\n        \").concat(componentCls, \"-move-up-enter\\n      \")]: {\n                    animationName: messageMoveIn,\n                    animationDuration: motionDurationSlow,\n                    animationPlayState: \"paused\",\n                    animationTimingFunction: motionEaseInOutCirc\n                },\n                [\"\\n        \".concat(componentCls, \"-move-up-appear\").concat(componentCls, \"-move-up-appear-active,\\n        \").concat(componentCls, \"-move-up-enter\").concat(componentCls, \"-move-up-enter-active\\n      \")]: {\n                    animationPlayState: \"running\"\n                },\n                [\"\".concat(componentCls, \"-move-up-leave\")]: {\n                    animationName: messageMoveOut,\n                    animationDuration: motionDurationSlow,\n                    animationPlayState: \"paused\",\n                    animationTimingFunction: motionEaseInOutCirc\n                },\n                [\"\".concat(componentCls, \"-move-up-leave\").concat(componentCls, \"-move-up-leave-active\")]: {\n                    animationPlayState: \"running\"\n                },\n                \"&-rtl\": {\n                    direction: \"rtl\",\n                    span: {\n                        direction: \"rtl\"\n                    }\n                }\n            })\n        },\n        // ============================ Notice ============================\n        {\n            [componentCls]: {\n                [\"\".concat(noticeCls, \"-wrapper\")]: Object.assign({}, noticeStyle)\n            }\n        },\n        // ============================= Pure =============================\n        {\n            [\"\".concat(componentCls, \"-notice-pure-panel\")]: Object.assign(Object.assign({}, noticeStyle), {\n                padding: 0,\n                textAlign: \"start\"\n            })\n        }\n    ];\n};\nconst prepareComponentToken = (token)=>({\n        zIndexPopup: token.zIndexPopupBase + _util_hooks__WEBPACK_IMPORTED_MODULE_2__.CONTAINER_MAX_OFFSET + 10,\n        contentBg: token.colorBgElevated,\n        contentPadding: \"\".concat((token.controlHeightLG - token.fontSize * token.lineHeight) / 2, \"px \").concat(token.paddingSM, \"px\")\n    });\n// ============================== Export ==============================\n/* harmony default export */ __webpack_exports__[\"default\"] = ((0,_theme_internal__WEBPACK_IMPORTED_MODULE_3__.genStyleHooks)(\"Message\", (token)=>{\n    // Gen-style functions here\n    const combinedToken = (0,_theme_internal__WEBPACK_IMPORTED_MODULE_4__.mergeToken)(token, {\n        height: 150\n    });\n    return genMessageStyle(combinedToken);\n}, prepareComponentToken));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hbnRkL2VzL21lc3NhZ2Uvc3R5bGUvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWdEO0FBQ1M7QUFDWjtBQUNvQjtBQUNqRSxNQUFNSyxrQkFBa0JDLENBQUFBO0lBQ3RCLE1BQU0sRUFDSkMsWUFBWSxFQUNaQyxPQUFPLEVBQ1BDLFNBQVMsRUFDVEMsU0FBUyxFQUNUQyxZQUFZLEVBQ1pDLFVBQVUsRUFDVkMsWUFBWSxFQUNaQyxTQUFTLEVBQ1RDLFVBQVUsRUFDVkMsbUJBQW1CLEVBQ25CQyxrQkFBa0IsRUFDbEJDLFFBQVEsRUFDUkMsU0FBUyxFQUNUQyxjQUFjLEVBQ2RDLFdBQVcsRUFDWCxlQUFlO0lBQ2ZDLGNBQWMsRUFDZEMsU0FBUyxFQUNWLEdBQUdqQjtJQUNKLE1BQU1rQixZQUFZLEdBQWdCLE9BQWJqQixjQUFhO0lBQ2xDLE1BQU1rQixnQkFBZ0IsSUFBSXpCLDBEQUFTQSxDQUFDLGlCQUFpQjtRQUNuRCxNQUFNO1lBQ0owQixTQUFTO1lBQ1RDLFdBQVc7WUFDWEMsU0FBUztRQUNYO1FBQ0EsUUFBUTtZQUNORixTQUFTUDtZQUNUUSxXQUFXO1lBQ1hDLFNBQVM7UUFDWDtJQUNGO0lBQ0EsTUFBTUMsaUJBQWlCLElBQUk3QiwwREFBU0EsQ0FBQyxrQkFBa0I7UUFDckQsTUFBTTtZQUNKOEIsV0FBV3hCLE1BQU15QixNQUFNO1lBQ3ZCTCxTQUFTUDtZQUNUUyxTQUFTO1FBQ1g7UUFDQSxRQUFRO1lBQ05FLFdBQVc7WUFDWEosU0FBUztZQUNURSxTQUFTO1FBQ1g7SUFDRjtJQUNBLE1BQU1JLGNBQWM7UUFDbEJOLFNBQVNQO1FBQ1RjLFdBQVc7UUFDWCxDQUFDLEdBQWdCLE9BQWIxQixjQUFhLG1CQUFpQixFQUFFO1lBQ2xDMkIsU0FBUztZQUNUQyxZQUFZO1FBQ2Q7UUFDQSxDQUFDLEdBQW9DM0IsT0FBakNELGNBQWEsc0JBQTRCLE9BQVJDLFNBQVUsRUFBRTtZQUMvQzRC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QUMsV0FBV0csQ0FBQUE7SUFDdEMsMkJBQTJCO0lBQzNCLE1BQU11RCxnQkFBZ0J6RCwyREFBVUEsQ0FBQ0UsT0FBTztRQUN0Q3lCLFFBQVE7SUFDVjtJQUNBLE9BQU8xQixnQkFBZ0J3RDtBQUN6QixHQUFHTixzQkFBc0JBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FudGQvZXMvbWVzc2FnZS9zdHlsZS9pbmRleC5qcz9lZTBkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEtleWZyYW1lcyB9IGZyb20gJ0BhbnQtZGVzaWduL2Nzc2luanMnO1xuaW1wb3J0IHsgQ09OVEFJTkVSX01BWF9PRkZTRVQgfSBmcm9tICcuLi8uLi9fdXRpbC9ob29rcyc7XG5pbXBvcnQgeyByZXNldENvbXBvbmVudCB9IGZyb20gJy4uLy4uL3N0eWxlJztcbmltcG9ydCB7IGdlblN0eWxlSG9va3MsIG1lcmdlVG9rZW4gfSBmcm9tICcuLi8uLi90aGVtZS9pbnRlcm5hbCc7XG5jb25zdCBnZW5NZXNzYWdlU3R5bGUgPSB0b2tlbiA9PiB7XG4gIGNvbnN0IHtcbiAgICBjb21wb25lbnRDbHMsXG4gICAgaWNvbkNscyxcbiAgICBib3hTaGFkb3csXG4gICAgY29sb3JUZXh0LFxuICAgIGNvbG9yU3VjY2VzcyxcbiAgICBjb2xvckVycm9yLFxuICAgIGNvbG9yV2FybmluZyxcbiAgICBjb2xvckluZm8sXG4gICAgZm9udFNpemVMRyxcbiAgICBtb3Rpb25FYXNlSW5PdXRDaXJjLFxuICAgIG1vdGlvbkR1cmF0aW9uU2xvdyxcbiAgICBtYXJnaW5YUyxcbiAgICBwYWRkaW5nWFMsXG4gICAgYm9yZGVyUmFkaXVzTEcsXG4gICAgekluZGV4UG9wdXAsXG4gICAgLy8gQ3VzdG9tIHRva2VuXG4gICAgY29udGVudFBhZGRpbmcsXG4gICAgY29udGVudEJnXG4gIH0gPSB0b2tlbjtcbiAgY29uc3Qgbm90aWNlQ2xzID0gYCR7Y29tcG9uZW50Q2xzfS1ub3RpY2VgO1xuICBjb25zdCBtZXNzYWdlTW92ZUluID0gbmV3IEtleWZyYW1lcygnTWVzc2FnZU1vdmVJbicsIHtcbiAgICAnMCUnOiB7XG4gICAgICBwYWRkaW5nOiAwLFxuICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWSgtMTAwJSknLFxuICAgICAgb3BhY2l0eTogMFxuICAgIH0sXG4gICAgJzEwMCUnOiB7XG4gICAgICBwYWRkaW5nOiBwYWRkaW5nWFMsXG4gICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKDApJyxcbiAgICAgIG9wYWNpdHk6IDFcbiAgICB9XG4gIH0pO1xuICBjb25zdCBtZXNzYWdlTW92ZU91dCA9IG5ldyBLZXlmcmFtZXMoJ01lc3NhZ2VNb3ZlT3V0Jywge1xuICAgICcwJSc6IHtcbiAgICAgIG1heEhlaWdodDogdG9rZW4uaGVpZ2h0LFxuICAgICAgcGFkZGluZzogcGFkZGluZ1hTLFxuICAgICAgb3BhY2l0eTogMVxuICAgIH0sXG4gICAgJzEwMCUnOiB7XG4gICAgICBtYXhIZWlnaHQ6IDAsXG4gICAgICBwYWRkaW5nOiAwLFxuICAgICAgb3BhY2l0eTogMFxuICAgIH1cbiAgfSk7XG4gIGNvbnN0IG5vdGljZVN0eWxlID0ge1xuICAgIHBhZGRpbmc6IHBhZGRpbmdYUyxcbiAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgIFtgJHtjb21wb25lbnRDbHN9LWN1c3RvbS1jb250ZW50YF06IHtcbiAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInXG4gICAgfSxcbiAgICBbYCR7Y29tcG9uZW50Q2xzfS1jdXN0b20tY29udGVudCA+ICR7aWNvbkNsc31gXToge1xuICAgICAgbWFyZ2luSW5saW5lRW5kOiBtYXJnaW5YUyxcbiAgICAgIC8vIGFmZmVjdGVkIGJ5IGx0ciBvciBydGxcbiAgICAgIGZvbnRTaXplOiBmb250U2l6ZUxHXG4gICAgfSxcbiAgICBbYCR7bm90aWNlQ2xzfS1jb250ZW50YF06IHtcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgcGFkZGluZzogY29udGVudFBhZGRpbmcsXG4gICAgICBiYWNrZ3JvdW5kOiBjb250ZW50QmcsXG4gICAgICBib3JkZXJSYWRpdXM6IGJvcmRlclJhZGl1c0xHLFxuICAgICAgYm94U2hhZG93LFxuICAgICAgcG9pbnRlckV2ZW50czogJ2FsbCdcbiAgICB9LFxuICAgIFtgJHtjb21wb25lbnRDbHN9LXN1Y2Nlc3MgPiAke2ljb25DbHN9YF06IHtcbiAgICAgIGNvbG9yOiBjb2xvclN1Y2Nlc3NcbiAgICB9LFxuICAgIFtgJHtjb21wb25lbnRDbHN9LWVycm9yID4gJHtpY29uQ2xzfWBdOiB7XG4gICAgICBjb2xvcjogY29sb3JFcnJvclxuICAgIH0sXG4gICAgW2Ake2NvbXBvbmVudENsc30td2FybmluZyA+ICR7aWNvbkNsc31gXToge1xuICAgICAgY29sb3I6IGNvbG9yV2FybmluZ1xuICAgIH0sXG4gICAgW2Ake2NvbXBvbmVudENsc30taW5mbyA+ICR7aWNvbkNsc30sXG4gICAgICAke2NvbXBvbmVudENsc30tbG9hZGluZyA+ICR7aWNvbkNsc31gXToge1xuICAgICAgY29sb3I6IGNvbG9ySW5mb1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIFtcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PSBIb2xkZXIgPT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICB7XG4gICAgW2NvbXBvbmVudENsc106IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVzZXRDb21wb25lbnQodG9rZW4pKSwge1xuICAgICAgY29sb3I6IGNvbG9yVGV4dCxcbiAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgdG9wOiBtYXJnaW5YUyxcbiAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICB6SW5kZXg6IHpJbmRleFBvcHVwLFxuICAgICAgW2Ake2NvbXBvbmVudENsc30tbW92ZS11cGBdOiB7XG4gICAgICAgIGFuaW1hdGlvbkZpbGxNb2RlOiAnZm9yd2FyZHMnXG4gICAgICB9LFxuICAgICAgW2BcbiAgICAgICAgJHtjb21wb25lbnRDbHN9LW1vdmUtdXAtYXBwZWFyLFxuICAgICAgICAke2NvbXBvbmVudENsc30tbW92ZS11cC1lbnRlclxuICAgICAgYF06IHtcbiAgICAgICAgYW5pbWF0aW9uTmFtZTogbWVzc2FnZU1vdmVJbixcbiAgICAgICAgYW5pbWF0aW9uRHVyYXRpb246IG1vdGlvbkR1cmF0aW9uU2xvdyxcbiAgICAgICAgYW5pbWF0aW9uUGxheVN0YXRlOiAncGF1c2VkJyxcbiAgICAgICAgYW5pbWF0aW9uVGltaW5nRnVuY3Rpb246IG1vdGlvbkVhc2VJbk91dENpcmNcbiAgICAgIH0sXG4gICAgICBbYFxuICAgICAgICAke2NvbXBvbmVudENsc30tbW92ZS11cC1hcHBlYXIke2NvbXBvbmVudENsc30tbW92ZS11cC1hcHBlYXItYWN0aXZlLFxuICAgICAgICAke2NvbXBvbmVudENsc30tbW92ZS11cC1lbnRlciR7Y29tcG9uZW50Q2xzfS1tb3ZlLXVwLWVudGVyLWFjdGl2ZVxuICAgICAgYF06IHtcbiAgICAgICAgYW5pbWF0aW9uUGxheVN0YXRlOiAncnVubmluZydcbiAgICAgIH0sXG4gICAgICBbYCR7Y29tcG9uZW50Q2xzfS1tb3ZlLXVwLWxlYXZlYF06IHtcbiAgICAgICAgYW5pbWF0aW9uTmFtZTogbWVzc2FnZU1vdmVPdXQsXG4gICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uOiBtb3Rpb25EdXJhdGlvblNsb3csXG4gICAgICAgIGFuaW1hdGlvblBsYXlTdGF0ZTogJ3BhdXNlZCcsXG4gICAgICAgIGFuaW1hdGlvblRpbWluZ0Z1bmN0aW9uOiBtb3Rpb25FYXNlSW5PdXRDaXJjXG4gICAgICB9LFxuICAgICAgW2Ake2NvbXBvbmVudENsc30tbW92ZS11cC1sZWF2ZSR7Y29tcG9uZW50Q2xzfS1tb3ZlLXVwLWxlYXZlLWFjdGl2ZWBdOiB7XG4gICAgICAgIGFuaW1hdGlvblBsYXlTdGF0ZTogJ3J1bm5pbmcnXG4gICAgICB9LFxuICAgICAgJyYtcnRsJzoge1xuICAgICAgICBkaXJlY3Rpb246ICdydGwnLFxuICAgICAgICBzcGFuOiB7XG4gICAgICAgICAgZGlyZWN0aW9uOiAncnRsJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfSxcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PSBOb3RpY2UgPT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICB7XG4gICAgW2NvbXBvbmVudENsc106IHtcbiAgICAgIFtgJHtub3RpY2VDbHN9LXdyYXBwZXJgXTogT2JqZWN0LmFzc2lnbih7fSwgbm90aWNlU3R5bGUpXG4gICAgfVxuICB9LFxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PSBQdXJlID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIHtcbiAgICBbYCR7Y29tcG9uZW50Q2xzfS1ub3RpY2UtcHVyZS1wYW5lbGBdOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG5vdGljZVN0eWxlKSwge1xuICAgICAgcGFkZGluZzogMCxcbiAgICAgIHRleHRBbGlnbjogJ3N0YXJ0J1xuICAgIH0pXG4gIH1dO1xufTtcbmV4cG9ydCBjb25zdCBwcmVwYXJlQ29tcG9uZW50VG9rZW4gPSB0b2tlbiA9PiAoe1xuICB6SW5kZXhQb3B1cDogdG9rZW4uekluZGV4UG9wdXBCYXNlICsgQ09OVEFJTkVSX01BWF9PRkZTRVQgKyAxMCxcbiAgY29udGVudEJnOiB0b2tlbi5jb2xvckJnRWxldmF0ZWQsXG4gIGNvbnRlbnRQYWRkaW5nOiBgJHsodG9rZW4uY29udHJvbEhlaWdodExHIC0gdG9rZW4uZm9udFNpemUgKiB0b2tlbi5saW5lSGVpZ2h0KSAvIDJ9cHggJHt0b2tlbi5wYWRkaW5nU019cHhgXG59KTtcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSBFeHBvcnQgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5leHBvcnQgZGVmYXVsdCBnZW5TdHlsZUhvb2tzKCdNZXNzYWdlJywgdG9rZW4gPT4ge1xuICAvLyBHZW4tc3R5bGUgZnVuY3Rpb25zIGhlcmVcbiAgY29uc3QgY29tYmluZWRUb2tlbiA9IG1lcmdlVG9rZW4odG9rZW4sIHtcbiAgICBoZWlnaHQ6IDE1MFxuICB9KTtcbiAgcmV0dXJuIGdlbk1lc3NhZ2VTdHlsZShjb21iaW5lZFRva2VuKTtcbn0sIHByZXBhcmVDb21wb25lbnRUb2tlbik7Il0sIm5hbWVzIjpbIktleWZyYW1lcyIsIkNPTlRBSU5FUl9NQVhfT0ZGU0VUIiwicmVzZXRDb21wb25lbnQiLCJnZW5TdHlsZUhvb2tzIiwibWVyZ2VUb2tlbiIsImdlbk1lc3NhZ2VTdHlsZSIsInRva2VuIiwiY29tcG9uZW50Q2xzIiwiaWNvbkNscyIsImJveFNoYWRvdyIsImNvbG9yVGV4dCIsImNvbG9yU3VjY2VzcyIsImNvbG9yRXJyb3IiLCJjb2xvcldhcm5pbmciLCJjb2xvckluZm8iLCJmb250U2l6ZUxHIiwibW90aW9uRWFzZUluT3V0Q2lyYyIsIm1vdGlvbkR1cmF0aW9uU2xvdyIsIm1hcmdpblhTIiwicGFkZGluZ1hTIiwiYm9yZGVyUmFkaXVzTEciLCJ6SW5kZXhQb3B1cCIsImNvbnRlbnRQYWRkaW5nIiwiY29udGVudEJnIiwibm90aWNlQ2xzIiwibWVzc2FnZU1vdmVJbiIsInBhZGRpbmciLCJ0cmFuc2Zvcm0iLCJvcGFjaXR5IiwibWVzc2FnZU1vdmVPdXQiLCJtYXhIZWlnaHQiLCJoZWlnaHQiLCJub3RpY2VTdHlsZSIsInRleHRBbGlnbiIsImRpc3BsYXkiLCJhbGlnbkl0ZW1zIiwibWFyZ2luSW5saW5lRW5kIiwiZm9udFNpemUiLCJiYWNrZ3JvdW5kIiwiYm9yZGVyUmFkaXVzIiwicG9pbnRlckV2ZW50cyIsImNvbG9yIiwiT2JqZWN0IiwiYXNzaWduIiwicG9zaXRpb24iLCJ0b3AiLCJ3aWR0aCIsInpJbmRleCIsImFuaW1hdGlvbkZpbGxNb2RlIiwiYW5pbWF0aW9uTmFtZSIsImFuaW1hdGlvbkR1cmF0aW9uIiwiYW5pbWF0aW9uUGxheVN0YXRlIiwiYW5pbWF0aW9uVGltaW5nRnVuY3Rpb24iLCJkaXJlY3Rpb24iLCJzcGFuIiwicHJlcGFyZUNvbXBvbmVudFRva2VuIiwiekluZGV4UG9wdXBCYXNlIiwiY29sb3JCZ0VsZXZhdGVkIiwiY29udHJvbEhlaWdodExHIiwibGluZUhlaWdodCIsInBhZGRpbmdTTSIsImNvbWJpbmVkVG9rZW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/antd/es/message/style/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/antd/es/message/useMessage.js":
/*!****************************************************!*\
  !*** ./node_modules/antd/es/message/useMessage.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ useMessage; },\n/* harmony export */   useInternalMessage: function() { return /* binding */ useInternalMessage; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ant_design_icons_es_icons_CloseOutlined__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ant-design/icons/es/icons/CloseOutlined */ \"(app-pages-browser)/./node_modules/@ant-design/icons/es/icons/CloseOutlined.js\");\n/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classnames */ \"(app-pages-browser)/./node_modules/classnames/index.js\");\n/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var rc_notification__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rc-notification */ \"(app-pages-browser)/./node_modules/rc-notification/es/index.js\");\n/* harmony import */ var _util_warning__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../_util/warning */ \"(app-pages-browser)/./node_modules/antd/es/_util/warning.js\");\n/* harmony import */ var _config_provider__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../config-provider */ \"(app-pages-browser)/./node_modules/antd/es/config-provider/context.js\");\n/* harmony import */ var _config_provider_hooks_useCSSVarCls__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../config-provider/hooks/useCSSVarCls */ \"(app-pages-browser)/./node_modules/antd/es/config-provider/hooks/useCSSVarCls.js\");\n/* harmony import */ var _PurePanel__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./PurePanel */ \"(app-pages-browser)/./node_modules/antd/es/message/PurePanel.js\");\n/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./style */ \"(app-pages-browser)/./node_modules/antd/es/message/style/index.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./util */ \"(app-pages-browser)/./node_modules/antd/es/message/util.js\");\n/* __next_internal_client_entry_do_not_use__ useInternalMessage,default auto */ var _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$(), _s3 = $RefreshSig$();\nvar __rest = undefined && undefined.__rest || function(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n};\n\n\n\n\n\n\n\n\n\n\nconst DEFAULT_OFFSET = 8;\nconst DEFAULT_DURATION = 3;\nconst Wrapper = (param)=>{\n    let { children, prefixCls } = param;\n    _s();\n    const rootCls = (0,_config_provider_hooks_useCSSVarCls__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(prefixCls);\n    const [wrapCSSVar, hashId, cssVarCls] = (0,_style__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(prefixCls, rootCls);\n    return wrapCSSVar(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(rc_notification__WEBPACK_IMPORTED_MODULE_2__.NotificationProvider, {\n        classNames: {\n            list: classnames__WEBPACK_IMPORTED_MODULE_1___default()(hashId, cssVarCls, rootCls)\n        }\n    }, children));\n};\n_s(Wrapper, \"CothqVycWrj4YdpXd2u2U3iXJm4=\", false, function() {\n    return [\n        _config_provider_hooks_useCSSVarCls__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n        _style__WEBPACK_IMPORTED_MODULE_4__[\"default\"]\n    ];\n});\n_c = Wrapper;\nconst renderNotifications = (node, param)=>{\n    let { prefixCls, key } = param;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Wrapper, {\n        prefixCls: prefixCls,\n        key: key\n    }, node);\n};\nconst Holder = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(_s1((props, ref)=>{\n    _s1();\n    const { top, prefixCls: staticPrefixCls, getContainer: staticGetContainer, maxCount, duration = DEFAULT_DURATION, rtl, transitionName, onAllRemoved } = props;\n    const { getPrefixCls, getPopupContainer, message, direction } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(_config_provider__WEBPACK_IMPORTED_MODULE_5__.ConfigContext);\n    const prefixCls = staticPrefixCls || getPrefixCls(\"message\");\n    // =============================== Style ===============================\n    const getStyle = ()=>({\n            left: \"50%\",\n            transform: \"translateX(-50%)\",\n            top: top !== null && top !== void 0 ? top : DEFAULT_OFFSET\n        });\n    const getClassName = ()=>classnames__WEBPACK_IMPORTED_MODULE_1___default()({\n            [\"\".concat(prefixCls, \"-rtl\")]: rtl !== null && rtl !== void 0 ? rtl : direction === \"rtl\"\n        });\n    // ============================== Motion ===============================\n    const getNotificationMotion = ()=>(0,_util__WEBPACK_IMPORTED_MODULE_6__.getMotion)(prefixCls, transitionName);\n    // ============================ Close Icon =============================\n    const mergedCloseIcon = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n        className: \"\".concat(prefixCls, \"-close-x\")\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_ant_design_icons_es_icons_CloseOutlined__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n        className: \"\".concat(prefixCls, \"-close-icon\")\n    }));\n    // ============================== Origin ===============================\n    const [api, holder] = (0,rc_notification__WEBPACK_IMPORTED_MODULE_2__.useNotification)({\n        prefixCls,\n        style: getStyle,\n        className: getClassName,\n        motion: getNotificationMotion,\n        closable: false,\n        closeIcon: mergedCloseIcon,\n        duration,\n        getContainer: ()=>(staticGetContainer === null || staticGetContainer === void 0 ? void 0 : staticGetContainer()) || (getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer()) || document.body,\n        maxCount,\n        onAllRemoved,\n        renderNotifications\n    });\n    // ================================ Ref ================================\n    react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle(ref, ()=>Object.assign(Object.assign({}, api), {\n            prefixCls,\n            message\n        }));\n    return holder;\n}, \"Cr0EYmQgQB+RNyLPo/fPh4iR9oE=\", false, function() {\n    return [\n        rc_notification__WEBPACK_IMPORTED_MODULE_2__.useNotification\n    ];\n}));\n_c1 = Holder;\n// ==============================================================================\n// ==                                   Hook                                   ==\n// ==============================================================================\nlet keyIndex = 0;\nfunction useInternalMessage(messageConfig) {\n    _s2();\n    const holderRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const warning = (0,_util_warning__WEBPACK_IMPORTED_MODULE_8__.devUseWarning)(\"Message\");\n    // ================================ API ================================\n    const wrapAPI = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        // Wrap with notification content\n        // >>> close\n        const close = (key)=>{\n            var _a;\n            (_a = holderRef.current) === null || _a === void 0 ? void 0 : _a.close(key);\n        };\n        // >>> Open\n        const open = (config)=>{\n            if (!holderRef.current) {\n                 true ? warning(false, \"usage\", \"You are calling notice in render which will break in React 18 concurrent mode. Please trigger in effect instead.\") : 0;\n                const fakeResult = ()=>{};\n                // eslint-disable-next-line react-hooks/immutability\n                fakeResult.then = ()=>{};\n                return fakeResult;\n            }\n            const { open: originOpen, prefixCls, message } = holderRef.current;\n            const noticePrefixCls = \"\".concat(prefixCls, \"-notice\");\n            const { content, icon, type, key, className, style, onClose } = config, restConfig = __rest(config, [\n                \"content\",\n                \"icon\",\n                \"type\",\n                \"key\",\n                \"className\",\n                \"style\",\n                \"onClose\"\n            ]);\n            let mergedKey = key;\n            if (mergedKey === undefined || mergedKey === null) {\n                keyIndex += 1;\n                mergedKey = \"antd-message-\".concat(keyIndex);\n            }\n            return (0,_util__WEBPACK_IMPORTED_MODULE_6__.wrapPromiseFn)((resolve)=>{\n                originOpen(Object.assign(Object.assign({}, restConfig), {\n                    key: mergedKey,\n                    content: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_PurePanel__WEBPACK_IMPORTED_MODULE_9__.PureContent, {\n                        prefixCls: prefixCls,\n                        type: type,\n                        icon: icon\n                    }, content),\n                    placement: \"top\",\n                    className: classnames__WEBPACK_IMPORTED_MODULE_1___default()(type && \"\".concat(noticePrefixCls, \"-\").concat(type), className, message === null || message === void 0 ? void 0 : message.className),\n                    style: Object.assign(Object.assign({}, message === null || message === void 0 ? void 0 : message.style), style),\n                    onClose: ()=>{\n                        onClose === null || onClose === void 0 ? void 0 : onClose();\n                        resolve();\n                    }\n                }));\n                // Return close function\n                return ()=>{\n                    close(mergedKey);\n                };\n            });\n        };\n        // >>> destroy\n        const destroy = (key)=>{\n            var _a;\n            if (key !== undefined) {\n                close(key);\n            } else {\n                (_a = holderRef.current) === null || _a === void 0 ? void 0 : _a.destroy();\n            }\n        };\n        const clone = {\n            open,\n            destroy\n        };\n        const keys = [\n            \"info\",\n            \"success\",\n            \"warning\",\n            \"error\",\n            \"loading\"\n        ];\n        keys.forEach((type)=>{\n            const typeOpen = (jointContent, duration, onClose)=>{\n                let config;\n                if (jointContent && typeof jointContent === \"object\" && \"content\" in jointContent) {\n                    config = jointContent;\n                } else {\n                    config = {\n                        content: jointContent\n                    };\n                }\n                // Params\n                let mergedDuration;\n                let mergedOnClose;\n                if (typeof duration === \"function\") {\n                    mergedOnClose = duration;\n                } else {\n                    mergedDuration = duration;\n                    mergedOnClose = onClose;\n                }\n                const mergedConfig = Object.assign(Object.assign({\n                    onClose: mergedOnClose,\n                    duration: mergedDuration\n                }, config), {\n                    type\n                });\n                return open(mergedConfig);\n            };\n            clone[type] = typeOpen;\n        });\n        return clone;\n    }, []);\n    // ============================== Return ===============================\n    return [\n        wrapAPI,\n        /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Holder, Object.assign({\n            key: \"message-holder\"\n        }, messageConfig, {\n            ref: holderRef\n        }))\n    ];\n}\n_s2(useInternalMessage, \"QRVbyP/o1OOHfAynlvbw4cB8aKI=\");\nfunction useMessage(messageConfig) {\n    _s3();\n    return useInternalMessage(messageConfig);\n}\n_s3(useMessage, \"qRKysAHQqDPucySJP7LgVeZh5gA=\", false, function() {\n    return [\n        useInternalMessage\n    ];\n});\nvar _c, _c1;\n$RefreshReg$(_c, \"Wrapper\");\n$RefreshReg$(_c1, \"Holder\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hbnRkL2VzL21lc3NhZ2UvdXNlTWVzc2FnZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQSxJQUFJQSxTQUFTLFNBQUksSUFBSSxTQUFJLENBQUNBLE1BQU0sSUFBSSxTQUFVQyxDQUFDLEVBQUVDLENBQUM7SUFDaEQsSUFBSUMsSUFBSSxDQUFDO0lBQ1QsSUFBSyxJQUFJQyxLQUFLSCxFQUFHLElBQUlJLE9BQU9DLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNQLEdBQUdHLE1BQU1GLEVBQUVPLE9BQU8sQ0FBQ0wsS0FBSyxHQUFHRCxDQUFDLENBQUNDLEVBQUUsR0FBR0gsQ0FBQyxDQUFDRyxFQUFFO0lBQ2hHLElBQUlILEtBQUssUUFBUSxPQUFPSSxPQUFPSyxxQkFBcUIsS0FBSyxZQUFZLElBQUssSUFBSUMsSUFBSSxHQUFHUCxJQUFJQyxPQUFPSyxxQkFBcUIsQ0FBQ1QsSUFBSVUsSUFBSVAsRUFBRVEsTUFBTSxFQUFFRCxJQUFLO1FBQzNJLElBQUlULEVBQUVPLE9BQU8sQ0FBQ0wsQ0FBQyxDQUFDTyxFQUFFLElBQUksS0FBS04sT0FBT0MsU0FBUyxDQUFDTyxvQkFBb0IsQ0FBQ0wsSUFBSSxDQUFDUCxHQUFHRyxDQUFDLENBQUNPLEVBQUUsR0FBR1IsQ0FBQyxDQUFDQyxDQUFDLENBQUNPLEVBQUUsQ0FBQyxHQUFHVixDQUFDLENBQUNHLENBQUMsQ0FBQ08sRUFBRSxDQUFDO0lBQ25HO0lBQ0EsT0FBT1I7QUFDVDtBQUMrQjtBQUNzQztBQUNqQztBQUN5RDtBQUM1QztBQUNFO0FBQ2M7QUFDdkI7QUFDWDtBQUNtQjtBQUNsRCxNQUFNd0IsaUJBQWlCO0FBQ3ZCLE1BQU1DLG1CQUFtQjtBQUN6QixNQUFNQyxVQUFVO1FBQUMsRUFDZkMsUUFBUSxFQUNSQyxTQUFTLEVBQ1Y7O0lBQ0MsTUFBTUMsVUFBVVYsK0VBQVlBLENBQUNTO0lBQzdCLE1BQU0sQ0FBQ0Us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QkFDSixJQUFJQztnQkFDSixJQUFJLE9BQU8zRCxhQUFhLFlBQVk7b0JBQ2xDMkQsZ0JBQWdCM0Q7Z0JBQ2xCLE9BQU87b0JBQ0wwRCxpQkFBaUIxRDtvQkFDakIyRCxnQkFBZ0JiO2dCQUNsQjtnQkFDQSxNQUFNYyxlQUFlekcsT0FBT3NFLE1BQU0sQ0FBQ3RFLE9BQU9zRSxNQUFNLENBQUM7b0JBQy9DcUIsU0FBU2E7b0JBQ1QzRCxVQUFVMEQ7Z0JBQ1osR0FBR3BCLFNBQVM7b0JBQ1ZPO2dCQUNGO2dCQUNBLE9BQU9SLEtBQUt1QjtZQUNkO1lBQ0FQLEtBQUssQ0FBQ1IsS0FBSyxHQUFHVztRQUNoQjtRQUNBLE9BQU9IO0lBQ1QsR0FBRyxFQUFFO0lBQ0wsd0VBQXdFO0lBQ3hFLE9BQU87UUFBQ3JCO1FBQVMsV0FBVyxHQUFFcEUsZ0RBQW1CLENBQUMyQixRQUFRcEMsT0FBT3NFLE1BQU0sQ0FBQztZQUN0RW5DLEtBQUs7UUFDUCxHQUFHc0MsZUFBZTtZQUNoQmxDLEtBQUttQztRQUNQO0tBQUk7QUFDTjtJQWxIZ0JGO0FBbUhELFNBQVNrQyxXQUFXakMsYUFBYTs7SUFDOUMsT0FBT0QsbUJBQW1CQztBQUM1QjtJQUZ3QmlDOztRQUNmbEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FudGQvZXMvbWVzc2FnZS91c2VNZXNzYWdlLmpzPzA5MDYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbnZhciBfX3Jlc3QgPSB0aGlzICYmIHRoaXMuX19yZXN0IHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gIHZhciB0ID0ge307XG4gIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKSB0W3BdID0gc1twXTtcbiAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKSBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKSB0W3BbaV1dID0gc1twW2ldXTtcbiAgfVxuICByZXR1cm4gdDtcbn07XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgQ2xvc2VPdXRsaW5lZCBmcm9tIFwiQGFudC1kZXNpZ24vaWNvbnMvZXMvaWNvbnMvQ2xvc2VPdXRsaW5lZFwiO1xuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgeyBOb3RpZmljYXRpb25Qcm92aWRlciwgdXNlTm90aWZpY2F0aW9uIGFzIHVzZVJjTm90aWZpY2F0aW9uIH0gZnJvbSAncmMtbm90aWZpY2F0aW9uJztcbmltcG9ydCB7IGRldlVzZVdhcm5pbmcgfSBmcm9tICcuLi9fdXRpbC93YXJuaW5nJztcbmltcG9ydCB7IENvbmZpZ0NvbnRleHQgfSBmcm9tICcuLi9jb25maWctcHJvdmlkZXInO1xuaW1wb3J0IHVzZUNTU1ZhckNscyBmcm9tICcuLi9jb25maWctcHJvdmlkZXIvaG9va3MvdXNlQ1NTVmFyQ2xzJztcbmltcG9ydCB7IFB1cmVDb250ZW50IH0gZnJvbSAnLi9QdXJlUGFuZWwnO1xuaW1wb3J0IHVzZVN0eWxlIGZyb20gJy4vc3R5bGUnO1xuaW1wb3J0IHsgZ2V0TW90aW9uLCB3cmFwUHJvbWlzZUZuIH0gZnJvbSAnLi91dGlsJztcbmNvbnN0IERFRkFVTFRfT0ZGU0VUID0gODtcbmNvbnN0IERFRkFVTFRfRFVSQVRJT04gPSAzO1xuY29uc3QgV3JhcHBlciA9ICh7XG4gIGNoaWxkcmVuLFxuICBwcmVmaXhDbHNcbn0pID0+IHtcbiAgY29uc3Qgcm9vdENscyA9IHVzZUNTU1ZhckNscyhwcmVmaXhDbHMpO1xuICBjb25zdCBbd3JhcENTU1ZhciwgaGFzaElkLCBjc3NWYXJDbHNdID0gdXNlU3R5bGUocHJlZml4Q2xzLCByb290Q2xzKTtcbiAgcmV0dXJuIHdyYXBDU1NWYXIoLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTm90aWZpY2F0aW9uUHJvdmlkZXIsIHtcbiAgICBjbGFzc05hbWVzOiB7XG4gICAgICBsaXN0OiBjbGFzc05hbWVzKGhhc2hJZCwgY3NzVmFyQ2xzLCByb290Q2xzKVxuICAgIH1cbiAgfSwgY2hpbGRyZW4pKTtcbn07XG5jb25zdCByZW5kZXJOb3RpZmljYXRpb25zID0gKG5vZGUsIHtcbiAgcHJlZml4Q2xzLFxuICBrZXlcbn0pID0+ICgvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChXcmFwcGVyLCB7XG4gIHByZWZpeENsczogcHJlZml4Q2xzLFxuICBrZXk6IGtleVxufSwgbm9kZSkpO1xuY29uc3QgSG9sZGVyID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHtcbiAgY29uc3Qge1xuICAgIHRvcCxcbiAgICBwcmVmaXhDbHM6IHN0YXRpY1ByZWZpeENscyxcbiAgICBnZXRDb250YWluZXI6IHN0YXRpY0dldENvbnRhaW5lcixcbiAgICBtYXhDb3VudCxcbiAgICBkdXJhdGlvbiA9IERFRkFVTFRfRFVSQVRJT04sXG4gICAgcnRsLFxuICAgIHRyYW5zaXRpb25OYW1lLFxuICAgIG9uQWxsUmVtb3ZlZFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHtcbiAgICBnZXRQcmVmaXhDbHMsXG4gICAgZ2V0UG9wdXBDb250YWluZXIsXG4gICAgbWVzc2FnZSxcbiAgICBkaXJlY3Rpb25cbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoQ29uZmlnQ29udGV4dCk7XG4gIGNvbnN0IHByZWZpeENscyA9IHN0YXRpY1ByZWZpeENscyB8fCBnZXRQcmVmaXhDbHMoJ21lc3NhZ2UnKTtcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSBTdHlsZSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGNvbnN0IGdldFN0eWxlID0gKCkgPT4gKHtcbiAgICBsZWZ0OiAnNTAlJyxcbiAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKC01MCUpJyxcbiAgICB0b3A6IHRvcCAhPT0gbnVsbCAmJiB0b3AgIT09IHZvaWQgMCA/IHRvcCA6IERFRkFVTFRfT0ZGU0VUXG4gIH0pO1xuICBjb25zdCBnZXRDbGFzc05hbWUgPSAoKSA9PiBjbGFzc05hbWVzKHtcbiAgICBbYCR7cHJlZml4Q2xzfS1ydGxgXTogcnRsICE9PSBudWxsICYmIHJ0bCAhPT0gdm9pZCAwID8gcnRsIDogZGlyZWN0aW9uID09PSAncnRsJ1xuICB9KTtcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09IE1vdGlvbiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGNvbnN0IGdldE5vdGlmaWNhdGlvbk1vdGlvbiA9ICgpID0+IGdldE1vdGlvbihwcmVmaXhDbHMsIHRyYW5zaXRpb25OYW1lKTtcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PSBDbG9zZSBJY29uID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGNvbnN0IG1lcmdlZENsb3NlSWNvbiA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgY2xhc3NOYW1lOiBgJHtwcmVmaXhDbHN9LWNsb3NlLXhgXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENsb3NlT3V0bGluZWQsIHtcbiAgICBjbGFzc05hbWU6IGAke3ByZWZpeENsc30tY2xvc2UtaWNvbmBcbiAgfSkpO1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gT3JpZ2luID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgY29uc3QgW2FwaSwgaG9sZGVyXSA9IHVzZVJjTm90aWZpY2F0aW9uKHtcbiAgICBwcmVmaXhDbHMsXG4gICAgc3R5bGU6IGdldFN0eWxlLFxuICAgIGNsYXNzTmFtZTogZ2V0Q2xhc3NOYW1lLFxuICAgIG1vdGlvbjogZ2V0Tm90aWZpY2F0aW9uTW90aW9uLFxuICAgIGNsb3NhYmxlOiBmYWxzZSxcbiAgICBjbG9zZUljb246IG1lcmdlZENsb3NlSWNvbixcbiAgICBkdXJhdGlvbixcbiAgICBnZXRDb250YWluZXI6ICgpID0+IChzdGF0aWNHZXRDb250YWluZXIgPT09IG51bGwgfHwgc3RhdGljR2V0Q29udGFpbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdGF0aWNHZXRDb250YWluZXIoKSkgfHwgKGdldFBvcHVwQ29udGFpbmVyID09PSBudWxsIHx8IGdldFBvcHVwQ29udGFpbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnZXRQb3B1cENvbnRhaW5lcigpKSB8fCBkb2N1bWVudC5ib2R5LFxuICAgIG1heENvdW50LFxuICAgIG9uQWxsUmVtb3ZlZCxcbiAgICByZW5kZXJOb3RpZmljYXRpb25zXG4gIH0pO1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSBSZWYgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgUmVhY3QudXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsICgpID0+IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYXBpKSwge1xuICAgIHByZWZpeENscyxcbiAgICBtZXNzYWdlXG4gIH0pKTtcbiAgcmV0dXJuIGhvbGRlcjtcbn0pO1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyA9PSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSG9vayAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPT1cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxubGV0IGtleUluZGV4ID0gMDtcbmV4cG9ydCBmdW5jdGlvbiB1c2VJbnRlcm5hbE1lc3NhZ2UobWVzc2FnZUNvbmZpZykge1xuICBjb25zdCBob2xkZXJSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IHdhcm5pbmcgPSBkZXZVc2VXYXJuaW5nKCdNZXNzYWdlJyk7XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09IEFQSSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBjb25zdCB3cmFwQVBJID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgLy8gV3JhcCB3aXRoIG5vdGlmaWNhdGlvbiBjb250ZW50XG4gICAgLy8gPj4+IGNsb3NlXG4gICAgY29uc3QgY2xvc2UgPSBrZXkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgKF9hID0gaG9sZGVyUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9zZShrZXkpO1xuICAgIH07XG4gICAgLy8gPj4+IE9wZW5cbiAgICBjb25zdCBvcGVuID0gY29uZmlnID0+IHtcbiAgICAgIGlmICghaG9sZGVyUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgJ3VzYWdlJywgJ1lvdSBhcmUgY2FsbGluZyBub3RpY2UgaW4gcmVuZGVyIHdoaWNoIHdpbGwgYnJlYWsgaW4gUmVhY3QgMTggY29uY3VycmVudCBtb2RlLiBQbGVhc2UgdHJpZ2dlciBpbiBlZmZlY3QgaW5zdGVhZC4nKSA6IHZvaWQgMDtcbiAgICAgICAgY29uc3QgZmFrZVJlc3VsdCA9ICgpID0+IHt9O1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvaW1tdXRhYmlsaXR5XG4gICAgICAgIGZha2VSZXN1bHQudGhlbiA9ICgpID0+IHt9O1xuICAgICAgICByZXR1cm4gZmFrZVJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb3Blbjogb3JpZ2luT3BlbixcbiAgICAgICAgcHJlZml4Q2xzLFxuICAgICAgICBtZXNzYWdlXG4gICAgICB9ID0gaG9sZGVyUmVmLmN1cnJlbnQ7XG4gICAgICBjb25zdCBub3RpY2VQcmVmaXhDbHMgPSBgJHtwcmVmaXhDbHN9LW5vdGljZWA7XG4gICAgICBjb25zdCB7XG4gICAgICAgICAgY29udGVudCxcbiAgICAgICAgICBpY29uLFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgICBzdHlsZSxcbiAgICAgICAgICBvbkNsb3NlXG4gICAgICAgIH0gPSBjb25maWcsXG4gICAgICAgIHJlc3RDb25maWcgPSBfX3Jlc3QoY29uZmlnLCBbXCJjb250ZW50XCIsIFwiaWNvblwiLCBcInR5cGVcIiwgXCJrZXlcIiwgXCJjbGFzc05hbWVcIiwgXCJzdHlsZVwiLCBcIm9uQ2xvc2VcIl0pO1xuICAgICAgbGV0IG1lcmdlZEtleSA9IGtleTtcbiAgICAgIGlmIChtZXJnZWRLZXkgPT09IHVuZGVmaW5lZCB8fCBtZXJnZWRLZXkgPT09IG51bGwpIHtcbiAgICAgICAga2V5SW5kZXggKz0gMTtcbiAgICAgICAgbWVyZ2VkS2V5ID0gYGFudGQtbWVzc2FnZS0ke2tleUluZGV4fWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcFByb21pc2VGbihyZXNvbHZlID0+IHtcbiAgICAgICAgb3JpZ2luT3BlbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3RDb25maWcpLCB7XG4gICAgICAgICAga2V5OiBtZXJnZWRLZXksXG4gICAgICAgICAgY29udGVudDogKC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFB1cmVDb250ZW50LCB7XG4gICAgICAgICAgICBwcmVmaXhDbHM6IHByZWZpeENscyxcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBpY29uOiBpY29uXG4gICAgICAgICAgfSwgY29udGVudCkpLFxuICAgICAgICAgIHBsYWNlbWVudDogJ3RvcCcsXG4gICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzKHR5cGUgJiYgYCR7bm90aWNlUHJlZml4Q2xzfS0ke3R5cGV9YCwgY2xhc3NOYW1lLCBtZXNzYWdlID09PSBudWxsIHx8IG1lc3NhZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1lc3NhZ2UuY2xhc3NOYW1lKSxcbiAgICAgICAgICBzdHlsZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtZXNzYWdlID09PSBudWxsIHx8IG1lc3NhZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1lc3NhZ2Uuc3R5bGUpLCBzdHlsZSksXG4gICAgICAgICAgb25DbG9zZTogKCkgPT4ge1xuICAgICAgICAgICAgb25DbG9zZSA9PT0gbnVsbCB8fCBvbkNsb3NlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkNsb3NlKCk7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIC8vIFJldHVybiBjbG9zZSBmdW5jdGlvblxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIGNsb3NlKG1lcmdlZEtleSk7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9O1xuICAgIC8vID4+PiBkZXN0cm95XG4gICAgY29uc3QgZGVzdHJveSA9IGtleSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2xvc2Uoa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIChfYSA9IGhvbGRlclJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgY2xvbmUgPSB7XG4gICAgICBvcGVuLFxuICAgICAgZGVzdHJveVxuICAgIH07XG4gICAgY29uc3Qga2V5cyA9IFsnaW5mbycsICdzdWNjZXNzJywgJ3dhcm5pbmcnLCAnZXJyb3InLCAnbG9hZGluZyddO1xuICAgIGtleXMuZm9yRWFjaCh0eXBlID0+IHtcbiAgICAgIGNvbnN0IHR5cGVPcGVuID0gKGpvaW50Q29udGVudCwgZHVyYXRpb24sIG9uQ2xvc2UpID0+IHtcbiAgICAgICAgbGV0IGNvbmZpZztcbiAgICAgICAgaWYgKGpvaW50Q29udGVudCAmJiB0eXBlb2Ygam9pbnRDb250ZW50ID09PSAnb2JqZWN0JyAmJiAnY29udGVudCcgaW4gam9pbnRDb250ZW50KSB7XG4gICAgICAgICAgY29uZmlnID0gam9pbnRDb250ZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IGpvaW50Q29udGVudFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFyYW1zXG4gICAgICAgIGxldCBtZXJnZWREdXJhdGlvbjtcbiAgICAgICAgbGV0IG1lcmdlZE9uQ2xvc2U7XG4gICAgICAgIGlmICh0eXBlb2YgZHVyYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBtZXJnZWRPbkNsb3NlID0gZHVyYXRpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWVyZ2VkRHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgICBtZXJnZWRPbkNsb3NlID0gb25DbG9zZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXJnZWRDb25maWcgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIG9uQ2xvc2U6IG1lcmdlZE9uQ2xvc2UsXG4gICAgICAgICAgZHVyYXRpb246IG1lcmdlZER1cmF0aW9uXG4gICAgICAgIH0sIGNvbmZpZyksIHtcbiAgICAgICAgICB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb3BlbihtZXJnZWRDb25maWcpO1xuICAgICAgfTtcbiAgICAgIGNsb25lW3R5cGVdID0gdHlwZU9wZW47XG4gICAgfSk7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9LCBbXSk7XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSBSZXR1cm4gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICByZXR1cm4gW3dyYXBBUEksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEhvbGRlciwgT2JqZWN0LmFzc2lnbih7XG4gICAga2V5OiBcIm1lc3NhZ2UtaG9sZGVyXCJcbiAgfSwgbWVzc2FnZUNvbmZpZywge1xuICAgIHJlZjogaG9sZGVyUmVmXG4gIH0pKV07XG59XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VNZXNzYWdlKG1lc3NhZ2VDb25maWcpIHtcbiAgcmV0dXJuIHVzZUludGVybmFsTWVzc2FnZShtZXNzYWdlQ29uZmlnKTtcbn0iXSwibmFtZXMiOlsiX19yZXN0IiwicyIsImUiLCJ0IiwicCIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImluZGV4T2YiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJpIiwibGVuZ3RoIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJSZWFjdCIsIkNsb3NlT3V0bGluZWQiLCJjbGFzc05hbWVzIiwiTm90aWZpY2F0aW9uUHJvdmlkZXIiLCJ1c2VOb3RpZmljYXRpb24iLCJ1c2VSY05vdGlmaWNhdGlvbiIsImRldlVzZVdhcm5pbmciLCJDb25maWdDb250ZXh0IiwidXNlQ1NTVmFyQ2xzIiwiUHVyZUNvbnRlbnQiLCJ1c2VTdHlsZSIsImdldE1vdGlvbiIsIndyYXBQcm9taXNlRm4iLCJERUZBVUxUX09GRlNFVCIsIkRFRkFVTFRfRFVSQVRJT04iLCJXcmFwcGVyIiwiY2hpbGRyZW4iLCJwcmVmaXhDbHMiLCJyb290Q2xzIiwid3JhcENTU1ZhciIsImhhc2hJZCIsImNzc1ZhckNscyIsImNyZWF0ZUVsZW1lbnQiLCJsaXN0IiwicmVuZGVyTm90aWZpY2F0aW9ucyIsIm5vZGUiLCJrZXkiLCJIb2xkZXIiLCJmb3J3YXJkUmVmIiwicHJvcHMiLCJyZWYiLCJ0b3AiLCJzdGF0aWNQcmVmaXhDbHMiLCJnZXRDb250YWluZXIiLCJzdGF0aWNHZXRDb250YWluZXIiLCJtYXhDb3VudCIsImR1cmF0aW9uIiwicnRsIiwidHJhbnNpdGlvbk5hbWUiLCJvbkFsbFJlbW92ZWQiLCJnZXRQcmVmaXhDbHMiLCJnZXRQb3B1cENvbnRhaW5lciIsIm1lc3NhZ2UiLCJkaXJlY3Rpb24iLCJ1c2VDb250ZXh0IiwiZ2V0U3R5bGUiLCJsZWZ0IiwidHJhbnNmb3JtIiwiZ2V0Q2xhc3NOYW1lIiwiZ2V0Tm90aWZpY2F0aW9uTW90aW9uIiwibWVyZ2VkQ2xvc2VJY29uIiwiY2xhc3NOYW1lIiwiYXBpIiwiaG9sZGVyIiwic3R5bGUiLCJtb3Rpb24iLCJjbG9zYWJsZSIsImNsb3NlSWNvbiIsImRvY3VtZW50IiwiYm9keSIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJhc3NpZ24iLCJrZXlJbmRleCIsInVzZUludGVybmFsTWVzc2FnZSIsIm1lc3NhZ2VDb25maWciLCJob2xkZXJSZWYiLCJ1c2VSZWYiLCJ3YXJuaW5nIiwid3JhcEFQSSIsInVzZU1lbW8iLCJjbG9zZSIsIl9hIiwiY3VycmVudCIsIm9wZW4iLCJjb25maWciLCJmYWtlUmVzdWx0IiwidGhlbiIsIm9yaWdpbk9wZW4iLCJub3RpY2VQcmVmaXhDbHMiLCJjb250ZW50IiwiaWNvbiIsInR5cGUiLCJvbkNsb3NlIiwicmVzdENvbmZpZyIsIm1lcmdlZEtleSIsInVuZGVmaW5lZCIsInJlc29sdmUiLCJwbGFjZW1lbnQiLCJkZXN0cm95IiwiY2xvbmUiLCJrZXlzIiwiZm9yRWFjaCIsInR5cGVPcGVuIiwiam9pbnRDb250ZW50IiwibWVyZ2VkRHVyYXRpb24iLCJtZXJnZWRPbkNsb3NlIiwibWVyZ2VkQ29uZmlnIiwidXNlTWVzc2FnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/antd/es/message/useMessage.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/antd/es/message/util.js":
/*!**********************************************!*\
  !*** ./node_modules/antd/es/message/util.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getMotion: function() { return /* binding */ getMotion; },\n/* harmony export */   wrapPromiseFn: function() { return /* binding */ wrapPromiseFn; }\n/* harmony export */ });\nfunction getMotion(prefixCls, transitionName) {\n    return {\n        motionName: transitionName !== null && transitionName !== void 0 ? transitionName : \"\".concat(prefixCls, \"-move-up\")\n    };\n}\n/** Wrap message open with promise like function */ function wrapPromiseFn(openFn) {\n    let closeFn;\n    const closePromise = new Promise((resolve)=>{\n        closeFn = openFn(()=>{\n            resolve(true);\n        });\n    });\n    const result = ()=>{\n        closeFn === null || closeFn === void 0 ? void 0 : closeFn();\n    };\n    result.then = (filled, rejected)=>closePromise.then(filled, rejected);\n    result.promise = closePromise;\n    return result;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hbnRkL2VzL21lc3NhZ2UvdXRpbC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFPLFNBQVNBLFVBQVVDLFNBQVMsRUFBRUMsY0FBYztJQUNqRCxPQUFPO1FBQ0xDLFlBQVlELG1CQUFtQixRQUFRQSxtQkFBbUIsS0FBSyxJQUFJQSxpQkFBaUIsR0FBYSxPQUFWRCxXQUFVO0lBQ25HO0FBQ0Y7QUFDQSxpREFBaUQsR0FDMUMsU0FBU0csY0FBY0MsTUFBTTtJQUNsQyxJQUFJQztJQUNKLE1BQU1DLGVBQWUsSUFBSUMsUUFBUUMsQ0FBQUE7UUFDL0JILFVBQVVELE9BQU87WUFDZkksUUFBUTtRQUNWO0lBQ0Y7SUFDQSxNQUFNQyxTQUFTO1FBQ2JKLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQTtJQUNwRDtJQUNBSSxPQUFPQyxJQUFJLEdBQUcsQ0FBQ0MsUUFBUUMsV0FBYU4sYUFBYUksSUFBSSxDQUFDQyxRQUFRQztJQUM5REgsT0FBT0ksT0FBTyxHQUFHUDtJQUNqQixPQUFPRztBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hbnRkL2VzL21lc3NhZ2UvdXRpbC5qcz8zZDg4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBnZXRNb3Rpb24ocHJlZml4Q2xzLCB0cmFuc2l0aW9uTmFtZSkge1xuICByZXR1cm4ge1xuICAgIG1vdGlvbk5hbWU6IHRyYW5zaXRpb25OYW1lICE9PSBudWxsICYmIHRyYW5zaXRpb25OYW1lICE9PSB2b2lkIDAgPyB0cmFuc2l0aW9uTmFtZSA6IGAke3ByZWZpeENsc30tbW92ZS11cGBcbiAgfTtcbn1cbi8qKiBXcmFwIG1lc3NhZ2Ugb3BlbiB3aXRoIHByb21pc2UgbGlrZSBmdW5jdGlvbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXBQcm9taXNlRm4ob3BlbkZuKSB7XG4gIGxldCBjbG9zZUZuO1xuICBjb25zdCBjbG9zZVByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICBjbG9zZUZuID0gb3BlbkZuKCgpID0+IHtcbiAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgfSk7XG4gIH0pO1xuICBjb25zdCByZXN1bHQgPSAoKSA9PiB7XG4gICAgY2xvc2VGbiA9PT0gbnVsbCB8fCBjbG9zZUZuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbG9zZUZuKCk7XG4gIH07XG4gIHJlc3VsdC50aGVuID0gKGZpbGxlZCwgcmVqZWN0ZWQpID0+IGNsb3NlUHJvbWlzZS50aGVuKGZpbGxlZCwgcmVqZWN0ZWQpO1xuICByZXN1bHQucHJvbWlzZSA9IGNsb3NlUHJvbWlzZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0iXSwibmFtZXMiOlsiZ2V0TW90aW9uIiwicHJlZml4Q2xzIiwidHJhbnNpdGlvbk5hbWUiLCJtb3Rpb25OYW1lIiwid3JhcFByb21pc2VGbiIsIm9wZW5GbiIsImNsb3NlRm4iLCJjbG9zZVByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlc3VsdCIsInRoZW4iLCJmaWxsZWQiLCJyZWplY3RlZCIsInByb21pc2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/antd/es/message/util.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/rc-notification/es/Notice.js":
/*!***************************************************!*\
  !*** ./node_modules/rc-notification/es/Notice.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/typeof */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/typeof.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/slicedToArray */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/slicedToArray.js\");\n/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! classnames */ \"(app-pages-browser)/./node_modules/classnames/index.js\");\n/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var rc_util_es_KeyCode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rc-util/es/KeyCode */ \"(app-pages-browser)/./node_modules/rc-util/es/KeyCode.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var rc_util_es_pickAttrs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! rc-util/es/pickAttrs */ \"(app-pages-browser)/./node_modules/rc-util/es/pickAttrs.js\");\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\nvar Notify = /*#__PURE__*/ _s(react__WEBPACK_IMPORTED_MODULE_6__.forwardRef(_c = _s(function(props, ref) {\n    _s();\n    var prefixCls = props.prefixCls, style = props.style, className = props.className, _props$duration = props.duration, duration = _props$duration === void 0 ? 4.5 : _props$duration, showProgress = props.showProgress, _props$pauseOnHover = props.pauseOnHover, pauseOnHover = _props$pauseOnHover === void 0 ? true : _props$pauseOnHover, eventKey = props.eventKey, content = props.content, closable = props.closable, _props$closeIcon = props.closeIcon, closeIcon = _props$closeIcon === void 0 ? \"x\" : _props$closeIcon, divProps = props.props, onClick = props.onClick, onNoticeClose = props.onNoticeClose, times = props.times, forcedHovering = props.hovering;\n    var _React$useState = react__WEBPACK_IMPORTED_MODULE_6__.useState(false), _React$useState2 = (0,_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(_React$useState, 2), hovering = _React$useState2[0], setHovering = _React$useState2[1];\n    var _React$useState3 = react__WEBPACK_IMPORTED_MODULE_6__.useState(0), _React$useState4 = (0,_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(_React$useState3, 2), percent = _React$useState4[0], setPercent = _React$useState4[1];\n    var _React$useState5 = react__WEBPACK_IMPORTED_MODULE_6__.useState(0), _React$useState6 = (0,_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(_React$useState5, 2), spentTime = _React$useState6[0], setSpentTime = _React$useState6[1];\n    var mergedHovering = forcedHovering || hovering;\n    var mergedShowProgress = duration > 0 && showProgress;\n    // ======================== Close =========================\n    var onInternalClose = function onInternalClose() {\n        onNoticeClose(eventKey);\n    };\n    var onCloseKeyDown = function onCloseKeyDown(e) {\n        if (e.key === \"Enter\" || e.code === \"Enter\" || e.keyCode === rc_util_es_KeyCode__WEBPACK_IMPORTED_MODULE_5__[\"default\"].ENTER) {\n            onInternalClose();\n        }\n    };\n    // ======================== Effect ========================\n    react__WEBPACK_IMPORTED_MODULE_6__.useEffect(function() {\n        if (!mergedHovering && duration > 0) {\n            var start = Date.now() - spentTime;\n            var timeout = setTimeout(function() {\n                onInternalClose();\n            }, duration * 1000 - spentTime);\n            return function() {\n                if (pauseOnHover) {\n                    clearTimeout(timeout);\n                }\n                setSpentTime(Date.now() - start);\n            };\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        duration,\n        mergedHovering,\n        times\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_6__.useEffect(function() {\n        if (!mergedHovering && mergedShowProgress && (pauseOnHover || spentTime === 0)) {\n            var start = performance.now();\n            var animationFrame;\n            var calculate = function calculate() {\n                cancelAnimationFrame(animationFrame);\n                animationFrame = requestAnimationFrame(function(timestamp) {\n                    var runtime = timestamp + spentTime - start;\n                    var progress = Math.min(runtime / (duration * 1000), 1);\n                    setPercent(progress * 100);\n                    if (progress < 1) {\n                        calculate();\n                    }\n                });\n            };\n            calculate();\n            return function() {\n                if (pauseOnHover) {\n                    cancelAnimationFrame(animationFrame);\n                }\n            };\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        duration,\n        spentTime,\n        mergedHovering,\n        mergedShowProgress,\n        times\n    ]);\n    // ======================== Closable ========================\n    var closableObj = react__WEBPACK_IMPORTED_MODULE_6__.useMemo(function() {\n        if ((0,_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(closable) === \"object\" && closable !== null) {\n            return closable;\n        }\n        if (closable) {\n            return {\n                closeIcon: closeIcon\n            };\n        }\n        return {};\n    }, [\n        closable,\n        closeIcon\n    ]);\n    var ariaProps = (0,rc_util_es_pickAttrs__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(closableObj, true);\n    // ======================== Progress ========================\n    var validPercent = 100 - (!percent || percent < 0 ? 0 : percent > 100 ? 100 : percent);\n    // ======================== Render ========================\n    var noticePrefixCls = \"\".concat(prefixCls, \"-notice\");\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_6__.createElement(\"div\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, divProps, {\n        ref: ref,\n        className: classnames__WEBPACK_IMPORTED_MODULE_4___default()(noticePrefixCls, className, (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({}, \"\".concat(noticePrefixCls, \"-closable\"), closable)),\n        style: style,\n        onMouseEnter: function onMouseEnter(e) {\n            var _divProps$onMouseEnte;\n            setHovering(true);\n            divProps === null || divProps === void 0 || (_divProps$onMouseEnte = divProps.onMouseEnter) === null || _divProps$onMouseEnte === void 0 || _divProps$onMouseEnte.call(divProps, e);\n        },\n        onMouseLeave: function onMouseLeave(e) {\n            var _divProps$onMouseLeav;\n            setHovering(false);\n            divProps === null || divProps === void 0 || (_divProps$onMouseLeav = divProps.onMouseLeave) === null || _divProps$onMouseLeav === void 0 || _divProps$onMouseLeav.call(divProps, e);\n        },\n        onClick: onClick\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_6__.createElement(\"div\", {\n        className: \"\".concat(noticePrefixCls, \"-content\")\n    }, content), closable && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_6__.createElement(\"a\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        tabIndex: 0,\n        className: \"\".concat(noticePrefixCls, \"-close\"),\n        onKeyDown: onCloseKeyDown,\n        \"aria-label\": \"Close\"\n    }, ariaProps, {\n        onClick: function onClick(e) {\n            e.preventDefault();\n            e.stopPropagation();\n            onInternalClose();\n        }\n    }), closableObj.closeIcon), mergedShowProgress && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_6__.createElement(\"progress\", {\n        className: \"\".concat(noticePrefixCls, \"-progress\"),\n        max: \"100\",\n        value: validPercent\n    }, validPercent + \"%\"));\n}, \"mslHKWIYMcTte9J3O95P/PqfEQ4=\")), \"mslHKWIYMcTte9J3O95P/PqfEQ4=\");\n_c1 = Notify;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Notify);\nvar _c, _c1;\n$RefreshReg$(_c, \"Notify$React.forwardRef\");\n$RefreshReg$(_c1, \"Notify\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yYy1ub3RpZmljYXRpb24vZXMvTm90aWNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUEwRDtBQUNjO0FBQ2hCO0FBQ2M7QUFDbEM7QUFDSztBQUNWO0FBQ2M7QUFDN0MsSUFBSVEsU0FBUyxXQUFXLEdBQUVGLEdBQUFBLDZDQUFnQixTQUFDLFNBQVVJLEtBQUssRUFBRUMsR0FBRzs7SUFDN0QsSUFBSUMsWUFBWUYsTUFBTUUsU0FBUyxFQUM3QkMsUUFBUUgsTUFBTUcsS0FBSyxFQUNuQkMsWUFBWUosTUFBTUksU0FBUyxFQUMzQkMsa0JBQWtCTCxNQUFNTSxRQUFRLEVBQ2hDQSxXQUFXRCxvQkFBb0IsS0FBSyxJQUFJLE1BQU1BLGlCQUM5Q0UsZUFBZVAsTUFBTU8sWUFBWSxFQUNqQ0Msc0JBQXNCUixNQUFNUyxZQUFZLEVBQ3hDQSxlQUFlRCx3QkFBd0IsS0FBSyxJQUFJLE9BQU9BLHFCQUN2REUsV0FBV1YsTUFBTVUsUUFBUSxFQUN6QkMsVUFBVVgsTUFBTVcsT0FBTyxFQUN2QkMsV0FBV1osTUFBTVksUUFBUSxFQUN6QkMsbUJBQW1CYixNQUFNYyxTQUFTLEVBQ2xDQSxZQUFZRCxxQkFBcUIsS0FBSyxJQUFJLE1BQU1BLGtCQUNoREUsV0FBV2YsTUFBTUEsS0FBSyxFQUN0QmdCLFVBQVVoQixNQUFNZ0IsT0FBTyxFQUN2QkMsZ0JBQWdCakIsTUFBTWlCLGFBQWEsRUFDbkNDLFFBQVFsQixNQUFNa0IsS0FBSyxFQUNuQkMsaUJBQWlCbkIsTUFBTW9CLFFBQVE7SUFDakMsSUFBSUMsa0JBQWtCekIsMkNBQWMsQ0FBQyxRQUNuQzJCLG1CQUFtQjlCLG9GQUFjQSxDQUFDNEIsaUJBQWlCLElBQ25ERCxXQUFXRyxnQkFBZ0IsQ0FBQyxFQUFFLEVBQzlCQyxjQUFjRCxnQkFBZ0IsQ0FBQyxFQUFFO0lBQ25DLElBQUlFLG1CQUFtQjdCLDJDQUFjLENBQUMsSUFDcEM4QixtQkFBbUJqQyxvRkFBY0EsQ0FBQ2dDLGtCQUFrQixJQUNwREUsVUFBVUQsZ0JBQWdCLENBQUMsRUFBRSxFQUM3QkUsYUFBYUYsZ0JBQWdCLENBQUMsRUFBRTtJQUNsQyxJQUFJRyxtQkFBbUJqQywyQ0FBYyxDQUFDLElBQ3BDa0MsbUJBQW1CckMsb0ZBQWNBLENBQUNvQyxrQkFBa0IsSUFDcERFLFlBQVlELGdCQUFnQixDQUFDLEVBQUUsRUFDL0JFLGVBQWVGLGdCQUFnQixDQUFDLEVBQUU7SUFDcEMsSUFBSUcsaUJBQWlCZCxrQkFBa0JDO0lBQ3ZDLElBQUljLHFCQUFxQjVCLFdBQVcsS0FBS0M7SUFFekMsMkRBQTJEO0lBQzNELElBQUk0QixrQkFBa0IsU0FBU0E7UUFDN0JsQixjQUFjUDtJQUNoQjtJQUNBLElBQUkwQixpQkFBaUIsU0FBU0EsZUFBZUMsQ0FBQztRQUM1QyxJQUFJQSxFQUFFQyxHQUFHLEtBQUssV0FBV0QsRUFBRUUsSUFBSSxLQUFLLFdBQVdGLEVBQUVHLE9BQU8sS0FBSzdDLDBEQUFPQSxDQUFDOEMsS0FBSyxFQUFFO1lBQzFFTjtRQUNGO0lBQ0Y7SUFFQSwyREFBMkQ7SUFDM0R2Qyw0Q0FBZSxDQUFDO1FBQ2QsSUFBSSxDQUFDcUMsa0JBQWtCM0IsV0FBVyxHQUFHO1lBQ25DLElBQUlxQyxRQUFRQyxLQUFLQyxHQUFHLEtBQUtkO1lBQ3pCLElBQUllLFVBQVVDLFdBQVc7Z0JBQ3ZCWjtZQUNGLEdBQUc3QixXQUFXLE9BQU95QjtZQUNyQixPQUFPO2dCQUNMLElBQUl0QixjQUFjO29CQUNoQnVDLGFBQWFGO2dCQUNmO2dCQUNBZCxhQUFhWSxLQUFLQyxHQUFHLEtBQUtGO1lBQzVCO1FBQ0Y7SUFDQSx1REFBdUQ7SUFDekQsR0FBRztRQUFDckM7UUFBVTJCO1FBQWdCZjtLQUFNO0lBQ3BDdEIsNENBQWUsQ0FBQztRQUNkLElBQUksQ0FBQ3FDLGtCQUFrQkMsc0JBQXVCekIsQ0FBQUEsZ0JBQWdCc0IsY0FBYyxJQUFJO1lBQzlFLElBQUlZLFFBQVFNLFlBQVlKLEdBQUc7WUFDM0IsSUFBSUs7WUFDSixJQUFJQyxZQUFZLFNBQVNBO2dCQUN2QkMscUJBQXFCRjtnQkFDckJBLGlCQUFpQkcsc0JBQXNCLFNBQVVDLFNBQVM7b0JBQ3hELElBQUlDLFVBQVVELFlBQVl2QixZQUFZWTtvQkFDdEMsSUFBSWEsV0FBV0MsS0FBS0MsR0FBRyxDQUFDSCxVQUFXakQsQ0FBQUEsV0FBVyxJQUFHLEdBQUk7b0JBQ3JEc0IsV0FBVzRCLFdBQVc7b0JBQ3RCLElBQUlBLFdBQVcsR0FBRzt3QkFDaEJMO29CQUNGO2dCQUNGO1lBQ0Y7WUFDQUE7WUFDQSxPQUFPO2dCQUNMLElBQUkxQyxjQUFjO29CQUNoQjJDLHFCQUFxQkY7Z0JBQ3ZCO1lBQ0Y7UUFDRjtJQUNBLHVEQUF1RDtJQUN6RCxHQUFHO1FBQUM1QztRQUFVeUI7UUFBV0U7UUFBZ0JDO1FBQW9CaEI7S0FBTTtJQUVuRSw2REFBNkQ7SUFDN0QsSUFBSXlDLGNBQWMvRCwwQ0FBYSxDQUFDO1FBQzlCLElBQUlKLDZFQUFPQSxDQUFDb0IsY0FBYyxZQUFZQSxhQUFhLE1BQU07WUFDdkQsT0FBT0E7UUFDVDtRQUNBLElBQUlBLFVBQVU7WUFDWixPQUFPO2dCQUNMRSxXQUFXQTtZQUNiO1FBQ0Y7UUFDQSxPQUFPLENBQUM7SUFDVixHQUFHO1FBQUNGO1FBQVVFO0tBQVU7SUFDeEIsSUFBSStDLFlBQVloRSxnRUFBU0EsQ0FBQzhELGFBQWE7SUFFdkMsNkRBQTZEO0lBQzdELElBQUlHLGVBQWUsTUFBTyxFQUFDbkMsV0FBV0EsVUFBVSxJQUFJLElBQUlBLFVBQVUsTUFBTSxNQUFNQSxPQUFNO0lBRXBGLDJEQUEyRDtJQUMzRCxJQUFJb0Msa0JBQWtCLEdBQUdDLE1BQU0sQ0FBQzlELFdBQVc7SUFDM0MsT0FBTyxXQUFXLEdBQUVOLGdEQUFtQixDQUFDLE9BQU9OLDhFQUFRQSxDQUFDLENBQUMsR0FBR3lCLFVBQVU7UUFDcEVkLEtBQUtBO1FBQ0xHLFdBQVdWLGlEQUFVQSxDQUFDcUUsaUJBQWlCM0QsV0FBV2IscUZBQWVBLENBQUMsQ0FBQyxHQUFHLEdBQUd5RSxNQUFNLENBQUNELGlCQUFpQixjQUFjbkQ7UUFDL0dULE9BQU9BO1FBQ1ArRCxjQUFjLFNBQVNBLGFBQWE3QixDQUFDO1lBQ25DLElBQUk4QjtZQUNKM0MsWUFBWTtZQUNaVCxhQUFhLFFBQVFBLGFBQWEsS0FBSyxLQUFLLENBQUNvRCx3QkFBd0JwRCxTQUFTbUQsWUFBWSxNQUFNLFFBQVFDLDBCQUEwQixLQUFLLEtBQUtBLHNCQUFzQkMsSUFBSSxDQUFDckQsVUFBVXNCO1FBQ25MO1FBQ0FnQyxjQUFjLFNBQVNBLGFBQWFoQyxDQUFDO1lBQ25DLElBQUlpQztZQUNKOUMsWUFBWTtZQUNaVCxhQUFhLFFBQVFBLGFBQWEsS0FBSyxLQUFLLENBQUN1RCx3QkFBd0J2RCxTQUFTc0QsWUFBWSxNQUFNLFFBQVFDLDBCQUEwQixLQUFLLEtBQUtBLHNCQUFzQkYsSUFBSSxDQUFDckQsVUFBVXNCO1FBQ25MO1FBQ0FyQixTQUFTQTtJQUNYLElBQUksV0FBVyxHQUFFcEIsZ0RBQW1CLENBQUMsT0FBTztRQUMxQ1EsV0FBVyxHQUFHNEQsTUFBTSxDQUFDRCxpQkFBaUI7SUFDeEMsR0FBR3BELFVBQVVDLFlBQVksV0FBVyxHQUFFaEIsZ0RBQW1CLENBQUMsS0FBS04sOEVBQVFBLENBQUM7UUFDdEVpRixVQUFVO1FBQ1ZuRSxXQUFXLEdBQUc0RCxNQUFNLENBQUNELGlCQUFpQjtRQUN0Q1MsV0FBV3BDO1FBQ1gsY0FBYztJQUNoQixHQUFHeUIsV0FBVztRQUNaN0MsU0FBUyxTQUFTQSxRQUFRcUIsQ0FBQztZQUN6QkEsRUFBRW9DLGNBQWM7WUFDaEJwQyxFQUFFcUMsZUFBZTtZQUNqQnZDO1FBQ0Y7SUFDRixJQUFJd0IsWUFBWTdDLFNBQVMsR0FBR29CLHNCQUFzQixXQUFXLEdBQUV0QyxnREFBbUIsQ0FBQyxZQUFZO1FBQzdGUSxXQUFXLEdBQUc0RCxNQUFNLENBQUNELGlCQUFpQjtRQUN0Q1ksS0FBSztRQUNMQyxPQUFPZDtJQUNULEdBQUdBLGVBQWU7QUFDcEI7O0FBQ0EsK0RBQWVoRSxNQUFNQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yYy1ub3RpZmljYXRpb24vZXMvTm90aWNlLmpzP2MzMmMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IF90eXBlb2YgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3R5cGVvZlwiO1xuaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5XCI7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBLZXlDb2RlIGZyb20gXCJyYy11dGlsL2VzL0tleUNvZGVcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBwaWNrQXR0cnMgZnJvbSBcInJjLXV0aWwvZXMvcGlja0F0dHJzXCI7XG52YXIgTm90aWZ5ID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gKHByb3BzLCByZWYpIHtcbiAgdmFyIHByZWZpeENscyA9IHByb3BzLnByZWZpeENscyxcbiAgICBzdHlsZSA9IHByb3BzLnN0eWxlLFxuICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICBfcHJvcHMkZHVyYXRpb24gPSBwcm9wcy5kdXJhdGlvbixcbiAgICBkdXJhdGlvbiA9IF9wcm9wcyRkdXJhdGlvbiA9PT0gdm9pZCAwID8gNC41IDogX3Byb3BzJGR1cmF0aW9uLFxuICAgIHNob3dQcm9ncmVzcyA9IHByb3BzLnNob3dQcm9ncmVzcyxcbiAgICBfcHJvcHMkcGF1c2VPbkhvdmVyID0gcHJvcHMucGF1c2VPbkhvdmVyLFxuICAgIHBhdXNlT25Ib3ZlciA9IF9wcm9wcyRwYXVzZU9uSG92ZXIgPT09IHZvaWQgMCA/IHRydWUgOiBfcHJvcHMkcGF1c2VPbkhvdmVyLFxuICAgIGV2ZW50S2V5ID0gcHJvcHMuZXZlbnRLZXksXG4gICAgY29udGVudCA9IHByb3BzLmNvbnRlbnQsXG4gICAgY2xvc2FibGUgPSBwcm9wcy5jbG9zYWJsZSxcbiAgICBfcHJvcHMkY2xvc2VJY29uID0gcHJvcHMuY2xvc2VJY29uLFxuICAgIGNsb3NlSWNvbiA9IF9wcm9wcyRjbG9zZUljb24gPT09IHZvaWQgMCA/ICd4JyA6IF9wcm9wcyRjbG9zZUljb24sXG4gICAgZGl2UHJvcHMgPSBwcm9wcy5wcm9wcyxcbiAgICBvbkNsaWNrID0gcHJvcHMub25DbGljayxcbiAgICBvbk5vdGljZUNsb3NlID0gcHJvcHMub25Ob3RpY2VDbG9zZSxcbiAgICB0aW1lcyA9IHByb3BzLnRpbWVzLFxuICAgIGZvcmNlZEhvdmVyaW5nID0gcHJvcHMuaG92ZXJpbmc7XG4gIHZhciBfUmVhY3QkdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZShmYWxzZSksXG4gICAgX1JlYWN0JHVzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF9SZWFjdCR1c2VTdGF0ZSwgMiksXG4gICAgaG92ZXJpbmcgPSBfUmVhY3QkdXNlU3RhdGUyWzBdLFxuICAgIHNldEhvdmVyaW5nID0gX1JlYWN0JHVzZVN0YXRlMlsxXTtcbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZTMgPSBSZWFjdC51c2VTdGF0ZSgwKSxcbiAgICBfUmVhY3QkdXNlU3RhdGU0ID0gX3NsaWNlZFRvQXJyYXkoX1JlYWN0JHVzZVN0YXRlMywgMiksXG4gICAgcGVyY2VudCA9IF9SZWFjdCR1c2VTdGF0ZTRbMF0sXG4gICAgc2V0UGVyY2VudCA9IF9SZWFjdCR1c2VTdGF0ZTRbMV07XG4gIHZhciBfUmVhY3QkdXNlU3RhdGU1ID0gUmVhY3QudXNlU3RhdGUoMCksXG4gICAgX1JlYWN0JHVzZVN0YXRlNiA9IF9zbGljZWRUb0FycmF5KF9SZWFjdCR1c2VTdGF0ZTUsIDIpLFxuICAgIHNwZW50VGltZSA9IF9SZWFjdCR1c2VTdGF0ZTZbMF0sXG4gICAgc2V0U3BlbnRUaW1lID0gX1JlYWN0JHVzZVN0YXRlNlsxXTtcbiAgdmFyIG1lcmdlZEhvdmVyaW5nID0gZm9yY2VkSG92ZXJpbmcgfHwgaG92ZXJpbmc7XG4gIHZhciBtZXJnZWRTaG93UHJvZ3Jlc3MgPSBkdXJhdGlvbiA+IDAgJiYgc2hvd1Byb2dyZXNzO1xuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PSBDbG9zZSA9PT09PT09PT09PT09PT09PT09PT09PT09XG4gIHZhciBvbkludGVybmFsQ2xvc2UgPSBmdW5jdGlvbiBvbkludGVybmFsQ2xvc2UoKSB7XG4gICAgb25Ob3RpY2VDbG9zZShldmVudEtleSk7XG4gIH07XG4gIHZhciBvbkNsb3NlS2V5RG93biA9IGZ1bmN0aW9uIG9uQ2xvc2VLZXlEb3duKGUpIHtcbiAgICBpZiAoZS5rZXkgPT09ICdFbnRlcicgfHwgZS5jb2RlID09PSAnRW50ZXInIHx8IGUua2V5Q29kZSA9PT0gS2V5Q29kZS5FTlRFUikge1xuICAgICAgb25JbnRlcm5hbENsb3NlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PSBFZmZlY3QgPT09PT09PT09PT09PT09PT09PT09PT09XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFtZXJnZWRIb3ZlcmluZyAmJiBkdXJhdGlvbiA+IDApIHtcbiAgICAgIHZhciBzdGFydCA9IERhdGUubm93KCkgLSBzcGVudFRpbWU7XG4gICAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBvbkludGVybmFsQ2xvc2UoKTtcbiAgICAgIH0sIGR1cmF0aW9uICogMTAwMCAtIHNwZW50VGltZSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAocGF1c2VPbkhvdmVyKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIHNldFNwZW50VGltZShEYXRlLm5vdygpIC0gc3RhcnQpO1xuICAgICAgfTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbZHVyYXRpb24sIG1lcmdlZEhvdmVyaW5nLCB0aW1lc10pO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmICghbWVyZ2VkSG92ZXJpbmcgJiYgbWVyZ2VkU2hvd1Byb2dyZXNzICYmIChwYXVzZU9uSG92ZXIgfHwgc3BlbnRUaW1lID09PSAwKSkge1xuICAgICAgdmFyIHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB2YXIgYW5pbWF0aW9uRnJhbWU7XG4gICAgICB2YXIgY2FsY3VsYXRlID0gZnVuY3Rpb24gY2FsY3VsYXRlKCkge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb25GcmFtZSk7XG4gICAgICAgIGFuaW1hdGlvbkZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICh0aW1lc3RhbXApIHtcbiAgICAgICAgICB2YXIgcnVudGltZSA9IHRpbWVzdGFtcCArIHNwZW50VGltZSAtIHN0YXJ0O1xuICAgICAgICAgIHZhciBwcm9ncmVzcyA9IE1hdGgubWluKHJ1bnRpbWUgLyAoZHVyYXRpb24gKiAxMDAwKSwgMSk7XG4gICAgICAgICAgc2V0UGVyY2VudChwcm9ncmVzcyAqIDEwMCk7XG4gICAgICAgICAgaWYgKHByb2dyZXNzIDwgMSkge1xuICAgICAgICAgICAgY2FsY3VsYXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjYWxjdWxhdGUoKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChwYXVzZU9uSG92ZXIpIHtcbiAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb25GcmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW2R1cmF0aW9uLCBzcGVudFRpbWUsIG1lcmdlZEhvdmVyaW5nLCBtZXJnZWRTaG93UHJvZ3Jlc3MsIHRpbWVzXSk7XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09IENsb3NhYmxlID09PT09PT09PT09PT09PT09PT09PT09PVxuICB2YXIgY2xvc2FibGVPYmogPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoX3R5cGVvZihjbG9zYWJsZSkgPT09ICdvYmplY3QnICYmIGNsb3NhYmxlICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY2xvc2FibGU7XG4gICAgfVxuICAgIGlmIChjbG9zYWJsZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2xvc2VJY29uOiBjbG9zZUljb25cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7fTtcbiAgfSwgW2Nsb3NhYmxlLCBjbG9zZUljb25dKTtcbiAgdmFyIGFyaWFQcm9wcyA9IHBpY2tBdHRycyhjbG9zYWJsZU9iaiwgdHJ1ZSk7XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09IFByb2dyZXNzID09PT09PT09PT09PT09PT09PT09PT09PVxuICB2YXIgdmFsaWRQZXJjZW50ID0gMTAwIC0gKCFwZXJjZW50IHx8IHBlcmNlbnQgPCAwID8gMCA6IHBlcmNlbnQgPiAxMDAgPyAxMDAgOiBwZXJjZW50KTtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT0gUmVuZGVyID09PT09PT09PT09PT09PT09PT09PT09PVxuICB2YXIgbm90aWNlUHJlZml4Q2xzID0gXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1ub3RpY2VcIik7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfZXh0ZW5kcyh7fSwgZGl2UHJvcHMsIHtcbiAgICByZWY6IHJlZixcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXMobm90aWNlUHJlZml4Q2xzLCBjbGFzc05hbWUsIF9kZWZpbmVQcm9wZXJ0eSh7fSwgXCJcIi5jb25jYXQobm90aWNlUHJlZml4Q2xzLCBcIi1jbG9zYWJsZVwiKSwgY2xvc2FibGUpKSxcbiAgICBzdHlsZTogc3R5bGUsXG4gICAgb25Nb3VzZUVudGVyOiBmdW5jdGlvbiBvbk1vdXNlRW50ZXIoZSkge1xuICAgICAgdmFyIF9kaXZQcm9wcyRvbk1vdXNlRW50ZTtcbiAgICAgIHNldEhvdmVyaW5nKHRydWUpO1xuICAgICAgZGl2UHJvcHMgPT09IG51bGwgfHwgZGl2UHJvcHMgPT09IHZvaWQgMCB8fCAoX2RpdlByb3BzJG9uTW91c2VFbnRlID0gZGl2UHJvcHMub25Nb3VzZUVudGVyKSA9PT0gbnVsbCB8fCBfZGl2UHJvcHMkb25Nb3VzZUVudGUgPT09IHZvaWQgMCB8fCBfZGl2UHJvcHMkb25Nb3VzZUVudGUuY2FsbChkaXZQcm9wcywgZSk7XG4gICAgfSxcbiAgICBvbk1vdXNlTGVhdmU6IGZ1bmN0aW9uIG9uTW91c2VMZWF2ZShlKSB7XG4gICAgICB2YXIgX2RpdlByb3BzJG9uTW91c2VMZWF2O1xuICAgICAgc2V0SG92ZXJpbmcoZmFsc2UpO1xuICAgICAgZGl2UHJvcHMgPT09IG51bGwgfHwgZGl2UHJvcHMgPT09IHZvaWQgMCB8fCAoX2RpdlByb3BzJG9uTW91c2VMZWF2ID0gZGl2UHJvcHMub25Nb3VzZUxlYXZlKSA9PT0gbnVsbCB8fCBfZGl2UHJvcHMkb25Nb3VzZUxlYXYgPT09IHZvaWQgMCB8fCBfZGl2UHJvcHMkb25Nb3VzZUxlYXYuY2FsbChkaXZQcm9wcywgZSk7XG4gICAgfSxcbiAgICBvbkNsaWNrOiBvbkNsaWNrXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBcIlwiLmNvbmNhdChub3RpY2VQcmVmaXhDbHMsIFwiLWNvbnRlbnRcIilcbiAgfSwgY29udGVudCksIGNsb3NhYmxlICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCBfZXh0ZW5kcyh7XG4gICAgdGFiSW5kZXg6IDAsXG4gICAgY2xhc3NOYW1lOiBcIlwiLmNvbmNhdChub3RpY2VQcmVmaXhDbHMsIFwiLWNsb3NlXCIpLFxuICAgIG9uS2V5RG93bjogb25DbG9zZUtleURvd24sXG4gICAgXCJhcmlhLWxhYmVsXCI6IFwiQ2xvc2VcIlxuICB9LCBhcmlhUHJvcHMsIHtcbiAgICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBvbkludGVybmFsQ2xvc2UoKTtcbiAgICB9XG4gIH0pLCBjbG9zYWJsZU9iai5jbG9zZUljb24pLCBtZXJnZWRTaG93UHJvZ3Jlc3MgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwcm9ncmVzc1wiLCB7XG4gICAgY2xhc3NOYW1lOiBcIlwiLmNvbmNhdChub3RpY2VQcmVmaXhDbHMsIFwiLXByb2dyZXNzXCIpLFxuICAgIG1heDogXCIxMDBcIixcbiAgICB2YWx1ZTogdmFsaWRQZXJjZW50XG4gIH0sIHZhbGlkUGVyY2VudCArICclJykpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBOb3RpZnk7Il0sIm5hbWVzIjpbIl9leHRlbmRzIiwiX2RlZmluZVByb3BlcnR5IiwiX3R5cGVvZiIsIl9zbGljZWRUb0FycmF5IiwiY2xhc3NOYW1lcyIsIktleUNvZGUiLCJSZWFjdCIsInBpY2tBdHRycyIsIk5vdGlmeSIsImZvcndhcmRSZWYiLCJwcm9wcyIsInJlZiIsInByZWZpeENscyIsInN0eWxlIiwiY2xhc3NOYW1lIiwiX3Byb3BzJGR1cmF0aW9uIiwiZHVyYXRpb24iLCJzaG93UHJvZ3Jlc3MiLCJfcHJvcHMkcGF1c2VPbkhvdmVyIiwicGF1c2VPbkhvdmVyIiwiZXZlbnRLZXkiLCJjb250ZW50IiwiY2xvc2FibGUiLCJfcHJvcHMkY2xvc2VJY29uIiwiY2xvc2VJY29uIiwiZGl2UHJvcHMiLCJvbkNsaWNrIiwib25Ob3RpY2VDbG9zZSIsInRpbWVzIiwiZm9yY2VkSG92ZXJpbmciLCJob3ZlcmluZyIsIl9SZWFjdCR1c2VTdGF0ZSIsInVzZVN0YXRlIiwiX1JlYWN0JHVzZVN0YXRlMiIsInNldEhvdmVyaW5nIiwiX1JlYWN0JHVzZVN0YXRlMyIsIl9SZWFjdCR1c2VTdGF0ZTQiLCJwZXJjZW50Iiwic2V0UGVyY2VudCIsIl9SZWFjdCR1c2VTdGF0ZTUiLCJfUmVhY3QkdXNlU3RhdGU2Iiwic3BlbnRUaW1lIiwic2V0U3BlbnRUaW1lIiwibWVyZ2VkSG92ZXJpbmciLCJtZXJnZWRTaG93UHJvZ3Jlc3MiLCJvbkludGVybmFsQ2xvc2UiLCJvbkNsb3NlS2V5RG93biIsImUiLCJrZXkiLCJjb2RlIiwia2V5Q29kZSIsIkVOVEVSIiwidXNlRWZmZWN0Iiwic3RhcnQiLCJEYXRlIiwibm93IiwidGltZW91dCIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJwZXJmb3JtYW5jZSIsImFuaW1hdGlvbkZyYW1lIiwiY2FsY3VsYXRlIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ0aW1lc3RhbXAiLCJydW50aW1lIiwicHJvZ3Jlc3MiLCJNYXRoIiwibWluIiwiY2xvc2FibGVPYmoiLCJ1c2VNZW1vIiwiYXJpYVByb3BzIiwidmFsaWRQZXJjZW50Iiwibm90aWNlUHJlZml4Q2xzIiwiY29uY2F0IiwiY3JlYXRlRWxlbWVudCIsIm9uTW91c2VFbnRlciIsIl9kaXZQcm9wcyRvbk1vdXNlRW50ZSIsImNhbGwiLCJvbk1vdXNlTGVhdmUiLCJfZGl2UHJvcHMkb25Nb3VzZUxlYXYiLCJ0YWJJbmRleCIsIm9uS2V5RG93biIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwibWF4IiwidmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/rc-notification/es/Notice.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/rc-notification/es/NoticeList.js":
/*!*******************************************************!*\
  !*** ./node_modules/rc-notification/es/NoticeList.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/toConsumableArray */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectSpread2 */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/objectSpread2.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutProperties */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/slicedToArray */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/slicedToArray.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! classnames */ \"(app-pages-browser)/./node_modules/classnames/index.js\");\n/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var rc_motion__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! rc-motion */ \"(app-pages-browser)/./node_modules/rc-motion/es/index.js\");\n/* harmony import */ var _Notice__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Notice */ \"(app-pages-browser)/./node_modules/rc-notification/es/Notice.js\");\n/* harmony import */ var _NotificationProvider__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./NotificationProvider */ \"(app-pages-browser)/./node_modules/rc-notification/es/NotificationProvider.js\");\n/* harmony import */ var _hooks_useStack__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./hooks/useStack */ \"(app-pages-browser)/./node_modules/rc-notification/es/hooks/useStack.js\");\nvar _s = $RefreshSig$();\n\n\n\n\n\n\nvar _excluded = [\n    \"className\",\n    \"style\",\n    \"classNames\",\n    \"styles\"\n];\n\n\n\n\n\n\nvar NoticeList = function NoticeList(props) {\n    _s();\n    var configList = props.configList, placement = props.placement, prefixCls = props.prefixCls, className = props.className, style = props.style, motion = props.motion, onAllNoticeRemoved = props.onAllNoticeRemoved, onNoticeClose = props.onNoticeClose, stackConfig = props.stack;\n    var _useContext = (0,react__WEBPACK_IMPORTED_MODULE_6__.useContext)(_NotificationProvider__WEBPACK_IMPORTED_MODULE_10__.NotificationContext), ctxCls = _useContext.classNames;\n    var dictRef = (0,react__WEBPACK_IMPORTED_MODULE_6__.useRef)({});\n    var _useState = (0,react__WEBPACK_IMPORTED_MODULE_6__.useState)(null), _useState2 = (0,_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(_useState, 2), latestNotice = _useState2[0], setLatestNotice = _useState2[1];\n    var _useState3 = (0,react__WEBPACK_IMPORTED_MODULE_6__.useState)([]), _useState4 = (0,_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(_useState3, 2), hoverKeys = _useState4[0], setHoverKeys = _useState4[1];\n    var keys = configList.map(function(config) {\n        return {\n            config: config,\n            key: String(config.key)\n        };\n    });\n    var _useStack = (0,_hooks_useStack__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(stackConfig), _useStack2 = (0,_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(_useStack, 2), stack = _useStack2[0], _useStack2$ = _useStack2[1], offset = _useStack2$.offset, threshold = _useStack2$.threshold, gap = _useStack2$.gap;\n    var expanded = stack && (hoverKeys.length > 0 || keys.length <= threshold);\n    var placementMotion = typeof motion === \"function\" ? motion(placement) : motion;\n    // Clean hover key\n    (0,react__WEBPACK_IMPORTED_MODULE_6__.useEffect)(function() {\n        if (stack && hoverKeys.length > 1) {\n            setHoverKeys(function(prev) {\n                return prev.filter(function(key) {\n                    return keys.some(function(_ref) {\n                        var dataKey = _ref.key;\n                        return key === dataKey;\n                    });\n                });\n            });\n        }\n    }, [\n        hoverKeys,\n        keys,\n        stack\n    ]);\n    // Force update latest notice\n    (0,react__WEBPACK_IMPORTED_MODULE_6__.useEffect)(function() {\n        var _keys;\n        if (stack && dictRef.current[(_keys = keys[keys.length - 1]) === null || _keys === void 0 ? void 0 : _keys.key]) {\n            var _keys2;\n            setLatestNotice(dictRef.current[(_keys2 = keys[keys.length - 1]) === null || _keys2 === void 0 ? void 0 : _keys2.key]);\n        }\n    }, [\n        keys,\n        stack\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_6___default().createElement(rc_motion__WEBPACK_IMPORTED_MODULE_8__.CSSMotionList, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        key: placement,\n        className: classnames__WEBPACK_IMPORTED_MODULE_7___default()(prefixCls, \"\".concat(prefixCls, \"-\").concat(placement), ctxCls === null || ctxCls === void 0 ? void 0 : ctxCls.list, className, (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_4__[\"default\"])((0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_4__[\"default\"])({}, \"\".concat(prefixCls, \"-stack\"), !!stack), \"\".concat(prefixCls, \"-stack-expanded\"), expanded)),\n        style: style,\n        keys: keys,\n        motionAppear: true\n    }, placementMotion, {\n        onAllRemoved: function onAllRemoved() {\n            onAllNoticeRemoved(placement);\n        }\n    }), function(_ref2, nodeRef) {\n        var config = _ref2.config, motionClassName = _ref2.className, motionStyle = _ref2.style, motionIndex = _ref2.index;\n        var _ref3 = config, key = _ref3.key, times = _ref3.times;\n        var strKey = String(key);\n        var _ref4 = config, configClassName = _ref4.className, configStyle = _ref4.style, configClassNames = _ref4.classNames, configStyles = _ref4.styles, restConfig = (0,_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(_ref4, _excluded);\n        var dataIndex = keys.findIndex(function(item) {\n            return item.key === strKey;\n        });\n        // If dataIndex is -1, that means this notice has been removed in data, but still in dom\n        // Should minus (motionIndex - 1) to get the correct index because keys.length is not the same as dom length\n        var stackStyle = {};\n        if (stack) {\n            var index = keys.length - 1 - (dataIndex > -1 ? dataIndex : motionIndex - 1);\n            var transformX = placement === \"top\" || placement === \"bottom\" ? \"-50%\" : \"0\";\n            if (index > 0) {\n                var _dictRef$current$strK, _dictRef$current$strK2, _dictRef$current$strK3;\n                stackStyle.height = expanded ? (_dictRef$current$strK = dictRef.current[strKey]) === null || _dictRef$current$strK === void 0 ? void 0 : _dictRef$current$strK.offsetHeight : latestNotice === null || latestNotice === void 0 ? void 0 : latestNotice.offsetHeight;\n                // Transform\n                var verticalOffset = 0;\n                for(var i = 0; i < index; i++){\n                    var _dictRef$current$keys;\n                    verticalOffset += ((_dictRef$current$keys = dictRef.current[keys[keys.length - 1 - i].key]) === null || _dictRef$current$keys === void 0 ? void 0 : _dictRef$current$keys.offsetHeight) + gap;\n                }\n                var transformY = (expanded ? verticalOffset : index * offset) * (placement.startsWith(\"top\") ? 1 : -1);\n                var scaleX = !expanded && latestNotice !== null && latestNotice !== void 0 && latestNotice.offsetWidth && (_dictRef$current$strK2 = dictRef.current[strKey]) !== null && _dictRef$current$strK2 !== void 0 && _dictRef$current$strK2.offsetWidth ? ((latestNotice === null || latestNotice === void 0 ? void 0 : latestNotice.offsetWidth) - offset * 2 * (index < 3 ? index : 3)) / ((_dictRef$current$strK3 = dictRef.current[strKey]) === null || _dictRef$current$strK3 === void 0 ? void 0 : _dictRef$current$strK3.offsetWidth) : 1;\n                stackStyle.transform = \"translate3d(\".concat(transformX, \", \").concat(transformY, \"px, 0) scaleX(\").concat(scaleX, \")\");\n            } else {\n                stackStyle.transform = \"translate3d(\".concat(transformX, \", 0, 0)\");\n            }\n        }\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_6___default().createElement(\"div\", {\n            ref: nodeRef,\n            className: classnames__WEBPACK_IMPORTED_MODULE_7___default()(\"\".concat(prefixCls, \"-notice-wrapper\"), motionClassName, configClassNames === null || configClassNames === void 0 ? void 0 : configClassNames.wrapper),\n            style: (0,_babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_2__[\"default\"])((0,_babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_2__[\"default\"])((0,_babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, motionStyle), stackStyle), configStyles === null || configStyles === void 0 ? void 0 : configStyles.wrapper),\n            onMouseEnter: function onMouseEnter() {\n                return setHoverKeys(function(prev) {\n                    return prev.includes(strKey) ? prev : [].concat((0,_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(prev), [\n                        strKey\n                    ]);\n                });\n            },\n            onMouseLeave: function onMouseLeave() {\n                return setHoverKeys(function(prev) {\n                    return prev.filter(function(k) {\n                        return k !== strKey;\n                    });\n                });\n            }\n        }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_6___default().createElement(_Notice__WEBPACK_IMPORTED_MODULE_9__[\"default\"], (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, restConfig, {\n            ref: function ref(node) {\n                if (dataIndex > -1) {\n                    dictRef.current[strKey] = node;\n                } else {\n                    delete dictRef.current[strKey];\n                }\n            },\n            prefixCls: prefixCls,\n            classNames: configClassNames,\n            styles: configStyles,\n            className: classnames__WEBPACK_IMPORTED_MODULE_7___default()(configClassName, ctxCls === null || ctxCls === void 0 ? void 0 : ctxCls.notice),\n            style: configStyle,\n            times: times,\n            key: key,\n            eventKey: key,\n            onNoticeClose: onNoticeClose,\n            hovering: stack && hoverKeys.length > 0\n        })));\n    });\n};\n_s(NoticeList, \"/ckwFF5H5uKEe1rLM4Sdao9eqSY=\", false, function() {\n    return [\n        _hooks_useStack__WEBPACK_IMPORTED_MODULE_11__[\"default\"],\n        _hooks_useStack__WEBPACK_IMPORTED_MODULE_11__[\"default\"],\n        _hooks_useStack__WEBPACK_IMPORTED_MODULE_11__[\"default\"],\n        _hooks_useStack__WEBPACK_IMPORTED_MODULE_11__[\"default\"],\n        _hooks_useStack__WEBPACK_IMPORTED_MODULE_11__[\"default\"],\n        _hooks_useStack__WEBPACK_IMPORTED_MODULE_11__[\"default\"],\n        _hooks_useStack__WEBPACK_IMPORTED_MODULE_11__[\"default\"]\n    ];\n});\n_c = NoticeList;\nif (true) {\n    NoticeList.displayName = \"NoticeList\";\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (NoticeList);\nvar _c;\n$RefreshReg$(_c, \"NoticeList\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yYy1ub3RpZmljYXRpb24vZXMvTm90aWNlTGlzdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQTBEO0FBQ29CO0FBQ1Q7QUFDcUI7QUFDbEI7QUFDRjtBQUN0RSxJQUFJTSxZQUFZO0lBQUM7SUFBYTtJQUFTO0lBQWM7Q0FBUztBQUNTO0FBQ3pDO0FBQ1k7QUFDWjtBQUMrQjtBQUNyQjtBQUN4QyxJQUFJVyxhQUFhLFNBQVNBLFdBQVdDLEtBQUs7O0lBQ3hDLElBQUlDLGFBQWFELE1BQU1DLFVBQVUsRUFDL0JDLFlBQVlGLE1BQU1FLFNBQVMsRUFDM0JDLFlBQVlILE1BQU1HLFNBQVMsRUFDM0JDLFlBQVlKLE1BQU1JLFNBQVMsRUFDM0JDLFFBQVFMLE1BQU1LLEtBQUssRUFDbkJDLFNBQVNOLE1BQU1NLE1BQU0sRUFDckJDLHFCQUFxQlAsTUFBTU8sa0JBQWtCLEVBQzdDQyxnQkFBZ0JSLE1BQU1RLGFBQWEsRUFDbkNDLGNBQWNULE1BQU1VLEtBQUs7SUFDM0IsSUFBSUMsY0FBY3JCLGlEQUFVQSxDQUFDTyx1RUFBbUJBLEdBQzlDZSxTQUFTRCxZQUFZRSxVQUFVO0lBQ2pDLElBQUlDLFVBQVV0Qiw2Q0FBTUEsQ0FBQyxDQUFDO0lBQ3RCLElBQUl1QixZQUFZdEIsK0NBQVFBLENBQUMsT0FDdkJ1QixhQUFhN0Isb0ZBQWNBLENBQUM0QixXQUFXLElBQ3ZDRSxlQUFlRCxVQUFVLENBQUMsRUFBRSxFQUM1QkUsa0JBQWtCRixVQUFVLENBQUMsRUFBRTtJQUNqQyxJQUFJRyxhQUFhMUIsK0NBQVFBLENBQUMsRUFBRSxHQUMxQjJCLGFBQWFqQyxvRkFBY0EsQ0FBQ2dDLFlBQVksSUFDeENFLFlBQVlELFVBQVUsQ0FBQyxFQUFFLEVBQ3pCRSxlQUFlRixVQUFVLENBQUMsRUFBRTtJQUM5QixJQUFJRyxPQUFPdEIsV0FBV3VCLEdBQUcsQ0FBQyxTQUFVQyxNQUFNO1FBQ3hDLE9BQU87WUFD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aEcsVUFBVUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmMtbm90aWZpY2F0aW9uL2VzL05vdGljZUxpc3QuanM/ZWQ0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfdG9Db25zdW1hYmxlQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5XCI7XG5pbXBvcnQgX29iamVjdFNwcmVhZCBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0U3ByZWFkMlwiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgX3NsaWNlZFRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXlcIjtcbnZhciBfZXhjbHVkZWQgPSBbXCJjbGFzc05hbWVcIiwgXCJzdHlsZVwiLCBcImNsYXNzTmFtZXNcIiwgXCJzdHlsZXNcIl07XG5pbXBvcnQgUmVhY3QsIHsgdXNlQ29udGV4dCwgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGNsc3ggZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgeyBDU1NNb3Rpb25MaXN0IH0gZnJvbSAncmMtbW90aW9uJztcbmltcG9ydCBOb3RpY2UgZnJvbSBcIi4vTm90aWNlXCI7XG5pbXBvcnQgeyBOb3RpZmljYXRpb25Db250ZXh0IH0gZnJvbSBcIi4vTm90aWZpY2F0aW9uUHJvdmlkZXJcIjtcbmltcG9ydCB1c2VTdGFjayBmcm9tIFwiLi9ob29rcy91c2VTdGFja1wiO1xudmFyIE5vdGljZUxpc3QgPSBmdW5jdGlvbiBOb3RpY2VMaXN0KHByb3BzKSB7XG4gIHZhciBjb25maWdMaXN0ID0gcHJvcHMuY29uZmlnTGlzdCxcbiAgICBwbGFjZW1lbnQgPSBwcm9wcy5wbGFjZW1lbnQsXG4gICAgcHJlZml4Q2xzID0gcHJvcHMucHJlZml4Q2xzLFxuICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICBzdHlsZSA9IHByb3BzLnN0eWxlLFxuICAgIG1vdGlvbiA9IHByb3BzLm1vdGlvbixcbiAgICBvbkFsbE5vdGljZVJlbW92ZWQgPSBwcm9wcy5vbkFsbE5vdGljZVJlbW92ZWQsXG4gICAgb25Ob3RpY2VDbG9zZSA9IHByb3BzLm9uTm90aWNlQ2xvc2UsXG4gICAgc3RhY2tDb25maWcgPSBwcm9wcy5zdGFjaztcbiAgdmFyIF91c2VDb250ZXh0ID0gdXNlQ29udGV4dChOb3RpZmljYXRpb25Db250ZXh0KSxcbiAgICBjdHhDbHMgPSBfdXNlQ29udGV4dC5jbGFzc05hbWVzO1xuICB2YXIgZGljdFJlZiA9IHVzZVJlZih7fSk7XG4gIHZhciBfdXNlU3RhdGUgPSB1c2VTdGF0ZShudWxsKSxcbiAgICBfdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlLCAyKSxcbiAgICBsYXRlc3ROb3RpY2UgPSBfdXNlU3RhdGUyWzBdLFxuICAgIHNldExhdGVzdE5vdGljZSA9IF91c2VTdGF0ZTJbMV07XG4gIHZhciBfdXNlU3RhdGUzID0gdXNlU3RhdGUoW10pLFxuICAgIF91c2VTdGF0ZTQgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUzLCAyKSxcbiAgICBob3ZlcktleXMgPSBfdXNlU3RhdGU0WzBdLFxuICAgIHNldEhvdmVyS2V5cyA9IF91c2VTdGF0ZTRbMV07XG4gIHZhciBrZXlzID0gY29uZmlnTGlzdC5tYXAoZnVuY3Rpb24gKGNvbmZpZykge1xuICAgIHJldHVybiB7XG4gICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgIGtleTogU3RyaW5nKGNvbmZpZy5rZXkpXG4gICAgfTtcbiAgfSk7XG4gIHZhciBfdXNlU3RhY2sgPSB1c2VTdGFjayhzdGFja0NvbmZpZyksXG4gICAgX3VzZVN0YWNrMiA9IF9zbGljZWRUb0FycmF5KF91c2VTdGFjaywgMiksXG4gICAgc3RhY2sgPSBfdXNlU3RhY2syWzBdLFxuICAgIF91c2VTdGFjazIkID0gX3VzZVN0YWNrMlsxXSxcbiAgICBvZmZzZXQgPSBfdXNlU3RhY2syJC5vZmZzZXQsXG4gICAgdGhyZXNob2xkID0gX3VzZVN0YWNrMiQudGhyZXNob2xkLFxuICAgIGdhcCA9IF91c2VTdGFjazIkLmdhcDtcbiAgdmFyIGV4cGFuZGVkID0gc3RhY2sgJiYgKGhvdmVyS2V5cy5sZW5ndGggPiAwIHx8IGtleXMubGVuZ3RoIDw9IHRocmVzaG9sZCk7XG4gIHZhciBwbGFjZW1lbnRNb3Rpb24gPSB0eXBlb2YgbW90aW9uID09PSAnZnVuY3Rpb24nID8gbW90aW9uKHBsYWNlbWVudCkgOiBtb3Rpb247XG5cbiAgLy8gQ2xlYW4gaG92ZXIga2V5XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHN0YWNrICYmIGhvdmVyS2V5cy5sZW5ndGggPiAxKSB7XG4gICAgICBzZXRIb3ZlcktleXMoZnVuY3Rpb24gKHByZXYpIHtcbiAgICAgICAgcmV0dXJuIHByZXYuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICByZXR1cm4ga2V5cy5zb21lKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgICAgICB2YXIgZGF0YUtleSA9IF9yZWYua2V5O1xuICAgICAgICAgICAgcmV0dXJuIGtleSA9PT0gZGF0YUtleTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtob3ZlcktleXMsIGtleXMsIHN0YWNrXSk7XG5cbiAgLy8gRm9yY2UgdXBkYXRlIGxhdGVzdCBub3RpY2VcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2tleXM7XG4gICAgaWYgKHN0YWNrICYmIGRpY3RSZWYuY3VycmVudFsoX2tleXMgPSBrZXlzW2tleXMubGVuZ3RoIC0gMV0pID09PSBudWxsIHx8IF9rZXlzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfa2V5cy5rZXldKSB7XG4gICAgICB2YXIgX2tleXMyO1xuICAgICAgc2V0TGF0ZXN0Tm90aWNlKGRpY3RSZWYuY3VycmVudFsoX2tleXMyID0ga2V5c1trZXlzLmxlbmd0aCAtIDFdKSA9PT0gbnVsbCB8fCBfa2V5czIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9rZXlzMi5rZXldKTtcbiAgICB9XG4gIH0sIFtrZXlzLCBzdGFja10pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ1NTTW90aW9uTGlzdCwgX2V4dGVuZHMoe1xuICAgIGtleTogcGxhY2VtZW50LFxuICAgIGNsYXNzTmFtZTogY2xzeChwcmVmaXhDbHMsIFwiXCIuY29uY2F0KHByZWZpeENscywgXCItXCIpLmNvbmNhdChwbGFjZW1lbnQpLCBjdHhDbHMgPT09IG51bGwgfHwgY3R4Q2xzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdHhDbHMubGlzdCwgY2xhc3NOYW1lLCBfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KHt9LCBcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLXN0YWNrXCIpLCAhIXN0YWNrKSwgXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1zdGFjay1leHBhbmRlZFwiKSwgZXhwYW5kZWQpKSxcbiAgICBzdHlsZTogc3R5bGUsXG4gICAga2V5czoga2V5cyxcbiAgICBtb3Rpb25BcHBlYXI6IHRydWVcbiAgfSwgcGxhY2VtZW50TW90aW9uLCB7XG4gICAgb25BbGxSZW1vdmVkOiBmdW5jdGlvbiBvbkFsbFJlbW92ZWQoKSB7XG4gICAgICBvbkFsbE5vdGljZVJlbW92ZWQocGxhY2VtZW50KTtcbiAgICB9XG4gIH0pLCBmdW5jdGlvbiAoX3JlZjIsIG5vZGVSZWYpIHtcbiAgICB2YXIgY29uZmlnID0gX3JlZjIuY29uZmlnLFxuICAgICAgbW90aW9uQ2xhc3NOYW1lID0gX3JlZjIuY2xhc3NOYW1lLFxuICAgICAgbW90aW9uU3R5bGUgPSBfcmVmMi5zdHlsZSxcbiAgICAgIG1vdGlvbkluZGV4ID0gX3JlZjIuaW5kZXg7XG4gICAgdmFyIF9yZWYzID0gY29uZmlnLFxuICAgICAga2V5ID0gX3JlZjMua2V5LFxuICAgICAgdGltZXMgPSBfcmVmMy50aW1lcztcbiAgICB2YXIgc3RyS2V5ID0gU3RyaW5nKGtleSk7XG4gICAgdmFyIF9yZWY0ID0gY29uZmlnLFxuICAgICAgY29uZmlnQ2xhc3NOYW1lID0gX3JlZjQuY2xhc3NOYW1lLFxuICAgICAgY29uZmlnU3R5bGUgPSBfcmVmNC5zdHlsZSxcbiAgICAgIGNvbmZpZ0NsYXNzTmFtZXMgPSBfcmVmNC5jbGFzc05hbWVzLFxuICAgICAgY29uZmlnU3R5bGVzID0gX3JlZjQuc3R5bGVzLFxuICAgICAgcmVzdENvbmZpZyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmNCwgX2V4Y2x1ZGVkKTtcbiAgICB2YXIgZGF0YUluZGV4ID0ga2V5cy5maW5kSW5kZXgoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtLmtleSA9PT0gc3RyS2V5O1xuICAgIH0pO1xuXG4gICAgLy8gSWYgZGF0YUluZGV4IGlzIC0xLCB0aGF0IG1lYW5zIHRoaXMgbm90aWNlIGhhcyBiZWVuIHJlbW92ZWQgaW4gZGF0YSwgYnV0IHN0aWxsIGluIGRvbVxuICAgIC8vIFNob3VsZCBtaW51cyAobW90aW9uSW5kZXggLSAxKSB0byBnZXQgdGhlIGNvcnJlY3QgaW5kZXggYmVjYXVzZSBrZXlzLmxlbmd0aCBpcyBub3QgdGhlIHNhbWUgYXMgZG9tIGxlbmd0aFxuICAgIHZhciBzdGFja1N0eWxlID0ge307XG4gICAgaWYgKHN0YWNrKSB7XG4gICAgICB2YXIgaW5kZXggPSBrZXlzLmxlbmd0aCAtIDEgLSAoZGF0YUluZGV4ID4gLTEgPyBkYXRhSW5kZXggOiBtb3Rpb25JbmRleCAtIDEpO1xuICAgICAgdmFyIHRyYW5zZm9ybVggPSBwbGFjZW1lbnQgPT09ICd0b3AnIHx8IHBsYWNlbWVudCA9PT0gJ2JvdHRvbScgPyAnLTUwJScgOiAnMCc7XG4gICAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgIHZhciBfZGljdFJlZiRjdXJyZW50JHN0ckssIF9kaWN0UmVmJGN1cnJlbnQkc3RySzIsIF9kaWN0UmVmJGN1cnJlbnQkc3RySzM7XG4gICAgICAgIHN0YWNrU3R5bGUuaGVpZ2h0ID0gZXhwYW5kZWQgPyAoX2RpY3RSZWYkY3VycmVudCRzdHJLID0gZGljdFJlZi5jdXJyZW50W3N0cktleV0pID09PSBudWxsIHx8IF9kaWN0UmVmJGN1cnJlbnQkc3RySyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2RpY3RSZWYkY3VycmVudCRzdHJLLm9mZnNldEhlaWdodCA6IGxhdGVzdE5vdGljZSA9PT0gbnVsbCB8fCBsYXRlc3ROb3RpY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxhdGVzdE5vdGljZS5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgLy8gVHJhbnNmb3JtXG4gICAgICAgIHZhciB2ZXJ0aWNhbE9mZnNldCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kZXg7IGkrKykge1xuICAgICAgICAgIHZhciBfZGljdFJlZiRjdXJyZW50JGtleXM7XG4gICAgICAgICAgdmVydGljYWxPZmZzZXQgKz0gKChfZGljdFJlZiRjdXJyZW50JGtleXMgPSBkaWN0UmVmLmN1cnJlbnRba2V5c1trZXlzLmxlbmd0aCAtIDEgLSBpXS5rZXldKSA9PT0gbnVsbCB8fCBfZGljdFJlZiRjdXJyZW50JGtleXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kaWN0UmVmJGN1cnJlbnQka2V5cy5vZmZzZXRIZWlnaHQpICsgZ2FwO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0cmFuc2Zvcm1ZID0gKGV4cGFuZGVkID8gdmVydGljYWxPZmZzZXQgOiBpbmRleCAqIG9mZnNldCkgKiAocGxhY2VtZW50LnN0YXJ0c1dpdGgoJ3RvcCcpID8gMSA6IC0xKTtcbiAgICAgICAgdmFyIHNjYWxlWCA9ICFleHBhbmRlZCAmJiBsYXRlc3ROb3RpY2UgIT09IG51bGwgJiYgbGF0ZXN0Tm90aWNlICE9PSB2b2lkIDAgJiYgbGF0ZXN0Tm90aWNlLm9mZnNldFdpZHRoICYmIChfZGljdFJlZiRjdXJyZW50JHN0cksyID0gZGljdFJlZi5jdXJyZW50W3N0cktleV0pICE9PSBudWxsICYmIF9kaWN0UmVmJGN1cnJlbnQkc3RySzIgIT09IHZvaWQgMCAmJiBfZGljdFJlZiRjdXJyZW50JHN0cksyLm9mZnNldFdpZHRoID8gKChsYXRlc3ROb3RpY2UgPT09IG51bGwgfHwgbGF0ZXN0Tm90aWNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXRlc3ROb3RpY2Uub2Zmc2V0V2lkdGgpIC0gb2Zmc2V0ICogMiAqIChpbmRleCA8IDMgPyBpbmRleCA6IDMpKSAvICgoX2RpY3RSZWYkY3VycmVudCRzdHJLMyA9IGRpY3RSZWYuY3VycmVudFtzdHJLZXldKSA9PT0gbnVsbCB8fCBfZGljdFJlZiRjdXJyZW50JHN0ckszID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZGljdFJlZiRjdXJyZW50JHN0ckszLm9mZnNldFdpZHRoKSA6IDE7XG4gICAgICAgIHN0YWNrU3R5bGUudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUzZChcIi5jb25jYXQodHJhbnNmb3JtWCwgXCIsIFwiKS5jb25jYXQodHJhbnNmb3JtWSwgXCJweCwgMCkgc2NhbGVYKFwiKS5jb25jYXQoc2NhbGVYLCBcIilcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFja1N0eWxlLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlM2QoXCIuY29uY2F0KHRyYW5zZm9ybVgsIFwiLCAwLCAwKVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIHJlZjogbm9kZVJlZixcbiAgICAgIGNsYXNzTmFtZTogY2xzeChcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLW5vdGljZS13cmFwcGVyXCIpLCBtb3Rpb25DbGFzc05hbWUsIGNvbmZpZ0NsYXNzTmFtZXMgPT09IG51bGwgfHwgY29uZmlnQ2xhc3NOYW1lcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnQ2xhc3NOYW1lcy53cmFwcGVyKSxcbiAgICAgIHN0eWxlOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgbW90aW9uU3R5bGUpLCBzdGFja1N0eWxlKSwgY29uZmlnU3R5bGVzID09PSBudWxsIHx8IGNvbmZpZ1N0eWxlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnU3R5bGVzLndyYXBwZXIpLFxuICAgICAgb25Nb3VzZUVudGVyOiBmdW5jdGlvbiBvbk1vdXNlRW50ZXIoKSB7XG4gICAgICAgIHJldHVybiBzZXRIb3ZlcktleXMoZnVuY3Rpb24gKHByZXYpIHtcbiAgICAgICAgICByZXR1cm4gcHJldi5pbmNsdWRlcyhzdHJLZXkpID8gcHJldiA6IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkocHJldiksIFtzdHJLZXldKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgb25Nb3VzZUxlYXZlOiBmdW5jdGlvbiBvbk1vdXNlTGVhdmUoKSB7XG4gICAgICAgIHJldHVybiBzZXRIb3ZlcktleXMoZnVuY3Rpb24gKHByZXYpIHtcbiAgICAgICAgICByZXR1cm4gcHJldi5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiBrICE9PSBzdHJLZXk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE5vdGljZSwgX2V4dGVuZHMoe30sIHJlc3RDb25maWcsIHtcbiAgICAgIHJlZjogZnVuY3Rpb24gcmVmKG5vZGUpIHtcbiAgICAgICAgaWYgKGRhdGFJbmRleCA+IC0xKSB7XG4gICAgICAgICAgZGljdFJlZi5jdXJyZW50W3N0cktleV0gPSBub2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBkaWN0UmVmLmN1cnJlbnRbc3RyS2V5XTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHByZWZpeENsczogcHJlZml4Q2xzLFxuICAgICAgY2xhc3NOYW1lczogY29uZmlnQ2xhc3NOYW1lcyxcbiAgICAgIHN0eWxlczogY29uZmlnU3R5bGVzLFxuICAgICAgY2xhc3NOYW1lOiBjbHN4KGNvbmZpZ0NsYXNzTmFtZSwgY3R4Q2xzID09PSBudWxsIHx8IGN0eENscyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4Q2xzLm5vdGljZSksXG4gICAgICBzdHlsZTogY29uZmlnU3R5bGUsXG4gICAgICB0aW1lczogdGltZXMsXG4gICAgICBrZXk6IGtleSxcbiAgICAgIGV2ZW50S2V5OiBrZXksXG4gICAgICBvbk5vdGljZUNsb3NlOiBvbk5vdGljZUNsb3NlLFxuICAgICAgaG92ZXJpbmc6IHN0YWNrICYmIGhvdmVyS2V5cy5sZW5ndGggPiAwXG4gICAgfSkpKTtcbiAgfSk7XG59O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgTm90aWNlTGlzdC5kaXNwbGF5TmFtZSA9ICdOb3RpY2VMaXN0Jztcbn1cbmV4cG9ydCBkZWZhdWx0IE5vdGljZUxpc3Q7Il0sIm5hbWVzIjpbIl9leHRlbmRzIiwiX3RvQ29uc3VtYWJsZUFycmF5IiwiX29iamVjdFNwcmVhZCIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsIl9kZWZpbmVQcm9wZXJ0eSIsIl9zbGljZWRUb0FycmF5IiwiX2V4Y2x1ZGVkIiwiUmVhY3QiLCJ1c2VDb250ZXh0IiwidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJjbHN4IiwiQ1NTTW90aW9uTGlzdCIsIk5vdGljZSIsIk5vdGlmaWNhdGlvbkNvbnRleHQiLCJ1c2VTdGFjayIsIk5vdGljZUxpc3QiLCJwcm9wcyIsImNvbmZpZ0xpc3QiLCJwbGFjZW1lbnQiLCJwcmVmaXhDbHMiLCJjbGFzc05hbWUiLCJzdHlsZSIsIm1vdGlvbiIsIm9uQWxsTm90aWNlUmVtb3ZlZCIsIm9uTm90aWNlQ2xvc2UiLCJzdGFja0NvbmZpZyIsInN0YWNrIiwiX3VzZUNvbnRleHQiLCJjdHhDbHMiLCJjbGFzc05hbWVzIiwiZGljdFJlZiIsIl91c2VTdGF0ZSIsIl91c2VTdGF0ZTIiLCJsYXRlc3ROb3RpY2UiLCJzZXRMYXRlc3ROb3RpY2UiLCJfdXNlU3RhdGUzIiwiX3VzZVN0YXRlNCIsImhvdmVyS2V5cyIsInNldEhvdmVyS2V5cyIsImtleXMiLCJtYXAiLCJjb25maWciLCJrZXkiLCJTdHJpbmciLCJfdXNlU3RhY2siLCJfdXNlU3RhY2syIiwiX3VzZVN0YWNrMiQiLCJvZmZzZXQiLCJ0aHJlc2hvbGQiLCJnYXAiLCJleHBhbmRlZCIsImxlbmd0aCIsInBsYWNlbWVudE1vdGlvbiIsInByZXYiLCJmaWx0ZXIiLCJzb21lIiwiX3JlZiIsImRhdGFLZXkiLCJfa2V5cyIsImN1cnJlbnQiLCJfa2V5czIiLCJjcmVhdGVFbGVtZW50IiwiY29uY2F0IiwibGlzdCIsIm1vdGlvbkFwcGVhciIsIm9uQWxsUmVtb3ZlZCIsIl9yZWYyIiwibm9kZVJlZiIsIm1vdGlvbkNsYXNzTmFtZSIsIm1vdGlvblN0eWxlIiwibW90aW9uSW5kZXgiLCJpbmRleCIsIl9yZWYzIiwidGltZXMiLCJzdHJLZXkiLCJfcmVmNCIsImNvbmZpZ0NsYXNzTmFtZSIsImNvbmZpZ1N0eWxlIiwiY29uZmlnQ2xhc3NOYW1lcyIsImNvbmZpZ1N0eWxlcyIsInN0eWxlcyIsInJlc3RDb25maWciLCJkYXRhSW5kZXgiLCJmaW5kSW5kZXgiLCJpdGVtIiwic3RhY2tTdHlsZSIsInRyYW5zZm9ybVgiLCJfZGljdFJlZiRjdXJyZW50JHN0cksiLCJfZGljdFJlZiRjdXJyZW50JHN0cksyIiwiX2RpY3RSZWYkY3VycmVudCRzdHJLMyIsImhlaWdodCIsIm9mZnNldEhlaWdodCIsInZlcnRpY2FsT2Zmc2V0IiwiaSIsIl9kaWN0UmVmJGN1cnJlbnQka2V5cyIsInRyYW5zZm9ybVkiLCJzdGFydHNXaXRoIiwic2NhbGVYIiwib2Zmc2V0V2lkdGgiLCJ0cmFuc2Zvcm0iLCJyZWYiLCJ3cmFwcGVyIiwib25Nb3VzZUVudGVyIiwiaW5jbHVkZXMiLCJvbk1vdXNlTGVhdmUiLCJrIiwibm9kZSIsIm5vdGljZSIsImV2ZW50S2V5IiwiaG92ZXJpbmciLCJwcm9jZXNzIiwiZGlzcGxheU5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/rc-notification/es/NoticeList.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/rc-notification/es/NotificationProvider.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rc-notification/es/NotificationProvider.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NotificationContext: function() { return /* binding */ NotificationContext; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nvar NotificationContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext({});\nvar NotificationProvider = function NotificationProvider(_ref) {\n    var children = _ref.children, classNames = _ref.classNames;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(NotificationContext.Provider, {\n        value: {\n            classNames: classNames\n        }\n    }, children);\n};\n_c = NotificationProvider;\n/* harmony default export */ __webpack_exports__[\"default\"] = (NotificationProvider);\nvar _c;\n$RefreshReg$(_c, \"NotificationProvider\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yYy1ub3RpZmljYXRpb24vZXMvTm90aWZpY2F0aW9uUHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTBCO0FBQ25CLElBQUlDLHNCQUFzQixXQUFXLEdBQUVELDBEQUFtQixDQUFDLENBQUMsR0FBRztBQUN0RSxJQUFJRyx1QkFBdUIsU0FBU0EscUJBQXFCQyxJQUFJO0lBQzNELElBQUlDLFdBQVdELEtBQUtDLFFBQVEsRUFDMUJDLGFBQWFGLEtBQUtFLFVBQVU7SUFDOUIsT0FBTyxXQUFXLEdBQUVOLDBEQUFtQixDQUFDQyxvQkFBb0JPLFFBQVEsRUFBRTtRQUNwRUMsT0FBTztZQUNMSCxZQUFZQTtRQUNkO0lBQ0YsR0FBR0Q7QUFDTDtLQVJJRjtBQVNKLCtEQUFlQSxvQkFBb0JBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JjLW5vdGlmaWNhdGlvbi9lcy9Ob3RpZmljYXRpb25Qcm92aWRlci5qcz8yMmFiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5leHBvcnQgdmFyIE5vdGlmaWNhdGlvbkNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCh7fSk7XG52YXIgTm90aWZpY2F0aW9uUHJvdmlkZXIgPSBmdW5jdGlvbiBOb3RpZmljYXRpb25Qcm92aWRlcihfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgY2xhc3NOYW1lcyA9IF9yZWYuY2xhc3NOYW1lcztcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE5vdGlmaWNhdGlvbkNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZToge1xuICAgICAgY2xhc3NOYW1lczogY2xhc3NOYW1lc1xuICAgIH1cbiAgfSwgY2hpbGRyZW4pO1xufTtcbmV4cG9ydCBkZWZhdWx0IE5vdGlmaWNhdGlvblByb3ZpZGVyOyJdLCJuYW1lcyI6WyJSZWFjdCIsIk5vdGlmaWNhdGlvbkNvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwiTm90aWZpY2F0aW9uUHJvdmlkZXIiLCJfcmVmIiwiY2hpbGRyZW4iLCJjbGFzc05hbWVzIiwiY3JlYXRlRWxlbWVudCIsIlByb3ZpZGVyIiwidmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/rc-notification/es/NotificationProvider.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/rc-notification/es/Notifications.js":
/*!**********************************************************!*\
  !*** ./node_modules/rc-notification/es/Notifications.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectSpread2 */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/objectSpread2.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/toConsumableArray */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/slicedToArray */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/slicedToArray.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\n/* harmony import */ var _NoticeList__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./NoticeList */ \"(app-pages-browser)/./node_modules/rc-notification/es/NoticeList.js\");\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n// ant-notification ant-notification-topRight\nvar Notifications = /*#__PURE__*/ _s(react__WEBPACK_IMPORTED_MODULE_3__.forwardRef(_c = _s(function(props, ref) {\n    _s();\n    var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? \"rc-notification\" : _props$prefixCls, container = props.container, motion = props.motion, maxCount = props.maxCount, className = props.className, style = props.style, onAllRemoved = props.onAllRemoved, stack = props.stack, renderNotifications = props.renderNotifications;\n    var _React$useState = react__WEBPACK_IMPORTED_MODULE_3__.useState([]), _React$useState2 = (0,_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_React$useState, 2), configList = _React$useState2[0], setConfigList = _React$useState2[1];\n    // ======================== Close =========================\n    var onNoticeClose = function onNoticeClose(key) {\n        var _config$onClose;\n        // Trigger close event\n        var config = configList.find(function(item) {\n            return item.key === key;\n        });\n        config === null || config === void 0 || (_config$onClose = config.onClose) === null || _config$onClose === void 0 || _config$onClose.call(config);\n        setConfigList(function(list) {\n            return list.filter(function(item) {\n                return item.key !== key;\n            });\n        });\n    };\n    // ========================= Refs =========================\n    react__WEBPACK_IMPORTED_MODULE_3__.useImperativeHandle(ref, function() {\n        return {\n            open: function open(config) {\n                setConfigList(function(list) {\n                    var clone = (0,_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(list);\n                    // Replace if exist\n                    var index = clone.findIndex(function(item) {\n                        return item.key === config.key;\n                    });\n                    var innerConfig = (0,_babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, config);\n                    if (index >= 0) {\n                        var _list$index;\n                        innerConfig.times = (((_list$index = list[index]) === null || _list$index === void 0 ? void 0 : _list$index.times) || 0) + 1;\n                        clone[index] = innerConfig;\n                    } else {\n                        innerConfig.times = 0;\n                        clone.push(innerConfig);\n                    }\n                    if (maxCount > 0 && clone.length > maxCount) {\n                        clone = clone.slice(-maxCount);\n                    }\n                    return clone;\n                });\n            },\n            close: function close(key) {\n                onNoticeClose(key);\n            },\n            destroy: function destroy() {\n                setConfigList([]);\n            }\n        };\n    });\n    // ====================== Placements ======================\n    var _React$useState3 = react__WEBPACK_IMPORTED_MODULE_3__.useState({}), _React$useState4 = (0,_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_React$useState3, 2), placements = _React$useState4[0], setPlacements = _React$useState4[1];\n    react__WEBPACK_IMPORTED_MODULE_3__.useEffect(function() {\n        var nextPlacements = {};\n        configList.forEach(function(config) {\n            var _config$placement = config.placement, placement = _config$placement === void 0 ? \"topRight\" : _config$placement;\n            if (placement) {\n                nextPlacements[placement] = nextPlacements[placement] || [];\n                nextPlacements[placement].push(config);\n            }\n        });\n        // Fill exist placements to avoid empty list causing remove without motion\n        Object.keys(placements).forEach(function(placement) {\n            nextPlacements[placement] = nextPlacements[placement] || [];\n        });\n        setPlacements(nextPlacements);\n    }, [\n        configList\n    ]);\n    // Clean up container if all notices fade out\n    var onAllNoticeRemoved = function onAllNoticeRemoved(placement) {\n        setPlacements(function(originPlacements) {\n            var clone = (0,_babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, originPlacements);\n            var list = clone[placement] || [];\n            if (!list.length) {\n                delete clone[placement];\n            }\n            return clone;\n        });\n    };\n    // Effect tell that placements is empty now\n    var emptyRef = react__WEBPACK_IMPORTED_MODULE_3__.useRef(false);\n    react__WEBPACK_IMPORTED_MODULE_3__.useEffect(function() {\n        if (Object.keys(placements).length > 0) {\n            emptyRef.current = true;\n        } else if (emptyRef.current) {\n            // Trigger only when from exist to empty\n            onAllRemoved === null || onAllRemoved === void 0 || onAllRemoved();\n            emptyRef.current = false;\n        }\n    }, [\n        placements\n    ]);\n    // ======================== Render ========================\n    if (!container) {\n        return null;\n    }\n    var placementList = Object.keys(placements);\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_4__.createPortal)(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3__.createElement(react__WEBPACK_IMPORTED_MODULE_3__.Fragment, null, placementList.map(function(placement) {\n        var placementConfigList = placements[placement];\n        var list = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3__.createElement(_NoticeList__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n            key: placement,\n            configList: placementConfigList,\n            placement: placement,\n            prefixCls: prefixCls,\n            className: className === null || className === void 0 ? void 0 : className(placement),\n            style: style === null || style === void 0 ? void 0 : style(placement),\n            motion: motion,\n            onNoticeClose: onNoticeClose,\n            onAllNoticeRemoved: onAllNoticeRemoved,\n            stack: stack\n        });\n        return renderNotifications ? renderNotifications(list, {\n            prefixCls: prefixCls,\n            key: placement\n        }) : list;\n    })), container);\n}, \"ITC1hmf2568id6K+0tq8zdLbvYI=\")), \"ITC1hmf2568id6K+0tq8zdLbvYI=\");\n_c1 = Notifications;\nif (true) {\n    Notifications.displayName = \"Notifications\";\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (Notifications);\nvar _c, _c1;\n$RefreshReg$(_c, \"Notifications$React.forwardRef\");\n$RefreshReg$(_c1, \"Notifications\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yYy1ub3RpZmljYXRpb24vZXMvTm90aWZpY2F0aW9ucy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBcUU7QUFDUztBQUNSO0FBQ3ZDO0FBQ1U7QUFDSDtBQUN0Qyw2Q0FBNkM7QUFDN0MsSUFBSU0sZ0JBQWdCLFdBQVcsR0FBRUgsR0FBQUEsNkNBQWdCLFNBQUMsU0FBVUssS0FBSyxFQUFFQyxHQUFHOztJQUNwRSxJQUFJQyxtQkFBbUJGLE1BQU1HLFNBQVMsRUFDcENBLFlBQVlELHFCQUFxQixLQUFLLElBQUksb0JBQW9CQSxrQkFDOURFLFlBQVlKLE1BQU1JLFNBQVMsRUFDM0JDLFNBQVNMLE1BQU1LLE1BQU0sRUFDckJDLFdBQVdOLE1BQU1NLFFBQVEsRUFDekJDLFlBQVlQLE1BQU1PLFNBQVMsRUFDM0JDLFFBQVFSLE1BQU1RLEtBQUssRUFDbkJDLGVBQWVULE1BQU1TLFlBQVksRUFDakNDLFFBQVFWLE1BQU1VLEtBQUssRUFDbkJDLHNCQUFzQlgsTUFBTVcsbUJBQW1CO0lBQ2pELElBQUlDLGtCQUFrQmpCLDJDQUFjLENBQUMsRUFBRSxHQUNyQ21CLG1CQUFtQnBCLG9GQUFjQSxDQUFDa0IsaUJBQWlCLElBQ25ERyxhQUFhRCxnQkFBZ0IsQ0FBQyxFQUFFLEVBQ2hDRSxnQkFBZ0JGLGdCQUFnQixDQUFDLEVBQUU7SUFFckMsMkRBQTJEO0lBQzNELElBQUlHLGdCQUFnQixTQUFTQSxjQUFjQyxHQUFHO1FBQzVDLElBQUlDO1FBQ0osc0JBQXNCO1FBQ3RCLElBQUlDLFNBQVNMLFdBQVdNLElBQUksQ0FBQyxTQUFVQyxJQUFJO1lBQ3pDLE9BQU9BLEtBQUtKLEdBQUcsS0FBS0E7UUFDdEI7UUFDQUUsV0FBVyxRQUFRQSxXQUFXLEtBQUssS0FBSyxDQUFDRCxrQkFBa0JDLE9BQU9HLE9BQU8sTUFBTSxRQUFRSixvQkFBb0IsS0FBSyxLQUFLQSxnQkFBZ0JLLElBQUksQ0FBQ0o7UUFDMUlKLGNB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aWNhdGlvbi9lcy9Ob3RpZmljYXRpb25zLmpzPzBjM2UiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9vYmplY3RTcHJlYWQgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFNwcmVhZDJcIjtcbmltcG9ydCBfdG9Db25zdW1hYmxlQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5XCI7XG5pbXBvcnQgX3NsaWNlZFRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXlcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNyZWF0ZVBvcnRhbCB9IGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgTm90aWNlTGlzdCBmcm9tIFwiLi9Ob3RpY2VMaXN0XCI7XG4vLyBhbnQtbm90aWZpY2F0aW9uIGFudC1ub3RpZmljYXRpb24tdG9wUmlnaHRcbnZhciBOb3RpZmljYXRpb25zID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gKHByb3BzLCByZWYpIHtcbiAgdmFyIF9wcm9wcyRwcmVmaXhDbHMgPSBwcm9wcy5wcmVmaXhDbHMsXG4gICAgcHJlZml4Q2xzID0gX3Byb3BzJHByZWZpeENscyA9PT0gdm9pZCAwID8gJ3JjLW5vdGlmaWNhdGlvbicgOiBfcHJvcHMkcHJlZml4Q2xzLFxuICAgIGNvbnRhaW5lciA9IHByb3BzLmNvbnRhaW5lcixcbiAgICBtb3Rpb24gPSBwcm9wcy5tb3Rpb24sXG4gICAgbWF4Q291bnQgPSBwcm9wcy5tYXhDb3VudCxcbiAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgc3R5bGUgPSBwcm9wcy5zdHlsZSxcbiAgICBvbkFsbFJlbW92ZWQgPSBwcm9wcy5vbkFsbFJlbW92ZWQsXG4gICAgc3RhY2sgPSBwcm9wcy5zdGFjayxcbiAgICByZW5kZXJOb3RpZmljYXRpb25zID0gcHJvcHMucmVuZGVyTm90aWZpY2F0aW9ucztcbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKFtdKSxcbiAgICBfUmVhY3QkdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX1JlYWN0JHVzZVN0YXRlLCAyKSxcbiAgICBjb25maWdMaXN0ID0gX1JlYWN0JHVzZVN0YXRlMlswXSxcbiAgICBzZXRDb25maWdMaXN0ID0gX1JlYWN0JHVzZVN0YXRlMlsxXTtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT0gQ2xvc2UgPT09PT09PT09PT09PT09PT09PT09PT09PVxuICB2YXIgb25Ob3RpY2VDbG9zZSA9IGZ1bmN0aW9uIG9uTm90aWNlQ2xvc2Uoa2V5KSB7XG4gICAgdmFyIF9jb25maWckb25DbG9zZTtcbiAgICAvLyBUcmlnZ2VyIGNsb3NlIGV2ZW50XG4gICAgdmFyIGNvbmZpZyA9IGNvbmZpZ0xpc3QuZmluZChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0ua2V5ID09PSBrZXk7XG4gICAgfSk7XG4gICAgY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwIHx8IChfY29uZmlnJG9uQ2xvc2UgPSBjb25maWcub25DbG9zZSkgPT09IG51bGwgfHwgX2NvbmZpZyRvbkNsb3NlID09PSB2b2lkIDAgfHwgX2NvbmZpZyRvbkNsb3NlLmNhbGwoY29uZmlnKTtcbiAgICBzZXRDb25maWdMaXN0KGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICByZXR1cm4gbGlzdC5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0ua2V5ICE9PSBrZXk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09IFJlZnMgPT09PT09PT09PT09PT09PT09PT09PT09PVxuICBSZWFjdC51c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvcGVuOiBmdW5jdGlvbiBvcGVuKGNvbmZpZykge1xuICAgICAgICBzZXRDb25maWdMaXN0KGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICAgICAgdmFyIGNsb25lID0gX3RvQ29uc3VtYWJsZUFycmF5KGxpc3QpO1xuXG4gICAgICAgICAgLy8gUmVwbGFjZSBpZiBleGlzdFxuICAgICAgICAgIHZhciBpbmRleCA9IGNsb25lLmZpbmRJbmRleChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0ua2V5ID09PSBjb25maWcua2V5O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBpbm5lckNvbmZpZyA9IF9vYmplY3RTcHJlYWQoe30sIGNvbmZpZyk7XG4gICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgIHZhciBfbGlzdCRpbmRleDtcbiAgICAgICAgICAgIGlubmVyQ29uZmlnLnRpbWVzID0gKCgoX2xpc3QkaW5kZXggPSBsaXN0W2luZGV4XSkgPT09IG51bGwgfHwgX2xpc3QkaW5kZXggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9saXN0JGluZGV4LnRpbWVzKSB8fCAwKSArIDE7XG4gICAgICAgICAgICBjbG9uZVtpbmRleF0gPSBpbm5lckNvbmZpZztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5uZXJDb25maWcudGltZXMgPSAwO1xuICAgICAgICAgICAgY2xvbmUucHVzaChpbm5lckNvbmZpZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtYXhDb3VudCA+IDAgJiYgY2xvbmUubGVuZ3RoID4gbWF4Q291bnQpIHtcbiAgICAgICAgICAgIGNsb25lID0gY2xvbmUuc2xpY2UoLW1heENvdW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBjbG9zZTogZnVuY3Rpb24gY2xvc2Uoa2V5KSB7XG4gICAgICAgIG9uTm90aWNlQ2xvc2Uoa2V5KTtcbiAgICAgIH0sXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBzZXRDb25maWdMaXN0KFtdKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09IFBsYWNlbWVudHMgPT09PT09PT09PT09PT09PT09PT09PVxuICB2YXIgX1JlYWN0JHVzZVN0YXRlMyA9IFJlYWN0LnVzZVN0YXRlKHt9KSxcbiAgICBfUmVhY3QkdXNlU3RhdGU0ID0gX3NsaWNlZFRvQXJyYXkoX1JlYWN0JHVzZVN0YXRlMywgMiksXG4gICAgcGxhY2VtZW50cyA9IF9SZWFjdCR1c2VTdGF0ZTRbMF0sXG4gICAgc2V0UGxhY2VtZW50cyA9IF9SZWFjdCR1c2VTdGF0ZTRbMV07XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5leHRQbGFjZW1lbnRzID0ge307XG4gICAgY29uZmlnTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgIHZhciBfY29uZmlnJHBsYWNlbWVudCA9IGNvbmZpZy5wbGFjZW1lbnQsXG4gICAgICAgIHBsYWNlbWVudCA9IF9jb25maWckcGxhY2VtZW50ID09PSB2b2lkIDAgPyAndG9wUmlnaHQnIDogX2NvbmZpZyRwbGFjZW1lbnQ7XG4gICAgICBpZiAocGxhY2VtZW50KSB7XG4gICAgICAgIG5leHRQbGFjZW1lbnRzW3BsYWNlbWVudF0gPSBuZXh0UGxhY2VtZW50c1twbGFjZW1lbnRdIHx8IFtdO1xuICAgICAgICBuZXh0UGxhY2VtZW50c1twbGFjZW1lbnRdLnB1c2goY29uZmlnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEZpbGwgZXhpc3QgcGxhY2VtZW50cyB0byBhdm9pZCBlbXB0eSBsaXN0IGNhdXNpbmcgcmVtb3ZlIHdpdGhvdXQgbW90aW9uXG4gICAgT2JqZWN0LmtleXMocGxhY2VtZW50cykuZm9yRWFjaChmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgICBuZXh0UGxhY2VtZW50c1twbGFjZW1lbnRdID0gbmV4dFBsYWNlbWVudHNbcGxhY2VtZW50XSB8fCBbXTtcbiAgICB9KTtcbiAgICBzZXRQbGFjZW1lbnRzKG5leHRQbGFjZW1lbnRzKTtcbiAgfSwgW2NvbmZpZ0xpc3RdKTtcblxuICAvLyBDbGVhbiB1cCBjb250YWluZXIgaWYgYWxsIG5vdGljZXMgZmFkZSBvdXRcbiAgdmFyIG9uQWxsTm90aWNlUmVtb3ZlZCA9IGZ1bmN0aW9uIG9uQWxsTm90aWNlUmVtb3ZlZChwbGFjZW1lbnQpIHtcbiAgICBzZXRQbGFjZW1lbnRzKGZ1bmN0aW9uIChvcmlnaW5QbGFjZW1lbnRzKSB7XG4gICAgICB2YXIgY2xvbmUgPSBfb2JqZWN0U3ByZWFkKHt9LCBvcmlnaW5QbGFjZW1lbnRzKTtcbiAgICAgIHZhciBsaXN0ID0gY2xvbmVbcGxhY2VtZW50XSB8fCBbXTtcbiAgICAgIGlmICghbGlzdC5sZW5ndGgpIHtcbiAgICAgICAgZGVsZXRlIGNsb25lW3BsYWNlbWVudF07XG4gICAgICB9XG4gICAgICByZXR1cm4gY2xvbmU7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gRWZmZWN0IHRlbGwgdGhhdCBwbGFjZW1lbnRzIGlzIGVtcHR5IG5vd1xuICB2YXIgZW1wdHlSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChPYmplY3Qua2V5cyhwbGFjZW1lbnRzKS5sZW5ndGggPiAwKSB7XG4gICAgICBlbXB0eVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGVtcHR5UmVmLmN1cnJlbnQpIHtcbiAgICAgIC8vIFRyaWdnZXIgb25seSB3aGVuIGZyb20gZXhpc3QgdG8gZW1wdHlcbiAgICAgIG9uQWxsUmVtb3ZlZCA9PT0gbnVsbCB8fCBvbkFsbFJlbW92ZWQgPT09IHZvaWQgMCB8fCBvbkFsbFJlbW92ZWQoKTtcbiAgICAgIGVtcHR5UmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9XG4gIH0sIFtwbGFjZW1lbnRzXSk7XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PSBSZW5kZXIgPT09PT09PT09PT09PT09PT09PT09PT09XG4gIGlmICghY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHBsYWNlbWVudExpc3QgPSBPYmplY3Qua2V5cyhwbGFjZW1lbnRzKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9jcmVhdGVQb3J0YWwoIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBwbGFjZW1lbnRMaXN0Lm1hcChmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgdmFyIHBsYWNlbWVudENvbmZpZ0xpc3QgPSBwbGFjZW1lbnRzW3BsYWNlbWVudF07XG4gICAgdmFyIGxpc3QgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChOb3RpY2VMaXN0LCB7XG4gICAgICBrZXk6IHBsYWNlbWVudCxcbiAgICAgIGNvbmZpZ0xpc3Q6IHBsYWNlbWVudENvbmZpZ0xpc3QsXG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIHByZWZpeENsczogcHJlZml4Q2xzLFxuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUgPT09IG51bGwgfHwgY2xhc3NOYW1lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbGFzc05hbWUocGxhY2VtZW50KSxcbiAgICAgIHN0eWxlOiBzdHlsZSA9PT0gbnVsbCB8fCBzdHlsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3R5bGUocGxhY2VtZW50KSxcbiAgICAgIG1vdGlvbjogbW90aW9uLFxuICAgICAgb25Ob3RpY2VDbG9zZTogb25Ob3RpY2VDbG9zZSxcbiAgICAgIG9uQWxsTm90aWNlUmVtb3ZlZDogb25BbGxOb3RpY2VSZW1vdmVkLFxuICAgICAgc3RhY2s6IHN0YWNrXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlbmRlck5vdGlmaWNhdGlvbnMgPyByZW5kZXJOb3RpZmljYXRpb25zKGxpc3QsIHtcbiAgICAgIHByZWZpeENsczogcHJlZml4Q2xzLFxuICAgICAga2V5OiBwbGFjZW1lbnRcbiAgICB9KSA6IGxpc3Q7XG4gIH0pKSwgY29udGFpbmVyKTtcbn0pO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgTm90aWZpY2F0aW9ucy5kaXNwbGF5TmFtZSA9ICdOb3RpZmljYXRpb25zJztcbn1cbmV4cG9ydCBkZWZhdWx0IE5vdGlmaWNhdGlvbnM7Il0sIm5hbWVzIjpbIl9vYmplY3RTcHJlYWQiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJfc2xpY2VkVG9BcnJheSIsIlJlYWN0IiwiY3JlYXRlUG9ydGFsIiwiTm90aWNlTGlzdCIsIk5vdGlmaWNhdGlvbnMiLCJmb3J3YXJkUmVmIiwicHJvcHMiLCJyZWYiLCJfcHJvcHMkcHJlZml4Q2xzIiwicHJlZml4Q2xzIiwiY29udGFpbmVyIiwibW90aW9uIiwibWF4Q291bnQiLCJjbGFzc05hbWUiLCJzdHlsZSIsIm9uQWxsUmVtb3ZlZCIsInN0YWNrIiwicmVuZGVyTm90aWZpY2F0aW9ucyIsIl9SZWFjdCR1c2VTdGF0ZSIsInVzZVN0YXRlIiwiX1JlYWN0JHVzZVN0YXRlMiIsImNvbmZpZ0xpc3QiLCJzZXRDb25maWdMaXN0Iiwib25Ob3RpY2VDbG9zZSIsImtleSIsIl9jb25maWckb25DbG9zZSIsImNvbmZpZyIsImZpbmQiLCJpdGVtIiwib25DbG9zZSIsImNhbGwiLCJsaXN0IiwiZmlsdGVyIiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsIm9wZW4iLCJjbG9uZSIsImluZGV4IiwiZmluZEluZGV4IiwiaW5uZXJDb25maWciLCJfbGlzdCRpbmRleCIsInRpbWVzIiwicHVzaCIsImxlbmd0aCIsInNsaWNlIiwiY2xvc2UiLCJkZXN0cm95IiwiX1JlYWN0JHVzZVN0YXRlMyIsIl9SZWFjdCR1c2VTdGF0ZTQiLCJwbGFjZW1lbnRzIiwic2V0UGxhY2VtZW50cyIsInVzZUVmZmVjdCIsIm5leHRQbGFjZW1lbnRzIiwiZm9yRWFjaCIsIl9jb25maWckcGxhY2VtZW50IiwicGxhY2VtZW50IiwiT2JqZWN0Iiwia2V5cyIsIm9uQWxsTm90aWNlUmVtb3ZlZCIsIm9yaWdpblBsYWNlbWVudHMiLCJlbXB0eVJlZiIsInVzZVJlZiIsImN1cnJlbnQiLCJwbGFjZW1lbnRMaXN0IiwiY3JlYXRlRWxlbWVudCIsIkZyYWdtZW50IiwibWFwIiwicGxhY2VtZW50Q29uZmlnTGlzdCIsInByb2Nlc3MiLCJkaXNwbGF5TmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/rc-notification/es/Notifications.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/rc-notification/es/hooks/useNotification.js":
/*!******************************************************************!*\
  !*** ./node_modules/rc-notification/es/hooks/useNotification.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ useNotification; }\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/toConsumableArray */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/slicedToArray */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/slicedToArray.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutProperties */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _Notifications__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Notifications */ \"(app-pages-browser)/./node_modules/rc-notification/es/Notifications.js\");\n/* harmony import */ var rc_util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rc-util */ \"(app-pages-browser)/./node_modules/rc-util/es/index.js\");\nvar _s = $RefreshSig$();\n\n\n\nvar _excluded = [\n    \"getContainer\",\n    \"motion\",\n    \"prefixCls\",\n    \"maxCount\",\n    \"className\",\n    \"style\",\n    \"onAllRemoved\",\n    \"stack\",\n    \"renderNotifications\"\n];\n\n\n\nvar defaultGetContainer = function defaultGetContainer() {\n    return document.body;\n};\nvar uniqueKey = 0;\nfunction mergeConfig() {\n    var clone = {};\n    for(var _len = arguments.length, objList = new Array(_len), _key = 0; _key < _len; _key++){\n        objList[_key] = arguments[_key];\n    }\n    objList.forEach(function(obj) {\n        if (obj) {\n            Object.keys(obj).forEach(function(key) {\n                var val = obj[key];\n                if (val !== undefined) {\n                    clone[key] = val;\n                }\n            });\n        }\n    });\n    return clone;\n}\nfunction useNotification() {\n    _s();\n    var rootConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var _rootConfig$getContai = rootConfig.getContainer, getContainer = _rootConfig$getContai === void 0 ? defaultGetContainer : _rootConfig$getContai, motion = rootConfig.motion, prefixCls = rootConfig.prefixCls, maxCount = rootConfig.maxCount, className = rootConfig.className, style = rootConfig.style, onAllRemoved = rootConfig.onAllRemoved, stack = rootConfig.stack, renderNotifications = rootConfig.renderNotifications, shareConfig = (0,_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(rootConfig, _excluded);\n    var _React$useState = react__WEBPACK_IMPORTED_MODULE_3__.useState(), _React$useState2 = (0,_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_React$useState, 2), container = _React$useState2[0], setContainer = _React$useState2[1];\n    var notificationsRef = react__WEBPACK_IMPORTED_MODULE_3__.useRef();\n    var contextHolder = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3__.createElement(_Notifications__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n        container: container,\n        ref: notificationsRef,\n        prefixCls: prefixCls,\n        motion: motion,\n        maxCount: maxCount,\n        className: className,\n        style: style,\n        onAllRemoved: onAllRemoved,\n        stack: stack,\n        renderNotifications: renderNotifications\n    });\n    var _React$useState3 = react__WEBPACK_IMPORTED_MODULE_3__.useState([]), _React$useState4 = (0,_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_React$useState3, 2), taskQueue = _React$useState4[0], setTaskQueue = _React$useState4[1];\n    var open = (0,rc_util__WEBPACK_IMPORTED_MODULE_5__.useEvent)(function(config) {\n        var mergedConfig = mergeConfig(shareConfig, config);\n        if (mergedConfig.key === null || mergedConfig.key === undefined) {\n            mergedConfig.key = \"rc-notification-\".concat(uniqueKey);\n            uniqueKey += 1;\n        }\n        setTaskQueue(function(queue) {\n            return [].concat((0,_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(queue), [\n                {\n                    type: \"open\",\n                    config: mergedConfig\n                }\n            ]);\n        });\n    });\n    // ========================= Refs =========================\n    var api = react__WEBPACK_IMPORTED_MODULE_3__.useMemo(function() {\n        return {\n            open: open,\n            close: function close(key) {\n                setTaskQueue(function(queue) {\n                    return [].concat((0,_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(queue), [\n                        {\n                            type: \"close\",\n                            key: key\n                        }\n                    ]);\n                });\n            },\n            destroy: function destroy() {\n                setTaskQueue(function(queue) {\n                    return [].concat((0,_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(queue), [\n                        {\n                            type: \"destroy\"\n                        }\n                    ]);\n                });\n            }\n        };\n    }, []);\n    // ======================= Container ======================\n    // React 18 should all in effect that we will check container in each render\n    // Which means getContainer should be stable.\n    react__WEBPACK_IMPORTED_MODULE_3__.useEffect(function() {\n        setContainer(getContainer());\n    });\n    // ======================== Effect ========================\n    react__WEBPACK_IMPORTED_MODULE_3__.useEffect(function() {\n        // Flush task when node ready\n        if (notificationsRef.current && taskQueue.length) {\n            taskQueue.forEach(function(task) {\n                switch(task.type){\n                    case \"open\":\n                        notificationsRef.current.open(task.config);\n                        break;\n                    case \"close\":\n                        notificationsRef.current.close(task.key);\n                        break;\n                    case \"destroy\":\n                        notificationsRef.current.destroy();\n                        break;\n                }\n            });\n            // https://github.com/ant-design/ant-design/issues/52590\n            // React `startTransition` will run once `useEffect` but many times `setState`,\n            // So `setTaskQueue` with filtered array will cause infinite loop.\n            // We cache the first match queue instead.\n            var oriTaskQueue;\n            var tgtTaskQueue;\n            // React 17 will mix order of effect & setState in async\n            // - open: setState[0]\n            // - effect[0]\n            // - open: setState[1]\n            // - effect setState([]) * here will clean up [0, 1] in React 17\n            setTaskQueue(function(oriQueue) {\n                if (oriTaskQueue !== oriQueue || !tgtTaskQueue) {\n                    oriTaskQueue = oriQueue;\n                    tgtTaskQueue = oriQueue.filter(function(task) {\n                        return !taskQueue.includes(task);\n                    });\n                }\n                return tgtTaskQueue;\n            });\n        }\n    }, [\n        taskQueue\n    ]);\n    // ======================== Return ========================\n    return [\n        api,\n        contextHolder\n    ];\n}\n_s(useNotification, \"a8C69TiTSJeCUCxW6dex5GJGscY=\", false, function() {\n    return [\n        rc_util__WEBPACK_IMPORTED_MODULE_5__.useEvent\n    ];\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yYy1ub3RpZmljYXRpb24vZXMvaG9va3MvdXNlTm90aWZpY2F0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUE4RTtBQUNSO0FBQ29CO0FBQzFGLElBQUlHLFlBQVk7SUFBQztJQUFnQjtJQUFVO0lBQWE7SUFBWTtJQUFhO0lBQVM7SUFBZ0I7SUFBUztDQUFzQjtBQUMxRztBQUNjO0FBQ1Y7QUFDbkMsSUFBSUksc0JBQXNCLFNBQVNBO0lBQ2pDLE9BQU9DLFNBQVNDLElBQUk7QUFDdEI7QUFDQSxJQUFJQyxZQUFZO0FBQ2hCLFNBQVNDO0lBQ1AsSUFBSUMsUUFBUSxDQUFDO0lBQ2IsSUFBSyxJQUFJQyxPQUFPQyxVQUFVQyxNQUFNLEVBQUVDLFVBQVUsSUFBSUMsTUFBTUosT0FBT0ssT0FBTyxHQUFHQSxPQUFPTCxNQUFNSyxPQUFRO1FBQzFGRixPQUFPLENBQUNFLEtBQUssR0FBR0osU0FBUyxDQUFDSSxLQUFLO0lBQ2pDO0lBQ0FGLFFBQVFHLE9BQU8sQ0FBQyxTQUFVQyxHQUFHO1FBQzNCLElBQUlBLEtBQUs7WUFDUEMsT0FBT0MsSUFBSSxDQUFDRixLQUFLRCxPQUFPLENBQUMsU0FBVUksR0FBRztnQkFDcEMsSUFBSUMsTUFBTUosR0FBRyxDQUFDRyxJQUFJO2dCQUNsQixJQUFJQyxRQUFRQyxXQUFXO29CQUNyQmIsS0FBSyxDQUFDVyxJQUFJLEdBQUdDO2dCQUNmO1lBQ0Y7UUFDRjtJQUNGO0lBQ0EsT0FBT1o7QUFDVDtBQUNlLFNBQVNjOztJQUN0QixJQUFJQyxhQUFhYixVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS1csWUFBWVgsU0FBUyxDQUFDLEVBQUUsR0FBRyxDQUFDO0lBQ3RGLElBQUljLHdCQUF3QkQsV0FBV0UsWUFBWSxFQUNqREEsZUFBZUQsMEJBQTBCLEtBQUssSUFBSXJCLHNCQUFzQnFCLHVCQUN4RUUsU0FBU0gsV0FBV0csTUFBTSxF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RixPQUFPO3dCQUNoQztnQkFDSjtZQUNGO1lBRUEsd0RBQXdEO1lBQ3hELCtFQUErRTtZQUMvRSxrRUFBa0U7WUFDbEUsMENBQTBDO1lBQzFDLElBQUlJO1lBQ0osSUFBSUM7WUFFSix3REFBd0Q7WUFDeEQsc0JBQXNCO1lBQ3RCLGNBQWM7WUFDZCxzQkFBc0I7WUFDdEIsZ0VBQWdFO1lBQ2hFZixhQUFhLFNBQVVnQixRQUFRO2dCQUM3QixJQUFJRixpQkFBaUJFLFlBQVksQ0FBQ0QsY0FBYztvQkFDOUNELGVBQWVFO29CQUNmRCxlQUFlQyxTQUFTQyxNQUFNLENBQUMsU0FBVUosSUFBSTt3QkFDM0MsT0FBTyxDQUFDZCxVQUFVbUIsUUFBUSxDQUFDTDtvQkFDN0I7Z0JBQ0Y7Z0JBQ0EsT0FBT0U7WUFDVDtRQUNGO0lBQ0YsR0FBRztRQUFDaEI7S0FBVTtJQUVkLDJEQUEyRDtJQUMzRCxPQUFPO1FBQUNRO1FBQUtiO0tBQWM7QUFDN0I7R0F6SHdCcEI7O1FBa0NYcEIsNkNBQVFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yYy1ub3RpZmljYXRpb24vZXMvaG9va3MvdXNlTm90aWZpY2F0aW9uLmpzP2ZjNWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF90b0NvbnN1bWFibGVBcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Db25zdW1hYmxlQXJyYXlcIjtcbmltcG9ydCBfc2xpY2VkVG9BcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheVwiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbnZhciBfZXhjbHVkZWQgPSBbXCJnZXRDb250YWluZXJcIiwgXCJtb3Rpb25cIiwgXCJwcmVmaXhDbHNcIiwgXCJtYXhDb3VudFwiLCBcImNsYXNzTmFtZVwiLCBcInN0eWxlXCIsIFwib25BbGxSZW1vdmVkXCIsIFwic3RhY2tcIiwgXCJyZW5kZXJOb3RpZmljYXRpb25zXCJdO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IE5vdGlmaWNhdGlvbnMgZnJvbSBcIi4uL05vdGlmaWNhdGlvbnNcIjtcbmltcG9ydCB7IHVzZUV2ZW50IH0gZnJvbSAncmMtdXRpbCc7XG52YXIgZGVmYXVsdEdldENvbnRhaW5lciA9IGZ1bmN0aW9uIGRlZmF1bHRHZXRDb250YWluZXIoKSB7XG4gIHJldHVybiBkb2N1bWVudC5ib2R5O1xufTtcbnZhciB1bmlxdWVLZXkgPSAwO1xuZnVuY3Rpb24gbWVyZ2VDb25maWcoKSB7XG4gIHZhciBjbG9uZSA9IHt9O1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgb2JqTGlzdCA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBvYmpMaXN0W19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIG9iakxpc3QuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKG9iaikge1xuICAgICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbCA9IG9ialtrZXldO1xuICAgICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjbG9uZVtrZXldID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY2xvbmU7XG59XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VOb3RpZmljYXRpb24oKSB7XG4gIHZhciByb290Q29uZmlnID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgdmFyIF9yb290Q29uZmlnJGdldENvbnRhaSA9IHJvb3RDb25maWcuZ2V0Q29udGFpbmVyLFxuICAgIGdldENvbnRhaW5lciA9IF9yb290Q29uZmlnJGdldENvbnRhaSA9PT0gdm9pZCAwID8gZGVmYXVsdEdldENvbnRhaW5lciA6IF9yb290Q29uZmlnJGdldENvbnRhaSxcbiAgICBtb3Rpb24gPSByb290Q29uZmlnLm1vdGlvbixcbiAgICBwcmVmaXhDbHMgPSByb290Q29uZmlnLnByZWZpeENscyxcbiAgICBtYXhDb3VudCA9IHJvb3RDb25maWcubWF4Q291bnQsXG4gICAgY2xhc3NOYW1lID0gcm9vdENvbmZpZy5jbGFzc05hbWUsXG4gICAgc3R5bGUgPSByb290Q29uZmlnLnN0eWxlLFxuICAgIG9uQWxsUmVtb3ZlZCA9IHJvb3RDb25maWcub25BbGxSZW1vdmVkLFxuICAgIHN0YWNrID0gcm9vdENvbmZpZy5zdGFjayxcbiAgICByZW5kZXJOb3RpZmljYXRpb25zID0gcm9vdENvbmZpZy5yZW5kZXJOb3RpZmljYXRpb25zLFxuICAgIHNoYXJlQ29uZmlnID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHJvb3RDb25maWcsIF9leGNsdWRlZCk7XG4gIHZhciBfUmVhY3QkdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZSgpLFxuICAgIF9SZWFjdCR1c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfUmVhY3QkdXNlU3RhdGUsIDIpLFxuICAgIGNvbnRhaW5lciA9IF9SZWFjdCR1c2VTdGF0ZTJbMF0sXG4gICAgc2V0Q29udGFpbmVyID0gX1JlYWN0JHVzZVN0YXRlMlsxXTtcbiAgdmFyIG5vdGlmaWNhdGlvbnNSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgdmFyIGNvbnRleHRIb2xkZXIgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChOb3RpZmljYXRpb25zLCB7XG4gICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgcmVmOiBub3RpZmljYXRpb25zUmVmLFxuICAgIHByZWZpeENsczogcHJlZml4Q2xzLFxuICAgIG1vdGlvbjogbW90aW9uLFxuICAgIG1heENvdW50OiBtYXhDb3VudCxcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICBzdHlsZTogc3R5bGUsXG4gICAgb25BbGxSZW1vdmVkOiBvbkFsbFJlbW92ZWQsXG4gICAgc3RhY2s6IHN0YWNrLFxuICAgIHJlbmRlck5vdGlmaWNhdGlvbnM6IHJlbmRlck5vdGlmaWNhdGlvbnNcbiAgfSk7XG4gIHZhciBfUmVhY3QkdXNlU3RhdGUzID0gUmVhY3QudXNlU3RhdGUoW10pLFxuICAgIF9SZWFjdCR1c2VTdGF0ZTQgPSBfc2xpY2VkVG9BcnJheShfUmVhY3QkdXNlU3RhdGUzLCAyKSxcbiAgICB0YXNrUXVldWUgPSBfUmVhY3QkdXNlU3RhdGU0WzBdLFxuICAgIHNldFRhc2tRdWV1ZSA9IF9SZWFjdCR1c2VTdGF0ZTRbMV07XG4gIHZhciBvcGVuID0gdXNlRXZlbnQoZnVuY3Rpb24gKGNvbmZpZykge1xuICAgIHZhciBtZXJnZWRDb25maWcgPSBtZXJnZUNvbmZpZyhzaGFyZUNvbmZpZywgY29uZmlnKTtcbiAgICBpZiAobWVyZ2VkQ29uZmlnLmtleSA9PT0gbnVsbCB8fCBtZXJnZWRDb25maWcua2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG1lcmdlZENvbmZpZy5rZXkgPSBcInJjLW5vdGlmaWNhdGlvbi1cIi5jb25jYXQodW5pcXVlS2V5KTtcbiAgICAgIHVuaXF1ZUtleSArPSAxO1xuICAgIH1cbiAgICBzZXRUYXNrUXVldWUoZnVuY3Rpb24gKHF1ZXVlKSB7XG4gICAgICByZXR1cm4gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShxdWV1ZSksIFt7XG4gICAgICAgIHR5cGU6ICdvcGVuJyxcbiAgICAgICAgY29uZmlnOiBtZXJnZWRDb25maWdcbiAgICAgIH1dKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PSBSZWZzID09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgdmFyIGFwaSA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvcGVuOiBvcGVuLFxuICAgICAgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKGtleSkge1xuICAgICAgICBzZXRUYXNrUXVldWUoZnVuY3Rpb24gKHF1ZXVlKSB7XG4gICAgICAgICAgcmV0dXJuIFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkocXVldWUpLCBbe1xuICAgICAgICAgICAgdHlwZTogJ2Nsb3NlJyxcbiAgICAgICAgICAgIGtleToga2V5XG4gICAgICAgICAgfV0pO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBzZXRUYXNrUXVldWUoZnVuY3Rpb24gKHF1ZXVlKSB7XG4gICAgICAgICAgcmV0dXJuIFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkocXVldWUpLCBbe1xuICAgICAgICAgICAgdHlwZTogJ2Rlc3Ryb3knXG4gICAgICAgICAgfV0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT0gQ29udGFpbmVyID09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gUmVhY3QgMTggc2hvdWxkIGFsbCBpbiBlZmZlY3QgdGhhdCB3ZSB3aWxsIGNoZWNrIGNvbnRhaW5lciBpbiBlYWNoIHJlbmRlclxuICAvLyBXaGljaCBtZWFucyBnZXRDb250YWluZXIgc2hvdWxkIGJlIHN0YWJsZS5cbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBzZXRDb250YWluZXIoZ2V0Q29udGFpbmVyKCkpO1xuICB9KTtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT0gRWZmZWN0ID09PT09PT09PT09PT09PT09PT09PT09PVxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIC8vIEZsdXNoIHRhc2sgd2hlbiBub2RlIHJlYWR5XG4gICAgaWYgKG5vdGlmaWNhdGlvbnNSZWYuY3VycmVudCAmJiB0YXNrUXVldWUubGVuZ3RoKSB7XG4gICAgICB0YXNrUXVldWUuZm9yRWFjaChmdW5jdGlvbiAodGFzaykge1xuICAgICAgICBzd2l0Y2ggKHRhc2sudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ29wZW4nOlxuICAgICAgICAgICAgbm90aWZpY2F0aW9uc1JlZi5jdXJyZW50Lm9wZW4odGFzay5jb25maWcpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnY2xvc2UnOlxuICAgICAgICAgICAgbm90aWZpY2F0aW9uc1JlZi5jdXJyZW50LmNsb3NlKHRhc2sua2V5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2Rlc3Ryb3knOlxuICAgICAgICAgICAgbm90aWZpY2F0aW9uc1JlZi5jdXJyZW50LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FudC1kZXNpZ24vYW50LWRlc2lnbi9pc3N1ZXMvNTI1OTBcbiAgICAgIC8vIFJlYWN0IGBzdGFydFRyYW5zaXRpb25gIHdpbGwgcnVuIG9uY2UgYHVzZUVmZmVjdGAgYnV0IG1hbnkgdGltZXMgYHNldFN0YXRlYCxcbiAgICAgIC8vIFNvIGBzZXRUYXNrUXVldWVgIHdpdGggZmlsdGVyZWQgYXJyYXkgd2lsbCBjYXVzZSBpbmZpbml0ZSBsb29wLlxuICAgICAgLy8gV2UgY2FjaGUgdGhlIGZpcnN0IG1hdGNoIHF1ZXVlIGluc3RlYWQuXG4gICAgICB2YXIgb3JpVGFza1F1ZXVlO1xuICAgICAgdmFyIHRndFRhc2tRdWV1ZTtcblxuICAgICAgLy8gUmVhY3QgMTcgd2lsbCBtaXggb3JkZXIgb2YgZWZmZWN0ICYgc2V0U3RhdGUgaW4gYXN5bmNcbiAgICAgIC8vIC0gb3Blbjogc2V0U3RhdGVbMF1cbiAgICAgIC8vIC0gZWZmZWN0WzBdXG4gICAgICAvLyAtIG9wZW46IHNldFN0YXRlWzFdXG4gICAgICAvLyAtIGVmZmVjdCBzZXRTdGF0ZShbXSkgKiBoZXJlIHdpbGwgY2xlYW4gdXAgWzAsIDFdIGluIFJlYWN0IDE3XG4gICAgICBzZXRUYXNrUXVldWUoZnVuY3Rpb24gKG9yaVF1ZXVlKSB7XG4gICAgICAgIGlmIChvcmlUYXNrUXVldWUgIT09IG9yaVF1ZXVlIHx8ICF0Z3RUYXNrUXVldWUpIHtcbiAgICAgICAgICBvcmlUYXNrUXVldWUgPSBvcmlRdWV1ZTtcbiAgICAgICAgICB0Z3RUYXNrUXVldWUgPSBvcmlRdWV1ZS5maWx0ZXIoZnVuY3Rpb24gKHRhc2spIHtcbiAgICAgICAgICAgIHJldHVybiAhdGFza1F1ZXVlLmluY2x1ZGVzKHRhc2spO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0Z3RUYXNrUXVldWU7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFt0YXNrUXVldWVdKTtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT0gUmV0dXJuID09PT09PT09PT09PT09PT09PT09PT09PVxuICByZXR1cm4gW2FwaSwgY29udGV4dEhvbGRlcl07XG59Il0sIm5hbWVzIjpbIl90b0NvbnN1bWFibGVBcnJheSIsIl9zbGljZWRUb0FycmF5IiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwiX2V4Y2x1ZGVkIiwiUmVhY3QiLCJOb3RpZmljYXRpb25zIiwidXNlRXZlbnQiLCJkZWZhdWx0R2V0Q29udGFpbmVyIiwiZG9jdW1lbnQiLCJib2R5IiwidW5pcXVlS2V5IiwibWVyZ2VDb25maWciLCJjbG9uZSIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJvYmpMaXN0IiwiQXJyYXkiLCJfa2V5IiwiZm9yRWFjaCIsIm9iaiIsIk9iamVjdCIsImtleXMiLCJrZXkiLCJ2YWwiLCJ1bmRlZmluZWQiLCJ1c2VOb3RpZmljYXRpb24iLCJyb290Q29uZmlnIiwiX3Jvb3RDb25maWckZ2V0Q29udGFpIiwiZ2V0Q29udGFpbmVyIiwibW90aW9uIiwicHJlZml4Q2xzIiwibWF4Q291bnQiLCJjbGFzc05hbWUiLCJzdHlsZSIsIm9uQWxsUmVtb3ZlZCIsInN0YWNrIiwicmVuZGVyTm90aWZpY2F0aW9ucyIsInNoYXJlQ29uZmlnIiwiX1JlYWN0JHVzZVN0YXRlIiwidXNlU3RhdGUiLCJfUmVhY3QkdXNlU3RhdGUyIiwiY29udGFpbmVyIiwic2V0Q29udGFpbmVyIiwibm90aWZpY2F0aW9uc1JlZiIsInVzZVJlZiIsImNvbnRleHRIb2xkZXIiLCJjcmVhdGVFbGVtZW50IiwicmVmIiwiX1JlYWN0JHVzZVN0YXRlMyIsIl9SZWFjdCR1c2VTdGF0ZTQiLCJ0YXNrUXVldWUiLCJzZXRUYXNrUXVldWUiLCJvcGVuIiwiY29uZmlnIiwibWVyZ2VkQ29uZmlnIiwiY29uY2F0IiwicXVldWUiLCJ0eXBlIiwiYXBpIiwidXNlTWVtbyIsImNsb3NlIiwiZGVzdHJveSIsInVzZUVmZmVjdCIsImN1cnJlbnQiLCJ0YXNrIiwib3JpVGFza1F1ZXVlIiwidGd0VGFza1F1ZXVlIiwib3JpUXVldWUiLCJmaWx0ZXIiLCJpbmNsdWRlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/rc-notification/es/hooks/useNotification.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/rc-notification/es/hooks/useStack.js":
/*!***********************************************************!*\
  !*** ./node_modules/rc-notification/es/hooks/useStack.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/typeof */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/typeof.js\");\n\nvar DEFAULT_OFFSET = 8;\nvar DEFAULT_THRESHOLD = 3;\nvar DEFAULT_GAP = 16;\nvar useStack = function useStack(config) {\n    var result = {\n        offset: DEFAULT_OFFSET,\n        threshold: DEFAULT_THRESHOLD,\n        gap: DEFAULT_GAP\n    };\n    if (config && (0,_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(config) === \"object\") {\n        var _config$offset, _config$threshold, _config$gap;\n        result.offset = (_config$offset = config.offset) !== null && _config$offset !== void 0 ? _config$offset : DEFAULT_OFFSET;\n        result.threshold = (_config$threshold = config.threshold) !== null && _config$threshold !== void 0 ? _config$threshold : DEFAULT_THRESHOLD;\n        result.gap = (_config$gap = config.gap) !== null && _config$gap !== void 0 ? _config$gap : DEFAULT_GAP;\n    }\n    return [\n        !!config,\n        result\n    ];\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (useStack);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yYy1ub3RpZmljYXRpb24vZXMvaG9va3MvdXNlU3RhY2suanMiLCJtYXBwaW5ncyI6Ijs7QUFBd0Q7QUFDeEQsSUFBSUMsaUJBQWlCO0FBQ3JCLElBQUlDLG9CQUFvQjtBQUN4QixJQUFJQyxjQUFjO0FBQ2xCLElBQUlDLFdBQVcsU0FBU0EsU0FBU0MsTUFBTTtJQUNyQyxJQUFJQyxTQUFTO1FBQ1hDLFFBQVFOO1FBQ1JPLFdBQVdOO1FBQ1hPLEtBQUtOO0lBQ1A7SUFDQSxJQUFJRSxVQUFVTCw2RUFBT0EsQ0FBQ0ssWUFBWSxVQUFVO1FBQzFDLElBQUlLLGdCQUFnQkMsbUJBQW1CQztRQUN2Q04sT0FBT0MsTUFBTSxHQUFHLENBQUNHLGlCQUFpQkwsT0FBT0UsTUFBTSxNQUFNLFFBQVFHLG1CQUFtQixLQUFLLElBQUlBLGlCQUFpQlQ7UUFDMUdLLE9BQU9FLFNBQVMsR0FBRyxDQUFDRyxvQkFBb0JOLE9BQU9HLFNBQVMsTUFBTSxRQUFRRyxzQkFBc0IsS0FBSyxJQUFJQSxvQkFBb0JUO1FBQ3pISSxPQUFPRyxHQUFHLEdBQUcsQ0FBQ0csY0FBY1AsT0FBT0ksR0FBRyxNQUFNLFFBQVFHLGdCQUFnQixLQUFLLElBQUlBLGNBQWNUO0lBQzdGO0lBQ0EsT0FBTztRQUFDLENBQUMsQ0FBQ0U7UUFBUUM7S0FBTztBQUMzQjtBQUNBLCtEQUFlRixRQUFRQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yYy1ub3RpZmljYXRpb24vZXMvaG9va3MvdXNlU3RhY2suanM/MzY0OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX3R5cGVvZiBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdHlwZW9mXCI7XG52YXIgREVGQVVMVF9PRkZTRVQgPSA4O1xudmFyIERFRkFVTFRfVEhSRVNIT0xEID0gMztcbnZhciBERUZBVUxUX0dBUCA9IDE2O1xudmFyIHVzZVN0YWNrID0gZnVuY3Rpb24gdXNlU3RhY2soY29uZmlnKSB7XG4gIHZhciByZXN1bHQgPSB7XG4gICAgb2Zmc2V0OiBERUZBVUxUX09GRlNFVCxcbiAgICB0aHJlc2hvbGQ6IERFRkFVTFRfVEhSRVNIT0xELFxuICAgIGdhcDogREVGQVVMVF9HQVBcbiAgfTtcbiAgaWYgKGNvbmZpZyAmJiBfdHlwZW9mKGNvbmZpZykgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIF9jb25maWckb2Zmc2V0LCBfY29uZmlnJHRocmVzaG9sZCwgX2NvbmZpZyRnYXA7XG4gICAgcmVzdWx0Lm9mZnNldCA9IChfY29uZmlnJG9mZnNldCA9IGNvbmZpZy5vZmZzZXQpICE9PSBudWxsICYmIF9jb25maWckb2Zmc2V0ICE9PSB2b2lkIDAgPyBfY29uZmlnJG9mZnNldCA6IERFRkFVTFRfT0ZGU0VUO1xuICAgIHJlc3VsdC50aHJlc2hvbGQgPSAoX2NvbmZpZyR0aHJlc2hvbGQgPSBjb25maWcudGhyZXNob2xkKSAhPT0gbnVsbCAmJiBfY29uZmlnJHRocmVzaG9sZCAhPT0gdm9pZCAwID8gX2NvbmZpZyR0aHJlc2hvbGQgOiBERUZBVUxUX1RIUkVTSE9MRDtcbiAgICByZXN1bHQuZ2FwID0gKF9jb25maWckZ2FwID0gY29uZmlnLmdhcCkgIT09IG51bGwgJiYgX2NvbmZpZyRnYXAgIT09IHZvaWQgMCA/IF9jb25maWckZ2FwIDogREVGQVVMVF9HQVA7XG4gIH1cbiAgcmV0dXJuIFshIWNvbmZpZywgcmVzdWx0XTtcbn07XG5leHBvcnQgZGVmYXVsdCB1c2VTdGFjazsiXSwibmFtZXMiOlsiX3R5cGVvZiIsIkRFRkFVTFRfT0ZGU0VUIiwiREVGQVVMVF9USFJFU0hPTEQiLCJERUZBVUxUX0dBUCIsInVzZVN0YWNrIiwiY29uZmlnIiwicmVzdWx0Iiwib2Zmc2V0IiwidGhyZXNob2xkIiwiZ2FwIiwiX2NvbmZpZyRvZmZzZXQiLCJfY29uZmlnJHRocmVzaG9sZCIsIl9jb25maWckZ2FwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/rc-notification/es/hooks/useStack.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/rc-notification/es/index.js":
/*!**************************************************!*\
  !*** ./node_modules/rc-notification/es/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Notice: function() { return /* reexport safe */ _Notice__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; },\n/* harmony export */   NotificationProvider: function() { return /* reexport safe */ _NotificationProvider__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; },\n/* harmony export */   useNotification: function() { return /* reexport safe */ _hooks_useNotification__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; }\n/* harmony export */ });\n/* harmony import */ var _hooks_useNotification__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hooks/useNotification */ \"(app-pages-browser)/./node_modules/rc-notification/es/hooks/useNotification.js\");\n/* harmony import */ var _Notice__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Notice */ \"(app-pages-browser)/./node_modules/rc-notification/es/Notice.js\");\n/* harmony import */ var _NotificationProvider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./NotificationProvider */ \"(app-pages-browser)/./node_modules/rc-notification/es/NotificationProvider.js\");\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yYy1ub3RpZmljYXRpb24vZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXNEO0FBQ3hCO0FBQzRCO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JjLW5vdGlmaWNhdGlvbi9lcy9pbmRleC5qcz9hMWI3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB1c2VOb3RpZmljYXRpb24gZnJvbSBcIi4vaG9va3MvdXNlTm90aWZpY2F0aW9uXCI7XG5pbXBvcnQgTm90aWNlIGZyb20gXCIuL05vdGljZVwiO1xuaW1wb3J0IE5vdGlmaWNhdGlvblByb3ZpZGVyIGZyb20gXCIuL05vdGlmaWNhdGlvblByb3ZpZGVyXCI7XG5leHBvcnQgeyB1c2VOb3RpZmljYXRpb24sIE5vdGljZSwgTm90aWZpY2F0aW9uUHJvdmlkZXIgfTsiXSwibmFtZXMiOlsidXNlTm90aWZpY2F0aW9uIiwiTm90aWNlIiwiTm90aWZpY2F0aW9uUHJvdmlkZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/rc-notification/es/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/flight/[flightId]/page.tsx":
/*!********************************************!*\
  !*** ./src/app/flight/[flightId]/page.tsx ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ FlightPage; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _barrel_optimize_names_Card_Col_Result_Row_Spin_Tabs_message_antd__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! __barrel_optimize__?names=Card,Col,Result,Row,Spin,Tabs,message!=!antd */ \"(app-pages-browser)/./node_modules/antd/es/message/index.js\");\n/* harmony import */ var _barrel_optimize_names_Card_Col_Result_Row_Spin_Tabs_message_antd__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! __barrel_optimize__?names=Card,Col,Result,Row,Spin,Tabs,message!=!antd */ \"(app-pages-browser)/./node_modules/antd/es/spin/index.js\");\n/* harmony import */ var _barrel_optimize_names_Card_Col_Result_Row_Spin_Tabs_message_antd__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! __barrel_optimize__?names=Card,Col,Result,Row,Spin,Tabs,message!=!antd */ \"(app-pages-browser)/./node_modules/antd/es/result/index.js\");\n/* harmony import */ var _barrel_optimize_names_Card_Col_Result_Row_Spin_Tabs_message_antd__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! __barrel_optimize__?names=Card,Col,Result,Row,Spin,Tabs,message!=!antd */ \"(app-pages-browser)/./node_modules/antd/es/row/index.js\");\n/* harmony import */ var _barrel_optimize_names_Card_Col_Result_Row_Spin_Tabs_message_antd__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! __barrel_optimize__?names=Card,Col,Result,Row,Spin,Tabs,message!=!antd */ \"(app-pages-browser)/./node_modules/antd/es/col/index.js\");\n/* harmony import */ var _barrel_optimize_names_Card_Col_Result_Row_Spin_Tabs_message_antd__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! __barrel_optimize__?names=Card,Col,Result,Row,Spin,Tabs,message!=!antd */ \"(app-pages-browser)/./node_modules/antd/es/card/index.js\");\n/* harmony import */ var _barrel_optimize_names_Card_Col_Result_Row_Spin_Tabs_message_antd__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! __barrel_optimize__?names=Card,Col,Result,Row,Spin,Tabs,message!=!antd */ \"(app-pages-browser)/./node_modules/antd/es/tabs/index.js\");\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var _barrel_optimize_names_BlockOutlined_LineChartOutlined_RocketOutlined_ant_design_icons__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! __barrel_optimize__?names=BlockOutlined,LineChartOutlined,RocketOutlined!=!@ant-design/icons */ \"(app-pages-browser)/./node_modules/@ant-design/icons/es/icons/RocketOutlined.js\");\n/* harmony import */ var _barrel_optimize_names_BlockOutlined_LineChartOutlined_RocketOutlined_ant_design_icons__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! __barrel_optimize__?names=BlockOutlined,LineChartOutlined,RocketOutlined!=!@ant-design/icons */ \"(app-pages-browser)/./node_modules/@ant-design/icons/es/icons/BlockOutlined.js\");\n/* harmony import */ var _barrel_optimize_names_BlockOutlined_LineChartOutlined_RocketOutlined_ant_design_icons__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! __barrel_optimize__?names=BlockOutlined,LineChartOutlined,RocketOutlined!=!@ant-design/icons */ \"(app-pages-browser)/./node_modules/@ant-design/icons/es/icons/LineChartOutlined.js\");\n/* harmony import */ var _components_FlightSummary__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/FlightSummary */ \"(app-pages-browser)/./src/components/FlightSummary.tsx\");\n/* harmony import */ var _components_AircraftMetadata__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/components/AircraftMetadata */ \"(app-pages-browser)/./src/components/AircraftMetadata.tsx\");\n/* harmony import */ var _components_DelaySummary__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/components/DelaySummary */ \"(app-pages-browser)/./src/components/DelaySummary.tsx\");\n/* harmony import */ var _components_EventTimeline__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/components/EventTimeline */ \"(app-pages-browser)/./src/components/EventTimeline.tsx\");\n/* harmony import */ var _components_BlockchainLog__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/components/BlockchainLog */ \"(app-pages-browser)/./src/components/BlockchainLog.tsx\");\n/* harmony import */ var _components_HistoricalBaseline__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @/components/HistoricalBaseline */ \"(app-pages-browser)/./src/components/HistoricalBaseline.tsx\");\n/* harmony import */ var _services_api__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @/services/api */ \"(app-pages-browser)/./src/services/api.ts\");\n/* harmony import */ var _services_web3__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @/services/web3 */ \"(app-pages-browser)/./src/services/web3.ts\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n\n\n\n\nfunction FlightPage() {\n    var _flight_blockchainEvents_, _flight_blockchainEvents;\n    _s();\n    const { flightId } = (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.useParams)();\n    const [flight, setFlight] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [recording, setRecording] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [metamaskModalVisible, setMetamaskModalVisible] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [pendingTransactions, setPendingTransactions] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (flightId) {\n            loadFlightData(flightId);\n        }\n    }, [\n        flightId\n    ]);\n    const loadFlightData = async (id)=>{\n        try {\n            setLoading(true);\n            const data = await (0,_services_api__WEBPACK_IMPORTED_MODULE_9__.fetchFlightData)(id);\n            setFlight(data);\n            setError(null);\n        } catch (err) {\n            setError(err.message || \"Failed to load flight data\");\n        } finally{\n            setLoading(false);\n        }\n    };\n    const handleRecordOnBlockchain = async ()=>{\n        if (!flight || !flight.events || flight.events.length === 0) {\n            _barrel_optimize_names_Card_Col_Result_Row_Spin_Tabs_message_antd__WEBPACK_IMPORTED_MODULE_11__[\"default\"].warning(\"No events to record\");\n            return;\n        }\n        // Check MetaMask\n        if (!(0,_services_web3__WEBPACK_IMPORTED_MODULE_10__.isMetaMaskInstalled)()) {\n            _barrel_optimize_names_Card_Col_Result_Row_Spin_Tabs_message_antd__WEBPACK_IMPORTED_MODULE_11__[\"default\"].error(\"MetaMask is not installed. Please install MetaMask to record events on blockchain.\");\n            return;\n        }\n        try {\n            await (0,_services_web3__WEBPACK_IMPORTED_MODULE_10__.connectMetaMask)();\n        } catch (error) {\n            _barrel_optimize_names_Card_Col_Result_Row_Spin_Tabs_message_antd__WEBPACK_IMPORTED_MODULE_11__[\"default\"].error(\"MetaMask connection failed: \".concat(error.message));\n            return;\n        }\n        // Find events that need to be recorded\n        const eventsNeedingTx = flight.events.filter((e)=>{\n            var _e_blockchain;\n            return !((_e_blockchain = e.blockchain) === null || _e_blockchain === void 0 ? void 0 : _e_blockchain.is_verified);\n        });\n        if (eventsNeedingTx.length === 0) {\n            _barrel_optimize_names_Card_Col_Result_Row_Spin_Tabs_message_antd__WEBPACK_IMPORTED_MODULE_11__[\"default\"].success(\"All events are already recorded on blockchain\");\n            return;\n        }\n        setRecording(true);\n        _barrel_optimize_names_Card_Col_Result_Row_Spin_Tabs_message_antd__WEBPACK_IMPORTED_MODULE_11__[\"default\"].info(\"Preparing \".concat(eventsNeedingTx.length, \" transaction(s)...\"));\n        try {\n            const contractAddress = await (0,_services_api__WEBPACK_IMPORTED_MODULE_9__.getContractAddress)();\n            if (!contractAddress) {\n                _barrel_optimize_names_Card_Col_Result_Row_Spin_Tabs_message_antd__WEBPACK_IMPORTED_MODULE_11__[\"default\"].error(\"Contract address not configured\");\n                setRecording(false);\n                return;\n            }\n            // Prepare transactions\n            const transactions = [];\n            for (const event of eventsNeedingTx){\n                try {\n                    const preparedTx = await (0,_services_api__WEBPACK_IMPORTED_MODULE_9__.prepareTransaction)(event.id);\n                    transactions.push({\n                        event,\n                        transaction: preparedTx\n                    });\n                } catch (error) {\n                    console.error(\"Failed to prepare transaction for \".concat(event.event_type, \":\"), error);\n                }\n            }\n            if (transactions.length > 0) {\n                setPendingTransactions(transactions);\n                setMetamaskModalVisible(true);\n            } else {\n                _barrel_optimize_names_Card_Col_Result_Row_Spin_Tabs_message_antd__WEBPACK_IMPORTED_MODULE_11__[\"default\"].error(\"Failed to prepare transactions\");\n            }\n        } catch (error) {\n            _barrel_optimize_names_Card_Col_Result_Row_Spin_Tabs_message_antd__WEBPACK_IMPORTED_MODULE_11__[\"default\"].error(\"Error: \".concat(error.message));\n        } finally{\n            setRecording(false);\n        }\n    };\n    const handleApproveTransactions = async ()=>{\n        if (pendingTransactions.length === 0) return;\n        setMetamaskModalVisible(false);\n        setRecording(true);\n        _barrel_optimize_names_Card_Col_Result_Row_Spin_Tabs_message_antd__WEBPACK_IMPORTED_MODULE_11__[\"default\"].info(\"Processing \".concat(pendingTransactions.length, \" transaction(s) via MetaMask...\"));\n        let successCount = 0;\n        for(let i = 0; i < pendingTransactions.length; i++){\n            const { event, transaction } = pendingTransactions[i];\n            try {\n                _barrel_optimize_names_Card_Col_Result_Row_Spin_Tabs_message_antd__WEBPACK_IMPORTED_MODULE_11__[\"default\"].info(\"Approving transaction \".concat(i + 1, \"/\").concat(pendingTransactions.length, \"...\"));\n                const receipt = await (0,_services_web3__WEBPACK_IMPORTED_MODULE_10__.sendPreparedTransaction)(transaction);\n                // Confirm transaction in backend\n                await (0,_services_api__WEBPACK_IMPORTED_MODULE_9__.confirmTransaction)(event.id, receipt.hash, Number(receipt.blockNumber));\n                successCount++;\n                _barrel_optimize_names_Card_Col_Result_Row_Spin_Tabs_message_antd__WEBPACK_IMPORTED_MODULE_11__[\"default\"].success(\"Transaction \".concat(i + 1, \" confirmed!\"));\n            } catch (error) {\n                if (error.code === 4001) {\n                    _barrel_optimize_names_Card_Col_Result_Row_Spin_Tabs_message_antd__WEBPACK_IMPORTED_MODULE_11__[\"default\"].warning(\"Transaction rejected by user\");\n                    break;\n                } else {\n                    _barrel_optimize_names_Card_Col_Result_Row_Spin_Tabs_message_antd__WEBPACK_IMPORTED_MODULE_11__[\"default\"].error(\"Transaction \".concat(i + 1, \" failed: \").concat(error.message));\n                }\n            }\n        }\n        if (successCount > 0) {\n            _barrel_optimize_names_Card_Col_Result_Row_Spin_Tabs_message_antd__WEBPACK_IMPORTED_MODULE_11__[\"default\"].success(\"Successfully recorded \".concat(successCount, \" event(s) on blockchain!\"));\n            // Reload flight data\n            await loadFlightData(flightId);\n        }\n        setRecording(false);\n        setPendingTransactions([]);\n    };\n    if (loading) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            style: {\n                display: \"flex\",\n                justifyContent: \"center\",\n                alignItems: \"center\",\n                minHeight: \"60vh\"\n            },\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Card_Col_Result_Row_Spin_Tabs_message_antd__WEBPACK_IMPORTED_MODULE_12__[\"default\"], {\n                size: \"large\",\n                tip: \"Locating flight on blockchain...\"\n            }, void 0, false, {\n                fileName: \"/Users/parthgohil/Documents/Coding Projects/FlightChain/frontend/src/app/flight/[flightId]/page.tsx\",\n                lineNumber: 153,\n                columnNumber: 17\n            }, this)\n        }, void 0, false, {\n            fileName: \"/Users/parthgohil/Documents/Coding Projects/FlightChain/frontend/src/app/flight/[flightId]/page.tsx\",\n            lineNumber: 152,\n            columnNumber: 13\n        }, this);\n    }\n    if (error || !flight) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Card_Col_Result_Row_Spin_Tabs_message_antd__WEBPACK_IMPORTED_MODULE_13__[\"default\"], {\n            status: \"error\",\n            title: \"Flight Not Found\",\n            subTitle: error || \"We couldn't locate this flight in our system.\"\n        }, void 0, false, {\n            fileName: \"/Users/parthgohil/Documents/Coding Projects/FlightChain/frontend/src/app/flight/[flightId]/page.tsx\",\n            lineNumber: 160,\n            columnNumber: 13\n        }, this);\n    }\n    const items = [\n        {\n            key: \"1\",\n            label: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_BlockOutlined_LineChartOutlined_RocketOutlined_ant_design_icons__WEBPACK_IMPORTED_MODULE_14__[\"default\"], {}, void 0, false, {\n                        fileName: \"/Users/parthgohil/Documents/Coding Projects/FlightChain/frontend/src/app/flight/[flightId]/page.tsx\",\n                        lineNumber: 171,\n                        columnNumber: 26\n                    }, this),\n                    \" Event Timeline\"\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/parthgohil/Documents/Coding Projects/FlightChain/frontend/src/app/flight/[flightId]/page.tsx\",\n                lineNumber: 171,\n                columnNumber: 20\n            }, this),\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_EventTimeline__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n                events: flight.events\n            }, void 0, false, {\n                fileName: \"/Users/parthgohil/Documents/Coding Projects/FlightChain/frontend/src/app/flight/[flightId]/page.tsx\",\n                lineNumber: 172,\n                columnNumber: 23\n            }, this)\n        },\n        {\n            key: \"2\",\n            label: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_BlockOutlined_LineChartOutlined_RocketOutlined_ant_design_icons__WEBPACK_IMPORTED_MODULE_15__[\"default\"], {}, void 0, false, {\n                        fileName: \"/Users/parthgohil/Documents/Coding Projects/FlightChain/frontend/src/app/flight/[flightId]/page.tsx\",\n                        lineNumber: 176,\n                        columnNumber: 26\n                    }, this),\n                    \" Blockchain Log\"\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/parthgohil/Documents/Coding Projects/FlightChain/frontend/src/app/flight/[flightId]/page.tsx\",\n                lineNumber: 176,\n                columnNumber: 20\n            }, this),\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_BlockchainLog__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n                events: flight.blockchainEvents\n            }, void 0, false, {\n                fileName: \"/Users/parthgohil/Documents/Coding Projects/FlightChain/frontend/src/app/flight/[flightId]/page.tsx\",\n                lineNumber: 177,\n                columnNumber: 23\n            }, this)\n        },\n        {\n            key: \"3\",\n            label: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_BlockOutlined_LineChartOutlined_RocketOutlined_ant_design_icons__WEBPACK_IMPORTED_MODULE_16__[\"default\"], {}, void 0, false, {\n                        fileName: \"/Users/parthgohil/Documents/Coding Projects/FlightChain/frontend/src/app/flight/[flightId]/page.tsx\",\n                        lineNumber: 181,\n                        columnNumber: 26\n                    }, this),\n                    \" Historical Baseline\"\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/parthgohil/Documents/Coding Projects/FlightChain/frontend/src/app/flight/[flightId]/page.tsx\",\n                lineNumber: 181,\n                columnNumber: 20\n            }, this),\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_HistoricalBaseline__WEBPACK_IMPORTED_MODULE_8__[\"default\"], {\n                flight: flight\n            }, void 0, false, {\n                fileName: \"/Users/parthgohil/Documents/Coding Projects/FlightChain/frontend/src/app/flight/[flightId]/page.tsx\",\n                lineNumber: 182,\n                columnNumber: 23\n            }, this)\n        }\n    ];\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flight-page\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_FlightSummary__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                flight: flight\n            }, void 0, false, {\n                fileName: \"/Users/parthgohil/Documents/Coding Projects/FlightChain/frontend/src/app/flight/[flightId]/page.tsx\",\n                lineNumber: 188,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Card_Col_Result_Row_Spin_Tabs_message_antd__WEBPACK_IMPORTED_MODULE_17__[\"default\"], {\n                gutter: [\n                    24,\n                    24\n                ],\n                style: {\n                    marginBottom: 24\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Card_Col_Result_Row_Spin_Tabs_message_antd__WEBPACK_IMPORTED_MODULE_18__[\"default\"], {\n                        xs: 24,\n                        md: 12,\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_AircraftMetadata__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                            aircraft: flight.aircraft\n                        }, void 0, false, {\n                            fileName: \"/Users/parthgohil/Documents/Coding Projects/FlightChain/frontend/src/app/flight/[flightId]/page.tsx\",\n                            lineNumber: 192,\n                            columnNumber: 21\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/Users/parthgohil/Documents/Coding Projects/FlightChain/frontend/src/app/flight/[flightId]/page.tsx\",\n                        lineNumber: 191,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Card_Col_Result_Row_Spin_Tabs_message_antd__WEBPACK_IMPORTED_MODULE_18__[\"default\"], {\n                        xs: 24,\n                        md: 12,\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_DelaySummary__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                            delayAnalysis: flight.delayAnalysis\n                        }, void 0, false, {\n                            fileName: \"/Users/parthgohil/Documents/Coding Projects/FlightChain/frontend/src/app/flight/[flightId]/page.tsx\",\n                            lineNumber: 195,\n                            columnNumber: 21\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/Users/parthgohil/Documents/Coding Projects/FlightChain/frontend/src/app/flight/[flightId]/page.tsx\",\n                        lineNumber: 194,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/parthgohil/Documents/Coding Projects/FlightChain/frontend/src/app/flight/[flightId]/page.tsx\",\n                lineNumber: 190,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Card_Col_Result_Row_Spin_Tabs_message_antd__WEBPACK_IMPORTED_MODULE_19__[\"default\"], {\n                style: {\n                    borderRadius: 8\n                },\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Card_Col_Result_Row_Spin_Tabs_message_antd__WEBPACK_IMPORTED_MODULE_20__[\"default\"], {\n                    defaultActiveKey: \"1\",\n                    items: items\n                }, void 0, false, {\n                    fileName: \"/Users/parthgohil/Documents/Coding Projects/FlightChain/frontend/src/app/flight/[flightId]/page.tsx\",\n                    lineNumber: 200,\n                    columnNumber: 17\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/parthgohil/Documents/Coding Projects/FlightChain/frontend/src/app/flight/[flightId]/page.tsx\",\n                lineNumber: 199,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    marginTop: 24,\n                    textAlign: \"center\",\n                    color: \"#999\",\n                    fontSize: 12\n                },\n                children: [\n                    \"Blockchain Contract: \",\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        style: {\n                            fontFamily: \"monospace\"\n                        },\n                        children: (_flight_blockchainEvents = flight.blockchainEvents) === null || _flight_blockchainEvents === void 0 ? void 0 : (_flight_blockchainEvents_ = _flight_blockchainEvents[0]) === null || _flight_blockchainEvents_ === void 0 ? void 0 : _flight_blockchainEvents_.contract_address\n                    }, void 0, false, {\n                        fileName: \"/Users/parthgohil/Documents/Coding Projects/FlightChain/frontend/src/app/flight/[flightId]/page.tsx\",\n                        lineNumber: 204,\n                        columnNumber: 38\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/parthgohil/Documents/Coding Projects/FlightChain/frontend/src/app/flight/[flightId]/page.tsx\",\n                lineNumber: 203,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/parthgohil/Documents/Coding Projects/FlightChain/frontend/src/app/flight/[flightId]/page.tsx\",\n        lineNumber: 187,\n        columnNumber: 9\n    }, this);\n}\n_s(FlightPage, \"lb9Sbsf0/RfWIi2K3m3SqO7WZzY=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_2__.useParams\n    ];\n});\n_c = FlightPage;\nvar _c;\n$RefreshReg$(_c, \"FlightPage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZmxpZ2h0L1tmbGlnaHRJZF0vcGFnZS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVtRDtBQUNzQztBQUM3QztBQUN5RDtBQUU5QztBQUNNO0FBQ1I7QUFDRTtBQUNBO0FBQ2M7QUFFd0M7QUFDYjtBQUdqRixTQUFTMkI7UUF5THdEQywyQkFBQUE7O0lBeEw1RSxNQUFNLEVBQUVDLFFBQVEsRUFBRSxHQUFHbkIsMERBQVNBO0lBQzlCLE1BQU0sQ0FBQ2tCLFFBQVFFLFVBQVUsR0FBRzVCLCtDQUFRQSxDQUFnQjtJQUNwRCxNQUFNLENBQUM2QixTQUFTQyxXQUFXLEdBQUc5QiwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUMrQixPQUFPQyxTQUFTLEdBQUdoQywrQ0FBUUEsQ0FBZ0I7SUFDbEQsTUFBTSxDQUFDaUMsV0FBV0MsYUFBYSxHQUFHbEMsK0NBQVFBLENBQUM7SUFDM0MsTUFBTSxDQUFDbUMsc0JBQXNCQyx3QkFBd0IsR0FBR3BDLCtDQUFRQSxDQUFDO0lBQ2pFLE1BQU0sQ0FBQ3FDLHFCQUFxQkMsdUJBQXVCLEdBQUd0QywrQ0FBUUEsQ0FBUSxFQUFFO0lBRXhFRCxnREFBU0EsQ0FBQztRQUNOLElBQUk0QixVQUFVO1lBQ1ZZLGVBQWVaO1FBQ25CO0lBQ0osR0FBRztRQUFDQTtLQUFTO0lBRWIsTUFBTVksaUJBQWlCLE9BQU9DO1FBQzFCLElBQUk7WUFDQVYsV0FBVztZQUNYLE1BQU1XLE9BQU8sTUFBTXZCLDhEQUFlQSxDQUFDc0I7WUFDbkNaLFVBQVVhO1lBQ1ZULFNBQVM7UUFDYixFQUFFLE9BQU9VLEtBQVU7WUFDZlYsU0FBU1UsSUFBSW5DLE9BQU8sSUFBSTtRQUM1QixTQUFVO1lBQ051QixXQUFXO1FBQ2Y7SUFDSjtJQUVBLE1BQU1hLDJCQUEyQjtRQUM3QixJQUFJLENBQUNqQixVQUFVLENBQUNBLE9BQU9rQixNQUFNLElBQUlsQixPQUFPa0IsTUFB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b3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2FwcC9mbGlnaHQvW2ZsaWdodElkXS9wYWdlLnRzeD9kMmI4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBUYWJzLCBDYXJkLCBTcGluLCBSZXN1bHQsIFJvdywgQ29sLCBCdXR0b24sIE1vZGFsLCBtZXNzYWdlLCBTcGFjZSB9IGZyb20gJ2FudGQnO1xuaW1wb3J0IHsgdXNlUGFyYW1zIH0gZnJvbSAnbmV4dC9uYXZpZ2F0aW9uJztcbmltcG9ydCB7IFJvY2tldE91dGxpbmVkLCBCbG9ja091dGxpbmVkLCBMaW5lQ2hhcnRPdXRsaW5lZCwgV2FsbGV0T3V0bGluZWQgfSBmcm9tICdAYW50LWRlc2lnbi9pY29ucyc7XG5cbmltcG9ydCBGbGlnaHRTdW1tYXJ5IGZyb20gJ0AvY29tcG9uZW50cy9GbGlnaHRTdW1tYXJ5JztcbmltcG9ydCBBaXJjcmFmdE1ldGFkYXRhIGZyb20gJ0AvY29tcG9uZW50cy9BaXJjcmFmdE1ldGFkYXRhJztcbmltcG9ydCBEZWxheVN1bW1hcnkgZnJvbSAnQC9jb21wb25lbnRzL0RlbGF5U3VtbWFyeSc7XG5pbXBvcnQgRXZlbnRUaW1lbGluZSBmcm9tICdAL2NvbXBvbmVudHMvRXZlbnRUaW1lbGluZSc7XG5pbXBvcnQgQmxvY2tjaGFpbkxvZyBmcm9tICdAL2NvbXBvbmVudHMvQmxvY2tjaGFpbkxvZyc7XG5pbXBvcnQgSGlzdG9yaWNhbEJhc2VsaW5lVmlldyBmcm9tICdAL2NvbXBvbmVudHMvSGlzdG9yaWNhbEJhc2VsaW5lJztcblxuaW1wb3J0IHsgZmV0Y2hGbGlnaHREYXRhLCBwcmVwYXJlVHJhbnNhY3Rpb24sIGNvbmZpcm1UcmFuc2FjdGlvbiwgZ2V0Q29udHJhY3RBZGRyZXNzIH0gZnJvbSAnQC9zZXJ2aWNlcy9hcGknO1xuaW1wb3J0IHsgaXNNZXRhTWFza0luc3RhbGxlZCwgY29ubmVjdE1ldGFNYXNrLCBzZW5kUHJlcGFyZWRUcmFuc2FjdGlvbiB9IGZyb20gJ0Avc2VydmljZXMvd2ViMyc7XG5pbXBvcnQgeyBGbGlnaHQgfSBmcm9tICdAL3R5cGVzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRmxpZ2h0UGFnZSgpIHtcbiAgICBjb25zdCB7IGZsaWdodElkIH0gPSB1c2VQYXJhbXMoKTtcbiAgICBjb25zdCBbZmxpZ2h0LCBzZXRGbGlnaHRdID0gdXNlU3RhdGU8RmxpZ2h0IHwgbnVsbD4obnVsbCk7XG4gICAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG4gICAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgICBjb25zdCBbcmVjb3JkaW5nLCBzZXRSZWNvcmRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IFttZXRhbWFza01vZGFsVmlzaWJsZSwgc2V0TWV0YW1hc2tNb2RhbFZpc2libGVdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IFtwZW5kaW5nVHJhbnNhY3Rpb25zLCBzZXRQZW5kaW5nVHJhbnNhY3Rpb25zXSA9IHVzZVN0YXRlPGFueVtdPihbXSk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZmxpZ2h0SWQpIHtcbiAgICAgICAgICAgIGxvYWRGbGlnaHREYXRhKGZsaWdodElkIGFzIHN0cmluZyk7XG4gICAgICAgIH1cbiAgICB9LCBbZmxpZ2h0SWRdKTtcblxuICAgIGNvbnN0IGxvYWRGbGlnaHREYXRhID0gYXN5bmMgKGlkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgZmV0Y2hGbGlnaHREYXRhKGlkKTtcbiAgICAgICAgICAgIHNldEZsaWdodChkYXRhKTtcbiAgICAgICAgICAgIHNldEVycm9yKG51bGwpO1xuICAgICAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgICAgICAgc2V0RXJyb3IoZXJyLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBsb2FkIGZsaWdodCBkYXRhJyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBoYW5kbGVSZWNvcmRPbkJsb2NrY2hhaW4gPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmICghZmxpZ2h0IHx8ICFmbGlnaHQuZXZlbnRzIHx8IGZsaWdodC5ldmVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBtZXNzYWdlLndhcm5pbmcoJ05vIGV2ZW50cyB0byByZWNvcmQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIE1ldGFNYXNrXG4gICAgICAgIGlmICghaXNNZXRhTWFza0luc3RhbGxlZCgpKSB7XG4gICAgICAgICAgICBtZXNzYWdlLmVycm9yKCdNZXRhTWFzayBpcyBub3QgaW5zdGFsbGVkLiBQbGVhc2UgaW5zdGFsbCBNZXRhTWFzayB0byByZWNvcmQgZXZlbnRzIG9uIGJsb2NrY2hhaW4uJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgY29ubmVjdE1ldGFNYXNrKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UuZXJyb3IoYE1ldGFNYXNrIGNvbm5lY3Rpb24gZmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaW5kIGV2ZW50cyB0aGF0IG5lZWQgdG8gYmUgcmVjb3JkZWRcbiAgICAgICAgY29uc3QgZXZlbnRzTmVlZGluZ1R4ID0gZmxpZ2h0LmV2ZW50cy5maWx0ZXIoKGU6IGFueSkgPT4gIWUuYmxvY2tjaGFpbj8uaXNfdmVyaWZpZWQpO1xuICAgICAgICBcbiAgICAgICAgaWYgKGV2ZW50c05lZWRpbmdUeC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc3VjY2VzcygnQWxsIGV2ZW50cyBhcmUgYWxyZWFkeSByZWNvcmRlZCBvbiBibG9ja2NoYWluJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzZXRSZWNvcmRpbmcodHJ1ZSk7XG4gICAgICAgIG1lc3NhZ2UuaW5mbyhgUHJlcGFyaW5nICR7ZXZlbnRzTmVlZGluZ1R4Lmxlbmd0aH0gdHJhbnNhY3Rpb24ocykuLi5gKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY29udHJhY3RBZGRyZXNzID0gYXdhaXQgZ2V0Q29udHJhY3RBZGRyZXNzKCk7XG4gICAgICAgICAgICBpZiAoIWNvbnRyYWN0QWRkcmVzcykge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXJyb3IoJ0NvbnRyYWN0IGFkZHJlc3Mgbm90IGNvbmZpZ3VyZWQnKTtcbiAgICAgICAgICAgICAgICBzZXRSZWNvcmRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUHJlcGFyZSB0cmFuc2FjdGlvbnNcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiBldmVudHNOZWVkaW5nVHgpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmVwYXJlZFR4ID0gYXdhaXQgcHJlcGFyZVRyYW5zYWN0aW9uKGV2ZW50LmlkKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogcHJlcGFyZWRUeFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBwcmVwYXJlIHRyYW5zYWN0aW9uIGZvciAke2V2ZW50LmV2ZW50X3R5cGV9OmAsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHNldFBlbmRpbmdUcmFuc2FjdGlvbnModHJhbnNhY3Rpb25zKTtcbiAgICAgICAgICAgICAgICBzZXRNZXRhbWFza01vZGFsVmlzaWJsZSh0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5lcnJvcignRmFpbGVkIHRvIHByZXBhcmUgdHJhbnNhY3Rpb25zJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UuZXJyb3IoYEVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzZXRSZWNvcmRpbmcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGhhbmRsZUFwcHJvdmVUcmFuc2FjdGlvbnMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmIChwZW5kaW5nVHJhbnNhY3Rpb25zLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgICAgIHNldE1ldGFtYXNrTW9kYWxWaXNpYmxlKGZhbHNlKTtcbiAgICAgICAgc2V0UmVjb3JkaW5nKHRydWUpO1xuICAgICAgICBtZXNzYWdlLmluZm8oYFByb2Nlc3NpbmcgJHtwZW5kaW5nVHJhbnNhY3Rpb25zLmxlbmd0aH0gdHJhbnNhY3Rpb24ocykgdmlhIE1ldGFNYXNrLi4uYCk7XG5cbiAgICAgICAgbGV0IHN1Y2Nlc3NDb3VudCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGVuZGluZ1RyYW5zYWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgeyBldmVudCwgdHJhbnNhY3Rpb24gfSA9IHBlbmRpbmdUcmFuc2FjdGlvbnNbaV07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW5mbyhgQXBwcm92aW5nIHRyYW5zYWN0aW9uICR7aSArIDF9LyR7cGVuZGluZ1RyYW5zYWN0aW9ucy5sZW5ndGh9Li4uYCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHNlbmRQcmVwYXJlZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBDb25maXJtIHRyYW5zYWN0aW9uIGluIGJhY2tlbmRcbiAgICAgICAgICAgICAgICBhd2FpdCBjb25maXJtVHJhbnNhY3Rpb24oZXZlbnQuaWQsIHJlY2VpcHQuaGFzaCwgTnVtYmVyKHJlY2VpcHQuYmxvY2tOdW1iZXIpKTtcbiAgICAgICAgICAgICAgICBzdWNjZXNzQ291bnQrKztcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnN1Y2Nlc3MoYFRyYW5zYWN0aW9uICR7aSArIDF9IGNvbmZpcm1lZCFgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gNDAwMSkge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLndhcm5pbmcoJ1RyYW5zYWN0aW9uIHJlamVjdGVkIGJ5IHVzZXInKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5lcnJvcihgVHJhbnNhY3Rpb24gJHtpICsgMX0gZmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN1Y2Nlc3NDb3VudCA+IDApIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc3VjY2VzcyhgU3VjY2Vzc2Z1bGx5IHJlY29yZGVkICR7c3VjY2Vzc0NvdW50fSBldmVudChzKSBvbiBibG9ja2NoYWluIWApO1xuICAgICAgICAgICAgLy8gUmVsb2FkIGZsaWdodCBkYXRhXG4gICAgICAgICAgICBhd2FpdCBsb2FkRmxpZ2h0RGF0YShmbGlnaHRJZCBhcyBzdHJpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0UmVjb3JkaW5nKGZhbHNlKTtcbiAgICAgICAgc2V0UGVuZGluZ1RyYW5zYWN0aW9ucyhbXSk7XG4gICAgfTtcblxuICAgIGlmIChsb2FkaW5nKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGRpc3BsYXk6ICdmbGV4JywganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInLCBhbGlnbkl0ZW1zOiAnY2VudGVyJywgbWluSGVpZ2h0OiAnNjB2aCcgfX0+XG4gICAgICAgICAgICAgICAgPFNwaW4gc2l6ZT1cImxhcmdlXCIgdGlwPVwiTG9jYXRpbmcgZmxpZ2h0IG9uIGJsb2NrY2hhaW4uLi5cIiAvPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGVycm9yIHx8ICFmbGlnaHQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxSZXN1bHRcbiAgICAgICAgICAgICAgICBzdGF0dXM9XCJlcnJvclwiXG4gICAgICAgICAgICAgICAgdGl0bGU9XCJGbGlnaHQgTm90IEZvdW5kXCJcbiAgICAgICAgICAgICAgICBzdWJUaXRsZT17ZXJyb3IgfHwgXCJXZSBjb3VsZG4ndCBsb2NhdGUgdGhpcyBmbGlnaHQgaW4gb3VyIHN5c3RlbS5cIn1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgaXRlbXMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogJzEnLFxuICAgICAgICAgICAgbGFiZWw6IDxzcGFuPjxSb2NrZXRPdXRsaW5lZCAvPiBFdmVudCBUaW1lbGluZTwvc3Bhbj4sXG4gICAgICAgICAgICBjaGlsZHJlbjogPEV2ZW50VGltZWxpbmUgZXZlbnRzPXtmbGlnaHQuZXZlbnRzfSAvPixcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiAnMicsXG4gICAgICAgICAgICBsYWJlbDogPHNwYW4+PEJsb2NrT3V0bGluZWQgLz4gQmxvY2tjaGFpbiBMb2c8L3NwYW4+LFxuICAgICAgICAgICAgY2hpbGRyZW46IDxCbG9ja2NoYWluTG9nIGV2ZW50cz17ZmxpZ2h0LmJsb2NrY2hhaW5FdmVudHN9IC8+LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6ICczJyxcbiAgICAgICAgICAgIGxhYmVsOiA8c3Bhbj48TGluZUNoYXJ0T3V0bGluZWQgLz4gSGlzdG9yaWNhbCBCYXNlbGluZTwvc3Bhbj4sXG4gICAgICAgICAgICBjaGlsZHJlbjogPEhpc3RvcmljYWxCYXNlbGluZVZpZXcgZmxpZ2h0PXtmbGlnaHR9IC8+LFxuICAgICAgICB9LFxuICAgIF07XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsaWdodC1wYWdlXCI+XG4gICAgICAgICAgICA8RmxpZ2h0U3VtbWFyeSBmbGlnaHQ9e2ZsaWdodH0gLz5cblxuICAgICAgICAgICAgPFJvdyBndXR0ZXI9e1syNCwgMjRdfSBzdHlsZT17eyBtYXJnaW5Cb3R0b206IDI0IH19PlxuICAgICAgICAgICAgICAgIDxDb2wgeHM9ezI0fSBtZD17MTJ9PlxuICAgICAgICAgICAgICAgICAgICA8QWlyY3JhZnRNZXRhZGF0YSBhaXJjcmFmdD17ZmxpZ2h0LmFpcmNyYWZ0fSAvPlxuICAgICAgICAgICAgICAgIDwvQ29sPlxuICAgICAgICAgICAgICAgIDxDb2wgeHM9ezI0fSBtZD17MTJ9PlxuICAgICAgICAgICAgICAgICAgICA8RGVsYXlTdW1tYXJ5IGRlbGF5QW5hbHlzaXM9e2ZsaWdodC5kZWxheUFuYWx5c2lzfSAvPlxuICAgICAgICAgICAgICAgIDwvQ29sPlxuICAgICAgICAgICAgPC9Sb3c+XG5cbiAgICAgICAgICAgIDxDYXJkIHN0eWxlPXt7IGJvcmRlclJhZGl1czogOCB9fT5cbiAgICAgICAgICAgICAgICA8VGFicyBkZWZhdWx0QWN0aXZlS2V5PVwiMVwiIGl0ZW1zPXtpdGVtc30gLz5cbiAgICAgICAgICAgIDwvQ2FyZD5cblxuICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBtYXJnaW5Ub3A6IDI0LCB0ZXh0QWxpZ246ICdjZW50ZXInLCBjb2xvcjogJyM5OTknLCBmb250U2l6ZTogMTIgfX0+XG4gICAgICAgICAgICAgICAgQmxvY2tjaGFpbiBDb250cmFjdDogPHNwYW4gc3R5bGU9e3sgZm9udEZhbWlseTogJ21vbm9zcGFjZScgfX0+e2ZsaWdodC5ibG9ja2NoYWluRXZlbnRzPy5bMF0/LmNvbnRyYWN0X2FkZHJlc3N9PC9zcGFuPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICk7XG59XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsIlRhYnMiLCJDYXJkIiwiU3BpbiIsIlJlc3VsdCIsIlJvdyIsIkNvbCIsIm1lc3NhZ2UiLCJ1c2VQYXJhbXMiLCJSb2NrZXRPdXRsaW5lZCIsIkJsb2NrT3V0bGluZWQiLCJMaW5lQ2hhcnRPdXRsaW5lZCIsIkZsaWdodFN1bW1hcnkiLCJBaXJjcmFmdE1ldGFkYXRhIiwiRGVsYXlTdW1tYXJ5IiwiRXZlbnRUaW1lbGluZSIsIkJsb2NrY2hhaW5Mb2ciLCJIaXN0b3JpY2FsQmFzZWxpbmVWaWV3IiwiZmV0Y2hGbGlnaHREYXRhIiwicHJlcGFyZVRyYW5zYWN0aW9uIiwiY29uZmlybVRyYW5zYWN0aW9uIiwiZ2V0Q29udHJhY3RBZGRyZXNzIiwiaXNNZXRhTWFza0luc3RhbGxlZCIsImNvbm5lY3RNZXRhTWFzayIsInNlbmRQcmVwYXJlZFRyYW5zYWN0aW9uIiwiRmxpZ2h0UGFnZSIsImZsaWdodCIsImZsaWdodElkIiwic2V0RmxpZ2h0IiwibG9hZGluZyIsInNldExvYWRpbmciLCJlcnJvciIsInNldEVycm9yIiwicmVjb3JkaW5nIiwic2V0UmVjb3JkaW5nIiwibWV0YW1hc2tNb2RhbFZpc2libGUiLCJzZXRNZXRhbWFza01vZGFsVmlzaWJsZSIsInBlbmRpbmdUcmFuc2FjdGlvbnMiLCJzZXRQZW5kaW5nVHJhbnNhY3Rpb25zIiwibG9hZEZsaWdodERhdGEiLCJpZCIsImRhdGEiLCJlcnIiLCJoYW5kbGVSZWNvcmRPbkJsb2NrY2hhaW4iLCJldmVudHMiLCJsZW5ndGgiLCJ3YXJuaW5nIiwiZXZlbnRzTmVlZGluZ1R4IiwiZmlsdGVyIiwiZSIsImJsb2NrY2hhaW4iLCJpc192ZXJpZmllZCIsInN1Y2Nlc3MiLCJpbmZvIiwiY29udHJhY3RBZGRyZXNzIiwidHJhbnNhY3Rpb25zIiwiZXZlbnQiLCJwcmVwYXJlZFR4IiwicHVzaCIsInRyYW5zYWN0aW9uIiwiY29uc29sZSIsImV2ZW50X3R5cGUiLCJoYW5kbGVBcHByb3ZlVHJhbnNhY3Rpb25zIiwic3VjY2Vzc0NvdW50IiwiaSIsInJlY2VpcHQiLCJoYXNoIiwiTnVtYmVyIiwiYmxvY2tOdW1iZXIiLCJjb2RlIiwiZGl2Iiwic3R5bGUiLCJkaXNwbGF5IiwianVzdGlmeUNvbnRlbnQiLCJhbGlnbkl0ZW1zIiwibWluSGVpZ2h0Iiwic2l6ZSIsInRpcCIsInN0YXR1cyIsInRpdGxlIiwic3ViVGl0bGUiLCJpdGVtcyIsImtleSIsImxhYmVsIiwic3BhbiIsImNoaWxkcmVuIiwiYmxvY2tjaGFpbkV2ZW50cyIsImNsYXNzTmFtZSIsImd1dHRlciIsIm1hcmdpbkJvdHRvbSIsInhzIiwibWQiLCJhaXJjcmFmdCIsImRlbGF5QW5hbHlzaXMiLCJib3JkZXJSYWRpdXMiLCJkZWZhdWx0QWN0aXZlS2V5IiwibWFyZ2luVG9wIiwidGV4dEFsaWduIiwiY29sb3IiLCJmb250U2l6ZSIsImZvbnRGYW1pbHkiLCJjb250cmFjdF9hZGRyZXNzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/flight/[flightId]/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/services/web3.ts":
/*!******************************!*\
  !*** ./src/services/web3.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONTRACT_ABI: function() { return /* binding */ CONTRACT_ABI; },\n/* harmony export */   connectMetaMask: function() { return /* binding */ connectMetaMask; },\n/* harmony export */   getCurrentAccount: function() { return /* binding */ getCurrentAccount; },\n/* harmony export */   getFlightEventsFromChain: function() { return /* binding */ getFlightEventsFromChain; },\n/* harmony export */   isMetaMaskInstalled: function() { return /* binding */ isMetaMaskInstalled; },\n/* harmony export */   prepareRecordEventTransaction: function() { return /* binding */ prepareRecordEventTransaction; },\n/* harmony export */   recordEventViaMetaMask: function() { return /* binding */ recordEventViaMetaMask; },\n/* harmony export */   sendPreparedTransaction: function() { return /* binding */ sendPreparedTransaction; }\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/providers/provider-browser.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/contract/contract.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/**\n * Web3 Service - MetaMask Integration\n * \n * Handles blockchain interactions via MetaMask wallet.\n * Users sign and pay for their own transactions.\n */ \nconst API_URL = process.env.NEXT_PUBLIC_API_URL || \"http://localhost:8000/api\";\n// Contract ABI - must match FlightEventRegistry.sol\nconst CONTRACT_ABI = [\n    \"function recordEvent(string memory _flightId, string memory _eventType, uint256 _timestamp, string memory _actor, bytes32 _dataHash) external returns (uint256)\",\n    \"function getFlightEventIndices(string memory _flightId) external view returns (uint256[])\",\n    \"function getEvent(uint256 _index) external view returns (string memory flightId, string memory eventType, uint256 timestamp, string memory actor, bytes32 dataHash, uint256 blockNumber, uint256 recordedAt)\",\n    \"function getTotalEvents() external view returns (uint256)\",\n    \"function verifyHash(bytes32 _dataHash) external view returns (bool)\"\n];\n/**\n * Check if MetaMask is installed\n */ function isMetaMaskInstalled() {\n    return  true && typeof window.ethereum !== \"undefined\";\n}\n/**\n * Request account access from MetaMask\n */ async function connectMetaMask() {\n    if (!isMetaMaskInstalled()) {\n        throw new Error(\"MetaMask is not installed. Please install MetaMask to continue.\");\n    }\n    const provider = new ethers__WEBPACK_IMPORTED_MODULE_0__.BrowserProvider(window.ethereum);\n    const accounts = await provider.send(\"eth_requestAccounts\", []);\n    if (accounts.length === 0) {\n        throw new Error(\"No accounts found. Please unlock MetaMask.\");\n    }\n    return accounts[0];\n}\n/**\n * Get the current connected account\n */ async function getCurrentAccount() {\n    if (!isMetaMaskInstalled()) {\n        return null;\n    }\n    try {\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_0__.BrowserProvider(window.ethereum);\n        const accounts = await provider.listAccounts();\n        return accounts.length > 0 ? accounts[0].address : null;\n    } catch (e) {\n        return null;\n    }\n}\n/**\n * Get contract instance\n */ async function getContract(contractAddress) {\n    if (!isMetaMaskInstalled()) {\n        throw new Error(\"MetaMask is not installed\");\n    }\n    const provider = new ethers__WEBPACK_IMPORTED_MODULE_0__.BrowserProvider(window.ethereum);\n    const signer = await provider.getSigner();\n    return new ethers__WEBPACK_IMPORTED_MODULE_1__.Contract(contractAddress, CONTRACT_ABI, signer);\n}\n/**\n * Record a flight event on blockchain via MetaMask\n * \n * @param contractAddress - Address of the deployed FlightEventRegistry contract\n * @param flightId - Flight identifier (e.g., \"UA123\")\n * @param eventType - Type of event (e.g., \"DEPARTURE\")\n * @param timestamp - Unix timestamp\n * @param actor - Actor responsible (e.g., \"SYSTEM\")\n * @param dataHash - SHA256 hash of event data (0x-prefixed hex string)\n * @returns Transaction receipt\n */ async function recordEventViaMetaMask(contractAddress, flightId, eventType, timestamp, actor, dataHash) {\n    // Ensure account is connected\n    await connectMetaMask();\n    const contract = await getContract(contractAddress);\n    // Convert dataHash to bytes32 (ensure it's 32 bytes)\n    // ethers.js v6 handles hex strings directly, so we can use hexlify or ensure it's a hex string\n    let dataHashHex;\n    if (dataHash.startsWith(\"0x\")) {\n        dataHashHex = dataHash;\n    } else {\n        dataHashHex = \"0x\" + dataHash;\n    }\n    // Ensure it's exactly 66 characters (0x + 64 hex chars = 32 bytes)\n    if (dataHashHex.length !== 66) {\n        throw new Error(\"Data hash must be 32 bytes (64 hex characters)\");\n    }\n    // Convert to bytes32 format that ethers expects\n    const dataHashBytes32 = ethers__WEBPACK_IMPORTED_MODULE_2__.getBytes(dataHashHex);\n    // Estimate gas\n    const gasEstimate = await contract.recordEvent.estimateGas(flightId, eventType, timestamp, actor, dataHashBytes32);\n    // Send transaction (MetaMask will prompt user)\n    const tx = await contract.recordEvent(flightId, eventType, timestamp, actor, dataHashBytes32, {\n        gasLimit: gasEstimate * BigInt(120) / BigInt(100) // Add 20% buffer\n    });\n    // Wait for confirmation\n    const receipt = await tx.wait();\n    return receipt;\n}\n/**\n * Read flight events from blockchain\n */ async function getFlightEventsFromChain(contractAddress, flightId) {\n    if (!isMetaMaskInstalled()) {\n        // Use read-only provider if MetaMask not available\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_3__.JsonRpcProvider(process.env.NEXT_PUBLIC_GANACHE_URL || \"http://127.0.0.1:8545\");\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_1__.Contract(contractAddress, CONTRACT_ABI, provider);\n        const indices = await contract.getFlightEventIndices(flightId);\n        const events = [];\n        for (const index of indices){\n            const event = await contract.getEvent(index);\n            events.push({\n                flightId: event.flightId,\n                eventType: event.eventType,\n                timestamp: Number(event.timestamp),\n                actor: event.actor,\n                dataHash: event.dataHash,\n                blockNumber: Number(event.blockNumber),\n                recordedAt: Number(event.recordedAt)\n            });\n        }\n        return events;\n    }\n    const provider = new ethers__WEBPACK_IMPORTED_MODULE_0__.BrowserProvider(window.ethereum);\n    const contract = new ethers__WEBPACK_IMPORTED_MODULE_1__.Contract(contractAddress, CONTRACT_ABI, provider);\n    const indices = await contract.getFlightEventIndices(flightId);\n    const events = [];\n    for (const index of indices){\n        const event = await contract.getEvent(index);\n        events.push({\n            flightId: event.flightId,\n            eventType: event.eventType,\n            timestamp: Number(event.timestamp),\n            actor: event.actor,\n            dataHash: event.dataHash,\n            blockNumber: Number(event.blockNumber),\n            recordedAt: Number(event.recordedAt)\n        });\n    }\n    return events;\n}\n/**\n * Prepare a transaction to record an event (without sending)\n */ async function prepareRecordEventTransaction(contractAddress, flightId, eventType, timestamp, actor, dataHash) {\n    const provider = new ethers__WEBPACK_IMPORTED_MODULE_3__.JsonRpcProvider(process.env.NEXT_PUBLIC_GANACHE_URL || \"http://127.0.0.1:8545\");\n    const contract = new ethers__WEBPACK_IMPORTED_MODULE_1__.Contract(contractAddress, CONTRACT_ABI, provider);\n    // Convert dataHash to bytes32\n    let dataHashHex;\n    if (dataHash.startsWith(\"0x\")) {\n        dataHashHex = dataHash;\n    } else {\n        dataHashHex = \"0x\" + dataHash;\n    }\n    // Ensure it's exactly 66 characters (0x + 64 hex chars = 32 bytes)\n    if (dataHashHex.length !== 66) {\n        throw new Error(\"Data hash must be 32 bytes (64 hex characters)\");\n    }\n    // Convert to bytes32 format\n    const dataHashBytes32 = ethers__WEBPACK_IMPORTED_MODULE_2__.getBytes(dataHashHex);\n    const data = contract.interface.encodeFunctionData(\"recordEvent\", [\n        flightId,\n        eventType,\n        timestamp,\n        actor,\n        dataHashBytes32\n    ]);\n    // Estimate gas\n    let gasEstimate;\n    try {\n        gasEstimate = await contract.recordEvent.estimateGas(flightId, eventType, timestamp, actor, dataHashBytes32);\n    } catch (e) {\n        gasEstimate = BigInt(300000); // Default fallback\n    }\n    return {\n        to: contractAddress,\n        data,\n        value: \"0x0\",\n        gas: \"0x\".concat(gasEstimate.toString(16))\n    };\n}\n/**\n * Send prepared transaction via MetaMask\n */ async function sendPreparedTransaction(transaction) {\n    if (!isMetaMaskInstalled()) {\n        throw new Error(\"MetaMask is not installed\");\n    }\n    await connectMetaMask();\n    const provider = new ethers__WEBPACK_IMPORTED_MODULE_0__.BrowserProvider(window.ethereum);\n    const signer = await provider.getSigner();\n    // MetaMask will prompt user for approval\n    const tx = await signer.sendTransaction({\n        to: transaction.to,\n        data: transaction.data,\n        value: transaction.value,\n        gasLimit: transaction.gas ? BigInt(transaction.gas) : undefined\n    });\n    const receipt = await tx.wait();\n    return receipt;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy93ZWIzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQUUrQjtBQUdoQyxNQUFNQyxVQUFVQyxPQUFPQSxDQUFDQyxHQUFHLENBQUNDLG1CQUFtQixJQUFJO0FBRW5ELG9EQUFvRDtBQUM3QyxNQUFNQyxlQUFlO0lBQ3hCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDSCxDQUFDO0FBRUY7O0NBRUMsR0FDTSxTQUFTQztJQUNaLE9BQU8sS0FBa0IsSUFBZSxPQUFPLE9BQWdCRSxRQUFRLEtBQUs7QUFDaEY7QUFFQTs7Q0FFQyxHQUNNLGVBQWVDO0lBQ2xCLElBQUksQ0FBQ0gsdUJBQXVCO1FBQ3hCLE1BQU0sSUFBSUksTUFBTTtJQUNwQjtJQUVBLE1BQU1DLFdBQVcsSUFBSVgsbURBQXNCLENBQUMsT0FBZ0JRLFFBQVE7SUFDcEUsTUFBTUssV0FBVyxNQUFNRixTQUFTRyxJQUFJLENBQUMsdUJBQXVCLEVBQUU7SUFFOUQsSUFBSUQsU0FBU0UsTUFBTSxLQUFLLEdBQUc7UUFDdkIsTUFBTSxJQUFJTCxNQUFNO0lBQ3BCO0lBRUEsT0FBT0csUUFBUSxDQUFDLEVBQUU7QUFDdEI7QUFFQTs7Q0FFQyxHQUNNLGVBQWVHO0lBQ2xCLElBQUksQ0FBQ1YsdUJBQXVCO1FBQ3hCLE9BQU87SUFDWDtJQUVBLElBQUk7UUFDQSxNQUFNSyxXQUFXLElBQUlYLG1EQUFzQixDQUFDLE9BQWdCUSxRQUFRO1FBQ3BFLE1BQU1LLFdBQVcsTUFBTUYsU0FBU00sWUFBWTtRQUM1QyxPQUFPSixTQUFTRSxNQUFNLEdBQUcsSUFBSUYsUUFBUSxDQUFDLEVBQUUsQ0FBQ0ssT0FBTyxHQUFHO0lBQ3ZELEVBQUUsVUFBTTtRQUNKLE9BQU87SUFDWDtBQUNKO0FBRUE7O0NBRUMsR0FDRCxlQUFlQyxZQUFZQyxlQUF1QjtJQUM5QyxJQUFJLENBQUNkLHVCQUF1QjtRQUN4QixNQUFNLElBQUlJLE1BQU07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O0FBRUE7O0NBRUMsR0FDTSxlQUFlQyx3QkFDbEJDLFdBQWdDO0lBRWhDLElBQUksQ0FBQzNELHVCQUF1QjtRQUN4QixNQUFNLElBQUlJLE1BQU07SUFDcEI7SUFFQSxNQUFNRDtJQUVOLE1BQU1FLFdBQVcsSUFBSVgsbURBQXNCLENBQUMsT0FBZ0JRLFFBQVE7SUFDcEUsTUFBTWEsU0FBUyxNQUFNVixTQUFTVyxTQUFTO0lBRXZDLHlDQUF5QztJQUN6QyxNQUFNZ0IsS0FBSyxNQUFNakIsT0FBTzZDLGVBQWUsQ0FBQztRQUNwQ04sSUFBSUssWUFBWUwsRUFBRTtRQUNsQkgsTUFBTVEsWUFBWVIsSUFBSTtRQUN0QkksT0FBT0ksWUFBWUosS0FBSztRQUN4QnRCLFVBQVUwQixZQUFZSCxHQUFHLEdBQUd0QixPQUFPeUIsWUFBWUgsR0FBRyxJQUFJSztJQUMxRDtJQUVBLE1BQU0xQixVQUFVLE1BQU1ILEdBQUdJLElBQUk7SUFDN0IsT0FBT0Q7QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc2VydmljZXMvd2ViMy50cz8xMWI4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogV2ViMyBTZXJ2aWNlIC0gTWV0YU1hc2sgSW50ZWdyYXRpb25cbiAqIFxuICogSGFuZGxlcyBibG9ja2NoYWluIGludGVyYWN0aW9ucyB2aWEgTWV0YU1hc2sgd2FsbGV0LlxuICogVXNlcnMgc2lnbiBhbmQgcGF5IGZvciB0aGVpciBvd24gdHJhbnNhY3Rpb25zLlxuICovXG5cbmltcG9ydCB7IGV0aGVycyB9IGZyb20gJ2V0aGVycyc7XG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xuXG5jb25zdCBBUElfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDo4MDAwL2FwaSc7XG5cbi8vIENvbnRyYWN0IEFCSSAtIG11c3QgbWF0Y2ggRmxpZ2h0RXZlbnRSZWdpc3RyeS5zb2xcbmV4cG9ydCBjb25zdCBDT05UUkFDVF9BQkkgPSBbXG4gICAgXCJmdW5jdGlvbiByZWNvcmRFdmVudChzdHJpbmcgbWVtb3J5IF9mbGlnaHRJZCwgc3RyaW5nIG1lbW9yeSBfZXZlbnRUeXBlLCB1aW50MjU2IF90aW1lc3RhbXAsIHN0cmluZyBtZW1vcnkgX2FjdG9yLCBieXRlczMyIF9kYXRhSGFzaCkgZXh0ZXJuYWwgcmV0dXJucyAodWludDI1NilcIixcbiAgICBcImZ1bmN0aW9uIGdldEZsaWdodEV2ZW50SW5kaWNlcyhzdHJpbmcgbWVtb3J5IF9mbGlnaHRJZCkgZXh0ZXJuYWwgdmlldyByZXR1cm5zICh1aW50MjU2W10pXCIsXG4gICAgXCJmdW5jdGlvbiBnZXRFdmVudCh1aW50MjU2IF9pbmRleCkgZXh0ZXJuYWwgdmlldyByZXR1cm5zIChzdHJpbmcgbWVtb3J5IGZsaWdodElkLCBzdHJpbmcgbWVtb3J5IGV2ZW50VHlwZSwgdWludDI1NiB0aW1lc3RhbXAsIHN0cmluZyBtZW1vcnkgYWN0b3IsIGJ5dGVzMzIgZGF0YUhhc2gsIHVpbnQyNTYgYmxvY2tOdW1iZXIsIHVpbnQyNTYgcmVjb3JkZWRBdClcIixcbiAgICBcImZ1bmN0aW9uIGdldFRvdGFsRXZlbnRzKCkgZXh0ZXJuYWwgdmlldyByZXR1cm5zICh1aW50MjU2KVwiLFxuICAgIFwiZnVuY3Rpb24gdmVyaWZ5SGFzaChieXRlczMyIF9kYXRhSGFzaCkgZXh0ZXJuYWwgdmlldyByZXR1cm5zIChib29sKVwiXG5dO1xuXG4vKipcbiAqIENoZWNrIGlmIE1ldGFNYXNrIGlzIGluc3RhbGxlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNNZXRhTWFza0luc3RhbGxlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mICh3aW5kb3cgYXMgYW55KS5ldGhlcmV1bSAhPT0gJ3VuZGVmaW5lZCc7XG59XG5cbi8qKlxuICogUmVxdWVzdCBhY2NvdW50IGFjY2VzcyBmcm9tIE1ldGFNYXNrXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb25uZWN0TWV0YU1hc2soKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBpZiAoIWlzTWV0YU1hc2tJbnN0YWxsZWQoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGFNYXNrIGlzIG5vdCBpbnN0YWxsZWQuIFBsZWFzZSBpbnN0YWxsIE1ldGFNYXNrIHRvIGNvbnRpbnVlLicpO1xuICAgIH1cblxuICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IGV0aGVycy5Ccm93c2VyUHJvdmlkZXIoKHdpbmRvdyBhcyBhbnkpLmV0aGVyZXVtKTtcbiAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHByb3ZpZGVyLnNlbmQoJ2V0aF9yZXF1ZXN0QWNjb3VudHMnLCBbXSk7XG4gICAgXG4gICAgaWYgKGFjY291bnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjY291bnRzIGZvdW5kLiBQbGVhc2UgdW5sb2NrIE1ldGFNYXNrLicpO1xuICAgIH1cblxuICAgIHJldHVybiBhY2NvdW50c1swXTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgY29ubmVjdGVkIGFjY291bnRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEN1cnJlbnRBY2NvdW50KCk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xuICAgIGlmICghaXNNZXRhTWFza0luc3RhbGxlZCgpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IGV0aGVycy5Ccm93c2VyUHJvdmlkZXIoKHdpbmRvdyBhcyBhbnkpLmV0aGVyZXVtKTtcbiAgICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCBwcm92aWRlci5saXN0QWNjb3VudHMoKTtcbiAgICAgICAgcmV0dXJuIGFjY291bnRzLmxlbmd0aCA+IDAgPyBhY2NvdW50c1swXS5hZGRyZXNzIDogbnVsbDtcbiAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG4vKipcbiAqIEdldCBjb250cmFjdCBpbnN0YW5jZVxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRDb250cmFjdChjb250cmFjdEFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8ZXRoZXJzLkNvbnRyYWN0PiB7XG4gICAgaWYgKCFpc01ldGFNYXNrSW5zdGFsbGVkKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRhTWFzayBpcyBub3QgaW5zdGFsbGVkJyk7XG4gICAgfVxuXG4gICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgZXRoZXJzLkJyb3dzZXJQcm92aWRlcigod2luZG93IGFzIGFueSkuZXRoZXJldW0pO1xuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpO1xuICAgIHJldHVybiBuZXcgZXRoZXJzLkNvbnRyYWN0KGNvbnRyYWN0QWRkcmVzcywgQ09OVFJBQ1RfQUJJLCBzaWduZXIpO1xufVxuXG4vKipcbiAqIFJlY29yZCBhIGZsaWdodCBldmVudCBvbiBibG9ja2NoYWluIHZpYSBNZXRhTWFza1xuICogXG4gKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIC0gQWRkcmVzcyBvZiB0aGUgZGVwbG95ZWQgRmxpZ2h0RXZlbnRSZWdpc3RyeSBjb250cmFjdFxuICogQHBhcmFtIGZsaWdodElkIC0gRmxpZ2h0IGlkZW50aWZpZXIgKGUuZy4sIFwiVUExMjNcIilcbiAqIEBwYXJhbSBldmVudFR5cGUgLSBUeXBlIG9mIGV2ZW50IChlLmcuLCBcIkRFUEFSVFVSRVwiKVxuICogQHBhcmFtIHRpbWVzdGFtcCAtIFVuaXggdGltZXN0YW1wXG4gKiBAcGFyYW0gYWN0b3IgLSBBY3RvciByZXNwb25zaWJsZSAoZS5nLiwgXCJTWVNURU1cIilcbiAqIEBwYXJhbSBkYXRhSGFzaCAtIFNIQTI1NiBoYXNoIG9mIGV2ZW50IGRhdGEgKDB4LXByZWZpeGVkIGhleCBzdHJpbmcpXG4gKiBAcmV0dXJucyBUcmFuc2FjdGlvbiByZWNlaXB0XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWNvcmRFdmVudFZpYU1ldGFNYXNrKFxuICAgIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICAgIGZsaWdodElkOiBzdHJpbmcsXG4gICAgZXZlbnRUeXBlOiBzdHJpbmcsXG4gICAgdGltZXN0YW1wOiBudW1iZXIsXG4gICAgYWN0b3I6IHN0cmluZyxcbiAgICBkYXRhSGFzaDogc3RyaW5nXG4pOiBQcm9taXNlPGV0aGVycy5UcmFuc2FjdGlvblJlY2VpcHQ+IHtcbiAgICAvLyBFbnN1cmUgYWNjb3VudCBpcyBjb25uZWN0ZWRcbiAgICBhd2FpdCBjb25uZWN0TWV0YU1hc2soKTtcblxuICAgIGNvbnN0IGNvbnRyYWN0ID0gYXdhaXQgZ2V0Q29udHJhY3QoY29udHJhY3RBZGRyZXNzKTtcbiAgICBcbiAgICAvLyBDb252ZXJ0IGRhdGFIYXNoIHRvIGJ5dGVzMzIgKGVuc3VyZSBpdCdzIDMyIGJ5dGVzKVxuICAgIC8vIGV0aGVycy5qcyB2NiBoYW5kbGVzIGhleCBzdHJpbmdzIGRpcmVjdGx5LCBzbyB3ZSBjYW4gdXNlIGhleGxpZnkgb3IgZW5zdXJlIGl0J3MgYSBoZXggc3RyaW5nXG4gICAgbGV0IGRhdGFIYXNoSGV4OiBzdHJpbmc7XG4gICAgaWYgKGRhdGFIYXNoLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgZGF0YUhhc2hIZXggPSBkYXRhSGFzaDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhSGFzaEhleCA9ICcweCcgKyBkYXRhSGFzaDtcbiAgICB9XG4gICAgXG4gICAgLy8gRW5zdXJlIGl0J3MgZXhhY3RseSA2NiBjaGFyYWN0ZXJzICgweCArIDY0IGhleCBjaGFycyA9IDMyIGJ5dGVzKVxuICAgIGlmIChkYXRhSGFzaEhleC5sZW5ndGggIT09IDY2KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBoYXNoIG11c3QgYmUgMzIgYnl0ZXMgKDY0IGhleCBjaGFyYWN0ZXJzKScpO1xuICAgIH1cbiAgICBcbiAgICAvLyBDb252ZXJ0IHRvIGJ5dGVzMzIgZm9ybWF0IHRoYXQgZXRoZXJzIGV4cGVjdHNcbiAgICBjb25zdCBkYXRhSGFzaEJ5dGVzMzIgPSBldGhlcnMuZ2V0Qnl0ZXMoZGF0YUhhc2hIZXgpO1xuICAgIFxuICAgIC8vIEVzdGltYXRlIGdhc1xuICAgIGNvbnN0IGdhc0VzdGltYXRlID0gYXdhaXQgY29udHJhY3QucmVjb3JkRXZlbnQuZXN0aW1hdGVHYXMoXG4gICAgICAgIGZsaWdodElkLFxuICAgICAgICBldmVudFR5cGUsXG4gICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgYWN0b3IsXG4gICAgICAgIGRhdGFIYXNoQnl0ZXMzMlxuICAgICk7XG5cbiAgICAvLyBTZW5kIHRyYW5zYWN0aW9uIChNZXRhTWFzayB3aWxsIHByb21wdCB1c2VyKVxuICAgIGNvbnN0IHR4ID0gYXdhaXQgY29udHJhY3QucmVjb3JkRXZlbnQoXG4gICAgICAgIGZsaWdodElkLFxuICAgICAgICBldmVudFR5cGUsXG4gICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgYWN0b3IsXG4gICAgICAgIGRhdGFIYXNoQnl0ZXMzMixcbiAgICAgICAge1xuICAgICAgICAgICAgZ2FzTGltaXQ6IGdhc0VzdGltYXRlICogQmlnSW50KDEyMCkgLyBCaWdJbnQoMTAwKSAvLyBBZGQgMjAlIGJ1ZmZlclxuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8vIFdhaXQgZm9yIGNvbmZpcm1hdGlvblxuICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0eC53YWl0KCk7XG4gICAgcmV0dXJuIHJlY2VpcHQ7XG59XG5cbi8qKlxuICogUmVhZCBmbGlnaHQgZXZlbnRzIGZyb20gYmxvY2tjaGFpblxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RmxpZ2h0RXZlbnRzRnJvbUNoYWluKFxuICAgIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICAgIGZsaWdodElkOiBzdHJpbmdcbik6IFByb21pc2U8YW55W10+IHtcbiAgICBpZiAoIWlzTWV0YU1hc2tJbnN0YWxsZWQoKSkge1xuICAgICAgICAvLyBVc2UgcmVhZC1vbmx5IHByb3ZpZGVyIGlmIE1ldGFNYXNrIG5vdCBhdmFpbGFibGVcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgZXRoZXJzLkpzb25ScGNQcm92aWRlcihcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0dBTkFDSEVfVVJMIHx8ICdodHRwOi8vMTI3LjAuMC4xOjg1NDUnXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChjb250cmFjdEFkZHJlc3MsIENPTlRSQUNUX0FCSSwgcHJvdmlkZXIpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgaW5kaWNlcyA9IGF3YWl0IGNvbnRyYWN0LmdldEZsaWdodEV2ZW50SW5kaWNlcyhmbGlnaHRJZCk7XG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IFtdO1xuICAgICAgICBcbiAgICAgICAgZm9yIChjb25zdCBpbmRleCBvZiBpbmRpY2VzKSB7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IGF3YWl0IGNvbnRyYWN0LmdldEV2ZW50KGluZGV4KTtcbiAgICAgICAgICAgIGV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBmbGlnaHRJZDogZXZlbnQuZmxpZ2h0SWQsXG4gICAgICAgICAgICAgICAgZXZlbnRUeXBlOiBldmVudC5ldmVudFR5cGUsXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiBOdW1iZXIoZXZlbnQudGltZXN0YW1wKSxcbiAgICAgICAgICAgICAgICBhY3RvcjogZXZlbnQuYWN0b3IsXG4gICAgICAgICAgICAgICAgZGF0YUhhc2g6IGV2ZW50LmRhdGFIYXNoLFxuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBOdW1iZXIoZXZlbnQuYmxvY2tOdW1iZXIpLFxuICAgICAgICAgICAgICAgIHJlY29yZGVkQXQ6IE51bWJlcihldmVudC5yZWNvcmRlZEF0KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBldmVudHM7XG4gICAgfVxuXG4gICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgZXRoZXJzLkJyb3dzZXJQcm92aWRlcigod2luZG93IGFzIGFueSkuZXRoZXJldW0pO1xuICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChjb250cmFjdEFkZHJlc3MsIENPTlRSQUNUX0FCSSwgcHJvdmlkZXIpO1xuICAgIFxuICAgIGNvbnN0IGluZGljZXMgPSBhd2FpdCBjb250cmFjdC5nZXRGbGlnaHRFdmVudEluZGljZXMoZmxpZ2h0SWQpO1xuICAgIGNvbnN0IGV2ZW50cyA9IFtdO1xuICAgIFxuICAgIGZvciAoY29uc3QgaW5kZXggb2YgaW5kaWNlcykge1xuICAgICAgICBjb25zdCBldmVudCA9IGF3YWl0IGNvbnRyYWN0LmdldEV2ZW50KGluZGV4KTtcbiAgICAgICAgZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgZmxpZ2h0SWQ6IGV2ZW50LmZsaWdodElkLFxuICAgICAgICAgICAgZXZlbnRUeXBlOiBldmVudC5ldmVudFR5cGUsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IE51bWJlcihldmVudC50aW1lc3RhbXApLFxuICAgICAgICAgICAgYWN0b3I6IGV2ZW50LmFjdG9yLFxuICAgICAgICAgICAgZGF0YUhhc2g6IGV2ZW50LmRhdGFIYXNoLFxuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IE51bWJlcihldmVudC5ibG9ja051bWJlciksXG4gICAgICAgICAgICByZWNvcmRlZEF0OiBOdW1iZXIoZXZlbnQucmVjb3JkZWRBdClcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBldmVudHM7XG59XG5cbi8qKlxuICogUHJlcGFyZSB0cmFuc2FjdGlvbiBkYXRhIGZvciBNZXRhTWFza1xuICogVGhpcyBpcyBjYWxsZWQgZnJvbSBiYWNrZW5kIHRvIHByZXBhcmUgdGhlIHRyYW5zYWN0aW9uIHdpdGhvdXQgZXhlY3V0aW5nIGl0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUHJlcGFyZWRUcmFuc2FjdGlvbiB7XG4gICAgdG86IHN0cmluZztcbiAgICBkYXRhOiBzdHJpbmc7XG4gICAgdmFsdWU6IHN0cmluZztcbiAgICBnYXM/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogUHJlcGFyZSBhIHRyYW5zYWN0aW9uIHRvIHJlY29yZCBhbiBldmVudCAod2l0aG91dCBzZW5kaW5nKVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJlcGFyZVJlY29yZEV2ZW50VHJhbnNhY3Rpb24oXG4gICAgY29udHJhY3RBZGRyZXNzOiBzdHJpbmcsXG4gICAgZmxpZ2h0SWQ6IHN0cmluZyxcbiAgICBldmVudFR5cGU6IHN0cmluZyxcbiAgICB0aW1lc3RhbXA6IG51bWJlcixcbiAgICBhY3Rvcjogc3RyaW5nLFxuICAgIGRhdGFIYXNoOiBzdHJpbmdcbik6IFByb21pc2U8UHJlcGFyZWRUcmFuc2FjdGlvbj4ge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IGV0aGVycy5Kc29uUnBjUHJvdmlkZXIoXG4gICAgICAgIHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0dBTkFDSEVfVVJMIHx8ICdodHRwOi8vMTI3LjAuMC4xOjg1NDUnXG4gICAgKTtcbiAgICBjb25zdCBjb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoY29udHJhY3RBZGRyZXNzLCBDT05UUkFDVF9BQkksIHByb3ZpZGVyKTtcbiAgICBcbiAgICAvLyBDb252ZXJ0IGRhdGFIYXNoIHRvIGJ5dGVzMzJcbiAgICBsZXQgZGF0YUhhc2hIZXg6IHN0cmluZztcbiAgICBpZiAoZGF0YUhhc2guc3RhcnRzV2l0aCgnMHgnKSkge1xuICAgICAgICBkYXRhSGFzaEhleCA9IGRhdGFIYXNoO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGFIYXNoSGV4ID0gJzB4JyArIGRhdGFIYXNoO1xuICAgIH1cbiAgICBcbiAgICAvLyBFbnN1cmUgaXQncyBleGFjdGx5IDY2IGNoYXJhY3RlcnMgKDB4ICsgNjQgaGV4IGNoYXJzID0gMzIgYnl0ZXMpXG4gICAgaWYgKGRhdGFIYXNoSGV4Lmxlbmd0aCAhPT0gNjYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIGhhc2ggbXVzdCBiZSAzMiBieXRlcyAoNjQgaGV4IGNoYXJhY3RlcnMpJyk7XG4gICAgfVxuICAgIFxuICAgIC8vIENvbnZlcnQgdG8gYnl0ZXMzMiBmb3JtYXRcbiAgICBjb25zdCBkYXRhSGFzaEJ5dGVzMzIgPSBldGhlcnMuZ2V0Qnl0ZXMoZGF0YUhhc2hIZXgpO1xuICAgIFxuICAgIGNvbnN0IGRhdGEgPSBjb250cmFjdC5pbnRlcmZhY2UuZW5jb2RlRnVuY3Rpb25EYXRhKCdyZWNvcmRFdmVudCcsIFtcbiAgICAgICAgZmxpZ2h0SWQsXG4gICAgICAgIGV2ZW50VHlwZSxcbiAgICAgICAgdGltZXN0YW1wLFxuICAgICAgICBhY3RvcixcbiAgICAgICAgZGF0YUhhc2hCeXRlczMyXG4gICAgXSk7XG5cbiAgICAvLyBFc3RpbWF0ZSBnYXNcbiAgICBsZXQgZ2FzRXN0aW1hdGU6IGJpZ2ludDtcbiAgICB0cnkge1xuICAgICAgICBnYXNFc3RpbWF0ZSA9IGF3YWl0IGNvbnRyYWN0LnJlY29yZEV2ZW50LmVzdGltYXRlR2FzKFxuICAgICAgICAgICAgZmxpZ2h0SWQsXG4gICAgICAgICAgICBldmVudFR5cGUsXG4gICAgICAgICAgICB0aW1lc3RhbXAsXG4gICAgICAgICAgICBhY3RvcixcbiAgICAgICAgICAgIGRhdGFIYXNoQnl0ZXMzMlxuICAgICAgICApO1xuICAgIH0gY2F0Y2gge1xuICAgICAgICBnYXNFc3RpbWF0ZSA9IEJpZ0ludCgzMDAwMDApOyAvLyBEZWZhdWx0IGZhbGxiYWNrXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG86IGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgdmFsdWU6ICcweDAnLFxuICAgICAgICBnYXM6IGAweCR7Z2FzRXN0aW1hdGUudG9TdHJpbmcoMTYpfWBcbiAgICB9O1xufVxuXG4vKipcbiAqIFNlbmQgcHJlcGFyZWQgdHJhbnNhY3Rpb24gdmlhIE1ldGFNYXNrXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZW5kUHJlcGFyZWRUcmFuc2FjdGlvbihcbiAgICB0cmFuc2FjdGlvbjogUHJlcGFyZWRUcmFuc2FjdGlvblxuKTogUHJvbWlzZTxldGhlcnMuVHJhbnNhY3Rpb25SZWNlaXB0PiB7XG4gICAgaWYgKCFpc01ldGFNYXNrSW5zdGFsbGVkKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRhTWFzayBpcyBub3QgaW5zdGFsbGVkJyk7XG4gICAgfVxuXG4gICAgYXdhaXQgY29ubmVjdE1ldGFNYXNrKCk7XG4gICAgXG4gICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgZXRoZXJzLkJyb3dzZXJQcm92aWRlcigod2luZG93IGFzIGFueSkuZXRoZXJldW0pO1xuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpO1xuICAgIFxuICAgIC8vIE1ldGFNYXNrIHdpbGwgcHJvbXB0IHVzZXIgZm9yIGFwcHJvdmFsXG4gICAgY29uc3QgdHggPSBhd2FpdCBzaWduZXIuc2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgdG86IHRyYW5zYWN0aW9uLnRvLFxuICAgICAgICBkYXRhOiB0cmFuc2FjdGlvbi5kYXRhLFxuICAgICAgICB2YWx1ZTogdHJhbnNhY3Rpb24udmFsdWUsXG4gICAgICAgIGdhc0xpbWl0OiB0cmFuc2FjdGlvbi5nYXMgPyBCaWdJbnQodHJhbnNhY3Rpb24uZ2FzKSA6IHVuZGVmaW5lZFxuICAgIH0pO1xuXG4gICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHR4LndhaXQoKTtcbiAgICByZXR1cm4gcmVjZWlwdDtcbn1cbiJdLCJuYW1lcyI6WyJldGhlcnMiLCJBUElfVVJMIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJDT05UUkFDVF9BQkkiLCJpc01ldGFNYXNrSW5zdGFsbGVkIiwid2luZG93IiwiZXRoZXJldW0iLCJjb25uZWN0TWV0YU1hc2siLCJFcnJvciIsInByb3ZpZGVyIiwiQnJvd3NlclByb3ZpZGVyIiwiYWNjb3VudHMiLCJzZW5kIiwibGVuZ3RoIiwiZ2V0Q3VycmVudEFjY291bnQiLCJsaXN0QWNjb3VudHMiLCJhZGRyZXNzIiwiZ2V0Q29udHJhY3QiLCJjb250cmFjdEFkZHJlc3MiLCJzaWduZXIiLCJnZXRTaWduZXIiLCJDb250cmFjdCIsInJlY29yZEV2ZW50VmlhTWV0YU1hc2siLCJmbGlnaHRJZCIsImV2ZW50VHlwZSIsInRpbWVzdGFtcCIsImFjdG9yIiwiZGF0YUhhc2giLCJjb250cmFjdCIsImRhdGFIYXNoSGV4Iiwic3RhcnRzV2l0aCIsImRhdGFIYXNoQnl0ZXMzMiIsImdldEJ5dGVzIiwiZ2FzRXN0aW1hdGUiLCJyZWNvcmRFdmVudCIsImVzdGltYXRlR2FzIiwidHgiLCJnYXNMaW1pdCIsIkJpZ0ludCIsInJlY2VpcHQiLCJ3YWl0IiwiZ2V0RmxpZ2h0RXZlbnRzRnJvbUNoYWluIiwiSnNvblJwY1Byb3ZpZGVyIiwiTkVYVF9QVUJMSUNfR0FOQUNIRV9VUkwiLCJpbmRpY2VzIiwiZ2V0RmxpZ2h0RXZlbnRJbmRpY2VzIiwiZXZlbnRzIiwiaW5kZXgiLCJldmVudCIsImdldEV2ZW50IiwicHVzaCIsIk51bWJlciIsImJsb2NrTnVtYmVyIiwicmVjb3JkZWRBdCIsInByZXBhcmVSZWNvcmRFdmVudFRyYW5zYWN0aW9uIiwiZGF0YSIsImludGVyZmFjZSIsImVuY29kZUZ1bmN0aW9uRGF0YSIsInRvIiwidmFsdWUiLCJnYXMiLCJ0b1N0cmluZyIsInNlbmRQcmVwYXJlZFRyYW5zYWN0aW9uIiwidHJhbnNhY3Rpb24iLCJzZW5kVHJhbnNhY3Rpb24iLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/web3.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@adraffy/ens-normalize/dist/index.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@adraffy/ens-normalize/dist/index.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ens_beautify: function() { return /* binding */ ens_beautify; },\n/* harmony export */   ens_emoji: function() { return /* binding */ ens_emoji; },\n/* harmony export */   ens_normalize: function() { return /* binding */ ens_normalize; },\n/* harmony export */   ens_normalize_fragment: function() { return /* binding */ ens_normalize_fragment; },\n/* harmony export */   ens_split: function() { return /* binding */ ens_split; },\n/* harmony export */   ens_tokenize: function() { return /* binding */ ens_tokenize; },\n/* harmony export */   is_combining_mark: function() { return /* binding */ is_combining_mark; },\n/* harmony export */   nfc: function() { return /* binding */ nfc; },\n/* harmony export */   nfd: function() { return /* binding */ nfd; },\n/* harmony export */   safe_str_from_cps: function() { return /* binding */ safe_str_from_cps; },\n/* harmony export */   should_escape: function() { return /* binding */ should_escape; }\n/* harmony export */ });\n// created 2023-09-25T01:01:55.148Z\n// compressed base64-encoded blob for include-ens data\n// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js\n// see: https://github.com/adraffy/ens-normalize.js#security\n// SHA-256: 0565ed049b9cf1614bb9e11ba7d8ac6a6fb96c893253d890f7e2b2884b9ded32\nvar COMPRESSED$1 = \"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\";\nconst FENCED = new Map([\n    [\n        8217,\n        \"apostrophe\"\n    ],\n    [\n        8260,\n        \"fraction slash\"\n    ],\n    [\n        12539,\n        \"middle dot\"\n    ]\n]);\nconst NSM_MAX = 4;\nfunction decode_arithmetic(bytes) {\n    let pos = 0;\n    function u16() {\n        return bytes[pos++] << 8 | bytes[pos++];\n    }\n    // decode the frequency table\n    let symbol_count = u16();\n    let total = 1;\n    let acc = [\n        0,\n        1\n    ]; // first symbol has frequency 1\n    for(let i = 1; i < symbol_count; i++){\n        acc.push(total += u16());\n    }\n    // skip the sized-payload that the last 3 symbols index into\n    let skip = u16();\n    let pos_payload = pos;\n    pos += skip;\n    let read_width = 0;\n    let read_buffer = 0;\n    function read_bit() {\n        if (read_width == 0) {\n            // this will read beyond end of buffer\n            // but (undefined|0) => zero pad\n            read_buffer = read_buffer << 8 | bytes[pos++];\n            read_width = 8;\n        }\n        return read_buffer >> --read_width & 1;\n    }\n    const N = 31;\n    const FULL = 2 ** N;\n    const HALF = FULL >>> 1;\n    const QRTR = HALF >> 1;\n    const MASK = FULL - 1;\n    // fill register\n    let register = 0;\n    for(let i = 0; i < N; i++)register = register << 1 | read_bit();\n    let symbols = [];\n    let low = 0;\n    let range = FULL; // treat like a float\n    while(true){\n        let value = Math.floor(((register - low + 1) * total - 1) / range);\n        let start = 0;\n        let end = symbol_count;\n        while(end - start > 1){\n            let mid = start + end >>> 1;\n            if (value < acc[mid]) {\n                end = mid;\n            } else {\n                start = mid;\n            }\n        }\n        if (start == 0) break; // first symbol is end mark\n        symbols.push(start);\n        let a = low + Math.floor(range * acc[start] / total);\n        let b = low + Math.floor(range * acc[start + 1] / total) - 1;\n        while(((a ^ b) & HALF) == 0){\n            register = register << 1 & MASK | read_bit();\n            a = a << 1 & MASK;\n            b = b << 1 & MASK | 1;\n        }\n        while(a & ~b & QRTR){\n            register = register & HALF | register << 1 & MASK >>> 1 | read_bit();\n            a = a << 1 ^ HALF;\n            b = (b ^ HALF) << 1 | HALF | 1;\n        }\n        low = a;\n        range = 1 + b - a;\n    }\n    let offset = symbol_count - 4;\n    return symbols.map((x)=>{\n        switch(x - offset){\n            case 3:\n                return offset + 0x10100 + (bytes[pos_payload++] << 16 | bytes[pos_payload++] << 8 | bytes[pos_payload++]);\n            case 2:\n                return offset + 0x100 + (bytes[pos_payload++] << 8 | bytes[pos_payload++]);\n            case 1:\n                return offset + bytes[pos_payload++];\n            default:\n                return x - 1;\n        }\n    });\n}\n// returns an iterator which returns the next symbol\nfunction read_payload(v) {\n    let pos = 0;\n    return ()=>v[pos++];\n}\nfunction read_compressed_payload(s) {\n    return read_payload(decode_arithmetic(unsafe_atob(s)));\n}\n// unsafe in the sense:\n// expected well-formed Base64 w/o padding \n// 20220922: added for https://github.com/adraffy/ens-normalize.js/issues/4\nfunction unsafe_atob(s) {\n    let lookup = [];\n    [\n        ...\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n    ].forEach((c, i)=>lookup[c.charCodeAt(0)] = i);\n    let n = s.length;\n    let ret = new Uint8Array(6 * n >> 3);\n    for(let i = 0, pos = 0, width = 0, carry = 0; i < n; i++){\n        carry = carry << 6 | lookup[s.charCodeAt(i)];\n        width += 6;\n        if (width >= 8) {\n            ret[pos++] = carry >> (width -= 8);\n        }\n    }\n    return ret;\n}\n// eg. [0,1,2,3...] => [0,-1,1,-2,...]\nfunction signed(i) {\n    return i & 1 ? ~i >> 1 : i >> 1;\n}\nfunction read_deltas(n, next) {\n    let v = Array(n);\n    for(let i = 0, x = 0; i < n; i++)v[i] = x += signed(next());\n    return v;\n}\n// [123][5] => [0 3] [1 1] [0 0]\nfunction read_sorted(next) {\n    let prev = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n    let ret = [];\n    while(true){\n        let x = next();\n        let n = next();\n        if (!n) break;\n        prev += x;\n        for(let i = 0; i < n; i++){\n            ret.push(prev + i);\n        }\n        prev += n + 1;\n    }\n    return ret;\n}\nfunction read_sorted_arrays(next) {\n    return read_array_while(()=>{\n        let v = read_sorted(next);\n        if (v.length) return v;\n    });\n}\n// returns map of x => ys\nfunction read_mapped(next) {\n    let ret = [];\n    while(true){\n        let w = next();\n        if (w == 0) break;\n        ret.push(read_linear_table(w, next));\n    }\n    while(true){\n        let w = next() - 1;\n        if (w < 0) break;\n        ret.push(read_replacement_table(w, next));\n    }\n    return ret.flat();\n}\n// read until next is falsy\n// return array of read values\nfunction read_array_while(next) {\n    let v = [];\n    while(true){\n        let x = next(v.length);\n        if (!x) break;\n        v.push(x);\n    }\n    return v;\n}\n// read w columns of length n\n// return as n rows of length w\nfunction read_transposed(n, w, next) {\n    let m = Array(n).fill().map(()=>[]);\n    for(let i = 0; i < w; i++){\n        read_deltas(n, next).forEach((x, j)=>m[j].push(x));\n    }\n    return m;\n}\n// returns [[x, ys], [x+dx, ys+dy], [x+2*dx, ys+2*dy], ...]\n// where dx/dy = steps, n = run size, w = length of y\nfunction read_linear_table(w, next) {\n    let dx = 1 + next();\n    let dy = next();\n    let vN = read_array_while(next);\n    let m = read_transposed(vN.length, 1 + w, next);\n    return m.flatMap((v, i)=>{\n        let [x, ...ys] = v;\n        return Array(vN[i]).fill().map((_, j)=>{\n            let j_dy = j * dy;\n            return [\n                x + j * dx,\n                ys.map((y)=>y + j_dy)\n            ];\n        });\n    });\n}\n// return [[x, ys...], ...]\n// where w = length of y\nfunction read_replacement_table(w, next) {\n    let n = 1 + next();\n    let m = read_transposed(n, 1 + w, next);\n    return m.map((v)=>[\n            v[0],\n            v.slice(1)\n        ]);\n}\nfunction read_trie(next) {\n    let ret = [];\n    let sorted = read_sorted(next);\n    expand(decode([]), []);\n    return ret; // not sorted\n    function decode(Q) {\n        let S = next(); // state: valid, save, check\n        let B = read_array_while(()=>{\n            let cps = read_sorted(next).map((i)=>sorted[i]);\n            if (cps.length) return decode(cps);\n        });\n        return {\n            S,\n            B,\n            Q\n        };\n    }\n    function expand(param, cps, saved) {\n        let { S, B } = param;\n        if (S & 4 && saved === cps[cps.length - 1]) return;\n        if (S & 2) saved = cps[cps.length - 1];\n        if (S & 1) ret.push(cps);\n        for (let br of B){\n            for (let cp of br.Q){\n                expand(br, [\n                    ...cps,\n                    cp\n                ], saved);\n            }\n        }\n    }\n}\nfunction hex_cp(cp) {\n    return cp.toString(16).toUpperCase().padStart(2, \"0\");\n}\nfunction quote_cp(cp) {\n    return \"{\".concat(hex_cp(cp), \"}\"); // raffy convention: like \"\\u{X}\" w/o the \"\\u\"\n}\n/*\r\nexport function explode_cp(s) {\r\n\treturn [...s].map(c => c.codePointAt(0));\r\n}\r\n*/ function explode_cp(s) {\n    let cps = [];\n    for(let pos = 0, len = s.length; pos < len;){\n        let cp = s.codePointAt(pos);\n        pos += cp < 0x10000 ? 1 : 2;\n        cps.push(cp);\n    }\n    return cps;\n}\nfunction str_from_cps(cps) {\n    const chunk = 4096;\n    let len = cps.length;\n    if (len < chunk) return String.fromCodePoint(...cps);\n    let buf = [];\n    for(let i = 0; i < len;){\n        buf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));\n    }\n    return buf.join(\"\");\n}\nfunction compare_arrays(a, b) {\n    let n = a.length;\n    let c = n - b.length;\n    for(let i = 0; c == 0 && i < n; i++)c = a[i] - b[i];\n    return c;\n}\n// created 2023-09-25T01:01:55.148Z\n// compressed base64-encoded blob for include-nf data\n// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js\n// see: https://github.com/adraffy/ens-normalize.js#security\n// SHA-256: a974b6f8541fc29d919bc85118af0a44015851fab5343f8679cb31be2bdb209e\nvar COMPRESSED = \"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\";\n// https://unicode.org/reports/tr15/\n// for reference implementation\n// see: /derive/nf.js\n// algorithmic hangul\n// https://www.unicode.org/versions/Unicode15.0.0/ch03.pdf (page 144)\nconst S0 = 0xAC00;\nconst L0 = 0x1100;\nconst V0 = 0x1161;\nconst T0 = 0x11A7;\nconst L_COUNT = 19;\nconst V_COUNT = 21;\nconst T_COUNT = 28;\nconst N_COUNT = V_COUNT * T_COUNT;\nconst S_COUNT = L_COUNT * N_COUNT;\nconst S1 = S0 + S_COUNT;\nconst L1 = L0 + L_COUNT;\nconst V1 = V0 + V_COUNT;\nconst T1 = T0 + T_COUNT;\nfunction unpack_cc(packed) {\n    return packed >> 24 & 0xFF;\n}\nfunction unpack_cp(packed) {\n    return packed & 0xFFFFFF;\n}\nlet SHIFTED_RANK, EXCLUSIONS, DECOMP, RECOMP;\nfunction init$1() {\n    //console.time('nf');\n    let r = read_compressed_payload(COMPRESSED);\n    SHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap((v, i)=>v.map((x)=>[\n                x,\n                i + 1 << 24\n            ]))); // pre-shifted\n    EXCLUSIONS = new Set(read_sorted(r));\n    DECOMP = new Map();\n    RECOMP = new Map();\n    for (let [cp, cps] of read_mapped(r)){\n        if (!EXCLUSIONS.has(cp) && cps.length == 2) {\n            let [a, b] = cps;\n            let bucket = RECOMP.get(a);\n            if (!bucket) {\n                bucket = new Map();\n                RECOMP.set(a, bucket);\n            }\n            bucket.set(b, cp);\n        }\n        DECOMP.set(cp, cps.reverse()); // stored reversed\n    }\n//console.timeEnd('nf');\n// 20230905: 11ms\n}\nfunction is_hangul(cp) {\n    return cp >= S0 && cp < S1;\n}\nfunction compose_pair(a, b) {\n    if (a >= L0 && a < L1 && b >= V0 && b < V1) {\n        return S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT;\n    } else if (is_hangul(a) && b > T0 && b < T1 && (a - S0) % T_COUNT == 0) {\n        return a + (b - T0);\n    } else {\n        let recomp = RECOMP.get(a);\n        if (recomp) {\n            recomp = recomp.get(b);\n            if (recomp) {\n                return recomp;\n            }\n        }\n        return -1;\n    }\n}\nfunction decomposed(cps) {\n    if (!SHIFTED_RANK) init$1();\n    let ret = [];\n    let buf = [];\n    let check_order = false;\n    function add(cp) {\n        let cc = SHIFTED_RANK.get(cp);\n        if (cc) {\n            check_order = true;\n            cp |= cc;\n        }\n        ret.push(cp);\n    }\n    for (let cp of cps){\n        while(true){\n            if (cp < 0x80) {\n                ret.push(cp);\n            } else if (is_hangul(cp)) {\n                let s_index = cp - S0;\n                let l_index = s_index / N_COUNT | 0;\n                let v_index = s_index % N_COUNT / T_COUNT | 0;\n                let t_index = s_index % T_COUNT;\n                add(L0 + l_index);\n                add(V0 + v_index);\n                if (t_index > 0) add(T0 + t_index);\n            } else {\n                let mapped = DECOMP.get(cp);\n                if (mapped) {\n                    buf.push(...mapped);\n                } else {\n                    add(cp);\n                }\n            }\n            if (!buf.length) break;\n            cp = buf.pop();\n        }\n    }\n    if (check_order && ret.length > 1) {\n        let prev_cc = unpack_cc(ret[0]);\n        for(let i = 1; i < ret.length; i++){\n            let cc = unpack_cc(ret[i]);\n            if (cc == 0 || prev_cc <= cc) {\n                prev_cc = cc;\n                continue;\n            }\n            let j = i - 1;\n            while(true){\n                let tmp = ret[j + 1];\n                ret[j + 1] = ret[j];\n                ret[j] = tmp;\n                if (!j) break;\n                prev_cc = unpack_cc(ret[--j]);\n                if (prev_cc <= cc) break;\n            }\n            prev_cc = unpack_cc(ret[i]);\n        }\n    }\n    return ret;\n}\nfunction composed_from_decomposed(v) {\n    let ret = [];\n    let stack = [];\n    let prev_cp = -1;\n    let prev_cc = 0;\n    for (let packed of v){\n        let cc = unpack_cc(packed);\n        let cp = unpack_cp(packed);\n        if (prev_cp == -1) {\n            if (cc == 0) {\n                prev_cp = cp;\n            } else {\n                ret.push(cp);\n            }\n        } else if (prev_cc > 0 && prev_cc >= cc) {\n            if (cc == 0) {\n                ret.push(prev_cp, ...stack);\n                stack.length = 0;\n                prev_cp = cp;\n            } else {\n                stack.push(cp);\n            }\n            prev_cc = cc;\n        } else {\n            let composed = compose_pair(prev_cp, cp);\n            if (composed >= 0) {\n                prev_cp = composed;\n            } else if (prev_cc == 0 && cc == 0) {\n                ret.push(prev_cp);\n                prev_cp = cp;\n            } else {\n                stack.push(cp);\n                prev_cc = cc;\n            }\n        }\n    }\n    if (prev_cp >= 0) {\n        ret.push(prev_cp, ...stack);\n    }\n    return ret;\n}\n// note: cps can be iterable\nfunction nfd(cps) {\n    return decomposed(cps).map(unpack_cp);\n}\nfunction nfc(cps) {\n    return composed_from_decomposed(decomposed(cps));\n}\nconst HYPHEN = 0x2D;\nconst STOP = 0x2E;\nconst STOP_CH = \".\";\nconst FE0F = 0xFE0F;\nconst UNIQUE_PH = 1;\n// 20230913: replace [...v] with Array_from(v) to avoid large spreads\nconst Array_from = (x)=>Array.from(x); // Array.from.bind(Array);\n_c = Array_from;\nfunction group_has_cp(g, cp) {\n    // 20230913: keep primary and secondary distinct instead of creating valid union\n    return g.P.has(cp) || g.Q.has(cp);\n}\nclass Emoji extends Array {\n    get is_emoji() {\n        return true;\n    }\n}\nlet MAPPED, IGNORED, CM, NSM, ESCAPE, NFC_CHECK, GROUPS, WHOLE_VALID, WHOLE_MAP, VALID, EMOJI_LIST, EMOJI_ROOT;\nfunction init() {\n    if (MAPPED) return;\n    let r = read_compressed_payload(COMPRESSED$1);\n    const read_sorted_array = ()=>read_sorted(r);\n    const read_sorted_set = ()=>new Set(read_sorted_array());\n    const set_add_many = (set, v)=>v.forEach((x)=>set.add(x));\n    MAPPED = new Map(read_mapped(r));\n    IGNORED = read_sorted_set(); // ignored characters are not valid, so just read raw codepoints\n    /*\r\n\t// direct include from payload is smaller than the decompression code\r\n\tconst FENCED = new Map(read_array_while(() => {\r\n\t\tlet cp = r();\r\n\t\tif (cp) return [cp, read_str(r())];\r\n\t}));\r\n\t*/ // 20230217: we still need all CM for proper error formatting\n    // but norm only needs NSM subset that are potentially-valid\n    CM = read_sorted_array();\n    NSM = new Set(read_sorted_array().map((i)=>CM[i]));\n    CM = new Set(CM);\n    ESCAPE = read_sorted_set(); // characters that should not be printed\n    NFC_CHECK = read_sorted_set(); // only needed to illustrate ens_tokenize() transformations\n    let chunks = read_sorted_arrays(r);\n    let unrestricted = r();\n    //const read_chunked = () => new Set(read_sorted_array().flatMap(i => chunks[i]).concat(read_sorted_array()));\n    const read_chunked = ()=>{\n        // 20230921: build set in parts, 2x faster\n        let set = new Set();\n        read_sorted_array().forEach((i)=>set_add_many(set, chunks[i]));\n        set_add_many(set, read_sorted_array());\n        return set;\n    };\n    GROUPS = read_array_while((i)=>{\n        // minifier property mangling seems unsafe\n        // so these are manually renamed to single chars\n        let N = read_array_while(r).map((x)=>x + 0x60);\n        if (N.length) {\n            let R = i >= unrestricted; // unrestricted then restricted\n            N[0] -= 32; // capitalize\n            N = str_from_cps(N);\n            if (R) N = \"Restricted[\".concat(N, \"]\");\n            let P = read_chunked(); // primary\n            let Q = read_chunked(); // secondary\n            let M = !r(); // not-whitelisted, check for NSM\n            // *** this code currently isn't needed ***\n            /*\r\n\t\t\tlet V = [...P, ...Q].sort((a, b) => a-b); // derive: sorted valid\r\n\t\t\tlet M = r()-1; // number of combining mark\r\n\t\t\tif (M < 0) { // whitelisted\r\n\t\t\t\tM = new Map(read_array_while(() => {\r\n\t\t\t\t\tlet i = r();\r\n\t\t\t\t\tif (i) return [V[i-1], read_array_while(() => {\r\n\t\t\t\t\t\tlet v = read_array_while(r);\r\n\t\t\t\t\t\tif (v.length) return v.map(x => x-1);\r\n\t\t\t\t\t})];\r\n\t\t\t\t}));\r\n\t\t\t}*/ return {\n                N,\n                P,\n                Q,\n                M,\n                R\n            };\n        }\n    });\n    // decode compressed wholes\n    WHOLE_VALID = read_sorted_set();\n    WHOLE_MAP = new Map();\n    let wholes = read_sorted_array().concat(Array_from(WHOLE_VALID)).sort((a, b)=>a - b); // must be sorted\n    wholes.forEach((cp, i)=>{\n        let d = r();\n        let w = wholes[i] = d ? wholes[i - d] : {\n            V: [],\n            M: new Map()\n        };\n        w.V.push(cp); // add to member set\n        if (!WHOLE_VALID.has(cp)) {\n            WHOLE_MAP.set(cp, w); // register with whole map\n        }\n    });\n    // compute confusable-extent complements\n    // usage: WHOLE_MAP.get(cp).M.get(cp) = complement set\n    for (let { V, M } of new Set(WHOLE_MAP.values())){\n        // connect all groups that have each whole character\n        let recs = [];\n        for (let cp of V){\n            let gs = GROUPS.filter((g)=>group_has_cp(g, cp));\n            let rec = recs.find((param)=>{\n                let { G } = param;\n                return gs.some((g)=>G.has(g));\n            });\n            if (!rec) {\n                rec = {\n                    G: new Set(),\n                    V: []\n                };\n                recs.push(rec);\n            }\n            rec.V.push(cp);\n            set_add_many(rec.G, gs);\n        }\n        // per character cache groups which are not a member of the extent\n        let union = recs.flatMap((x)=>Array_from(x.G)); // all of the groups used by this whole\n        for (let { G, V } of recs){\n            let complement = new Set(union.filter((g)=>!G.has(g))); // groups not covered by the extent\n            for (let cp of V){\n                M.set(cp, complement); // this is the same reference\n            }\n        }\n    }\n    // compute valid set\n    // 20230924: VALID was union but can be re-used\n    VALID = new Set(); // exists in 1+ groups\n    let multi = new Set(); // exists in 2+ groups\n    const add_to_union = (cp)=>VALID.has(cp) ? multi.add(cp) : VALID.add(cp);\n    for (let g of GROUPS){\n        for (let cp of g.P)add_to_union(cp);\n        for (let cp of g.Q)add_to_union(cp);\n    }\n    // dual purpose WHOLE_MAP: return placeholder if unique non-confusable\n    for (let cp of VALID){\n        if (!WHOLE_MAP.has(cp) && !multi.has(cp)) {\n            WHOLE_MAP.set(cp, UNIQUE_PH);\n        }\n    }\n    // add all decomposed parts\n    // see derive: \"Valid is Closed (via Brute-force)\"\n    set_add_many(VALID, nfd(VALID));\n    // decode emoji\n    // 20230719: emoji are now fully-expanded to avoid quirk logic \n    EMOJI_LIST = read_trie(r).map((v)=>Emoji.from(v)).sort(compare_arrays);\n    EMOJI_ROOT = new Map(); // this has approx 7K nodes (2+ per emoji)\n    for (let cps of EMOJI_LIST){\n        // 20230719: change to *slightly* stricter algorithm which disallows \n        // insertion of misplaced FE0F in emoji sequences (matching ENSIP-15)\n        // example: beautified [A B] (eg. flag emoji) \n        //  before: allow: [A FE0F B], error: [A FE0F FE0F B] \n        //   after: error: both\n        // note: this code now matches ENSNormalize.{cs,java} logic\n        let prev = [\n            EMOJI_ROOT\n        ];\n        for (let cp of cps){\n            let next = prev.map((node)=>{\n                let child = node.get(cp);\n                if (!child) {\n                    // should this be object? \n                    // (most have 1-2 items, few have many)\n                    // 20230719: no, v8 default map is 4?\n                    child = new Map();\n                    node.set(cp, child);\n                }\n                return child;\n            });\n            if (cp === FE0F) {\n                prev.push(...next); // less than 20 elements\n            } else {\n                prev = next;\n            }\n        }\n        for (let x of prev){\n            x.V = cps;\n        }\n    }\n}\n// if escaped: {HEX}\n//       else: \"x\" {HEX}\nfunction quoted_cp(cp) {\n    return (should_escape(cp) ? \"\" : \"\".concat(bidi_qq(safe_str_from_cps([\n        cp\n    ])), \" \")) + quote_cp(cp);\n}\n// 20230211: some messages can be mixed-directional and result in spillover\n// use 200E after a quoted string to force the remainder of a string from \n// acquring the direction of the quote\n// https://www.w3.org/International/questions/qa-bidi-unicode-controls#exceptions\nfunction bidi_qq(s) {\n    return '\"'.concat(s, '\"'); // strong LTR\n}\nfunction check_label_extension(cps) {\n    if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {\n        throw new Error('invalid label extension: \"'.concat(str_from_cps(cps.slice(0, 4)), '\"')); // this can only be ascii so cant be bidi\n    }\n}\nfunction check_leading_underscore(cps) {\n    const UNDERSCORE = 0x5F;\n    for(let i = cps.lastIndexOf(UNDERSCORE); i > 0;){\n        if (cps[--i] !== UNDERSCORE) {\n            throw new Error(\"underscore allowed only at start\");\n        }\n    }\n}\n// check that a fenced cp is not leading, trailing, or touching another fenced cp\nfunction check_fenced(cps) {\n    let cp = cps[0];\n    let prev = FENCED.get(cp);\n    if (prev) throw error_placement(\"leading \".concat(prev));\n    let n = cps.length;\n    let last = -1; // prevents trailing from throwing\n    for(let i = 1; i < n; i++){\n        cp = cps[i];\n        let match = FENCED.get(cp);\n        if (match) {\n            // since cps[0] isn't fenced, cps[1] cannot throw\n            if (last == i) throw error_placement(\"\".concat(prev, \" + \").concat(match));\n            last = i + 1;\n            prev = match;\n        }\n    }\n    if (last == n) throw error_placement(\"trailing \".concat(prev));\n}\n// create a safe to print string \n// invisibles are escaped\n// leading cm uses placeholder\n// if cps exceed max, middle truncate with ellipsis\n// quoter(cp) => string, eg. 3000 => \"{3000}\"\n// note: in html, you'd call this function then replace [<>&] with entities\nfunction safe_str_from_cps(cps) {\n    let max = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Infinity, quoter = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : quote_cp;\n    //if (Number.isInteger(cps)) cps = [cps];\n    //if (!Array.isArray(cps)) throw new TypeError(`expected codepoints`);\n    let buf = [];\n    if (is_combining_mark(cps[0])) buf.push(\"\");\n    if (cps.length > max) {\n        max >>= 1;\n        cps = [\n            ...cps.slice(0, max),\n            0x2026,\n            ...cps.slice(-max)\n        ];\n    }\n    let prev = 0;\n    let n = cps.length;\n    for(let i = 0; i < n; i++){\n        let cp = cps[i];\n        if (should_escape(cp)) {\n            buf.push(str_from_cps(cps.slice(prev, i)));\n            buf.push(quoter(cp));\n            prev = i + 1;\n        }\n    }\n    buf.push(str_from_cps(cps.slice(prev, n)));\n    return buf.join(\"\");\n}\n// note: set(s) cannot be exposed because they can be modified\n// note: Object.freeze() doesn't work\nfunction is_combining_mark(cp) {\n    init();\n    return CM.has(cp);\n}\nfunction should_escape(cp) {\n    init();\n    return ESCAPE.has(cp);\n}\n// return all supported emoji as fully-qualified emoji \n// ordered by length then lexicographic \nfunction ens_emoji() {\n    init();\n    return EMOJI_LIST.map((x)=>x.slice()); // emoji are exposed so copy\n}\nfunction ens_normalize_fragment(frag, decompose) {\n    init();\n    let nf = decompose ? nfd : nfc;\n    return frag.split(STOP_CH).map((label)=>str_from_cps(tokens_from_str(explode_cp(label), nf, filter_fe0f).flat())).join(STOP_CH);\n}\nfunction ens_normalize(name) {\n    return flatten(split(name, nfc, filter_fe0f));\n}\nfunction ens_beautify(name) {\n    let labels = split(name, nfc, (x)=>x); // emoji not exposed\n    for (let { type, output, error } of labels){\n        if (error) break; // flatten will throw\n        // replace leading/trailing hyphen\n        // 20230121: consider beautifing all or leading/trailing hyphen to unicode variant\n        // not exactly the same in every font, but very similar: \"-\" vs \"\"\n        /*\r\n\t\tconst UNICODE_HYPHEN = 0x2010;\r\n\t\t// maybe this should replace all for visual consistancy?\r\n\t\t// `node tools/reg-count.js regex ^-\\{2,\\}` => 592\r\n\t\t//for (let i = 0; i < output.length; i++) if (output[i] == 0x2D) output[i] = 0x2010;\r\n\t\tif (output[0] == HYPHEN) output[0] = UNICODE_HYPHEN;\r\n\t\tlet end = output.length-1;\r\n\t\tif (output[end] == HYPHEN) output[end] = UNICODE_HYPHEN;\r\n\t\t*/ // 20230123: WHATWG URL uses \"CheckHyphens\" false\n        // https://url.spec.whatwg.org/#idna\n        // update ethereum symbol\n        //  =>  if not greek\n        if (type !== \"Greek\") array_replace(output, 0x3BE, 0x39E);\n    // 20221213: fixes bidi subdomain issue, but breaks invariant (200E is disallowed)\n    // could be fixed with special case for: 2D (.) + 200E (LTR)\n    // https://discuss.ens.domains/t/bidi-label-ordering-spoof/15824\n    //output.splice(0, 0, 0x200E);\n    }\n    return flatten(labels);\n}\nfunction array_replace(v, a, b) {\n    let prev = 0;\n    while(true){\n        let next = v.indexOf(a, prev);\n        if (next < 0) break;\n        v[next] = b;\n        prev = next + 1;\n    }\n}\nfunction ens_split(name, preserve_emoji) {\n    return split(name, nfc, preserve_emoji ? (x)=>x.slice() : filter_fe0f); // emoji are exposed so copy\n}\nfunction split(name, nf, ef) {\n    if (!name) return []; // 20230719: empty name allowance\n    init();\n    let offset = 0;\n    // https://unicode.org/reports/tr46/#Validity_Criteria\n    // 4.) \"The label must not contain a U+002E ( . ) FULL STOP.\"\n    return name.split(STOP_CH).map((label)=>{\n        let input = explode_cp(label);\n        let info = {\n            input,\n            offset\n        };\n        offset += input.length + 1; // + stop\n        try {\n            // 1.) \"The label must be in Unicode Normalization Form NFC\"\n            let tokens = info.tokens = tokens_from_str(input, nf, ef);\n            let token_count = tokens.length;\n            let type;\n            if (!token_count) {\n                //norm = [];\n                //type = 'None'; // use this instead of next match, \"ASCII\"\n                // 20230120: change to strict\n                // https://discuss.ens.domains/t/ens-name-normalization-2nd/14564/59\n                throw new Error(\"empty label\");\n            }\n            let norm = info.output = tokens.flat();\n            check_leading_underscore(norm);\n            let emoji = info.emoji = token_count > 1 || tokens[0].is_emoji; // same as: tokens.some(x => x.is_emoji);\n            if (!emoji && norm.every((cp)=>cp < 0x80)) {\n                // 20230123: matches matches WHATWG, see note 3.3\n                check_label_extension(norm); // only needed for ascii\n                // cant have fenced\n                // cant have cm\n                // cant have wholes\n                // see derive: \"Fastpath ASCII\"\n                type = \"ASCII\";\n            } else {\n                let chars = tokens.flatMap((x)=>x.is_emoji ? [] : x); // all of the nfc tokens concat together\n                if (!chars.length) {\n                    type = \"Emoji\";\n                } else {\n                    // 5.) \"The label must not begin with a combining mark, that is: General_Category=Mark.\"\n                    if (CM.has(norm[0])) throw error_placement(\"leading combining mark\");\n                    for(let i = 1; i < token_count; i++){\n                        let cps = tokens[i];\n                        if (!cps.is_emoji && CM.has(cps[0])) {\n                            // bidi_qq() not needed since emoji is LTR and cps is a CM\n                            throw error_placement('emoji + combining mark: \"'.concat(str_from_cps(tokens[i - 1]), \" + \").concat(safe_str_from_cps([\n                                cps[0]\n                            ]), '\"'));\n                        }\n                    }\n                    check_fenced(norm);\n                    let unique = Array_from(new Set(chars));\n                    let [g] = determine_group(unique); // take the first match\n                    // see derive: \"Matching Groups have Same CM Style\"\n                    // alternative: could form a hybrid type: Latin/Japanese/...\t\n                    check_group(g, chars); // need text in order\n                    check_whole(g, unique); // only need unique text (order would be required for multiple-char confusables)\n                    type = g.N;\n                // 20230121: consider exposing restricted flag\n                // it's simpler to just check for 'Restricted'\n                // or even better: type.endsWith(']')\n                //if (g.R) info.restricted = true;\n                }\n            }\n            info.type = type;\n        } catch (err) {\n            info.error = err; // use full error object\n        }\n        return info;\n    });\n}\nfunction check_whole(group, unique) {\n    let maker;\n    let shared = [];\n    for (let cp of unique){\n        let whole = WHOLE_MAP.get(cp);\n        if (whole === UNIQUE_PH) return; // unique, non-confusable\n        if (whole) {\n            let set = whole.M.get(cp); // groups which have a character that look-like this character\n            maker = maker ? maker.filter((g)=>set.has(g)) : Array_from(set);\n            if (!maker.length) return; // confusable intersection is empty\n        } else {\n            shared.push(cp);\n        }\n    }\n    if (maker) {\n        // we have 1+ confusable\n        // check if any of the remaining groups\n        // contain the shared characters too\n        for (let g of maker){\n            if (shared.every((cp)=>group_has_cp(g, cp))) {\n                throw new Error(\"whole-script confusable: \".concat(group.N, \"/\").concat(g.N));\n            }\n        }\n    }\n}\n// assumption: unique.size > 0\n// returns list of matching groups\nfunction determine_group(unique) {\n    let groups = GROUPS;\n    for (let cp of unique){\n        // note: we need to dodge CM that are whitelisted\n        // but that code isn't currently necessary\n        let gs = groups.filter((g)=>group_has_cp(g, cp));\n        if (!gs.length) {\n            if (!GROUPS.some((g)=>group_has_cp(g, cp))) {\n                // the character was composed of valid parts\n                // but it's NFC form is invalid\n                // 20230716: change to more exact statement, see: ENSNormalize.{cs,java}\n                // note: this doesn't have to be a composition\n                // 20230720: change to full check\n                throw error_disallowed(cp); // this should be rare\n            } else {\n                // there is no group that contains all these characters\n                // throw using the highest priority group that matched\n                // https://www.unicode.org/reports/tr39/#mixed_script_confusables\n                throw error_group_member(groups[0], cp);\n            }\n        }\n        groups = gs;\n        if (gs.length == 1) break; // there is only one group left\n    }\n    // there are at least 1 group(s) with all of these characters\n    return groups;\n}\n// throw on first error\nfunction flatten(split) {\n    return split.map((param)=>{\n        let { input, error, output } = param;\n        if (error) {\n            // don't print label again if just a single label\n            let msg = error.message;\n            // bidi_qq() only necessary if msg is digits\n            throw new Error(split.length == 1 ? msg : \"Invalid label \".concat(bidi_qq(safe_str_from_cps(input, 63)), \": \").concat(msg));\n        }\n        return str_from_cps(output);\n    }).join(STOP_CH);\n}\nfunction error_disallowed(cp) {\n    // TODO: add cp to error?\n    return new Error(\"disallowed character: \".concat(quoted_cp(cp)));\n}\nfunction error_group_member(g, cp) {\n    let quoted = quoted_cp(cp);\n    let gg = GROUPS.find((g)=>g.P.has(cp)); // only check primary\n    if (gg) {\n        quoted = \"\".concat(gg.N, \" \").concat(quoted);\n    }\n    return new Error(\"illegal mixture: \".concat(g.N, \" + \").concat(quoted));\n}\nfunction error_placement(where) {\n    return new Error(\"illegal placement: \".concat(where));\n}\n// assumption: cps.length > 0\n// assumption: cps[0] isn't a CM\n// assumption: the previous character isn't an emoji\nfunction check_group(g, cps) {\n    for (let cp of cps){\n        if (!group_has_cp(g, cp)) {\n            // for whitelisted scripts, this will throw illegal mixture on invalid cm, eg. \"e{300}{300}\"\n            // at the moment, it's unnecessary to introduce an extra error type\n            // until there exists a whitelisted multi-character\n            //   eg. if (M < 0 && is_combining_mark(cp)) { ... }\n            // there are 3 cases:\n            //   1. illegal cm for wrong group => mixture error\n            //   2. illegal cm for same group => cm error\n            //       requires set of whitelist cm per group: \n            //        eg. new Set([...g.P, ...g.Q].flatMap(nfc).filter(cp => CM.has(cp)))\n            //   3. wrong group => mixture error\n            throw error_group_member(g, cp);\n        }\n    }\n    //if (M >= 0) { // we have a known fixed cm count\n    if (g.M) {\n        let decomposed = nfd(cps);\n        for(let i = 1, e = decomposed.length; i < e; i++){\n            // 20230210: bugfix: using cps instead of decomposed h/t Carbon225\n            /*\r\n\t\t\tif (CM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n\t\t\t\tif (j - i > M) {\r\n\t\t\t\t\tthrow new Error(`too many combining marks: ${g.N} ${bidi_qq(str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${M})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t\t*/ // 20230217: switch to NSM counting\n            // https://www.unicode.org/reports/tr39/#Optional_Detection\n            if (NSM.has(decomposed[i])) {\n                let j = i + 1;\n                for(let cp; j < e && NSM.has(cp = decomposed[j]); j++){\n                    // a. Forbid sequences of the same nonspacing mark.\n                    for(let k = i; k < j; k++){\n                        if (decomposed[k] == cp) {\n                            throw new Error(\"duplicate non-spacing marks: \".concat(quoted_cp(cp)));\n                        }\n                    }\n                }\n                // parse to end so we have full nsm count\n                // b. Forbid sequences of more than 4 nonspacing marks (gc=Mn or gc=Me).\n                if (j - i > NSM_MAX) {\n                    // note: this slice starts with a base char or spacing-mark cm\n                    throw new Error(\"excessive non-spacing marks: \".concat(bidi_qq(safe_str_from_cps(decomposed.slice(i - 1, j))), \" (\").concat(j - i, \"/\").concat(NSM_MAX, \")\"));\n                }\n                i = j;\n            }\n        }\n    }\n// *** this code currently isn't needed ***\n/*\r\n\tlet cm_whitelist = M instanceof Map;\r\n\tfor (let i = 0, e = cps.length; i < e; ) {\r\n\t\tlet cp = cps[i++];\r\n\t\tlet seqs = cm_whitelist && M.get(cp);\r\n\t\tif (seqs) { \r\n\t\t\t// list of codepoints that can follow\r\n\t\t\t// if this exists, this will always be 1+\r\n\t\t\tlet j = i;\r\n\t\t\twhile (j < e && CM.has(cps[j])) j++;\r\n\t\t\tlet cms = cps.slice(i, j);\r\n\t\t\tlet match = seqs.find(seq => !compare_arrays(seq, cms));\r\n\t\t\tif (!match) throw new Error(`disallowed combining mark sequence: \"${safe_str_from_cps([cp, ...cms])}\"`);\r\n\t\t\ti = j;\r\n\t\t} else if (!V.has(cp)) {\r\n\t\t\t// https://www.unicode.org/reports/tr39/#mixed_script_confusables\r\n\t\t\tlet quoted = quoted_cp(cp);\r\n\t\t\tfor (let cp of cps) {\r\n\t\t\t\tlet u = UNIQUE.get(cp);\r\n\t\t\t\tif (u && u !== g) {\r\n\t\t\t\t\t// if both scripts are restricted this error is confusing\r\n\t\t\t\t\t// because we don't differentiate RestrictedA from RestrictedB \r\n\t\t\t\t\tif (!u.R) quoted = `${quoted} is ${u.N}`;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthrow new Error(`disallowed ${g.N} character: ${quoted}`);\r\n\t\t\t//throw new Error(`disallowed character: ${quoted} (expected ${g.N})`);\r\n\t\t\t//throw new Error(`${g.N} does not allow: ${quoted}`);\r\n\t\t}\r\n\t}\r\n\tif (!cm_whitelist) {\r\n\t\tlet decomposed = nfd(cps);\r\n\t\tfor (let i = 1, e = decomposed.length; i < e; i++) { // we know it can't be cm leading\r\n\t\t\tif (CM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n\t\t\t\tif (j - i > M) {\r\n\t\t\t\t\tthrow new Error(`too many combining marks: \"${str_from_cps(decomposed.slice(i-1, j))}\" (${j-i}/${M})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t*/ }\n// given a list of codepoints\n// returns a list of lists, where emoji are a fully-qualified (as Array subclass)\n// eg. explode_cp(\"abcd\") => [[61, 62, 63], Emoji[1F4A9, FE0F], [64]]\n// 20230818: rename for 'process' name collision h/t Javarome\n// https://github.com/adraffy/ens-normalize.js/issues/23\nfunction tokens_from_str(input, nf, ef) {\n    let ret = [];\n    let chars = [];\n    input = input.slice().reverse(); // flip so we can pop\n    while(input.length){\n        let emoji = consume_emoji_reversed(input);\n        if (emoji) {\n            if (chars.length) {\n                ret.push(nf(chars));\n                chars = [];\n            }\n            ret.push(ef(emoji));\n        } else {\n            let cp = input.pop();\n            if (VALID.has(cp)) {\n                chars.push(cp);\n            } else {\n                let cps = MAPPED.get(cp);\n                if (cps) {\n                    chars.push(...cps); // less than 10 elements\n                } else if (!IGNORED.has(cp)) {\n                    // 20230912: unicode 15.1 changed the order of processing such that\n                    // disallowed parts are only rejected after NFC\n                    // https://unicode.org/reports/tr46/#Validity_Criteria\n                    // this doesn't impact normalization as of today\n                    // technically, this error can be removed as the group logic will apply similar logic\n                    // however the error type might be less clear\n                    throw error_disallowed(cp);\n                }\n            }\n        }\n    }\n    if (chars.length) {\n        ret.push(nf(chars));\n    }\n    return ret;\n}\nfunction filter_fe0f(cps) {\n    return cps.filter((cp)=>cp != FE0F);\n}\n// given array of codepoints\n// returns the longest valid emoji sequence (or undefined if no match)\n// *MUTATES* the supplied array\n// disallows interleaved ignored characters\n// fills (optional) eaten array with matched codepoints\nfunction consume_emoji_reversed(cps, eaten) {\n    let node = EMOJI_ROOT;\n    let emoji;\n    let pos = cps.length;\n    while(pos){\n        node = node.get(cps[--pos]);\n        if (!node) break;\n        let { V } = node;\n        if (V) {\n            emoji = V;\n            if (eaten) eaten.push(...cps.slice(pos).reverse()); // (optional) copy input, used for ens_tokenize()\n            cps.length = pos; // truncate\n        }\n    }\n    return emoji;\n}\n// ************************************************************\n// tokenizer \nconst TY_VALID = \"valid\";\nconst TY_MAPPED = \"mapped\";\nconst TY_IGNORED = \"ignored\";\nconst TY_DISALLOWED = \"disallowed\";\nconst TY_EMOJI = \"emoji\";\nconst TY_NFC = \"nfc\";\nconst TY_STOP = \"stop\";\nfunction ens_tokenize(name) {\n    let { nf = true } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    init();\n    let input = explode_cp(name).reverse();\n    let eaten = [];\n    let tokens = [];\n    while(input.length){\n        let emoji = consume_emoji_reversed(input, eaten);\n        if (emoji) {\n            tokens.push({\n                type: TY_EMOJI,\n                emoji: emoji.slice(),\n                input: eaten,\n                cps: filter_fe0f(emoji)\n            });\n            eaten = []; // reset buffer\n        } else {\n            let cp = input.pop();\n            if (cp == STOP) {\n                tokens.push({\n                    type: TY_STOP,\n                    cp\n                });\n            } else if (VALID.has(cp)) {\n                tokens.push({\n                    type: TY_VALID,\n                    cps: [\n                        cp\n                    ]\n                });\n            } else if (IGNORED.has(cp)) {\n                tokens.push({\n                    type: TY_IGNORED,\n                    cp\n                });\n            } else {\n                let cps = MAPPED.get(cp);\n                if (cps) {\n                    tokens.push({\n                        type: TY_MAPPED,\n                        cp,\n                        cps: cps.slice()\n                    });\n                } else {\n                    tokens.push({\n                        type: TY_DISALLOWED,\n                        cp\n                    });\n                }\n            }\n        }\n    }\n    if (nf) {\n        for(let i = 0, start = -1; i < tokens.length; i++){\n            let token = tokens[i];\n            if (is_valid_or_mapped(token.type)) {\n                if (requires_check(token.cps)) {\n                    let end = i + 1;\n                    for(let pos = end; pos < tokens.length; pos++){\n                        let { type, cps } = tokens[pos];\n                        if (is_valid_or_mapped(type)) {\n                            if (!requires_check(cps)) break;\n                            end = pos + 1;\n                        } else if (type !== TY_IGNORED) {\n                            break;\n                        }\n                    }\n                    if (start < 0) start = i;\n                    let slice = tokens.slice(start, end);\n                    let cps0 = slice.flatMap((x)=>is_valid_or_mapped(x.type) ? x.cps : []); // strip junk tokens\n                    let cps = nfc(cps0);\n                    if (compare_arrays(cps, cps0)) {\n                        tokens.splice(start, end - start, {\n                            type: TY_NFC,\n                            input: cps0,\n                            cps,\n                            tokens0: collapse_valid_tokens(slice),\n                            tokens: ens_tokenize(str_from_cps(cps), {\n                                nf: false\n                            })\n                        });\n                        i = start;\n                    } else {\n                        i = end - 1; // skip to end of slice\n                    }\n                    start = -1; // reset\n                } else {\n                    start = i; // remember last\n                }\n            } else if (token.type !== TY_IGNORED) {\n                start = -1; // reset\n            }\n        }\n    }\n    return collapse_valid_tokens(tokens);\n}\nfunction is_valid_or_mapped(type) {\n    return type == TY_VALID || type == TY_MAPPED;\n}\nfunction requires_check(cps) {\n    return cps.some((cp)=>NFC_CHECK.has(cp));\n}\nfunction collapse_valid_tokens(tokens) {\n    for(let i = 0; i < tokens.length; i++){\n        if (tokens[i].type == TY_VALID) {\n            let j = i + 1;\n            while(j < tokens.length && tokens[j].type == TY_VALID)j++;\n            tokens.splice(i, j - i, {\n                type: TY_VALID,\n                cps: tokens.slice(i, j).flatMap((x)=>x.cps)\n            });\n        }\n    }\n    return tokens;\n}\n\nvar _c;\n$RefreshReg$(_c, \"Array_from\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYWRyYWZmeS9lbnMtbm9ybWFsaXplL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUEsbUNBQW1DO0FBQ25DLHNEQUFzRDtBQUN0RCw0RUFBNEU7QUFDNUUsNERBQTREO0FBQzVELDRFQUE0RTtBQUM1RSxJQUFJQSxlQUFlO0FBQ25CLE1BQU1DLFNBQVMsSUFBSUMsSUFBSTtJQUFDO1FBQUM7UUFBSztLQUFhO0lBQUM7UUFBQztRQUFLO0tBQWlCO0lBQUM7UUFBQztRQUFNO0tBQWE7Q0FBQztBQUN6RixNQUFNQyxVQUFVO0FBRWhCLFNBQVNDLGtCQUFrQkMsS0FBSztJQUMvQixJQUFJQyxNQUFNO0lBQ1YsU0FBU0M7UUFBUSxPQUFPLEtBQU0sQ0FBQ0QsTUFBTSxJQUFJLElBQUtELEtBQUssQ0FBQ0MsTUFBTTtJQUFFO0lBRTVELDZCQUE2QjtJQUM3QixJQUFJRSxlQUFlRDtJQUNuQixJQUFJRSxRQUFRO0lBQ1osSUFBSUMsTUFBTTtRQUFDO1FBQUc7S0FBRSxFQUFFLCtCQUErQjtJQUNqRCxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUgsY0FBY0csSUFBSztRQUN0Q0QsSUFBSUUsSUFBSSxDQUFDSCxTQUFTRjtJQUNuQjtJQUVBLDREQUE0RDtJQUM1RCxJQUFJTSxPQUFPTjtJQUNYLElBQUlPLGNBQWNSO0lBQ2xCQSxPQUFPTztJQUVQLElBQUlFLGFBQWE7SUFDakIsSUFBSUMsY0FBYztJQUNsQixTQUFTQztRQUNSLElBQUlGLGNBQWMsR0FBRztZQUNwQixzQ0FBc0M7WUFDdEMsZ0NBQWdDO1lBQ2hDQyxjQUFjLGVBQWdCLElBQUtYLEtBQUssQ0FBQ0MsTUFBTTtZQUMvQ1MsYUFBYTtRQUNkO1FBQ0EsT0FBTyxlQUFnQixFQUFFQSxhQUFjO0lBQ3hDO0lBRUEsTUFBTUcsSUFBSTtJQUNWLE1BQU1DLE9BQU8sS0FBR0Q7SUFDaEIsTUFBTUUsT0FBT0QsU0FBUztJ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LENBQUMvRyxDQUFBQSxLQUFNbUYsVUFBVTNDLEdBQUcsQ0FBQ3hDO0FBQ3JDO0FBRUEsU0FBU3dNLHNCQUFzQnpDLE1BQU07SUFDcEMsSUFBSyxJQUFJN08sSUFBSSxHQUFHQSxJQUFJNk8sT0FBT3hNLE1BQU0sRUFBRXJDLElBQUs7UUFDdkMsSUFBSTZPLE1BQU0sQ0FBQzdPLEVBQUUsQ0FBQ21PLElBQUksSUFBSXFDLFVBQVU7WUFDL0IsSUFBSTlNLElBQUkxRCxJQUFJO1lBQ1osTUFBTzBELElBQUltTCxPQUFPeE0sTUFBTSxJQUFJd00sTUFBTSxDQUFDbkwsRUFBRSxDQUFDeUssSUFBSSxJQUFJcUMsU0FBVTlNO1lBQ3hEbUwsT0FBT3VDLE1BQU0sQ0FBQ3BSLEdBQUcwRCxJQUFJMUQsR0FBRztnQkFBQ21PLE1BQU1xQztnQkFBVTdMLEtBQUtrSyxPQUFPMUssS0FBSyxDQUFDbkUsR0FBRzBELEdBQUdJLE9BQU8sQ0FBQ3BDLENBQUFBLElBQUtBLEVBQUVpRCxHQUFHO1lBQUM7UUFDckY7SUFDRDtJQUNBLE9BQU9rSztBQUNSO0FBRWtLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYWRyYWZmeS9lbnMtbm9ybWFsaXplL2Rpc3QvaW5kZXgubWpzPzk1ODkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gY3JlYXRlZCAyMDIzLTA5LTI1VDAxOjAxOjU1LjE0OFpcbi8vIGNvbXByZXNzZWQgYmFzZTY0LWVuY29kZWQgYmxvYiBmb3IgaW5jbHVkZS1lbnMgZGF0YVxuLy8gc291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vYWRyYWZmeS9lbnMtbm9ybWFsaXplLmpzL2Jsb2IvbWFpbi9zcmMvbWFrZS5qc1xuLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vYWRyYWZmeS9lbnMtbm9ybWFsaXplLmpzI3NlY3VyaXR5XG4vLyBTSEEtMjU2OiAwNTY1ZWQwNDliOWNmMTYxNGJiOWUxMWJhN2Q4YWM2YTZmYjk2Yzg5MzI1M2Q4OTBmN2UyYjI4ODRiOWRlZDMyXG52YXIgQ09NUFJFU1NFRCQxID0gJ0FFRVVkd21nRFM4QnhRS0tBUDRCT2dEakFUQUFuZ0RVQUlNQW9BQm9BT0FBYWdDT0FFUUFoQUJNQUhJQU93QTlBQ3NBTmdBbUFHSUFIZ0F1QUNnQUp3QVhBQzBBR2dBakFCOEFMd0FVQUNrQUVnQWVBQWtBR3dBUkFCa0FGZ0E1QUNnQUxRQXJBRGNBRlFBcEFCQUFIZ0FpQUJBQUdnQWVBQk1BR0FVaEJlOEJGeFJFTjhzRjJ3QzVBSzVIQVc4QXJRa0R6UUN1aHpjM056Y0JQNjhORWZNQUJRZEhCdXc1QlY4RllBQTlNemtJOXI0WkJnN1F5UUFXQTlDZU93TE5DamNDanFrQ2h1QS9sbStSQXNYVEFvUDZBU2ZuRVFEeXRRRkpBaldWQ2tlWEFPc0E2Z29kQUIvY3dkQVVFMFdsQkNOL0FRVUNRUmpGRC9NUkJqSHhEUVNKYncwakJ6VUFzd0J4bWUrdG5JY0FZd2FiQXlzRzhRQWpBRU1NbXhjRHFnUEtReURYQ01NeEE3a1VRd0QzTlhPckFLbUZJQUFmQkMwRDN4NEJKUURCR2RVRkFoRWdWRDhKbndtUUppTldZVXpyZzBvQUd3QVVBQjBBRm5OY0FDa0FGZ0JQOWgzZ1Bmc0RPV0RLbmVZMkNoZ2xYMVVEWUQzMEFCc0FGQUFkQUJaeklHUkFud0REOHdBakFFRU16UmJEcWdNQjJzQUZZd1hxQXRDbkFzUzRBd3BVSktSdEZIc2FkVXo5QU1NVmJ3THBBQk0xTkpFWDBaa0NnWU1CRXlNQXhSVnZBdWtBRXpVQlVGQXRtVXdTQXk0REJURVIzM0VmdFFIZlN3QjVNeEovQWprV0tRTHpMOEUvY3dCQjZRSDlMUURQRHRPOUFTTnJpUUM1RFFBTkF3Q0syMUVGSTkxekh3Q29MOWtCcVFjSEJ3Y0hLelVEb3dCdkFRb2hQdlUzZkFRZ0h3Q3lBYzhDS1FNQTV6TVNlenI3VUxnRm1EcC9MelZRQmdFR0FpOEZZUVZndDhBRmNUdGxRaHBDV0VtZmU1dG1aNklBRXhzRHpROHQrWDhyQkt0VEFsdGJBbjBqc3k4Qmw2dXRQV01EVFI4RWkya1JBTmtEQnJOSE55c0RCekVDUVdVQWN3RnBKM2tBaXlVaEFKMEJVYjhBTDNFZkFiZk5BejgxS1VzRld3RjNZUVp0QW0wQStWRWZBekVKRFFCUlNRQ3pBUUJsQUhzQU03MEdEL3YzSVpXSEJ3QVJLUUF4QUxzalR3SFpBZU1QRXptWGdJSHdBQklBR1FBOEFFVUFRRHQzZ2R2SUVHY1FaQWtHVFJGTWRFSVZFd0swRDY0TDdSRWRETmtxMDlQZ0FEU3hCL01EV3dmekExc0RXd2Z6Qi9NRFd3ZnpBMXNEV3dOYkExc2NFdkFpMjhnUVp3OVFCSFVGbGdXVEJONElpeVpSRVlrSE1BamFWQlYwSmh4UEEwMEJCQ010U1NRN216TVRKVXBNRkUwTENBUTJTbXl2ZlVBRFR6R3pWUDJRcWdQVE1sYzVkQWtHSG5rU3FBQXlEM3NrTmIxT2hucFBjYWdLVTArMnRZZEphazV2QXNZNnNFQUFDaWtKbTIvRGQxWUdSUkFmSjZrUSt3dzNBYmtCUHczeFM5d0U5UVkvQk0wZmdSa2REOUdWb0FpcExlRU04U2JuTHFXQVhpUDVLb2NGOFV2NFBPRUxVVkZzRDEwTGFRbm5PbWVCVWdNbEFSRWlqd3JoRFQwSWNSRDNDczF2RGVrUlNRYzlBOWxKbmdDcEJ3VUxGUjA1RmJrbUZHS3dDdzA1ZXdiL0d2b0xreWF6RXkxN0FBWFhHaVVHVVFFdEd3TUEweTdyaGJSYU5Wd2dUMk1HQndzcEk4c1VyRkFrRFNsQXUzaE1HaDhIR1NXdEFwVkRkRXFMVVRvZWx5SDZQRUVOYWk0WFVZQUgrVHdKR1ZNTGhUeWlScTlGRWhIV1BwRTlUQ0pOVERBRU9ZTXNNeWVQQ2RNUGlReTlmSFlCWFFrbENiVU1kUk0xRVJzM3lRZzlCeDB4bHlnbkdRZ2xScGxnbmdUN293UDNFOVVERHdWRENVVUhGd081SERFVE1oVXRCUkdCS05zQzl6YlpMcmNDazFhRUFSc0Z6dzhwSCtNUVZFZmtEdTBJbndKcEE0Y2w3d0F4RlNVQUd5S2ZDRWRuQUdPUDNGTUpMczhJeTJwd0kzZ0RheFRyWlJGM0I1VU9Xd2VySERjVnd4emxjTXhlRDRZTUtLZXpDVjhCZVFtZEFXTUU1d2dOTlYrTXBDQkZaMWVMWEJpZklHVkJRMTRBQWpVTWFSV2pSTUdIZkFLUEQyOFNId0U1QVhjSFBRMEZBbnNSOFJGdkVKa0k3NFlJTmJrei9Eb3BCRk1oaHlBVkNpc0RVMnpTQ3lzbS9RejhiUUduRW1ZREVEUkJkL0pucjJDNktCZ0JCeDB5eVVGa0lmVUxsay9SREtBYXhSaEdWRElaNkFmREEvY2E5eWZ1UVZzR0F3T25CeGM2VVRQeUJNRUxiUWlQQ1VNQVRRNm5Hd2ZiR0c0S2RZelVBVFdQQWJ1ZEExdVZod0p6a3dZN0J3OEFhdytMQlgzcEFDRUNxd2luQUFrQTB3TmJBRDBDc1FlaEFCMEFpVVVCUVFNck13RWw2UUtUQTVjSU5jOEJtVE1COXkwRUg4Y01HUUQ3TzI1T0FzTzFBb0J1WnFZRjRWd0NrZ0pOT1FGUktRUUpVa3RWQTdOMTVRRGZBRThHRitOTEFSbXZUczhlNTBjQjQzTXZBTXNBL3dBSk9RY0pSUUhSQWZkeEFMc0JZd3MxQ2FhM3VRRlI3UzBBaHdBWmJ3SGJBbzBBNFFBNUFJUDFBVmNBVVFWZC9RWFhBbE5OQVJVMUhDOWJaUUcvQXlNQk53RVJBSDBHejVHcHpRc2pCSEVIMXdJUUh4WGxBdTh5QjdrRkF5TGpFOUZDeVFLOTRsa0FNaG9LUEFxckNxcGdYMlEzQ2pWMlBWUUFFaCtzUHNzL1VnVlZPMWM3WER0WE8xdzdWenRjTzFjN1hEdFhPMXdEbThQbXcrWUtjRjlKWWU4TXFnM1lSTXc2VFJQZllGVmdOaFBNTGJzVXhSWFNKVm9aUVJyQUp3a2w2RlVORHdndDEyWTBDREEwZVJmQUFFTXBiSU5GWTRvZU5BcFBIT3RUbFZUOExSOEF0VXVtTTdNTnNCc1pSRVFGUzNYeFlpNFdFZ29tQW1TRkFtSkdYMUd6QVY4M0pBS2grd0pvbkFKbURRS2ZpRGdmRHdKbVB3Sm1LZ1J5QklNRGZ4Y0RmcFk1Q2psN0d6bUdPaWNuQW13aEFqSTZPQTRDYmNzQ2JiTHpqZ00zYTBrdkFXc0E0Z0RsQUU0SkI1d01rUUVDRDhZQUVia0Nkek1DZHFaREFubFBSd0o0dmlGZzMwV3lSdmNDZkVNQ2Vzd0NmUTBDZlBSSUJFaUJaeWdBTHhsSlhFcGZHUnRLMEFMUkJRTFEwRXNyQTRoVEE0ZnFSTW1STmdMeXBWMEhBd095UzlKTU1Ta0gwMDFRVGJNQ2kwTUNpdHpGSHdzaFIyc0p1d0tPT3dLT1lFU2JoUUtPM1FLT1lIeFJ1Rk01QVE1UzJGU0pBcFAvQXBNUUFPMEFJRlVpVmJOVjFBb3NIeW1aaWpMbGVHcEZQejBDbDZNQzc3WllKYXdBWFNrQ2xwTUNsb0NnQUsxWnNGb05oVkVBUHdLV3VRS1dVbHhJWE5VQ21jOENtV2hjemwwTEhRS2Nuem5HT3FFQ25Cb0NuNThDbnJ5T0FDRVROUzRUQXAzMUFwNldBTGxCWVRoaDh3S2Uxd0tnY2dHdEFwNmpJd0tlVXFsanpHUXJLUzhDSjdNQ0pvSUNvUDhDb0ZEYkFxWXpBcVhTQXFnREFJRUNwL1pvZ0dpMUFBZE5haUJxMVFLczV3S3NzZ0t0YXdLdEJnSlhJUUpWNEFLeDVkc0RIMUpzbXdLeXdSRUNzdXdiYk9SdFoyMU1Zd01sMFFLMllEOURicFFES1VrQ3VHSUN1VXNaQXJrdWUzQTZjT1VDdlIwRExiWURNaFVDdm94eUJnTXpkUUsrSG5NbWMxTUN3ODhDd3doemhuUlBPVWwwNUFNOHF3RURQSjREUGNNQ3hZQUN4a3NDeGhTTkFzaHRWUUxJU0FMSlV3TEpNZ0prb1FMZDFuaDlaWGl5ZVNsTDFBTVlwMmNHQW1INEdmZVZLSHNQWHBaZXZ4VUN6MjhDejNBelQxZlc5eGVqQU1xeEFzOTNBUzN1QTA0V2ZrOEpBdHdyQXR1T0F0SlRBMUpnQTFOakFRVURWWkNBalVNRXp4cnhaRWw1QTRMU2c1RUMyc3NDMmVLRUZJUk5wMEFEaHFrQU13TmtFb1oxWGYwQVdRTGZhUUxldkhkN0F1SXo3UmdCOHpRckFmU2ZBZkxXaXdMcjl3THBkSDBEQXVyOUF1cm9BUDFMQWIwQzdvMEM2NkNXcnBjSEF1NURBNFhrbUgxdzVIR2xBdk1IQUcwRGpocVpsd0wzRndPUmNnT1Npd0wzbkFMNTNRTDRhcG9nbXErL081c2lBNTJIQXY3K0FSOEFQWjhnQVorM0F3V1JBNlp1QTZiZEFOWEpBd1p1b1l5aUNRMERERTBCRXdFakIzRUdaYjFyQ1FDL0JHL0RGWThldHhFQUczazlBQ2NETnhKUkE0MkRBV2NySlFDTTh3QWxBT2FuQzZPVkNMc0dJNmZKQmdDdkJSbkRCdkVsUlVZRkZvQUZjRDlHU0ROQ0tVSzhYM2taWDhRQWxzMEZPZ0NRVkNHYndUc3VZRG9adXRjT054ak9HSkhKL2dWZkJXQUZYd1ZnQldzRllBVmZCV0FGWHdWZ0JWOEZZQVZmQldCT0hRamZqVzhLQ2dvS2JGN3hNd1RSQTdrR044UERBTU1FcjhNQTcwZ3hGcm9GVGo1eFBuaENSMEsrWDMwL1gvQUFXQmt6c3dDTkJzeHp6QVNtNzBhQ1JTNHJERE1lTHo0OWZuWGZjc0g1R2Nvc2NRRnoxM1k0SHdWbkJYTEp5Y25BQ05kUll3Z0lDQXFFWG9XVHhnQTdQNGtBQ3hiWkJ1MjFLdzBBak1zVEF3a1ZBT1Z0SlVVc0oxSkN1VUxFU1VBclh5OWdQaTlBS3duSlJRWUtURDlMUG9BK2lUNTRQbmtDa1VMRVVVcERYOU5XVjNKVkVqUUFjMXczQTNJQkUzWW5YK2c3UWlNSmI2TUthaXN6UkNVdVFyTkN4RFBNQ2N3RVg5RVdKellSRUJFRUJ3SUhLbjZsMzNKQ05WSWZ5YlBKdEFsdHlkUFVDbWhCWncvdEVLc1pBSk9WSlUxQ0xSdXhiVUhPUUFvN1AwcytlRUpISEE4U0pWUlBkR00wTlZycHZCb0toZlVsTTBKSEhHVVFVaEVXTzF4TFNqOE1PMHVjTkFxSkl6VkNSeHY5RUZzcUt5QTRPUWdOajJud1pncDVaTkZnRTJBMUszWUhTMkFoUVFvakptQzdEZ3B6R0cxV1lGVVpDUVlIWk85Z0hXQ2RZSVZndTJCVFlKbHdGaDhHdlJiY1hiRzhZZ3RESHJNQnd6UFZ5UW9uSFFna0N5WUJnUUowQWpjNG5WcUlBd0dTQ3NCUElnRHNLM1NXRXRJVkJhNU44Z0dqQW8ra1Z3Vklad0QvQUVVU0NEd2VYNElUclJRc0o4SzNUd0JYRkR3RUFCMFR2elZjQXRvVFMyMFJJd0RnVmdaOUJCSW1ZZ0E1QUw0Q29pOExGbmV6T2tDbklRRmpBWTRLQkFQaDlSY0dzZ1pTQnNFQUpjdGRzV0lSdTJrVGtRc3RSdzdEQWNNQktncFBCR0lHTURBd0tDWW5LVFFhTGc0QUtSU1ZBRndDZGwrWVVaMEpkaWNGRDNsUEFkdDFGOVpaS0NHeHVFM3lCeGtGVkdjQS93QkZFZ2lDQndBT0xIUVNqeE90UURnMXo3ZGVGUk1BWjhRVEFHdEtiMUFwSWlQSEFEa0F2Z0tpTHkxREZ0WUNtQmlEQWxERFdOQjBlbzdmcGFNTy9hRVZSUnYwQVRFUVpCSU9EeU1FQWM4SlFoQ2JEUmd6RkQ0VEFFTUF1OVlCQ2dDc0FPa0FtNUkzQUJ3QVl4dk9OblIrTWhYSkF4Z0tReXhMMitra0poTWJoUUtEQk1rU3N2RjBBRDlCTlE2dVFDN1dxU1FId3hFQUVFSXUxaGtoQUgyejRpUVB3eUpQSE5XcGR5WUJSU3BuSkFMem9CQUVWUFBzSDIwTXhBMENDRVFLUmdBRnlBdEZBbE1Od3dqRURVUUpSQXJFTHRhcE1nN0REWmdKSXcrVEd1a0VJd3ZERmtNQXFBdERFTU1NQmhpb2UrUUFPM01NUkFBQ3JnbkVCU1BZOVEwRkRuYlNCb01BQjhNU1l4a1N4QUVKQVBJSkFBQjhGV01PRnRNYy9IY1h3eGhEQUM3REF2T293d0Fld3dKZEtES0hBQUhEQUFMckZVUVZ3d0Fid3l2enBXTVd2OHdBL0FCcEF5KytiY1lEVUtQRDBLaERDd0ttSjFNQUFtTUE1K1Vad3hBYWd3aXBCUkwvZUFEZnc2ZkRHT01DR3NPamszbDZCd09wbzRzQUVzTU9HeE1BQTVzQWJjTU9BQXZEcDBNSkdrTUR3Z2lwbk5JUEF3ZklxVU1HQU9HREFBUHpBQlhEQUFjREFBbkRBR21UQUJyREFBN0RDaGpEam5FV0F3QUJZd0FPY3dBdVV5WUFCc01BRjhNSUtRQU5VZ0M2d3k0QUE4TUFEcU1xOHdDeVlnQWNJd0FCOHdxcEFBWE9DeDBWNHdBSG93QkN3d0VLQUduREFBdURBQjNEQUFqRENha0FCZElBYnFjWjNRQ1pDQ2tBQmRJQUFBRkRBQWZqQUIyakNDa0FCcUlBQ1lNQUd6TUFiU01BNXNPSUFBaGpBQWhEQUJUREJBa3BBQWJTQU9PVEFBbERDNmtPelB0bkFBZERBRzZrUUZBQVR3QUt3d3dBQTBNQUNiVURQd0FISXdBWmd3QUNFNmNEQUFvakFBcERBQW9EcC9NR3d3QUpJd0FERXdBUVF3Z0FGRU1BRVhNQUQ1TUFEZk1BRGNNQUdSTU9GaU1BRlVNQWJxTVd1d0hEQU1JQUUwTUxBR2t6RWdEaFV3QUNRd0FFV2dBWGd3VWpBQWJZQUJqREJTWUJnekJhQUVGTkFMY1FCeFVNZWdBd01uZ0JyQTBJWmdKMEt4UUhCUkVQZDFOMFp6S1JKd2FJSEFacU5UNERxUXE4QnduZ0FCNERBd3QyQVg1NlQxb2NLUU5YQWgxR0FUUUdDM3RPeFlOYWdrZ0FNUUE1Q1FBREFRRUFXeExqQUlPWU5BRXpBSDd0RlJrNlRnbFNBRjhOQUFsWUFRK1MxQUNBUXdRb3JRQmlBTjRkQUoxd1B5ZVRBTlZ6dVFEWDNBSWVFTXA5ZXlNZ1hpVUFFZGtCa0ppektsdGJWVkFhUk1xUkFBRUFoeVEvU0RFejZCbWZWd0I2QVRFc09DbEtJUmNET0YwRS84MzJBRk50NUFCeUFua0NSeEdDT3M5NE5qWGRBd0lOR0JvbkRCd1BBTFcyQXdJQ0FnQUFBQUFBQUFZREJRTURBUnJVQXdBdEFBQUFBZ0VHQmdZR0JnWUZCUVVGQlFVRUJRWUhDQWtFQlFVRkJRUUFBQUlDQUFBQUlnQ05BSkFBbFQwQTZnQzdBTndBcEVRQXdnQ3lBSzBBcUFEdUFLWUEyZ0NqQU9jQkNBRURBTWNBZ1FCaUFOSUExQUVEQU40QThnQ1FBS2tCTVFEcUFOOEEzQXNCQ1E4eU85cmEydHE4eHVMVDF0UkpPQjBCVWdGY05VMEJXZ0ZwQVdnQld3Rk1VVWxMYmhNQlV4c05FQXM2UGhNT0FDY1VLeTB2TWo1QVFFTkRRMFJGRkVZR0pGZFhWMWRaV1ZoWkwxcGJYVnhjSTJObloyWm9aeXBzYm5aMWVIaDRlSGg0ZW5wNmVucDZlbnA2ZW5wOGZIMThlMklBUlBJQVNRQ2FBSGdBTWdCbStBQ09BRmNBVndBM0FuYnZBSXNBQmZqNEFHUUFrL0lBbndCUEFHSUFaUC8vc0FDRkFJVUFhUUJXQUxFQUpBQzJBSU1DUUFKREFQd0E1d0QrQVA0QTZBRC9BT2tBNlFEb0FPWUFMd0o3QVZFQlFBRStBVlFCUGdFK0FUNEJPUUU0QVRnQk9BRWNBVmdYQURFUUNBRUFVeDhTSGdzZEhoWUFqZ0NXQUtZQVVRQnFJQUl4QUhZQWJ3Q1hBeFVESnpJRElVbEdUekVBa1FKUEFNY0NWd0trQU1BQ2xnS1dBcFlDbGdLV0FwWUNpd0tXQXBZQ2xnS1dBcFlDbGdLVkFwVUNtQUtnQXBjQ2xnS1dBcFFDbEFLVUFwUUNrZ0tWQW5VQjFBS1hBcDhDbGdLV0FwVWVBSUVUQlFEK0RRT2ZBbUVDT2g4QlZCZzlBdUlaRWpNYkFVNC9HMVdaQVh1c1JBRnBZUUVGQTBGUEFRWUFtVEVlSUpkeUFERm9BSEVBTmdDUkE1ek1rL0MyakdJTndqTVd5Z0laQ2FYZGZESUxCQ3M1ZEFFN1luUUJ1Z0RsaG9pSGhvaUdpWXFLaG91T2pJYU5rSTZJajRxUWlwR0drb2FUaHBTU2xZYVdocGVLbUlhWmhwcUdtNGFjaTUyUW5vcWZodUlDNFhUcEF0OTBBSXAwTEhTb0FJc0FkSFFFUXdSQUJFSUVSUVJEQkVrRVJnUkJCRWNFU1FSSUJFUUVSZ1JKQUo1dWRBQ3JBNDkwQUx4dUFRMTBBTkZaZEhRQTEzUUNGSFFBL21KMEFQNEJJUUQrQVB3QS9BRDlBUHdEaEdaMDNBU01LMjNIQVA0QS9BRDhBUDBBL0NSMGRBQ1JZblFBL2dDUkFTRUEvZ0NSQXZRQS9nQ1JBNFJtZE53RWpDdHR4eVIwQVA5aWRBRWhBUDRBL2dEOEFQd0EvUUQ4QVA4QS9BRDhBUDBBL0FPRVpuVGNCSXdyYmNja2RIUUFrV0owQVNFQS9nQ1JBUDRBa1FMMEFQNEFrUU9FWm5UY0JJd3JiY2NrZEFKTEFUNTBBbElCUVhRQ1U4bDBkQUpmZEhRRHBnTDBBNllEcGdPbkE2Y0Rwd09uQTRSbWROd0VqQ3R0eHlSMGRBQ1JZblFCSVFPbUFKRURwZ0NSQXZRRHBnQ1JBNFJtZE53RWpDdHR4eVIwQkRoMEFKRUVPUUNSRHBVNWRTZ0NBRFIwM2dWMkN3QXJkQUVGQU01aUNuUjBBRjFpQUFZY09ncDBkQUNSQ25RQVhBRUl3V1owQ25SbWRIUUFrV1owQ25SbWRFWGdBRkYwM2dwMGRFWTB0bFQydTNTT0FRVHdzY3doalpaS3JoWWNCU2ZGcDlYTmJLaVZET0QyYitjcGU0L1oxN21RbmJ0enpoYWVRdEUyR0dqMElETlRqUlVTeVR4eHcvUlBIVy8rdlM3ZDFOZlJ0OXo5UVBaZzRYN1FGZmhDbmt2Z05QSUl0T3NDMmVWNmhQYW5uWk5IbFo5eHJ3WlhJTU9sdTNqU29RU3E3OFdFandMancxRUxTbEYxYUJ2Znp3azVaWDdBVXZRempQUUtiRHVRK3NtNHdOT3A0QTZBZFZ1UlMwdDF5L0RacGc0UjZtN0ZOak05SGd2VzdCaTg4emFNak9vNmxNOHd0QkJkajhMUDR5bHYzekNYUGhlYk1LSmMwNjZvOXNGNzFvRlcvOEpYdTg2SEpid0RJRDVsenc1R1dMUi9MaFQwUXFucDJKUXhOWk5mY2JMSXpQeStZeXBxUm0vbEJtR21leCs4MitQaXN4VXVtU2VKa0FMSVQ2ckplenhNSCtDVEptUXR0NXV3VFZiTDNwdG1qRFVRemxTSXZXaThUbDduZzFOcHVSbjFOZzRuMTRRYyszSWlsN093a3ZOV29nTFNQa24zcGloSUZ5dHlJR21NaE9lM24xdFdzdU15OUJkS3lxRjRaM3YyU2dnZ1RMOUtWdk1YUG5DYlJlK29PdUZGUDNIZWpCRy93OWd2bWZOWXZnNkp1V2lhMmxjU1NOMXVJakJrdHpvSWF6T0hQSlo3a0tIUHo4bVJXVmRXM2xBOFdHRjlkUUY2Qm02NzNib292M0JVV0RVMkpOY2FoUjIzR3RmSEtMT3ovdmlaK3JZblpGYUl6blhPNjdDWUVKMWZYdVRScFpoWVprS2U1NHhlb2Fna05HTHMrTlRaSEUwclg0NS9YdlEyUkdBRFg2dmNBdmR4SVVCVjI3d3hHbTJ6alpvNFgzSUxnQWxyT0ZoZXVaNnd0c3ZhSWo0eUxZN3FxYXdsbGlhSWNyejJHK2MzdnNjQW5Da0N1TXpNbVp2TWZ1OWxMd1R2ZlgrM2NWU3lQZE45WndnRFpoZmpSZ05KY0xpSjY3Yjl4eDhKSHN3cHJiaUUzdjlVcGhvdEFQSWduWFZJTjVLbU1jMHBpWGhjNmNDaFBuTitNUmhHOWFkdGR0dFFUVHdTSXBsOEk0L2ovL2Qzc3oxMzI2cVRCVHBQUk0vSGdoM2t6cUVYczhaQWs0RXJRaE5POGh6clEwRExrV01BL04rOTF0bjJNZE9KbldDMkZDWmVoa1Fyd3p3YktPamh2WnNiTTk1UW9lTDlza1l5TWY0c3JWUFZKU2dnN3BPTFV0ci9uOWVUOTlvZTluTHRGUnBqQTlva1YyS2o4aDlrNUhhQzBvaXZSRDhWeVhrSjgxdGNkNGZITlhQQ2Zsb0lRYXN4c3VPMTgvNDZkUjJqZ3VsL1VJZXQyRzBrUnZueU9OTUtoSHM2SjI2RkVvcVNxZCtyZllqZUVHd0hXVkRwWDFmaDFqQkJjS0dNcVJlcGp1OVkwMG1EVkhDK1hkaWovajQ0cktmdmZqR2luTnMxak8vMEYzakI4M1hDRElOTi9IQjg0YXhsUCszRS9rbGt0Um8rdmwzVS9haXlNSmJJb2RFMVhTc0RuNlVBeklvTXRVT2JZMitrLzRnWS9sK0FrWko1U2oydlFya3lMbTNGb3hqaERYKzMxVVhCRmY5WHJBSDMxZkZxb0JtREVadmh2dnBuWjg3TitvWkV1N1U5Ty9ubmsrUVdqM3g4dXlvUmJFbmYrTzVVTXI5aTBuSFAzOElGNUF2enJCVzhZV0JVUjBtSUF6SXZuZFFxOU4zdi9KdG8zYVBqUFhVUGw4QVNkUFB5QXA3akVOZjhiazdWTU05b2w5WEdtbEJtZURNdUdxdCtXenVMNkNYQXhYakloQ1BNNXZBQ2NoZ01KLzhYQkdMTy9EMWlzVnZHaHd3SEhyMURMYUk1bW4ySnIvYjFwVUQ5MHVjaURhUzhjWE5EekNXdk5tVC9QaFFlNWU4blRubm5rdDhEcy9TSWppYmN1bS9mcURoS29weEFZOEFrU3JQbitJR0RFS09PK1UzWE9QNmRqRnMySDVOOStvcmhPYWhpUWs1S25FVVdhK0N6a1Z6aHA4Yk1IUmJnODFxaGpqWHVJS2JIalNMU0lCS1dxb2NrR3RLaW5ZK3o0L1JkQlVGNnBjYzNKbW5seFZjTmdySTRTRXpLVVpTd2NEMlFDeXh6S3ZlK2dBbWc2WnVTUmtwUEZhNm1mVGh1N0xKTnUzSDVLNDJ1Q3BOdlBBc29lZG9sS1YvTEhlL2VKK0JiYUc1TUcwTmFTR1ZQUlVtTkZNRkZTU3BYRWNYd2JWaDdVRVRPWlp0b1ZOUkdPSWJia2lnM01jRXRSNjhjRzBSWkFvSmV2V1lvN0RnL2xaMUNRemJsV2VVdlZIbXI4Zlk0TnFkOUpKaUgvekVYMjRtSnZpSDYwZkF5RnIwQTNjNGJDMWozeVpVNjBWZ0p4WG44SmdKWExVSXNpQm5tS21NWXorN3lCUUZCdnFiMmVZbnVXNTlqb1pCZjU2L3dYdldJUjRSOHdUbVY4MGkxbVp5K1M0K0JVRVMraHpqazB1WHBDLy8vei9JbHFIWjFtb256bFhwOGFDZmhHS010aTczRkkxS2JMMXE2SUtPNGZ1QnVaNTlnYWdqbjV4VTc5bXVNcEhYZzZTK2UrZ0RNL1U5QktMSGJsOWw2bzhjelFLbDRSVWtKSmlxZnRRRzJpM0JNZy9UUWxVWUZrSkRZQk9PdkF1Z1l1ellTRG5aYkREZC9hU2Q5eDBPZTZGK2JKY0hmbDkrZ3A2TDUvVGdBK0JkRkZvdmJmQ3JRNDBzNXZNUHc4ODY2cE5YOHp5RkdlRldkeElwUFZwOVJnMVVQT1ZGYkZacnZhRnEvWUF6SFFncU1XcGFoTVlmcUhwbXdYZkhMMS9rcFltR3VIRndUNTVtUXUwZHlsZk51cTJPcTBoVE1DUHdxZnhudUJJUExYZmNpNFkxQU55KzFDVWlwUXhsZC9pelZoMTZXeUcyUTBDUVE5TnF0QW54MUhDSHdEajdzWXhPU0Iwd29wWlNuT3p4UU9jRXhteHJWVEYyQmtPdGhWcEdmdWhhR0VDZkNKcEpLcGpuaWhZK3hPVDJRSnhONjErOUs2UVNxdHYyU2hyODJJM2pnSnJxQmcwd0VMRlpQanZIcHZ6VHRhSm5MSzZWYjk3WW45MzNrb08vc2FON2ZzandOS3pwNGwybEpWeDJvcmpDR3pDLzRaTDR6Q3ZlcjZhUVl0QzVzZG95Y2h1RkU2dWZPaW9nK1ZXaTVVRGtibXZtdGFoLzNhQXJFQklpMzlzNUlMVW5sRkxnaWxjR3V6OUNRc2hFWTdmdzJvdW9JTEFZUFZUL2d5QUlxM1RGQUl3VnNsK2t0a1J6L3FHZm5DREdybTVnc2wvbDlRZHZDV0dzalB6M2RVN1h1cUtmZFVyci82WElnanA0cmV5NkFKQm1DbVVKTWpJVEhWZEZiNW0xcCtkTE1DTDh0NTV6RDQyY21mdG1MRUpDMERhMDRZaVJDVlVCTExhOEQwNzEvTjVVQk5CWERoMExGc21oVi81QjVFeE9CNGozV1ZHL1MzbGZLNW8rVjZFTEh2eTZSUjluNGFjK1ZzSzRWRTR5cGhQdlYra0c5RmVnVEJINFpSWEwySHl0VUhDZHVKYXpCL0t5a2pmZXRZeE9YVEx3czI2N2FHT2QrSStKaEtQLy8rVm5YbVM5ME9EL2p2TGNWdTBhc3lxY3VZTjFtU2I2WFRsQ2txdjF2aWdaUElZd05GL3pwV2NUMUdSLzZhRUlSamtoMHloZzRMWEpmYUdvYllKVFk0Skk1OEtpQUtnbW1nQUtXZGw1bllDZUxxYXZSSkdRTnVZdVp0WkZHeCtJa0k0dzROUzJ4d2JldE5NdW5PakJ1L2htS0NJL3c3dGZpaXlVZC8vNHJiVGVXdDRpekJZOFl2R0lONnZ5S1ltUC84WDh3SEtDZU4rV1JjS003MCt0WEtOR3lldlU5SDJEZzVCc2xqblRmOFlic0oxVG1Nczc0Q2UyWGxIaXNsZWd1aHllZzQ0clFPSFp1dy82SFRraG5udXJLMmQ2MnE2eVM3MjEwU3NBSWFSK2pYTVFBK3N2a3JMcHNVWStGMzBVdzg5dU9kR0FSNnZvNEZJTUUwRWZWVmVIVHU2ZUtpY2ZoU3FPZVhKaGJmdGNkMDhzV0VuTlVMMUM5Zm5wclRnZDgzSU11dDhvblZVRjBodnF6WmZIZHVQamJqd0VYSWNvWW15K1A2dGNKWkhtZU92NlZydkVka0hESmVjakh1SGVXQU5lNzlWRzY2MnFUakEvSEN2dW1WdjNxTCtMck9jcHFHcHMyWkd3UWRGSjdQVTRpdXlSbEJyd2ZPK3huUHlyNDdzMmNYVmJXekF5em5EaUJHakNNM2tzeGpqcU02MkdFOUM4ZjVVMzhrQjNWanRhYktwL25SZHZNRVNQR0RHOTBiV1JMQXQxUWs1RHlMdWF6UlIxWXpkQzFjK2haWHZBV1Y4eEE3MlM0QThCNjd2alZoYmJhM01Nb3AyOTNGZUVYcGU3ekl0TVdySkcvTE9IOUJ5T1htWW5OSmZqbWZ1WDlLYnJwZ0xPYmE0blorZmw4R2Jkdi9paHYrNndGR0tIQ1lyVndtaEZDMEozVjJibjJ0SUIxd0NjMUNTVDNkM1gyT3l4aGd1WGNzNHNtNjc5VW5nem9mdVNlQmV3TUZKYm9JUUhiVWgvbTJKaFcyaEc5REl2RzJ0N3laSXpLQlR6OXdCdG5OQysycENSWWhTSXVRMWo4eHN6NVZ2cW55VUl0aHZ1b3l5dTdmTklyZy9LUVVWbUdRYXFrcVprL1Z4NWIzMy9nc0VzOHlYN1NDMUorTlY0aWN6NmJ2SUU3QzVHNk1jQmFJOHJWZzU2cTVRQkpXeG4vODdRMXNQSzQrc1FhOGZMVTVnWG80cGFhcTRjT2NRNHdSMFZCSFBHaktoK1VsUENiQTFuTFh5RVVYNDVxWjhKNy9MbjRGUEpFMlRkekQwWjhNTFNOUWl5a01NbVN5T0NpRmZ5ODRScTYwZW1ZQjJ2RDA5S2pZd3NvSXBlRGNCRFRFbEJiWHhORDcyeWhkOXBDLzFDTWlkLzVIVU12QUwyN090Y0lKRHpOS3BSUE5xUE9weXQyYVBHejlRV0lzOWhROUxpWDVzOG05aGpUVXUvZjdNeUlhdGpqZCt0U2ZRM3VmWnhQcG1KaFRhQnRadEtMVWNmT0NVcUFEdU8rUW9IOEI5djZVK1AwSFYxR0xRbXRvTkZUYjNzNzRpdlpnakVTMHFmSys4UmRHZ0JiY0NNU3k4ZUJ2aDk4K2V0MUtJRnFTZTFLUVB5WFVMQk1Uc0lZbnlzSXdpWkJKWWRJMjB2c2VWK3d1SmtjcUdlbWVoS2phQWI5TDU3eFptM2cyelgwYloyeGsvZlUrYkNvN1RsbmJXN0p1RjFZZFVSby8yR3c3VmNsREcxVzdMT3RhczJMWDR1cGlmWi8yM3J6cHNuWS9BTGZSZ3JjV1A1aFltVjlWeFZPUUExZlp2cDlGMlVOVSs3ZDd4UnlWbTV3aUxwMy8wZGxWN3ZkdzFQTWlacmJEQVl6SVZxRWpSWTJZVTAzc0poUG5sd0lQY1pVRzVsdEw2UzhYQ3hVMWVZUzVjanIzNHZlQm1YQXZ5N3lONFpqQXJJRzBkZkQvNVVwQk5sWDFaUG94Sk93eXFSaTN3UVd0T3pkNG9OS2gwTGtvVG04Y3dxZ0lmS2hxcUdPaHdvNzFJK3pYbk1lbVR2MkIyQVV6QUJXeUZ6dEdnR1VMakREeldZd0pVVkJUaktDbjVLMlFHTUsxQ1FUN1N6emlPam8rQmhBbXFCanp1YzN4WXltMmVlZEdlT0lSSlZ5VHdEdzM3aUNNZTRnNVZibnNiNVpCZHhPQW5NVDdIVTRESHB4V0d1UTdHZWlZMzBDcGJ2enNzNTUrNUttMVlzYkQ1ZWEzTkk5UU5ZSVhvbDVhcGdTdTlkWjhmOHhTNWR0SHBpZG81QmNsRHVMV1k0bGhpazB0YkphMDd5SmhIMEJPeUV1dC9HUmJZVFM2UmZpVFlXR01Da05wZlNIaTdIdmRpVGdsRVZIS1pYYVZoZXpINGtrWGlJdktvcFlBbFB1c2Z0cEU0YTVJWnd2dzF4L2VMdm9ESWgvenBvOUZpUUluc1RiMlNBa0tIVjQyWFlCanBKRGc0Mzc0WGlWYjN3czRxTTBzOWVTUTVIenNNVTRPWkpLdW9wRmpCTStkQVpFbDhSVU14NXVVMk40ODZLcjE0MXRWc0dRZkdqT1JZTUNKQU1zeEVMZU5UNFJtV2pSY3BkVEdCd2N4NlhOOWRyV3FQbUp6Y3JHckg0K0RSYzcrbjF3M2tQWnd1MEJrTnI2aFFycWdvN0pUQjlBNWtkSi9IN1A0Y1dCTXdzbXVpeEF6SkIzeXJRcG5HSXE5MGx4QVhMekRDZG4xTFBpYnNSdDdySE5qZ1FCa2xSZ1BaOHZUYmpYZGdYclRXUXNLNU1kclhYUVZQcDBSaW5xM2ZyelpLSjBxRDZRaGM0MFZ6QXJhVVhsb2IxZ3ZraEszdnBtSGdJNkZSbFFaTng2ZVJxa3Awenk0QVFsWDgxM2ZBUHRMM2pNUmFpdEdGRmpvMHptRXJsb0MraCtZWWRWUTZrNEYvZXB4QW9GMEJtcUVvS05UdDZqNHZRWk5RMkJvcUY5Vmo1M1RPSW9ObURpdTlYcDE1UmtJZ1FJR2NvTHBmb0liZW56cEdVQXRxRkpwNVcrTExueDM4akhlRUNUSi9uYXZLWTFOV2ZOMHNZMVQ4L3BCOGtJSDNEVTNEWCt1NlczWXdweXBCTVlPaGJTeEdqcTg0Ulo4NGZXSm93OHB5SHFuNFMvOUoxNUVjQ01zWHFyZnd5ZDltaGl1MytyRW85cFBwb0prZFpxSGpyYTROdnpGd3VUaE5LeTZoYW8vU2xMdzNaQURVY1VwM3czU1JWZlcycmhsODB6T2dUWW5LRTBIczJxcDFKNkgzeHFQcUlrdlVEUk1GRFl5UmJzRkkzTTlNRXlvdlBrOHJsdzcvMGE4MWNEVkxtQnNSMnplMnBCdUtiMjNmYmVaQzB1WG9JdkRwcGZUd0lEeGsxT3EyZEdlc0djK29KWFdKTEdrT2hhM0NYK0RVbnpnQXA5SEdIOVJzUFpONjNIbjRSTUE1ZVNWaFBITys5UmNSYi9JT2d0VzMxVjFRNUlQR3RveFBqQytNRUpiVmxJTVlBRGQ5YUhZV1VJUUtvcHVQT0htb3FTa3VibkFLbnpnS0hxZ0lPZlc1UmRBZ290TjZCTitPMlpZSGt1ZW1MbnZROFU5VEhWclMxUnRMbUtiY0M3UGVlRHNZem52cXplZzZWQ053bXIwWXl4MXduTGp5VDg0Qlp6M0VKeUNwdEQzeWV1ZUF5RFdJczBMMnFzL1ZRM0hVeXFmcmphMFYxTGREenFBaWtlV3VWNHNjN1JMSUI2OWpFSUJqQ2t5WmVkb1VIcUNyT3ZTaFZ6eWQ3M09kckpXMGhQT3VRdjJxT29IRGM5eFZiNll1NnVxM1hxcDJaYUg0NkE3bHpldmJ4UUVtZnJ6dkFZU0p1WjRXRGsxSHozUVgxTFZkaVVLMEV2bEFHQVlsRzNNZDMwcjdkY1BONjN5cUJDSWoyNXBycHZaUDBuSTQrRWdXb0ZHOTVWNTk2Q3VyWHBLUkJHUmpRbEhDdnk1SWIvaVc4blpKV3dyRVQzbWdkNm1FaGZQNEtDdWFMam9wV3M3aCtNZFhGZEl2OGRIUUpnZzF4aTFlWXFCMHVEWWp4d1ZtcmkwU3Y1WEt1dC9vbnFhcEMrRlFpQzJDMWx2WUo5TVZjbzZ5RFlzUzNBQU5VZk10dnRiWUkyaGZ3WmF0aVNzbm9VZU1aZDM0R1Zqa01NS0ErWG5qSnBYZ1JXMlNIVFpwbFZvd1BtSnN2WHk2dzNjZk8xQUsyZHZ0WkVLVGtDL1RZOUxGaUtIQ0cwRG5yTVFkR20ybHpsQkhNOWlFWXluSDJVY1ZNaFVFanNjMG9EQlRnbzJaU1ExZ3prQUhlV2VCWFlGallMdXVmOHl6VEN5Ny9SRlI4MVdEalhNYnEyQk9INWRVUm54bzZvaXZteEwzY0t6S0lubFprRDMxbnZwSEI5S2s3R2ZjZkUxdCsxVjY0YjlMdGdlSkdscFJGeFFDQXFXSjVEb1k3N3NraThnc09FT3IydXl3WmFvTy9OR2EwWDB5MXBOUUhCaTNiMlNVR05wY1p4RFQ3ckxiQmYxRlNuUThndXhHVzNXKzM2QlcwZ0JqZTRET3o2QmE2U1ZrMHhpS2d0K3EySk9GeXI0U1lmbnUrSWMxUVpZSXV3SEJyZ3pyNlV2T2NTQ3pQVE9vN0Q2SUM0SVNlUzd6a2w0aCsyVm9lSHBuRy91V1IzK3lzTmdQY09JWFFidjBuNG1yM0J3UWNkS0p4Z1BTZXl1UC96MUpqZzRlOW5Vdm9YZWdxUVZJRTMwRUh4NUdIditGQVZVTlRvd1lESmd5RmhmNUl2bFltRXFSaWY2K1dOMU1rRUptRGNRSVR4OUZYMjNhNG14eTFBUVJzT0hPLytlSW1YOWw4RU1KSTNvUFd6Vlh4U09lSFUxZFVXWXIydUFBN0FNYit2QUVaU2JVM3FvYjlpYkN5WGV5cEVNcFo2ODYzbzZRUHFscUdIWmt1V0FCU1RWTmQ0Y09oOWh2M3FFcFN4Mlp5L0RKTVA2Y0l0RW1pQko1UEZxUW5ERUl0M05yQTNDT2xPU2d6NDNEN2dwTkZOSjVNQmg0b0Z6aERQaWdsQzJ5cHNOVTRJU3l3WTJlcmt5YjFOQzNRaC9JZldqMGVEZ1pJNC9sbjhXUGZCc1QzbWVUanExVXF0MUU3WmwvcWZ0cWt4NmFNOUt1ZU1DZWtTbk1yY0hqMUNxVFdXekV6UHNaR2NEZTNVZTRXcytYRllWeE5iT0ZGOGV6a3ZRR1I2Wk90T0xVMmxRRW5NQlN0eDQ3dkU2UGI3QVlNQlJqMk9PZlpYZmlzakpucFRmU05qbzZzWjZxU3ZOeFpObURlUzdHazN5WXlDazFIdEtOMlVuaE1Jak9YVXpBcUR2OTBseDlPL3EvQVQxWk1uaXQ1WFFlOXdtUXhuRS9XU0gwQ3FaOS8ySHkrU2ZtcGVnOFJ3c0hJNVo4a0M4SDI5M20vTEhWVk0vQkE3SGFUSllnNUVuazdNL3hXcHEwMTkyQUNmQmFpMkxBL3FyQ2pDcjZEaDFCSU16TVhJTkJtWDk2TUo1SG4ybnhsbi9SWFBGaHdIeFVtU1YwRVYyVjBqbTg2L2R4eHVZU1UxVzdzVmtFYk45RXprRzBRRndQaHlIS3liM3QrRmo1V29VVVRFcmNhekUvTjZFVzZMdnAwZC8vU0RQajdFVjlVZEpOK0FtbmYzV3drM0EwU2xKOVowMHl2WFo3bjN6NzBHNDdIZnNvdzhXcTFKWGNmd25BK1l4YTVtRnNnVjQ2NEtLUDRUMzF3cUlnekZQZDNlQ2UzajVvcnk1ZkJGMmhnQ0Z5VkZyTHpJOWVldE5Ydk03b1FxeUZnRG80Q1RwL2hEVjlOTVg5SkRIUS9ueUhUTHZaTE5MRjZmdG4yT3hqR204K1BxT3doeG5QSFdpcGtFLzh3YnR5cmk4MFNyN3BNTmtRR01mbzRaWUs5T2NDQzRFU1ZGRmJMTUl2bHhTb1JxV2llMHd4cW5MZmNMU1hNU3BNTVFFSllEVk9iWXNYSVFOdjRUR053anExa3ZUMVVPa2ljVHJHM0lhQlozWGRTY1MzdThzZ2VaUFZwT0xrYmlGOTQwRmpiQ2VOUklOTnZEYmQwMUVQQnJUQ1BwbTEybTQzemUxYkJCNTlJYTZPdmhudXIvTnZ4M0l4d1NXb2wrM0gycWZDSlI4ZGY2YVFmNHY2V2lPTnhrSytJcVQ0cEtRclpLL0xwbGdESS9QSlpiT2VwOGR0YlY3b0NyNkNnZnBXYThOY3pPa1B4ODFpU0hic05oVlNKQk90ckxJTXJMMzFMSzlUcUhxQWJBSGUwUkxtbVY4MDZrUkxETE5FaFVFSmZtOXUwc3hwa0w5M1pnZDZydyt0cUJmVE1pNTl4cVhITFhTSHdTYlNCbDBFSzArbG9FQ09QdHJsKy9uc2FGZTE5N2RpNHlVZ29lNGpLb0FKRFhjNkRHRGpyUU9vRkRXWko5SFh3dDh4RHJRUCs3YVJ3V0tXSTFHRjhzOE80S3p4V0JCY3dubDN2bmwxT2V6M29oNkVhMXZqUjcvejdERFRyRnRxVTJXL0tBRXpBdVhETlo3TVk3M01GMjE2ZHpkU2JXbVVwNGxjbTdrZUpmV2FNSGd1dDl4NUM5bWo2NlowbEoreWhzalZ2eWlXcmZrMWx6UE9UZGhHMTVZN2dRbFh0YWN2STdxdi9YTlNzY0R3cWtnd0hUL2dVc0Q1eUI3TGRSUnZKeFFHWUlObjloVHBvZEtGVlNUUHJ0R3Z5UXcrSGxSRlhJa29kRXJBR3U5SXkxWXBmU1BjM2prRmg1Q1gzbFB4djdhcWpFL0pBZlRJcEVqR2IvSDdNTzBlMnZzVmlTVzFxYS9MbWk0L240REVJM2c3bFlyY2Fuc3BEZkVwS2tkVjFPalNMT3kwQkNVcVZvRUNhQjU1dnMwNnJYbDRqcW1Mc1BzRk0vN3ZZSjB2ckJoRENtLzAwQS9IODFsMXVla0ovNkxtbDNIYjkrTktpTHFBVEptRHB5emZZWkZIdW1FakM2NjJMMEJ3a3hpN0U5VTRjUUEwWE1WRHVNWUFJZUxNUGdRYU1WT2Q4Zm10NVNmbEZJZnVCb3N6ZUF3N293NWdYUEUyWS95QmMvN2pFeEFSVWYvQnhJSFFCRjVTbjNpNjF3NHo1eEpkQ3lPMUYxWDMrM2F4K0pTdk1lWjdTNlFTS3AxRnAvc2pZejZaK1ZnQ1p6aWJHZUVvdWpyeWZNdWxIN1JhaTVrQWZ0OWViY1c1MER5SnIydW8yejk3bVRXSXU0NVlzU25OU01yck5VdUcxWHNZQnREOVREWXpRZmZLQjg3dldia000RWJQQUZnb0JWNEdRUyt2dEZEVXFPRkFvaTFuVHRtSU92ZzM4TjRoVDJTbjhyOGNsbUJDWHNwQmxNQllUbnJxRkpHQlQzd1pPekF5SkRyZTlkSEg3K3g3cWFhS0RPQjRVUUFMRDVlY1MwREU0b2J1YlFFaXVKWjBFcEJWcEx1WWNjZThBYTRQWWQvVjRETERBSkJZS1FQQ1dUY3JFYVo1SFliSmkxMUdkNmhqR29tMWlpMThWSFluRzI4Tktwa3oyVUtWUHhsaFlTcDh1WnIzNjdpT21veTd6c3hlaFc5d3pjeTJ6RzBhODBQQk1DUlFNYjMyaG5hSGVPUjhmbk5EelpoYU5ZaGtPZERzQlVaM2xvRE1hMVlQMHVTMGNqVVAzYi82REJscW1aT2VOQUJEc0xsNUJJNVFKdXBzOHV4QXVXSmRrVUIvcE82WmF4NnRzZzdmTjVtampEZ01HbmdPK0RQY0txaUhJRGJGSUd1ZHh0UFRJeURpOVNGTUtCRGNmZEdRUnY0MXExQXFteGdrVmZKTW5QOHcvQmM3TjkvVFI2QzdtR09iRnFGa0lFb204c0tpMnhZcUpMVENISzdjeHphWnZxT0RvMjJjM3dpc0JDUDRIZUFnY1JiTlBBc0JrTlJoU21ENDhkSHVwZEJSdzRtSXZ0UzVvZUY2emVUMUtNQ3loTW5taHBrRkFHV25Hc2NvTmt3dlE4Wk01bEUvdmdUSEZZTDk5T3VOeGRGQnhURURkNXYycUxSOHk5V2tYc1dnRzZrWk5uZEZHK3BPL1VBa09DaXBxSWhMM2hxN2NSU2RyQ3E3WWhVc1RvY0VjbmFGYTZuVmtoblNlUllVQTFZTzB6NWl0RjlTbHkzVmx4WUR3MjM5VEpKSDZmM0VVZllPNWxiN2JjRmN6OEJwN09vOFFtbnNVSE96L2ZhZ1ZVQnRLRXcxaVQ4OGorYUtrdjhjc2NLTmtNeGpZcjgzNDREMWtGb1o3L3RkMVc2TENOWU41OTQzMDF0VUdSbUZqQXplUmc1dnlvTTFGNitiSlovUTU0ak4vazhTRmQzRHhQVFlhQVVzaXZzQmZnVG43TXg4SDJTcFB0NEdPZFlSbkVKT0g2akhNMnA2U2dCMGd6SVJxNmZIeEdNbVNtcWFQQ21sZnd4aXVsb2FWSWl0TEdOOHdpZTJDRFdoa3pMb0NKY09EaDdLSU9BcWJIRXZYZFV4YVM0VFRUczA3Q2x6ai82R21WczlraVpEZXJNeEVuaFVCNlFRUGxjZnFrRzk4ODJScUhvTGlIR0JvSGZRdVhJc0FHOEdUQXRhbzJLVndSbnZ2YW04am8xZTMxMkdRQUtXRWE0c1VWRUFNRzRHNmNrY09ORHdSY2cxZTJEMytvaFhnWTRVQVdGOHdIS1FNclNuekNnZkZwc3hoK2FIWE1HdFBRcm9RYXNSWTRVNlVkRzByejFWamJrYTBNZWtPR1JaUUV2cVFGbHhzZUZvcjh6V0ZnSGVrM3YyOStXcU42Z2FLNWdaT1RPTVp6cFFJQzEyMDFMa01DWGlsZDN2V1hTYzVVWDl4Y0ZZZmJSUHpHRmExRkRjUGZQQi9qVUVxL0ZlR3Q0MTlDSTNZbUJsVm9Ic2E0S2Rjd1FQNVpTd0hIaEZKNy9QaC9SYXAvNHZtRzkxZUR3UFAwbERmQ0RSQ0xzelRxZnpNNzF4cG1pS2kySHdTNFdscXZHTnd0dndGNURxcG42S1RxOGF4MDBVTVBreERjWnJFRUVzSXZIaVVYWEVwaGRiNEdCNEZ5bWxQd0J6NEdwZXJxcTVwVzdUUTYveU5SaFc4VlQ1Tmh1UDB1ZGx4bzRnSUxxNVp4QVprOFpHaDNnNENxeEpsUEtZN0FReHVwZlVjVnBXVDVWSXRwMSszMFVxb3lQNHdXc1JvM29sUlJna1daWjJaTjZWQzNPWkZlWEI4TmJuVXJTZGlrTnB0RDFRaUd1S2tyOEVtU1IvQUs5UncrRkYzczV1d3VQYnZIR2lQZUZPVmlsdE1LN0FVYU9zcTkreDljbmRrM2lKRUU1TEtaUmxXSmJLT1p3ZVJPem1QTlZQa2pFM0svVHlBNTdSczY4VGtaM01SOGFrS3BtN2NGam5qUGQvRGRrV2pnWW9LSFNyNVd1NXNzb0JZVTRhY1JzNWcyREh4VW1kcThWWE9YUmJ1bkQ4UU4wTGhna3NzZ2FoY2RvWXNOdnVYR1VLL0tYRC83b0ZiK1ZHZGhxSW4wMnZldU01Ykx1ZEpPYzJLeTBHTWFHNFcveFdCeElKY0w3eWxpSk9YT3B4MEFrQnFVZ3psRGN6bUxUNGlJTFhEeHh0UlIxb1phMkpXRmdpQWI0M29ickpuRy9UWkMyS1NLMndxT3pSWlRYYXZaWkZNYjFmM2JYdlZhTmFLODI4dzlUTzYxMGdrOEpOZjNnTWZFVHpYWHNiY3ZSR0NHOUpXUVo2K2NEUHFjNDQ2NllvMlJjS0grUElMZUtPcXRubGJJblIzTW1CZUdHM0ZIMTB5emt5YnVxRUMySFNRd3BBMEFuN2Q5KzczQmtEVVRtMzBiWm1vUC9SR2JnRk4rR3JDT2ZBRGdxcjBXYkkxYTFva3BGbXM4aUhZdzlobTB6VXZsRU1pdkJSeE1vZHJiSkorOS9wM2pVZFFROUJDdFFkeG5PR3JUNWR6UlVtdzA1OTMvbWJSU2RCZzBuUnZSWk01L0UxNm03WkhtREV0V2h3dmZkWkNaOEo4TTEyVzB5Uk1zelhhbVdmUVR3SVo0YXlZa3RybnNjUXVXcjhpZHAzUGpUMmVGL2ptdGRoSWZjcE1uYitJZlpZMkZlYlc2VVkvQUszalA0dTNUdTR6RTRxbG5RZ0xGYk0xOUVCSXNOZjdLaGpkYnFRL0Q2eWlEYitObEVpMlNLRCtpdlhWVUs4aWIwb0JvMzY2Z1hrUjhaeEdqcEpJRGNFZ1pQYTlUY1llMFRJYmlQbC9yUFVRRHUzWEJKOVgvR05xM0ZBVXNLc2xsNTdEemFHTXJqY1QrZ2N0cCs5TUxZWENxK3NxUDgxZVZRMHI5bHQrZ2NRZlpiQUNSYkVqdmxNc2t6dFpHOGdiQzhRbjl0dDI2UTd5N25EcmJacS9MRXo3a1I2SmM2cGczTjlyVlg4WTVNSnJHbE1MOXA5bFU0amJUa0txQ3ZlZVpVSmpIQjAzbTJLUktSMlR5dG9Ga1RYT0xnN2tlVTFzMWxyUE1RSnBvT0tMdUFBQyt5MUhsSnVjVTZ5c0I1aHNYaHZTUFBMcTVKN0p0bnFIS1o0dllqQzRWeTgxNTNRWSs2NzgweER1R0FSc0diT3MxV3F6SDBRUzc2NXJuU0tFYmJLbGtPOG9JL1ZEd1VkMGlzMTN0S3BxSUx1MW1ESkZOeS9pSkFXY3ZEZ2p4dnVzSVQrUEd6M1NUL0o5cjlNdGZkMGpwYUdlaUxZSXFYYzdEaUhTUzhUY2pGVmtzaTY2UEVreFcxejZ1amJMTFVHTk5ZbnpPV3BIOEJaR0s0YkNLN2lSK01iSXY4bmNEQXoxdTRTdE4zdlRUemV3cjlJUWprOXd4RnhuKzZOMWRkS3MwdmZmSmlTMDhOM2E0RzFTVnJsWjk3US9NKzhHOWZlNUFQNmQ5L1FxNFdSbk9SVmhvZlBJS0VkQ3IzbGxzcFVmRTBvS0lJWW9CeUJSUGgrYlgxSExTM0pXR0pSaEl2RTFhVzROVGQ4ZVBpNFora1hiK1o4c25ZZlNOY3FpamhBZ1ZzeDRSQ001NGNYVWlZa2plQm1tQzRhak9IckNob0VMc2NKSkM3Kzlqak1qdzVCYWdaS2xnUk1pU05ZejdoN3Z2WklvUXFidFFtc3BjMGNVazFHLzczaVh0U3BST2w1d3RMZ1FpMG1XMkV4OGkzV1VMaGNnZ3g2RTFMTVZIVXNkYzlHSEkxUEgzVTJLbzBQeUdkbjlLZFZPTG03RlBCdWkwaTlhMEhwQTYwTXNld1ZFNHo4Q0F0NWQ0MDFHdjZ6WGxJVDVZYml0MVZJQTBGQ3M3d3R2WXJlcnUxZlV5VzNvTEFaLythVG5ack9jWVJOVkE4c3BvUnRsUm9XZmxzUkNsRmNnemtxaUhPcmYwL1NWdytFcFZhRmxKMGc0S3hxMU1NT21pUWRwTU5wdGU4bE1NUXFtNmNJRlhsbkdiZkpsbHlzS0RpKzBKSk1vdGtxZ0l4T1NRZ1U5ZG4vbFdrZVZmOG5VbTNpd1gyTmwzV0R3OWk2QVVLM3ZCQWJaWnJjSnBEUS9ONjRBVndqVDA3SmVmMzBHU1NtdE51MldsVzdZb3lXMkZsV2ZaRlFVd2s4NjdFZExZS2s5Vkc2SmdFbkJpQnhrWTdMTW80WUxRSkpsQW85bC9vVHZKa1NBUkRGL1h0eUF6TThPMnQzZVQvaVhhNndETjNXZXdObVFIZFBmc3hDaFUvS3RMRzJNbjhpNFpxS2RTbElhQlphZHhKbVJ6VlMvbzR5QTY1UlRTVmlxNjBvYTM5NUxxdzBwelk0U2lwd0UwU1hYc0tWK0dacmFHU2tyL1JXMDh3UFJ2cXZTVWtZQk1BOWxQeDRtMjRheitJSG1DYlhBKzBmYXhUUkU5d3VHZU8wNkRJWGE2UWxLSjNwdUl5aXVBVmZQcjczNnZ6bzJwQmlyUytWeGVsM1RNbTNKS2h6OW8yWm9SdmFGVnBJa3lrYjBIY200b0hGQk1jTlNOajcvNEdKdDQzb2dvblkyVmc0bnNEUUlXeEFjb3JwWEFDemdCcVFQallzRS9WVXBYcHdOTWFuRXJ1NE53TUNGUGtYdk1vcXZvZUxOM3F5dS9OMWVXRUh0dE1ENjV2MTlsLzBrSDJtUjM1aXYvRkkreWpvSEo5Z1BNejY3YWYzTXEvQm9XWHF1M3JwaGlXTVhWa21uUFNFa3BHcFVJMmgxTVRoaWRlR0ZFT0s2WVpIUHdZek1CdnBOQzcrWkh4UGI3ZXBmZWZHeUlCNEp6TzlEVE5FWW5ETFZWSGRReXZPRVZlZnJrNlV2NWtUUVlWWVdXZHFyZGNJbDd5bGp3d0lXZGZRL3krMlFCM2VSL3F4WU9idVl5QjRnVGJvMmluNFB6YXJVMXNPOW5FVGttajkvQW94REErSk0zR01xUXRKUjRqdGR1SHRub0NMeGQxZ1FVc2NIUkIvTW9SWUlFc1AycERaOUt2SGd0bGsxaVRiV1diSGhvaHdGRVlYN3k1MWZVVjJudVVtbm9VY3FuV0lRQUFnbDlMVFZYK0JjMFFHTkVoQ2h4SFI0WWpmRTUxUFVkR2ZzU0ZFNmNrN0JMMy9oVGY5akxxNEcxSWFmSU54T0xLZUF0TzdxdXVsWXZINVlPQmMrelg3Q3JNZ1duVzQ3L2pmUnNXbkpqWVlvRTd4TWZXVjJITjJpeUlxTEknO1xuY29uc3QgRkVOQ0VEID0gbmV3IE1hcChbWzgyMTcsXCJhcG9zdHJvcGhlXCJdLFs4MjYwLFwiZnJhY3Rpb24gc2xhc2hcIl0sWzEyNTM5LFwibWlkZGxlIGRvdFwiXV0pO1xuY29uc3QgTlNNX01BWCA9IDQ7XG5cbmZ1bmN0aW9uIGRlY29kZV9hcml0aG1ldGljKGJ5dGVzKSB7XHJcblx0bGV0IHBvcyA9IDA7XHJcblx0ZnVuY3Rpb24gdTE2KCkgeyByZXR1cm4gKGJ5dGVzW3BvcysrXSA8PCA4KSB8IGJ5dGVzW3BvcysrXTsgfVxyXG5cdFxyXG5cdC8vIGRlY29kZSB0aGUgZnJlcXVlbmN5IHRhYmxlXHJcblx0bGV0IHN5bWJvbF9jb3VudCA9IHUxNigpO1xyXG5cdGxldCB0b3RhbCA9IDE7XHJcblx0bGV0IGFjYyA9IFswLCAxXTsgLy8gZmlyc3Qgc3ltYm9sIGhhcyBmcmVxdWVuY3kgMVxyXG5cdGZvciAobGV0IGkgPSAxOyBpIDwgc3ltYm9sX2NvdW50OyBpKyspIHtcclxuXHRcdGFjYy5wdXNoKHRvdGFsICs9IHUxNigpKTtcclxuXHR9XHJcblxyXG5cdC8vIHNraXAgdGhlIHNpemVkLXBheWxvYWQgdGhhdCB0aGUgbGFzdCAzIHN5bWJvbHMgaW5kZXggaW50b1xyXG5cdGxldCBza2lwID0gdTE2KCk7XHJcblx0bGV0IHBvc19wYXlsb2FkID0gcG9zO1xyXG5cdHBvcyArPSBza2lwO1xyXG5cclxuXHRsZXQgcmVhZF93aWR0aCA9IDA7XHJcblx0bGV0IHJlYWRfYnVmZmVyID0gMDsgXHJcblx0ZnVuY3Rpb24gcmVhZF9iaXQoKSB7XHJcblx0XHRpZiAocmVhZF93aWR0aCA9PSAwKSB7XHJcblx0XHRcdC8vIHRoaXMgd2lsbCByZWFkIGJleW9uZCBlbmQgb2YgYnVmZmVyXHJcblx0XHRcdC8vIGJ1dCAodW5kZWZpbmVkfDApID0+IHplcm8gcGFkXHJcblx0XHRcdHJlYWRfYnVmZmVyID0gKHJlYWRfYnVmZmVyIDw8IDgpIHwgYnl0ZXNbcG9zKytdO1xyXG5cdFx0XHRyZWFkX3dpZHRoID0gODtcclxuXHRcdH1cclxuXHRcdHJldHVybiAocmVhZF9idWZmZXIgPj4gLS1yZWFkX3dpZHRoKSAmIDE7XHJcblx0fVxyXG5cclxuXHRjb25zdCBOID0gMzE7XHJcblx0Y29uc3QgRlVMTCA9IDIqKk47XHJcblx0Y29uc3QgSEFMRiA9IEZVTEwgPj4+IDE7XHJcblx0Y29uc3QgUVJUUiA9IEhBTEYgPj4gMTtcclxuXHRjb25zdCBNQVNLID0gRlVMTCAtIDE7XHJcblxyXG5cdC8vIGZpbGwgcmVnaXN0ZXJcclxuXHRsZXQgcmVnaXN0ZXIgPSAwO1xyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgTjsgaSsrKSByZWdpc3RlciA9IChyZWdpc3RlciA8PCAxKSB8IHJlYWRfYml0KCk7XHJcblxyXG5cdGxldCBzeW1ib2xzID0gW107XHJcblx0bGV0IGxvdyA9IDA7XHJcblx0bGV0IHJhbmdlID0gRlVMTDsgLy8gdHJlYXQgbGlrZSBhIGZsb2F0XHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdGxldCB2YWx1ZSA9IE1hdGguZmxvb3IoKCgocmVnaXN0ZXIgLSBsb3cgKyAxKSAqIHRvdGFsKSAtIDEpIC8gcmFuZ2UpO1xyXG5cdFx0bGV0IHN0YXJ0ID0gMDtcclxuXHRcdGxldCBlbmQgPSBzeW1ib2xfY291bnQ7XHJcblx0XHR3aGlsZSAoZW5kIC0gc3RhcnQgPiAxKSB7IC8vIGJpbmFyeSBzZWFyY2hcclxuXHRcdFx0bGV0IG1pZCA9IChzdGFydCArIGVuZCkgPj4+IDE7XHJcblx0XHRcdGlmICh2YWx1ZSA8IGFjY1ttaWRdKSB7XHJcblx0XHRcdFx0ZW5kID0gbWlkO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHN0YXJ0ID0gbWlkO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRpZiAoc3RhcnQgPT0gMCkgYnJlYWs7IC8vIGZpcnN0IHN5bWJvbCBpcyBlbmQgbWFya1xyXG5cdFx0c3ltYm9scy5wdXNoKHN0YXJ0KTtcclxuXHRcdGxldCBhID0gbG93ICsgTWF0aC5mbG9vcihyYW5nZSAqIGFjY1tzdGFydF0gICAvIHRvdGFsKTtcclxuXHRcdGxldCBiID0gbG93ICsgTWF0aC5mbG9vcihyYW5nZSAqIGFjY1tzdGFydCsxXSAvIHRvdGFsKSAtIDE7XHJcblx0XHR3aGlsZSAoKChhIF4gYikgJiBIQUxGKSA9PSAwKSB7XHJcblx0XHRcdHJlZ2lzdGVyID0gKHJlZ2lzdGVyIDw8IDEpICYgTUFTSyB8IHJlYWRfYml0KCk7XHJcblx0XHRcdGEgPSAoYSA8PCAxKSAmIE1BU0s7XHJcblx0XHRcdGIgPSAoYiA8PCAxKSAmIE1BU0sgfCAxO1xyXG5cdFx0fVxyXG5cdFx0d2hpbGUgKGEgJiB+YiAmIFFSVFIpIHtcclxuXHRcdFx0cmVnaXN0ZXIgPSAocmVnaXN0ZXIgJiBIQUxGKSB8ICgocmVnaXN0ZXIgPDwgMSkgJiAoTUFTSyA+Pj4gMSkpIHwgcmVhZF9iaXQoKTtcclxuXHRcdFx0YSA9IChhIDw8IDEpIF4gSEFMRjtcclxuXHRcdFx0YiA9ICgoYiBeIEhBTEYpIDw8IDEpIHwgSEFMRiB8IDE7XHJcblx0XHR9XHJcblx0XHRsb3cgPSBhO1xyXG5cdFx0cmFuZ2UgPSAxICsgYiAtIGE7XHJcblx0fVxyXG5cdGxldCBvZmZzZXQgPSBzeW1ib2xfY291bnQgLSA0O1xyXG5cdHJldHVybiBzeW1ib2xzLm1hcCh4ID0+IHsgLy8gaW5kZXggaW50byBwYXlsb2FkXHJcblx0XHRzd2l0Y2ggKHggLSBvZmZzZXQpIHtcclxuXHRcdFx0Y2FzZSAzOiByZXR1cm4gb2Zmc2V0ICsgMHgxMDEwMCArICgoYnl0ZXNbcG9zX3BheWxvYWQrK10gPDwgMTYpIHwgKGJ5dGVzW3Bvc19wYXlsb2FkKytdIDw8IDgpIHwgYnl0ZXNbcG9zX3BheWxvYWQrK10pO1xyXG5cdFx0XHRjYXNlIDI6IHJldHVybiBvZmZzZXQgKyAweDEwMCArICgoYnl0ZXNbcG9zX3BheWxvYWQrK10gPDwgOCkgfCBieXRlc1twb3NfcGF5bG9hZCsrXSk7XHJcblx0XHRcdGNhc2UgMTogcmV0dXJuIG9mZnNldCArIGJ5dGVzW3Bvc19wYXlsb2FkKytdO1xyXG5cdFx0XHRkZWZhdWx0OiByZXR1cm4geCAtIDE7XHJcblx0XHR9XHJcblx0fSk7XHJcbn1cdFxyXG5cclxuLy8gcmV0dXJucyBhbiBpdGVyYXRvciB3aGljaCByZXR1cm5zIHRoZSBuZXh0IHN5bWJvbFxyXG5mdW5jdGlvbiByZWFkX3BheWxvYWQodikge1xyXG5cdGxldCBwb3MgPSAwO1xyXG5cdHJldHVybiAoKSA9PiB2W3BvcysrXTtcclxufVxyXG5mdW5jdGlvbiByZWFkX2NvbXByZXNzZWRfcGF5bG9hZChzKSB7XHJcblx0cmV0dXJuIHJlYWRfcGF5bG9hZChkZWNvZGVfYXJpdGhtZXRpYyh1bnNhZmVfYXRvYihzKSkpO1xyXG59XHJcblxyXG4vLyB1bnNhZmUgaW4gdGhlIHNlbnNlOlxyXG4vLyBleHBlY3RlZCB3ZWxsLWZvcm1lZCBCYXNlNjQgdy9vIHBhZGRpbmcgXHJcbi8vIDIwMjIwOTIyOiBhZGRlZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qcy9pc3N1ZXMvNFxyXG5mdW5jdGlvbiB1bnNhZmVfYXRvYihzKSB7XHJcblx0bGV0IGxvb2t1cCA9IFtdO1xyXG5cdFsuLi4nQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyddLmZvckVhY2goKGMsIGkpID0+IGxvb2t1cFtjLmNoYXJDb2RlQXQoMCldID0gaSk7XHJcblx0bGV0IG4gPSBzLmxlbmd0aDtcclxuXHRsZXQgcmV0ID0gbmV3IFVpbnQ4QXJyYXkoKDYgKiBuKSA+PiAzKTtcclxuXHRmb3IgKGxldCBpID0gMCwgcG9zID0gMCwgd2lkdGggPSAwLCBjYXJyeSA9IDA7IGkgPCBuOyBpKyspIHtcclxuXHRcdGNhcnJ5ID0gKGNhcnJ5IDw8IDYpIHwgbG9va3VwW3MuY2hhckNvZGVBdChpKV07XHJcblx0XHR3aWR0aCArPSA2O1xyXG5cdFx0aWYgKHdpZHRoID49IDgpIHtcclxuXHRcdFx0cmV0W3BvcysrXSA9IChjYXJyeSA+PiAod2lkdGggLT0gOCkpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gcmV0O1xyXG59XHJcblxyXG4vLyBlZy4gWzAsMSwyLDMuLi5dID0+IFswLC0xLDEsLTIsLi4uXVxyXG5mdW5jdGlvbiBzaWduZWQoaSkgeyBcclxuXHRyZXR1cm4gKGkgJiAxKSA/ICh+aSA+PiAxKSA6IChpID4+IDEpO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWFkX2RlbHRhcyhuLCBuZXh0KSB7XHJcblx0bGV0IHYgPSBBcnJheShuKTtcclxuXHRmb3IgKGxldCBpID0gMCwgeCA9IDA7IGkgPCBuOyBpKyspIHZbaV0gPSB4ICs9IHNpZ25lZChuZXh0KCkpO1xyXG5cdHJldHVybiB2O1xyXG59XHJcblxyXG4vLyBbMTIzXVs1XSA9PiBbMCAzXSBbMSAxXSBbMCAwXVxyXG5mdW5jdGlvbiByZWFkX3NvcnRlZChuZXh0LCBwcmV2ID0gMCkge1xyXG5cdGxldCByZXQgPSBbXTtcclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0bGV0IHggPSBuZXh0KCk7XHJcblx0XHRsZXQgbiA9IG5leHQoKTtcclxuXHRcdGlmICghbikgYnJlYWs7XHJcblx0XHRwcmV2ICs9IHg7XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xyXG5cdFx0XHRyZXQucHVzaChwcmV2ICsgaSk7XHJcblx0XHR9XHJcblx0XHRwcmV2ICs9IG4gKyAxO1xyXG5cdH1cclxuXHRyZXR1cm4gcmV0O1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWFkX3NvcnRlZF9hcnJheXMobmV4dCkge1xyXG5cdHJldHVybiByZWFkX2FycmF5X3doaWxlKCgpID0+IHsgXHJcblx0XHRsZXQgdiA9IHJlYWRfc29ydGVkKG5leHQpO1xyXG5cdFx0aWYgKHYubGVuZ3RoKSByZXR1cm4gdjtcclxuXHR9KTtcclxufVxyXG5cclxuLy8gcmV0dXJucyBtYXAgb2YgeCA9PiB5c1xyXG5mdW5jdGlvbiByZWFkX21hcHBlZChuZXh0KSB7XHJcblx0bGV0IHJldCA9IFtdO1xyXG5cdHdoaWxlICh0cnVlKSB7XHJcblx0XHRsZXQgdyA9IG5leHQoKTtcclxuXHRcdGlmICh3ID09IDApIGJyZWFrO1xyXG5cdFx0cmV0LnB1c2gocmVhZF9saW5lYXJfdGFibGUodywgbmV4dCkpO1xyXG5cdH1cclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0bGV0IHcgPSBuZXh0KCkgLSAxO1xyXG5cdFx0aWYgKHcgPCAwKSBicmVhaztcclxuXHRcdHJldC5wdXNoKHJlYWRfcmVwbGFjZW1lbnRfdGFibGUodywgbmV4dCkpO1xyXG5cdH1cclxuXHRyZXR1cm4gcmV0LmZsYXQoKTtcclxufVxyXG5cclxuLy8gcmVhZCB1bnRpbCBuZXh0IGlzIGZhbHN5XHJcbi8vIHJldHVybiBhcnJheSBvZiByZWFkIHZhbHVlc1xyXG5mdW5jdGlvbiByZWFkX2FycmF5X3doaWxlKG5leHQpIHtcclxuXHRsZXQgdiA9IFtdO1xyXG5cdHdoaWxlICh0cnVlKSB7XHJcblx0XHRsZXQgeCA9IG5leHQodi5sZW5ndGgpO1xyXG5cdFx0aWYgKCF4KSBicmVhaztcclxuXHRcdHYucHVzaCh4KTtcclxuXHR9XHJcblx0cmV0dXJuIHY7XHJcbn1cclxuXHJcbi8vIHJlYWQgdyBjb2x1bW5zIG9mIGxlbmd0aCBuXHJcbi8vIHJldHVybiBhcyBuIHJvd3Mgb2YgbGVuZ3RoIHdcclxuZnVuY3Rpb24gcmVhZF90cmFuc3Bvc2VkKG4sIHcsIG5leHQpIHtcclxuXHRsZXQgbSA9IEFycmF5KG4pLmZpbGwoKS5tYXAoKCkgPT4gW10pO1xyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgdzsgaSsrKSB7XHJcblx0XHRyZWFkX2RlbHRhcyhuLCBuZXh0KS5mb3JFYWNoKCh4LCBqKSA9PiBtW2pdLnB1c2goeCkpO1xyXG5cdH1cclxuXHRyZXR1cm4gbTtcclxufVxyXG4gXHJcbi8vIHJldHVybnMgW1t4LCB5c10sIFt4K2R4LCB5cytkeV0sIFt4KzIqZHgsIHlzKzIqZHldLCAuLi5dXHJcbi8vIHdoZXJlIGR4L2R5ID0gc3RlcHMsIG4gPSBydW4gc2l6ZSwgdyA9IGxlbmd0aCBvZiB5XHJcbmZ1bmN0aW9uIHJlYWRfbGluZWFyX3RhYmxlKHcsIG5leHQpIHtcclxuXHRsZXQgZHggPSAxICsgbmV4dCgpO1xyXG5cdGxldCBkeSA9IG5leHQoKTtcclxuXHRsZXQgdk4gPSByZWFkX2FycmF5X3doaWxlKG5leHQpO1xyXG5cdGxldCBtID0gcmVhZF90cmFuc3Bvc2VkKHZOLmxlbmd0aCwgMSt3LCBuZXh0KTtcclxuXHRyZXR1cm4gbS5mbGF0TWFwKCh2LCBpKSA9PiB7XHJcblx0XHRsZXQgW3gsIC4uLnlzXSA9IHY7XHJcblx0XHRyZXR1cm4gQXJyYXkodk5baV0pLmZpbGwoKS5tYXAoKF8sIGopID0+IHtcclxuXHRcdFx0bGV0IGpfZHkgPSBqICogZHk7XHJcblx0XHRcdHJldHVybiBbeCArIGogKiBkeCwgeXMubWFwKHkgPT4geSArIGpfZHkpXTtcclxuXHRcdH0pO1xyXG5cdH0pO1xyXG59XHJcblxyXG4vLyByZXR1cm4gW1t4LCB5cy4uLl0sIC4uLl1cclxuLy8gd2hlcmUgdyA9IGxlbmd0aCBvZiB5XHJcbmZ1bmN0aW9uIHJlYWRfcmVwbGFjZW1lbnRfdGFibGUodywgbmV4dCkgeyBcclxuXHRsZXQgbiA9IDEgKyBuZXh0KCk7XHJcblx0bGV0IG0gPSByZWFkX3RyYW5zcG9zZWQobiwgMSt3LCBuZXh0KTtcclxuXHRyZXR1cm4gbS5tYXAodiA9PiBbdlswXSwgdi5zbGljZSgxKV0pO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gcmVhZF90cmllKG5leHQpIHtcclxuXHRsZXQgcmV0ID0gW107XHJcblx0bGV0IHNvcnRlZCA9IHJlYWRfc29ydGVkKG5leHQpOyBcclxuXHRleHBhbmQoZGVjb2RlKFtdKSwgW10pO1xyXG5cdHJldHVybiByZXQ7IC8vIG5vdCBzb3J0ZWRcclxuXHRmdW5jdGlvbiBkZWNvZGUoUSkgeyAvLyBjaGFyYWN0ZXJzIHRoYXQgbGVhZCBpbnRvIHRoaXMgbm9kZVxyXG5cdFx0bGV0IFMgPSBuZXh0KCk7IC8vIHN0YXRlOiB2YWxpZCwgc2F2ZSwgY2hlY2tcclxuXHRcdGxldCBCID0gcmVhZF9hcnJheV93aGlsZSgoKSA9PiB7IC8vIGJ1Y2tldHMgbGVhZGluZyB0byBuZXcgbm9kZXNcclxuXHRcdFx0bGV0IGNwcyA9IHJlYWRfc29ydGVkKG5leHQpLm1hcChpID0+IHNvcnRlZFtpXSk7XHJcblx0XHRcdGlmIChjcHMubGVuZ3RoKSByZXR1cm4gZGVjb2RlKGNwcyk7XHJcblx0XHR9KTtcclxuXHRcdHJldHVybiB7UywgQiwgUX07XHJcblx0fVxyXG5cdGZ1bmN0aW9uIGV4cGFuZCh7UywgQn0sIGNwcywgc2F2ZWQpIHtcclxuXHRcdGlmIChTICYgNCAmJiBzYXZlZCA9PT0gY3BzW2Nwcy5sZW5ndGgtMV0pIHJldHVybjtcclxuXHRcdGlmIChTICYgMikgc2F2ZWQgPSBjcHNbY3BzLmxlbmd0aC0xXTtcclxuXHRcdGlmIChTICYgMSkgcmV0LnB1c2goY3BzKTsgXHJcblx0XHRmb3IgKGxldCBiciBvZiBCKSB7XHJcblx0XHRcdGZvciAobGV0IGNwIG9mIGJyLlEpIHtcclxuXHRcdFx0XHRleHBhbmQoYnIsIFsuLi5jcHMsIGNwXSwgc2F2ZWQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59XG5cbmZ1bmN0aW9uIGhleF9jcChjcCkge1xyXG5cdHJldHVybiBjcC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKS5wYWRTdGFydCgyLCAnMCcpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBxdW90ZV9jcChjcCkge1xyXG5cdHJldHVybiBgeyR7aGV4X2NwKGNwKX19YDsgLy8gcmFmZnkgY29udmVudGlvbjogbGlrZSBcIlxcdXtYfVwiIHcvbyB0aGUgXCJcXHVcIlxyXG59XHJcblxyXG4vKlxyXG5leHBvcnQgZnVuY3Rpb24gZXhwbG9kZV9jcChzKSB7XHJcblx0cmV0dXJuIFsuLi5zXS5tYXAoYyA9PiBjLmNvZGVQb2ludEF0KDApKTtcclxufVxyXG4qL1xyXG5mdW5jdGlvbiBleHBsb2RlX2NwKHMpIHsgLy8gdGhpcyBpcyBhYm91dCAyeCBmYXN0ZXJcclxuXHRsZXQgY3BzID0gW107XHJcblx0Zm9yIChsZXQgcG9zID0gMCwgbGVuID0gcy5sZW5ndGg7IHBvcyA8IGxlbjsgKSB7XHJcblx0XHRsZXQgY3AgPSBzLmNvZGVQb2ludEF0KHBvcyk7XHJcblx0XHRwb3MgKz0gY3AgPCAweDEwMDAwID8gMSA6IDI7XHJcblx0XHRjcHMucHVzaChjcCk7XHJcblx0fVxyXG5cdHJldHVybiBjcHM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0cl9mcm9tX2NwcyhjcHMpIHtcclxuXHRjb25zdCBjaHVuayA9IDQwOTY7XHJcblx0bGV0IGxlbiA9IGNwcy5sZW5ndGg7XHJcblx0aWYgKGxlbiA8IGNodW5rKSByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4uY3BzKTtcclxuXHRsZXQgYnVmID0gW107XHJcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICkge1xyXG5cdFx0YnVmLnB1c2goU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4uY3BzLnNsaWNlKGksIGkgKz0gY2h1bmspKSk7XHJcblx0fVxyXG5cdHJldHVybiBidWYuam9pbignJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbXBhcmVfYXJyYXlzKGEsIGIpIHtcclxuXHRsZXQgbiA9IGEubGVuZ3RoO1xyXG5cdGxldCBjID0gbiAtIGIubGVuZ3RoO1xyXG5cdGZvciAobGV0IGkgPSAwOyBjID09IDAgJiYgaSA8IG47IGkrKykgYyA9IGFbaV0gLSBiW2ldO1xyXG5cdHJldHVybiBjO1xyXG59XG5cbi8vIGNyZWF0ZWQgMjAyMy0wOS0yNVQwMTowMTo1NS4xNDhaXG4vLyBjb21wcmVzc2VkIGJhc2U2NC1lbmNvZGVkIGJsb2IgZm9yIGluY2x1ZGUtbmYgZGF0YVxuLy8gc291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vYWRyYWZmeS9lbnMtbm9ybWFsaXplLmpzL2Jsb2IvbWFpbi9zcmMvbWFrZS5qc1xuLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vYWRyYWZmeS9lbnMtbm9ybWFsaXplLmpzI3NlY3VyaXR5XG4vLyBTSEEtMjU2OiBhOTc0YjZmODU0MWZjMjlkOTE5YmM4NTExOGFmMGE0NDAxNTg1MWZhYjUzNDNmODY3OWNiMzFiZTJiZGIyMDllXG52YXIgQ09NUFJFU1NFRCA9ICdBRVVEVEFIQkNGUUFUUURSQURBQWNnQWdBRFFBRkFBc0FCUUFId0FPQUNRQURRQVJBQW9BRndBSEFCSUFDQUFQQUFVQUN3QUZBQXdBQkFBUUFBTUFCd0FFQUFvQUJRQUlBQUlBQ2dBQkFBUUFGQUFMQUFJQUN3QUJBQUlBQVFBSEFBTUFBd0FFQUFzQURBQU1BQXdBQ2dBTkFBMEFBd0FLQUFrQUJBQWRBQVlBWndEU0Fkc0RKZ0MwQ2tNQjh4aFpBcWZvQzE5MFVHY1RoZ0J1cndmN1BUMDlQYjA5QWpnSnVtOE9qRGxseEhZVUtYQVB4enE2dEFCQXhnSzh5c1V2V0FnTVBUMDlQVDA5UFNzNkxUMkhjZ1dYV3dGTG9TTUVFRWw1UkZWTUt2TzBYUThFeERkSk1uSWdzajI2UFRReXk4RmZFUThBWThJUEFHY0Vid1J3QkhFRWNnUnpCSFFFZFFSMkJIY0VlQVI2QkhzRWZBUitCSUFFZ2ZuZEJRb0JZZ1VMQVdJRkRBRmlCTmNFMkFUWkJSQUZFUVV2QmRBTEZBc1ZEUGNOQncxM0RZY09NQTR4RGpNQjRCbGxISTBCMmdyYkFNRHBITGtRN1FIVkFQUk5RUUZuR1JVRWcweUVCMnVhSkY4QUpwSUJwb2I1QUVSU01BS05vQVhxYVFMVUJNQ3pFaUFDbndSWkVra1ZzUzd0QU5Bc0JHMFJ1QVFMRVBBQnY5SElDVFVCWGlnUFp3UkJBcE1ET3dBYW1odGFBQnFFQVk4S3ZLeDNMUTRBckFCOFVod0VCQVZTYWdEOEFFRlpBRGtCSWFkVmoyVU1VZ3g1SWw0QU5RQzlBeElCMUJsYkVQTUFzMzBDR3hsWEFod1pLUUlFQ0JjNkVic0NveG5nenY3VXpSUUE4TTBCYXdMNlp3a043d0FCQUQzM09RUmNzZ0xKQ2pNQ2pxVUNodHcva20rTkFzWFBBb1AyQlQ4NFB3VVJBSzBSQXZwdGI2Y0FwUVMvT01NZXk1SEpTODRVZHhweFRQa0NvZ1ZGSVRhVE93RVJBSzVwQXZrTkJPVnlBN3EzQktsT0pTQUxBZ1VJQlJjRWRBU3BCWHF6QUJYRlNXWk9hd0xDT3F3Ly9Bb2xDWmR2djNkU0JrRVFHeWVsRVBjTU13RzFBVHNON1V2WUJQRUdPd1RKSDMwWkdRL05sWndJcFMzZERPMG00eTZoZ0ZvajlTcURCZTFMOUR6ZEMwMVJhQTlaQzJVSjR6cGpnVTRESVFFTklvc0szUTA1Q0cwUTh3ckphdzNsRVVVSE9RUFZTWm9BcFFjQkN4RWROUlcxSmhCaXJBc0pPWGNHK3hyMkM0OG1yeE1wZXZ3RjB4b2hCazBCS1JyL0FNOHU1NFd3V2pGY0hFOWZCZ01MSlNQSEZLaFFJQTBsUUxkNFNCb2JCeFVscVFLUlEzQktoMUUySHBNaDlqdzlEV1l1RTFGOEIvVThCUmxQQzRFOG5rYXJSUTRSMGo2TlBVZ2lTVXdzQkRWL0xDOG5pd25QRDRVTXVYeHlBVmtKSVFteERIRVRNUkVYTjhVSU9RY1pMWmNrSnhVSUlVYVZZSm9FOTU4RDh4UFJBd3NGUHdsQkJ4TUR0Und0RXk0VktRVU5nU1RYQXZNMjFTNnpBbzlXZ0FFWEJjc1BKUi9mRUZCSDRBN3BDSnNDWlFPREplc0FMUlVoQUJjaW13aERZd0JmajloVEJTN0xDTWRxYkNOMEEyY1U1MkVSY3dlUkRsY0hweHd6RmI4YzRYRElYZ3VHQ0NpanJ3bGJBWFVKbVFGZkJPTUlDVFZiaktBZ1FXZFRpMWdZbXlCaFFUOWQvQUl4REdVVm4wUzloM2dDaXc5ckVoc0JOUUZ6QnprTkFRSjNFZTBSYXhDVkNPdUdCRFcxTS9nNkpRUlBJWU1nRVFvbkEwOXN6Z3NuSnZrTStHa0JveEppQXd3MFBYZnVaNnRndGlRWC9RY1pNc1ZCWUNIeEM1SlB6UXljR3NFWVFsUXVHZVFIdndQekd2TW42a0ZYQmY4RG93TVRPazB6N2dTOUMya0lpd2svQUVrT294Y0gxeGhxQ25HTTBBRXhpd0czbVFOWGtZTUNiNDhHTndjTEFHY0xod1Y1NVFBZEFxY0lvd0FGQU04RFZ3QTVBcTBIblFBWkFJVkJBVDBESnk4QkllVUNqd09UQ0RITEFaVXZBZk1wQkJ2RERCVUE5emR1U2dMRHNRS0FhbWFpQmQxWUFvNENTVFVCVFNVRUJVNUhVUU92Y2VFQTJ3QkxCaFBmUndFVnEwckxHdU5EQWQ5dkt3REhBUHNBQlRVSEJVRUJ6UUh6YlFDM0FWOExNUW1pczdVQlRla3BBSU1BRldzQjF3S0pBTjBBTlFCLzhRRlRBRTBGV2ZrRjB3SlBTUUVSTVJnclYyRUJ1d01mQVRNQkRRQjVCc3VOcGNrSEh3UnRCOU1DRUJzVjRRTHZMZ2UxQVFNaTN4UE5Rc1VDdmQ1Vm9XQUNaSUVDWWtKYlRhOWJOeUFDb2ZjQ2FKZ0NaZ2tDbjRRNEd3c0NaanNDWmlZRWJnUi9BMzhUQTM2U09RWTVkeGM1Z2pvakl3SnNIUUl5TmpnS0FtM0hBbTJ1NzRvelowVXJBV2NBM2dEaEFFb0ZCNWdNalFEK0M4SUFEYlVDZHk4Q2RxSS9BbmxMUXdKNHVoMWMyMFd1UnRjQ2ZEOENlc2dDZlFrQ2ZQQUZXUVVnU0FCSWZXTWtBb0Z0QW9BQUFvQUZBbit1U1ZoS1d4VVhTc3dDMFFFQzBNeExKd09JVHdPSDVrVEZrVElDOHFGZEF3TURya3ZPVEMwbEE4OU5URTJ2QW9zL0Fvcll3UnNISFVObkJiY0NqamNDamx4QWw0RUNqdGtDamx4NFViUlROUXBTMUZTRkFwUDdBcE1NQU9rQUhGVWVWYTlWMEFZc0d5bVZoakxoZUdaRk96a0NsNThDNzdKWUlhZ0FXU1VDbG84Q2xueWNBS2xackZvSmdVMEFPd0tXdFFLV1RseEVYTkVDbWNzQ21XUmN5bDBIR1FLY216bkNPcDBDbkJZQ241c0NucmlLQUIwUE1Tb1BBcDN4QXA2U0FMVTlZVFJoN3dLZTB3S2diZ0dwQXA2Zkh3S2VUcVZqeUdRbkpTc0NKNjhDSm40Q29Qc0NvRXdDb3QwQ29jUUNwaThDcGM0Q3AvOEFmUUtuOG1oOGFMRUFBMGxxSEdyUkFxempBcXl1QXExbkFxMENBbGNkQWxYY0FySGgxd01mVG15WEFySzlEUUt5NkJkczRHMWpiVWhmQXlYTkFyWmNPejl1a0FNcFJRSzRYZ0s1UnhVQ3VTcDNjRFp3NFFLOUdRSzcybkNXQXpJUkFyNkljZ0lETTNFQ3ZocHpJbk5QQXNQTEFzTUVjNEowU3pWRmRPQURQS2NEUEpvRFBiOEN4WHdDeGtjQ3hoQ0pBc2hwVVFMSVJBTEpUd0xKTGdKa25RTGQwbmg1WVhpdWVTVkwwQU1ZbzJjQ0FtSDBHZk9WSkhzTFhwSmV1eEVDejJzQ3oyd3ZTMVBTOHhPZkFNYXRBczl6QVNucUEwNFNma3NGQXR3bkF0dUtBdEpQQTFKY0ExTmZBUUVEVll5QWlUOEF5eGJ0WUVXQ0hJTFRnczZEalFMYXh3TFozb1FRaEVtblBBT0dwUUF2QTJRT2huRlorUUJWQXQ5bEF0NjRjM2NDNGkvdEZBSHpNQ2NCOUpzQjh0S0hBdXZ6QXVsd2VRTHErUUxxNUFENVJ3RzVBdTZKQXV1Y2xxcVhBd0x1UHdPRjRKaDVjT0J4b1FMekF3QnBBNDRXbVpNQzl4TURrVzREa29jQzk1Z0MrZGtDK0dhYUhKcXJ1emViSGdPZGd3TCsrZ0ViQURtZkhKK3pBd1dOQTZacUE2YlpBTkhGQXdacW9ZaWlCUWtEREVrQ3dBQS9Bd0RoUVJkVEFSSHpBMnNIbDJjRkFKTXRLN2V2dmRzQmlaa1VmeEVFT1FIN0tRVWhEcDBKbndDUy9TbFh4UUwzQVowQXR3VzVBRzhMYlVFdUZDYU5MZ0ZEQVlEOEFiVW1BSFVERGdSdEFDd0NGZ3loQUFBS0FqMENhZ1BkQTM0RWtRRWdSUVVoZkFvQUJRQkVBQk1BTmhJQ2R3RUFCZFVEYSs4S3hRSUE5d3FmSjcreHQrVUJrU0ZCUWdIcEZIOFJOTUNKQUFRQUd3QmFBa1VDaElzQUJqcFRPcFNOYlFDNE9vODYwQUNOT01FNjNBQ2xBT2dBeXdFNmdUbzdPZnc1K1R0MmlUcGJPNTZKT204NUdBRldBVE1CYkFVdk5WMDFuald0TldZMWRUVzJOY1UxZ2pXUk5kSTE0VFdlTmEwMTdqWDlOYkkxd1RZQ05oRTF4alhWTmhZMkp6WGVOZTAyTGpZOU5pNDFMU0UyT2pZOU5qdzJ5VGNJQkpBOFZ6WTROdDAzSURjUE5zb2dONGszTUFvRXNEeG5OaVEzR1Rkc09vMDNJVUxVUXdkQzRFTUxIQThQQ1pzb2JTaFJWUVlBNlg4QTZiQUJGQ25YQXVrQm93QzlCYmNBYndOekJMOE1EQU1NQVFnREFBa0tDd3NMQ1FvR0JBVlZCSS9EdndEejliMjlrYVVDYjBRdHNSVE5MdDRlR0JjU0hBTVpGaFlaRWhZRUFSQUVCVUVjUVJ4QkhFRWNRUnhCSEVFYVFSeEJIRUZDU1R4QlBFbElTVWhCTmtNMlFUWWJOa2xJU1ZtQlZJZ0JGTFdaQXUwQmhRQ2pCY0VBYnlrQnZ3R0pBYVFjRVowZVBDa2xNQUFoTXZBSU1BTDU0Z0M3Qm04RWVzY2p6UU1wQVJRcEtnRFVBQmF2QWo2MjZ4UUFKUDBBM2V0enVmNE5OUkE3ZWZ5Mlo5TlFyQ25DME9TeUFOejVCQkliSjVJRkRSNm1pSWF2WVM2dHByamptdUtlYnhtNUM3NFEyMjVYMXBrYVlZUGI2ZjFESzRrM3hNRUJiOVMyV01qRWliVE5XaHNSSklBK3Z3TlZFaVhURTVpWHMvd2V6VjY2b0ZMZnA5TlpHWVcrR2sxOUoyK2JDVDZZZTJ3NkxEWWRnektNVWFiazU5NWVMQkNYQU56OUhVcFdiQVRxOXZxWFZ4OVhEZytQYzlYcDQrYnNTMDA1U1ZNL0JKQk00Njg3V1V1ZitVajlkRWk4YUROYVB4dHBiRHhjRzFUSFRJbVVNWnE0VUNhYU5ZcHNWcXJhTnlLTEpYRFlzRlovNWpsN2JMUnRPODh0N1AzeFphQXhoYjVPZFBNWHFzU2twMVdDaWVHOGpYbTFVOTkrYmx2TGxYelBDUytNOTNWbkpDaUsrMDlMZmFTYUJBVkJvbXlEZ0p1YThkZlV6UjdnYTM0SXZSMk52aitBOWhlSjZsc2wxS0c0TmtJMTAzMkNuZmYxbTF3b2YyQjlvSEpLNGJpNkprRWRTcWVOZWl1bzZRb1paaW5jb2M3My9USDlTWEY4c0NFN1h5dVl5VzhXU2diR0ZDalBWMGloTEtoZFBzMDhUeDgyZllBa0xMYzRJMndkbDRhcFk3R1U1bEhSRnpSV0plcDdXdzN3YmVBM3FtZDU5Lzg2UDR4dU5hcURweWdYdDZNODVnbFNCSE9DR2dKRG50K3BOOWJLN0hBcE1ndVg2KzA2UlpOanpWbWNaSit3Y1VySjkvL2JwUk54TnVLcE5sOXVGZHMrUzl0ZHg3TGFNNVprSXJQajZuSVU5bW5iRnRWYnM5cy91TGdsOE1WY3pBd2V0K2lPRXp6QmxZVzdSQ01nRTZneU5MZXE2KzF0SXg0ZHBnWm5kMERrc0pTNWYrSk5EcHd3Y1BOWGFhVnNwcTFmYlFhak9ySmdLMG9mS3RKMU5lOTBMNlZPNE1PbDVTODg2cDd1NnhvN09Makc4VEdMK0hVMUpYR0pncHBnNG5OYk5KNW5selNwdVBZeTIxSlVFY1VBOTRQb0ZpWmZqWnVlK1FueVE4MGVrT3VaVmt4eDRnK2N2aEpmSGdObDRoeTEvYTYrUktjS2xhci9KMjl5Ly9FenRsYlZQSFZVZVExelg4NmVRVkFqUi9NM2RBOXc0VzhMZmFYcDRFZ004NXdPV2FzbGk4MzdQelZNT25zTHpSK2szbzc1L2xSUEFKU0UxeEFLUXpFaTV2MTBrZStWQnZSdDFjd1FSTWQrVTVtTENUR1ZkNlhpWnRnQkc1Y0RpMHcyMkdLY1ZOdkhpdTVMUWJaRURWdHowb25uN2s1K2hldUtYVnNadFN6aWxrTFJBVW1qTVhFTUIzSjlZQzUwWEJ4UGl6NTNTQytFaG5QbDlXc0tDdjkyU00vT0ZGSU1KWllmbDBXVzh0SU8zVXhZY3dkTUFqN0ZTbWdyc1oyYUFaTzAzQk9oUDFiTk5aSXR5WFlRRlRwQzNTRzFWdVBEcUg5R2tpQ0RtRStKd3h5SVZTTzVzaURFckFPcEVYRmdqeTZQUXRPVkRqK3M2ZTFyOGhlV1Z2bVpuVGNpdWY0RWlOWnpDQWQ3U09NaFhFUklPbHNISU1HMzk5aTlhTFR5M20yaFJMWmpKVkROTFM1M2lHSUsxMWRQcVF0MHpCRHlnNnFjN1lxa0RtMk01VmU2ZENXQ2FDYlRYWDJyVG9hSWd6Nit6aDRsWVVpLys2bnFjRk1Ba1FKS0hZTEswd1lrNU45c3pWNnhpaERiRERGcjQ1bE4xSzRhQ1hCcS9GaXRQU3VkOWdMdDVaVm4rWnFHWDdjd20yejVFR01nZkZwSUZ5aEdHdURQbXNvNlRJdFRNd255Kzd1UG5MQ2Y0VzZnb0ZRRlYwb1FTc2M5VmZNbVZMY0xyNlpldERaYmFTRlRMcW5TTy9iSVBqQTMvekFVb3FnR0ZBRVFTNElodU16RXAySTNqSnpiemtrL0lFbXlheCtyaFpUd2Q2ZitDR3R3UGl4dThJdnpBQ3F1UFdQUkV1OVp2R2tVenBSd3ZSUnVhTk42Y3IwVzF3V2l0czlJQ2RZSjdsdGJnTWlTTDNzVFBldWZnTmNWcU1WV0ZrQ1BESDRqRzJqQTBYY1ZnUWo2MkNiMjl2OWYvei8rMktiWXZJdi96empwUUFQa2xpYVZEek5yVzU3VFovWk95WkQwbmxmTW1BSUJJQUdBSTBEM2svbWRONHhyOXY4NVpiWmJicWZIMmpHZDVoVXFOWld3bDVTUGZvR21mRWxtYXpVSWVOTDFqL21rRjdWTkF6VHE0ak50OEpvUTExTlFPY21ocHJYb3hTeGZSR0o5TERFT0FRK2RteEFRSDkwaXRpOWUydS9Nb2V1YUdjRFRIb0MreHNtRWVXbXhFS2VmUXVJekhicHc1VGM1Y0VvY2JvQUQwOW9pcFdRaHRUTzF3aXZmL08rRFJlMnJwbC9FOXdscnpCb3JqSnNPZUcxQi9YUFc0RWFKRUZkTmxFQ0VaZ2E1Wm9HUkhYZ1lvdUdSdVZrbTh0REVTaUV5Rk5vKzNzNU01cHVTZFR5VUwybGxuSU5WSEV0OTFYVU5XNGV3ZE1nSjRib0pmRXl0L2lZNVdYcWJBK0EyRmt0NVowbHV0aVdoZTluWkl5SVVqeVhEQzNVc2FHMXQrZU54Nno0Vy9PWW9UQjdBNngrZE5TVE9pOUFJbmN0YkVTcW01Z3ZPTHd3N09XWFBybUh3Vlphc3JsNGVEMTEzcG0rSnRUN0pWT3ZuQ1hxZHp6ZFRSSGdKMFBpR1RGWVc1R3Z0OVI5TEQ2THpmczB2L1RaWkhTbXlWTnE3dmlJSEU2REJLN1FwMDdJejU1RU04U1l0UXZaZi9vYkJuaVRXaTVDMi9vdkhmdzRWbmRrRTVYWWRqT2hDTVJqRGVPRWZYZU4vQ3dmR2R1aVVJZnNvRmVVeFhlUVhiYTdjNzk3MlhOdjh3K2RUampVTTBRZU5BUmVXK0owMTRkS0FEL01jUVlYVDdjMEdRUElrbjNMbDZSN2dHanVpUW9aRDBURWVFcVFwS29aMTVnLzBPUFFJMTdRaVN2OUFVUk9hL1YvVFFOM2R2TEFyZWMzUnJzWWx2Qm0xYjhMV3psdGR1Z3NDNTBsTktZTEVwMmErWlpZcVBlalVMUmxPSmg1emovTFZNeVREdndLaE14eHd1RGt4SjFRcG9OSTBPVFdMb200WjcxU056STlUVjFpWEpySXU5V2NuZCtNQ2FBdzhvMWpTWGQ5NFlVLzFnbmtyQzlCVUVPdFF2RUlRN2cwaTZoK0tMMkpLazhZZGw3SHJ1dmdXTVNBbU5lK0xzaEdoVjRxbldIaE85L1JJUFF6WTF0SFJqMlZxT3lOc0RwSzBjd3crNTZBZERDNGdzV3dZMFh4b3VjSVdJcXMvR2N3bldxbGFUMEtQcjhtYks1VTk0LzMwMWkxV0x0NFlJTlRWdkNGQnJGWmJJYlk4ZXljT2RlSjJ0ZUQ1SWZQTENSZzdqamNGVHdsTUZObDl6ZGgvbzNFL2hIUHdqN0JXZzBNVTA5cFByQkxickNnbTU0QTZIK0k2djI3K2pMNWdraldnL2lZZGtzOWpiZlZQNXkvbjBkbGdXRU1sS2FzbDdKdkZaZDU2TGZ5YlcxZWVhVk8wZ3hUZlhad0Q4RzRTSTExNnl4N1VLVlJndWk2WWExWXBpeHFYZU5MYzhJeHRBd0NVNUlod1FnbitOcUhuUmFEdjYxQ3hLaE9xNHBPWDdNNnBrQStQbXBkNGoxdm42QUNVQUxvTExjNHZwWGNpOFZpZEx4em03cUZCZTdzK3F1dUpzNkVUWW1ucGdTM0x3U1p4UElsdGdCRFh6OE0xay9XMnlTTnYyZjkvTlBoeExHSzJEMjFka0hlU0dtZW5SVDNZcWNkbDBtL2gzT1lyOFYrbFhOWUdmOGFDQ3BkNGJXakU0UUlQajd2VUtONE5yZnM3TUw2WTJPeVM4MzBKQ25vZmcvazdscEZwdDRTcVpjNUhHZzFIQ09ySHZPZEM4YlA2RkdEYkUvVlYwbVg0SWFremJkUy9vcCtLdDNHMjQvOFFiQlY3eTg2c0dTUS92WnpVOEZYczd1NmpJdndjaHNFUDJCcEloVzNHOHVXTndhM0htamZIL1pqaGhDV3ZsdUFjRituTWYxNENsS2c1aEdndFBMSjk4dWVOQWtjNUhzMldabGsyUUh2ZnJlQ0sxQ0NHTzZuTVpWU2I5OVZNL2FqcjhXSFR0ZTlKU21rWHEvaS9VOTQzSEViZHpXNlJlL1M4OGRLZ2c4cEdPTGxBZU5pcXJjTGtVUjMvYUNsRnBNWGNPVVAzcm1FVGNXU2ZNWFpFM1RVT2k4aStmcVJuVFlMZmxWeC9WYi82R0o3ZUlSWlVBNmszUllSM2lGU0s5YzRpRGROd0p1WkwyRkt6L0lLNVZpbWNOV0VxZFhqU294U2dtRjBVUGxEb1VsTnJQY003ZnRtQThZOWdLaXFLRUh1V04rQVpSSXd0VlN4eWUyS2Y4ck0zbGhKNVhjQlhVOW40djBPeTFSVTJNKzRxTThBUVBWd3NlOEVyTlNvYjVvRlBXeHVxWm5Wem8xcUIvSUJ4a00zRVZVS0ZVVWxPM2U1MTI1OUdnTmNKYkNtbHZyZGp0b1RXN3JDaG0xd3lDS3pwQ1R3b3pVVUVPSWNXTG5lUkxnTVhoK1NqR1NGa0FsbHpiR1M1SEs3TGxmQ01STlJEU3ZiUVBqY1hhZW5OWXhDdnUyUXl6bno2U3R1eFZqNjZTZ0kwVDhCNi9zZkhBSllaYVo3OHRoak9TSUZ1bU5XTFFiZVppeERDQ0MrdjBZQnRreGlCQjNqZWZIcVovZEZIVStjcmJqNk92UzF4L0pERDd2bG03ek9WUHdwVUMwMW5oeFp1WS82M0U3Zyc7XG5cbi8vIGh0dHBzOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjE1L1xyXG4vLyBmb3IgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9uXHJcbi8vIHNlZTogL2Rlcml2ZS9uZi5qc1xyXG5cclxuXHJcbi8vIGFsZ29yaXRobWljIGhhbmd1bFxyXG4vLyBodHRwczovL3d3dy51bmljb2RlLm9yZy92ZXJzaW9ucy9Vbmljb2RlMTUuMC4wL2NoMDMucGRmIChwYWdlIDE0NClcclxuY29uc3QgUzAgPSAweEFDMDA7XHJcbmNvbnN0IEwwID0gMHgxMTAwO1xyXG5jb25zdCBWMCA9IDB4MTE2MTtcclxuY29uc3QgVDAgPSAweDExQTc7XHJcbmNvbnN0IExfQ09VTlQgPSAxOTtcclxuY29uc3QgVl9DT1VOVCA9IDIxO1xyXG5jb25zdCBUX0NPVU5UID0gMjg7XHJcbmNvbnN0IE5fQ09VTlQgPSBWX0NPVU5UICogVF9DT1VOVDtcclxuY29uc3QgU19DT1VOVCA9IExfQ09VTlQgKiBOX0NPVU5UO1xyXG5jb25zdCBTMSA9IFMwICsgU19DT1VOVDtcclxuY29uc3QgTDEgPSBMMCArIExfQ09VTlQ7XHJcbmNvbnN0IFYxID0gVjAgKyBWX0NPVU5UO1xyXG5jb25zdCBUMSA9IFQwICsgVF9DT1VOVDtcclxuXHJcbmZ1bmN0aW9uIHVucGFja19jYyhwYWNrZWQpIHtcclxuXHRyZXR1cm4gKHBhY2tlZCA+PiAyNCkgJiAweEZGO1xyXG59XHJcbmZ1bmN0aW9uIHVucGFja19jcChwYWNrZWQpIHtcclxuXHRyZXR1cm4gcGFja2VkICYgMHhGRkZGRkY7XHJcbn1cclxuXHJcbmxldCBTSElGVEVEX1JBTkssIEVYQ0xVU0lPTlMsIERFQ09NUCwgUkVDT01QO1xyXG5cclxuZnVuY3Rpb24gaW5pdCQxKCkge1xyXG5cdC8vY29uc29sZS50aW1lKCduZicpO1xyXG5cdGxldCByID0gcmVhZF9jb21wcmVzc2VkX3BheWxvYWQoQ09NUFJFU1NFRCk7XHJcblx0U0hJRlRFRF9SQU5LID0gbmV3IE1hcChyZWFkX3NvcnRlZF9hcnJheXMocikuZmxhdE1hcCgodiwgaSkgPT4gdi5tYXAoeCA9PiBbeCwgKGkrMSkgPDwgMjRdKSkpOyAvLyBwcmUtc2hpZnRlZFxyXG5cdEVYQ0xVU0lPTlMgPSBuZXcgU2V0KHJlYWRfc29ydGVkKHIpKTtcclxuXHRERUNPTVAgPSBuZXcgTWFwKCk7XHJcblx0UkVDT01QID0gbmV3IE1hcCgpO1xyXG5cdGZvciAobGV0IFtjcCwgY3BzXSBvZiByZWFkX21hcHBlZChyKSkge1xyXG5cdFx0aWYgKCFFWENMVVNJT05TLmhhcyhjcCkgJiYgY3BzLmxlbmd0aCA9PSAyKSB7XHJcblx0XHRcdGxldCBbYSwgYl0gPSBjcHM7XHJcblx0XHRcdGxldCBidWNrZXQgPSBSRUNPTVAuZ2V0KGEpO1xyXG5cdFx0XHRpZiAoIWJ1Y2tldCkge1xyXG5cdFx0XHRcdGJ1Y2tldCA9IG5ldyBNYXAoKTtcclxuXHRcdFx0XHRSRUNPTVAuc2V0KGEsIGJ1Y2tldCk7XHJcblx0XHRcdH1cclxuXHRcdFx0YnVja2V0LnNldChiLCBjcCk7XHJcblx0XHR9XHJcblx0XHRERUNPTVAuc2V0KGNwLCBjcHMucmV2ZXJzZSgpKTsgLy8gc3RvcmVkIHJldmVyc2VkXHJcblx0fVxyXG5cdC8vY29uc29sZS50aW1lRW5kKCduZicpO1xyXG5cdC8vIDIwMjMwOTA1OiAxMW1zXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzX2hhbmd1bChjcCkge1xyXG5cdHJldHVybiBjcCA+PSBTMCAmJiBjcCA8IFMxO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb21wb3NlX3BhaXIoYSwgYikge1xyXG5cdGlmIChhID49IEwwICYmIGEgPCBMMSAmJiBiID49IFYwICYmIGIgPCBWMSkge1xyXG5cdFx0cmV0dXJuIFMwICsgKGEgLSBMMCkgKiBOX0NPVU5UICsgKGIgLSBWMCkgKiBUX0NPVU5UO1xyXG5cdH0gZWxzZSBpZiAoaXNfaGFuZ3VsKGEpICYmIGIgPiBUMCAmJiBiIDwgVDEgJiYgKGEgLSBTMCkgJSBUX0NPVU5UID09IDApIHtcclxuXHRcdHJldHVybiBhICsgKGIgLSBUMCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdGxldCByZWNvbXAgPSBSRUNPTVAuZ2V0KGEpO1xyXG5cdFx0aWYgKHJlY29tcCkge1xyXG5cdFx0XHRyZWNvbXAgPSByZWNvbXAuZ2V0KGIpO1xyXG5cdFx0XHRpZiAocmVjb21wKSB7XHJcblx0XHRcdFx0cmV0dXJuIHJlY29tcDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIC0xO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gZGVjb21wb3NlZChjcHMpIHtcclxuXHRpZiAoIVNISUZURURfUkFOSykgaW5pdCQxKCk7XHJcblx0bGV0IHJldCA9IFtdO1xyXG5cdGxldCBidWYgPSBbXTtcclxuXHRsZXQgY2hlY2tfb3JkZXIgPSBmYWxzZTtcclxuXHRmdW5jdGlvbiBhZGQoY3ApIHtcclxuXHRcdGxldCBjYyA9IFNISUZURURfUkFOSy5nZXQoY3ApO1xyXG5cdFx0aWYgKGNjKSB7XHJcblx0XHRcdGNoZWNrX29yZGVyID0gdHJ1ZTtcclxuXHRcdFx0Y3AgfD0gY2M7XHJcblx0XHR9XHJcblx0XHRyZXQucHVzaChjcCk7XHJcblx0fVxyXG5cdGZvciAobGV0IGNwIG9mIGNwcykge1xyXG5cdFx0d2hpbGUgKHRydWUpIHtcclxuXHRcdFx0aWYgKGNwIDwgMHg4MCkge1xyXG5cdFx0XHRcdHJldC5wdXNoKGNwKTtcclxuXHRcdFx0fSBlbHNlIGlmIChpc19oYW5ndWwoY3ApKSB7XHJcblx0XHRcdFx0bGV0IHNfaW5kZXggPSBjcCAtIFMwO1xyXG5cdFx0XHRcdGxldCBsX2luZGV4ID0gc19pbmRleCAvIE5fQ09VTlQgfCAwO1xyXG5cdFx0XHRcdGxldCB2X2luZGV4ID0gKHNfaW5kZXggJSBOX0NPVU5UKSAvIFRfQ09VTlQgfCAwO1xyXG5cdFx0XHRcdGxldCB0X2luZGV4ID0gc19pbmRleCAlIFRfQ09VTlQ7XHJcblx0XHRcdFx0YWRkKEwwICsgbF9pbmRleCk7XHJcblx0XHRcdFx0YWRkKFYwICsgdl9pbmRleCk7XHJcblx0XHRcdFx0aWYgKHRfaW5kZXggPiAwKSBhZGQoVDAgKyB0X2luZGV4KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsZXQgbWFwcGVkID0gREVDT01QLmdldChjcCk7XHJcblx0XHRcdFx0aWYgKG1hcHBlZCkge1xyXG5cdFx0XHRcdFx0YnVmLnB1c2goLi4ubWFwcGVkKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0YWRkKGNwKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKCFidWYubGVuZ3RoKSBicmVhaztcclxuXHRcdFx0Y3AgPSBidWYucG9wKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChjaGVja19vcmRlciAmJiByZXQubGVuZ3RoID4gMSkge1xyXG5cdFx0bGV0IHByZXZfY2MgPSB1bnBhY2tfY2MocmV0WzBdKTtcclxuXHRcdGZvciAobGV0IGkgPSAxOyBpIDwgcmV0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGxldCBjYyA9IHVucGFja19jYyhyZXRbaV0pO1xyXG5cdFx0XHRpZiAoY2MgPT0gMCB8fCBwcmV2X2NjIDw9IGNjKSB7XHJcblx0XHRcdFx0cHJldl9jYyA9IGNjO1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGxldCBqID0gaS0xO1xyXG5cdFx0XHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0XHRcdGxldCB0bXAgPSByZXRbaisxXTtcclxuXHRcdFx0XHRyZXRbaisxXSA9IHJldFtqXTtcclxuXHRcdFx0XHRyZXRbal0gPSB0bXA7XHJcblx0XHRcdFx0aWYgKCFqKSBicmVhaztcclxuXHRcdFx0XHRwcmV2X2NjID0gdW5wYWNrX2NjKHJldFstLWpdKTtcclxuXHRcdFx0XHRpZiAocHJldl9jYyA8PSBjYykgYnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdFx0cHJldl9jYyA9IHVucGFja19jYyhyZXRbaV0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gcmV0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb21wb3NlZF9mcm9tX2RlY29tcG9zZWQodikge1xyXG5cdGxldCByZXQgPSBbXTtcclxuXHRsZXQgc3RhY2sgPSBbXTtcclxuXHRsZXQgcHJldl9jcCA9IC0xO1xyXG5cdGxldCBwcmV2X2NjID0gMDtcclxuXHRmb3IgKGxldCBwYWNrZWQgb2Ygdikge1xyXG5cdFx0bGV0IGNjID0gdW5wYWNrX2NjKHBhY2tlZCk7XHJcblx0XHRsZXQgY3AgPSB1bnBhY2tfY3AocGFja2VkKTtcclxuXHRcdGlmIChwcmV2X2NwID09IC0xKSB7XHJcblx0XHRcdGlmIChjYyA9PSAwKSB7XHJcblx0XHRcdFx0cHJldl9jcCA9IGNwO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJldC5wdXNoKGNwKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmIChwcmV2X2NjID4gMCAmJiBwcmV2X2NjID49IGNjKSB7XHJcblx0XHRcdGlmIChjYyA9PSAwKSB7XHJcblx0XHRcdFx0cmV0LnB1c2gocHJldl9jcCwgLi4uc3RhY2spO1xyXG5cdFx0XHRcdHN0YWNrLmxlbmd0aCA9IDA7XHJcblx0XHRcdFx0cHJldl9jcCA9IGNwO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHN0YWNrLnB1c2goY3ApO1xyXG5cdFx0XHR9XHJcblx0XHRcdHByZXZfY2MgPSBjYztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGxldCBjb21wb3NlZCA9IGNvbXBvc2VfcGFpcihwcmV2X2NwLCBjcCk7XHJcblx0XHRcdGlmIChjb21wb3NlZCA+PSAwKSB7XHJcblx0XHRcdFx0cHJldl9jcCA9IGNvbXBvc2VkO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHByZXZfY2MgPT0gMCAmJiBjYyA9PSAwKSB7XHJcblx0XHRcdFx0cmV0LnB1c2gocHJldl9jcCk7XHJcblx0XHRcdFx0cHJldl9jcCA9IGNwO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHN0YWNrLnB1c2goY3ApO1xyXG5cdFx0XHRcdHByZXZfY2MgPSBjYztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAocHJldl9jcCA+PSAwKSB7XHJcblx0XHRyZXQucHVzaChwcmV2X2NwLCAuLi5zdGFjayk7XHRcclxuXHR9XHJcblx0cmV0dXJuIHJldDtcclxufVxyXG5cclxuLy8gbm90ZTogY3BzIGNhbiBiZSBpdGVyYWJsZVxyXG5mdW5jdGlvbiBuZmQoY3BzKSB7XHJcblx0cmV0dXJuIGRlY29tcG9zZWQoY3BzKS5tYXAodW5wYWNrX2NwKTtcclxufVxyXG5mdW5jdGlvbiBuZmMoY3BzKSB7XHJcblx0cmV0dXJuIGNvbXBvc2VkX2Zyb21fZGVjb21wb3NlZChkZWNvbXBvc2VkKGNwcykpO1xyXG59XG5cbmNvbnN0IEhZUEhFTiA9IDB4MkQ7XHJcbmNvbnN0IFNUT1AgPSAweDJFO1xyXG5jb25zdCBTVE9QX0NIID0gJy4nO1xyXG5jb25zdCBGRTBGID0gMHhGRTBGO1xyXG5jb25zdCBVTklRVUVfUEggPSAxO1xyXG5cclxuLy8gMjAyMzA5MTM6IHJlcGxhY2UgWy4uLnZdIHdpdGggQXJyYXlfZnJvbSh2KSB0byBhdm9pZCBsYXJnZSBzcHJlYWRzXHJcbmNvbnN0IEFycmF5X2Zyb20gPSB4ID0+IEFycmF5LmZyb20oeCk7IC8vIEFycmF5LmZyb20uYmluZChBcnJheSk7XHJcblxyXG5mdW5jdGlvbiBncm91cF9oYXNfY3AoZywgY3ApIHtcclxuXHQvLyAyMDIzMDkxMzoga2VlcCBwcmltYXJ5IGFuZCBzZWNvbmRhcnkgZGlzdGluY3QgaW5zdGVhZCBvZiBjcmVhdGluZyB2YWxpZCB1bmlvblxyXG5cdHJldHVybiBnLlAuaGFzKGNwKSB8fCBnLlEuaGFzKGNwKTtcclxufVxyXG5cclxuY2xhc3MgRW1vamkgZXh0ZW5kcyBBcnJheSB7XHJcblx0Z2V0IGlzX2Vtb2ppKCkgeyByZXR1cm4gdHJ1ZTsgfSAvLyBmcmVlIHRhZ2dpbmcgc3lzdGVtXHJcbn1cclxuXHJcbmxldCBNQVBQRUQsIElHTk9SRUQsIENNLCBOU00sIEVTQ0FQRSwgTkZDX0NIRUNLLCBHUk9VUFMsIFdIT0xFX1ZBTElELCBXSE9MRV9NQVAsIFZBTElELCBFTU9KSV9MSVNULCBFTU9KSV9ST09UO1xyXG5cclxuZnVuY3Rpb24gaW5pdCgpIHtcclxuXHRpZiAoTUFQUEVEKSByZXR1cm47XHJcblx0XHJcblx0bGV0IHIgPSByZWFkX2NvbXByZXNzZWRfcGF5bG9hZChDT01QUkVTU0VEJDEpO1xyXG5cdGNvbnN0IHJlYWRfc29ydGVkX2FycmF5ID0gKCkgPT4gcmVhZF9zb3J0ZWQocik7XHJcblx0Y29uc3QgcmVhZF9zb3J0ZWRfc2V0ID0gKCkgPT4gbmV3IFNldChyZWFkX3NvcnRlZF9hcnJheSgpKTtcclxuXHRjb25zdCBzZXRfYWRkX21hbnkgPSAoc2V0LCB2KSA9PiB2LmZvckVhY2goeCA9PiBzZXQuYWRkKHgpKTtcclxuXHJcblx0TUFQUEVEID0gbmV3IE1hcChyZWFkX21hcHBlZChyKSk7IFxyXG5cdElHTk9SRUQgPSByZWFkX3NvcnRlZF9zZXQoKTsgLy8gaWdub3JlZCBjaGFyYWN0ZXJzIGFyZSBub3QgdmFsaWQsIHNvIGp1c3QgcmVhZCByYXcgY29kZXBvaW50c1xyXG5cclxuXHQvKlxyXG5cdC8vIGRpcmVjdCBpbmNsdWRlIGZyb20gcGF5bG9hZCBpcyBzbWFsbGVyIHRoYW4gdGhlIGRlY29tcHJlc3Npb24gY29kZVxyXG5cdGNvbnN0IEZFTkNFRCA9IG5ldyBNYXAocmVhZF9hcnJheV93aGlsZSgoKSA9PiB7XHJcblx0XHRsZXQgY3AgPSByKCk7XHJcblx0XHRpZiAoY3ApIHJldHVybiBbY3AsIHJlYWRfc3RyKHIoKSldO1xyXG5cdH0pKTtcclxuXHQqL1xyXG5cdC8vIDIwMjMwMjE3OiB3ZSBzdGlsbCBuZWVkIGFsbCBDTSBmb3IgcHJvcGVyIGVycm9yIGZvcm1hdHRpbmdcclxuXHQvLyBidXQgbm9ybSBvbmx5IG5lZWRzIE5TTSBzdWJzZXQgdGhhdCBhcmUgcG90ZW50aWFsbHktdmFsaWRcclxuXHRDTSA9IHJlYWRfc29ydGVkX2FycmF5KCk7XHJcblx0TlNNID0gbmV3IFNldChyZWFkX3NvcnRlZF9hcnJheSgpLm1hcChpID0+IENNW2ldKSk7XHJcblx0Q00gPSBuZXcgU2V0KENNKTtcclxuXHRcclxuXHRFU0NBUEUgPSByZWFkX3NvcnRlZF9zZXQoKTsgLy8gY2hhcmFjdGVycyB0aGF0IHNob3VsZCBub3QgYmUgcHJpbnRlZFxyXG5cdE5GQ19DSEVDSyA9IHJlYWRfc29ydGVkX3NldCgpOyAvLyBvbmx5IG5lZWRlZCB0byBpbGx1c3RyYXRlIGVuc190b2tlbml6ZSgpIHRyYW5zZm9ybWF0aW9uc1xyXG5cclxuXHRsZXQgY2h1bmtzID0gcmVhZF9zb3J0ZWRfYXJyYXlzKHIpO1xyXG5cdGxldCB1bnJlc3RyaWN0ZWQgPSByKCk7XHJcblx0Ly9jb25zdCByZWFkX2NodW5rZWQgPSAoKSA9PiBuZXcgU2V0KHJlYWRfc29ydGVkX2FycmF5KCkuZmxhdE1hcChpID0+IGNodW5rc1tpXSkuY29uY2F0KHJlYWRfc29ydGVkX2FycmF5KCkpKTtcclxuXHRjb25zdCByZWFkX2NodW5rZWQgPSAoKSA9PiB7XHJcblx0XHQvLyAyMDIzMDkyMTogYnVpbGQgc2V0IGluIHBhcnRzLCAyeCBmYXN0ZXJcclxuXHRcdGxldCBzZXQgPSBuZXcgU2V0KCk7XHJcblx0XHRyZWFkX3NvcnRlZF9hcnJheSgpLmZvckVhY2goaSA9PiBzZXRfYWRkX21hbnkoc2V0LCBjaHVua3NbaV0pKTtcclxuXHRcdHNldF9hZGRfbWFueShzZXQsIHJlYWRfc29ydGVkX2FycmF5KCkpO1xyXG5cdFx0cmV0dXJuIHNldDsgXHJcblx0fTtcclxuXHRHUk9VUFMgPSByZWFkX2FycmF5X3doaWxlKGkgPT4ge1xyXG5cdFx0Ly8gbWluaWZpZXIgcHJvcGVydHkgbWFuZ2xpbmcgc2VlbXMgdW5zYWZlXHJcblx0XHQvLyBzbyB0aGVzZSBhcmUgbWFudWFsbHkgcmVuYW1lZCB0byBzaW5nbGUgY2hhcnNcclxuXHRcdGxldCBOID0gcmVhZF9hcnJheV93aGlsZShyKS5tYXAoeCA9PiB4KzB4NjApO1xyXG5cdFx0aWYgKE4ubGVuZ3RoKSB7XHJcblx0XHRcdGxldCBSID0gaSA+PSB1bnJlc3RyaWN0ZWQ7IC8vIHVucmVzdHJpY3RlZCB0aGVuIHJlc3RyaWN0ZWRcclxuXHRcdFx0TlswXSAtPSAzMjsgLy8gY2FwaXRhbGl6ZVxyXG5cdFx0XHROID0gc3RyX2Zyb21fY3BzKE4pO1xyXG5cdFx0XHRpZiAoUikgTj1gUmVzdHJpY3RlZFske059XWA7XHJcblx0XHRcdGxldCBQID0gcmVhZF9jaHVua2VkKCk7IC8vIHByaW1hcnlcclxuXHRcdFx0bGV0IFEgPSByZWFkX2NodW5rZWQoKTsgLy8gc2Vjb25kYXJ5XHJcblx0XHRcdGxldCBNID0gIXIoKTsgLy8gbm90LXdoaXRlbGlzdGVkLCBjaGVjayBmb3IgTlNNXHJcblx0XHRcdC8vICoqKiB0aGlzIGNvZGUgY3VycmVudGx5IGlzbid0IG5lZWRlZCAqKipcclxuXHRcdFx0LypcclxuXHRcdFx0bGV0IFYgPSBbLi4uUCwgLi4uUV0uc29ydCgoYSwgYikgPT4gYS1iKTsgLy8gZGVyaXZlOiBzb3J0ZWQgdmFsaWRcclxuXHRcdFx0bGV0IE0gPSByKCktMTsgLy8gbnVtYmVyIG9mIGNvbWJpbmluZyBtYXJrXHJcblx0XHRcdGlmIChNIDwgMCkgeyAvLyB3aGl0ZWxpc3RlZFxyXG5cdFx0XHRcdE0gPSBuZXcgTWFwKHJlYWRfYXJyYXlfd2hpbGUoKCkgPT4ge1xyXG5cdFx0XHRcdFx0bGV0IGkgPSByKCk7XHJcblx0XHRcdFx0XHRpZiAoaSkgcmV0dXJuIFtWW2ktMV0sIHJlYWRfYXJyYXlfd2hpbGUoKCkgPT4ge1xyXG5cdFx0XHRcdFx0XHRsZXQgdiA9IHJlYWRfYXJyYXlfd2hpbGUocik7XHJcblx0XHRcdFx0XHRcdGlmICh2Lmxlbmd0aCkgcmV0dXJuIHYubWFwKHggPT4geC0xKTtcclxuXHRcdFx0XHRcdH0pXTtcclxuXHRcdFx0XHR9KSk7XHJcblx0XHRcdH0qL1xyXG5cdFx0XHRyZXR1cm4ge04sIFAsIFEsIE0sIFJ9O1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHQvLyBkZWNvZGUgY29tcHJlc3NlZCB3aG9sZXNcclxuXHRXSE9MRV9WQUxJRCA9IHJlYWRfc29ydGVkX3NldCgpO1xyXG5cdFdIT0xFX01BUCA9IG5ldyBNYXAoKTtcclxuXHRsZXQgd2hvbGVzID0gcmVhZF9zb3J0ZWRfYXJyYXkoKS5jb25jYXQoQXJyYXlfZnJvbShXSE9MRV9WQUxJRCkpLnNvcnQoKGEsIGIpID0+IGEtYik7IC8vIG11c3QgYmUgc29ydGVkXHJcblx0d2hvbGVzLmZvckVhY2goKGNwLCBpKSA9PiB7XHJcblx0XHRsZXQgZCA9IHIoKTsgXHJcblx0XHRsZXQgdyA9IHdob2xlc1tpXSA9IGQgPyB3aG9sZXNbaS1kXSA6IHtWOiBbXSwgTTogbmV3IE1hcCgpfTtcclxuXHRcdHcuVi5wdXNoKGNwKTsgLy8gYWRkIHRvIG1lbWJlciBzZXRcclxuXHRcdGlmICghV0hPTEVfVkFMSUQuaGFzKGNwKSkge1xyXG5cdFx0XHRXSE9MRV9NQVAuc2V0KGNwLCB3KTsgIC8vIHJlZ2lzdGVyIHdpdGggd2hvbGUgbWFwXHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdC8vIGNvbXB1dGUgY29uZnVzYWJsZS1leHRlbnQgY29tcGxlbWVudHNcclxuXHQvLyB1c2FnZTogV0hPTEVfTUFQLmdldChjcCkuTS5nZXQoY3ApID0gY29tcGxlbWVudCBzZXRcclxuXHRmb3IgKGxldCB7ViwgTX0gb2YgbmV3IFNldChXSE9MRV9NQVAudmFsdWVzKCkpKSB7XHJcblx0XHQvLyBjb25uZWN0IGFsbCBncm91cHMgdGhhdCBoYXZlIGVhY2ggd2hvbGUgY2hhcmFjdGVyXHJcblx0XHRsZXQgcmVjcyA9IFtdO1xyXG5cdFx0Zm9yIChsZXQgY3Agb2YgVikge1xyXG5cdFx0XHRsZXQgZ3MgPSBHUk9VUFMuZmlsdGVyKGcgPT4gZ3JvdXBfaGFzX2NwKGcsIGNwKSk7XHJcblx0XHRcdGxldCByZWMgPSByZWNzLmZpbmQoKHtHfSkgPT4gZ3Muc29tZShnID0+IEcuaGFzKGcpKSk7XHJcblx0XHRcdGlmICghcmVjKSB7XHJcblx0XHRcdFx0cmVjID0ge0c6IG5ldyBTZXQoKSwgVjogW119O1xyXG5cdFx0XHRcdHJlY3MucHVzaChyZWMpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJlYy5WLnB1c2goY3ApO1xyXG5cdFx0XHRzZXRfYWRkX21hbnkocmVjLkcsIGdzKTtcclxuXHRcdH1cclxuXHRcdC8vIHBlciBjaGFyYWN0ZXIgY2FjaGUgZ3JvdXBzIHdoaWNoIGFyZSBub3QgYSBtZW1iZXIgb2YgdGhlIGV4dGVudFxyXG5cdFx0bGV0IHVuaW9uID0gcmVjcy5mbGF0TWFwKHggPT4gQXJyYXlfZnJvbSh4LkcpKTsgLy8gYWxsIG9mIHRoZSBncm91cHMgdXNlZCBieSB0aGlzIHdob2xlXHJcblx0XHRmb3IgKGxldCB7RywgVn0gb2YgcmVjcykge1xyXG5cdFx0XHRsZXQgY29tcGxlbWVudCA9IG5ldyBTZXQodW5pb24uZmlsdGVyKGcgPT4gIUcuaGFzKGcpKSk7IC8vIGdyb3VwcyBub3QgY292ZXJlZCBieSB0aGUgZXh0ZW50XHJcblx0XHRcdGZvciAobGV0IGNwIG9mIFYpIHtcclxuXHRcdFx0XHRNLnNldChjcCwgY29tcGxlbWVudCk7IC8vIHRoaXMgaXMgdGhlIHNhbWUgcmVmZXJlbmNlXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIGNvbXB1dGUgdmFsaWQgc2V0XHJcblx0Ly8gMjAyMzA5MjQ6IFZBTElEIHdhcyB1bmlvbiBidXQgY2FuIGJlIHJlLXVzZWRcclxuXHRWQUxJRCA9IG5ldyBTZXQoKTsgLy8gZXhpc3RzIGluIDErIGdyb3Vwc1xyXG5cdGxldCBtdWx0aSA9IG5ldyBTZXQoKTsgLy8gZXhpc3RzIGluIDIrIGdyb3Vwc1xyXG5cdGNvbnN0IGFkZF90b191bmlvbiA9IGNwID0+IFZBTElELmhhcyhjcCkgPyBtdWx0aS5hZGQoY3ApIDogVkFMSUQuYWRkKGNwKTtcclxuXHRmb3IgKGxldCBnIG9mIEdST1VQUykge1xyXG5cdFx0Zm9yIChsZXQgY3Agb2YgZy5QKSBhZGRfdG9fdW5pb24oY3ApO1xyXG5cdFx0Zm9yIChsZXQgY3Agb2YgZy5RKSBhZGRfdG9fdW5pb24oY3ApO1xyXG5cdH1cclxuXHQvLyBkdWFsIHB1cnBvc2UgV0hPTEVfTUFQOiByZXR1cm4gcGxhY2Vob2xkZXIgaWYgdW5pcXVlIG5vbi1jb25mdXNhYmxlXHJcblx0Zm9yIChsZXQgY3Agb2YgVkFMSUQpIHtcclxuXHRcdGlmICghV0hPTEVfTUFQLmhhcyhjcCkgJiYgIW11bHRpLmhhcyhjcCkpIHtcclxuXHRcdFx0V0hPTEVfTUFQLnNldChjcCwgVU5JUVVFX1BIKTtcclxuXHRcdH1cclxuXHR9XHJcblx0Ly8gYWRkIGFsbCBkZWNvbXBvc2VkIHBhcnRzXHJcblx0Ly8gc2VlIGRlcml2ZTogXCJWYWxpZCBpcyBDbG9zZWQgKHZpYSBCcnV0ZS1mb3JjZSlcIlxyXG5cdHNldF9hZGRfbWFueShWQUxJRCwgbmZkKFZBTElEKSk7XHJcblx0XHJcblx0Ly8gZGVjb2RlIGVtb2ppXHJcblx0Ly8gMjAyMzA3MTk6IGVtb2ppIGFyZSBub3cgZnVsbHktZXhwYW5kZWQgdG8gYXZvaWQgcXVpcmsgbG9naWMgXHJcblx0RU1PSklfTElTVCA9IHJlYWRfdHJpZShyKS5tYXAodiA9PiBFbW9qaS5mcm9tKHYpKS5zb3J0KGNvbXBhcmVfYXJyYXlzKTtcclxuXHRFTU9KSV9ST09UID0gbmV3IE1hcCgpOyAvLyB0aGlzIGhhcyBhcHByb3ggN0sgbm9kZXMgKDIrIHBlciBlbW9qaSlcclxuXHRmb3IgKGxldCBjcHMgb2YgRU1PSklfTElTVCkge1xyXG5cdFx0Ly8gMjAyMzA3MTk6IGNoYW5nZSB0byAqc2xpZ2h0bHkqIHN0cmljdGVyIGFsZ29yaXRobSB3aGljaCBkaXNhbGxvd3MgXHJcblx0XHQvLyBpbnNlcnRpb24gb2YgbWlzcGxhY2VkIEZFMEYgaW4gZW1vamkgc2VxdWVuY2VzIChtYXRjaGluZyBFTlNJUC0xNSlcclxuXHRcdC8vIGV4YW1wbGU6IGJlYXV0aWZpZWQgW0EgQl0gKGVnLiBmbGFnIGVtb2ppKSBcclxuXHRcdC8vICBiZWZvcmU6IGFsbG93OiBbQSBGRTBGIEJdLCBlcnJvcjogW0EgRkUwRiBGRTBGIEJdIFxyXG5cdFx0Ly8gICBhZnRlcjogZXJyb3I6IGJvdGhcclxuXHRcdC8vIG5vdGU6IHRoaXMgY29kZSBub3cgbWF0Y2hlcyBFTlNOb3JtYWxpemUue2NzLGphdmF9IGxvZ2ljXHJcblx0XHRsZXQgcHJldiA9IFtFTU9KSV9ST09UXTtcclxuXHRcdGZvciAobGV0IGNwIG9mIGNwcykge1xyXG5cdFx0XHRsZXQgbmV4dCA9IHByZXYubWFwKG5vZGUgPT4ge1xyXG5cdFx0XHRcdGxldCBjaGlsZCA9IG5vZGUuZ2V0KGNwKTtcclxuXHRcdFx0XHRpZiAoIWNoaWxkKSB7XHJcblx0XHRcdFx0XHQvLyBzaG91bGQgdGhpcyBiZSBvYmplY3Q/IFxyXG5cdFx0XHRcdFx0Ly8gKG1vc3QgaGF2ZSAxLTIgaXRlbXMsIGZldyBoYXZlIG1hbnkpXHJcblx0XHRcdFx0XHQvLyAyMDIzMDcxOTogbm8sIHY4IGRlZmF1bHQgbWFwIGlzIDQ/XHJcblx0XHRcdFx0XHRjaGlsZCA9IG5ldyBNYXAoKTtcclxuXHRcdFx0XHRcdG5vZGUuc2V0KGNwLCBjaGlsZCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBjaGlsZDtcclxuXHRcdFx0fSk7XHJcblx0XHRcdGlmIChjcCA9PT0gRkUwRikge1xyXG5cdFx0XHRcdHByZXYucHVzaCguLi5uZXh0KTsgLy8gbGVzcyB0aGFuIDIwIGVsZW1lbnRzXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cHJldiA9IG5leHQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGZvciAobGV0IHggb2YgcHJldikge1xyXG5cdFx0XHR4LlYgPSBjcHM7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG4vLyBpZiBlc2NhcGVkOiB7SEVYfVxyXG4vLyAgICAgICBlbHNlOiBcInhcIiB7SEVYfVxyXG5mdW5jdGlvbiBxdW90ZWRfY3AoY3ApIHtcclxuXHRyZXR1cm4gKHNob3VsZF9lc2NhcGUoY3ApID8gJycgOiBgJHtiaWRpX3FxKHNhZmVfc3RyX2Zyb21fY3BzKFtjcF0pKX0gYCkgKyBxdW90ZV9jcChjcCk7XHJcbn1cclxuXHJcbi8vIDIwMjMwMjExOiBzb21lIG1lc3NhZ2VzIGNhbiBiZSBtaXhlZC1kaXJlY3Rpb25hbCBhbmQgcmVzdWx0IGluIHNwaWxsb3ZlclxyXG4vLyB1c2UgMjAwRSBhZnRlciBhIHF1b3RlZCBzdHJpbmcgdG8gZm9yY2UgdGhlIHJlbWFpbmRlciBvZiBhIHN0cmluZyBmcm9tIFxyXG4vLyBhY3F1cmluZyB0aGUgZGlyZWN0aW9uIG9mIHRoZSBxdW90ZVxyXG4vLyBodHRwczovL3d3dy53My5vcmcvSW50ZXJuYXRpb25hbC9xdWVzdGlvbnMvcWEtYmlkaS11bmljb2RlLWNvbnRyb2xzI2V4Y2VwdGlvbnNcclxuZnVuY3Rpb24gYmlkaV9xcShzKSB7XHJcblx0cmV0dXJuIGBcIiR7c31cIlxcdTIwMEVgOyAvLyBzdHJvbmcgTFRSXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrX2xhYmVsX2V4dGVuc2lvbihjcHMpIHtcclxuXHRpZiAoY3BzLmxlbmd0aCA+PSA0ICYmIGNwc1syXSA9PSBIWVBIRU4gJiYgY3BzWzNdID09IEhZUEhFTikge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGxhYmVsIGV4dGVuc2lvbjogXCIke3N0cl9mcm9tX2NwcyhjcHMuc2xpY2UoMCwgNCkpfVwiYCk7IC8vIHRoaXMgY2FuIG9ubHkgYmUgYXNjaWkgc28gY2FudCBiZSBiaWRpXHJcblx0fVxyXG59XHJcbmZ1bmN0aW9uIGNoZWNrX2xlYWRpbmdfdW5kZXJzY29yZShjcHMpIHtcclxuXHRjb25zdCBVTkRFUlNDT1JFID0gMHg1RjtcclxuXHRmb3IgKGxldCBpID0gY3BzLmxhc3RJbmRleE9mKFVOREVSU0NPUkUpOyBpID4gMDsgKSB7XHJcblx0XHRpZiAoY3BzWy0taV0gIT09IFVOREVSU0NPUkUpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCd1bmRlcnNjb3JlIGFsbG93ZWQgb25seSBhdCBzdGFydCcpO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG4vLyBjaGVjayB0aGF0IGEgZmVuY2VkIGNwIGlzIG5vdCBsZWFkaW5nLCB0cmFpbGluZywgb3IgdG91Y2hpbmcgYW5vdGhlciBmZW5jZWQgY3BcclxuZnVuY3Rpb24gY2hlY2tfZmVuY2VkKGNwcykge1xyXG5cdGxldCBjcCA9IGNwc1swXTtcclxuXHRsZXQgcHJldiA9IEZFTkNFRC5nZXQoY3ApO1xyXG5cdGlmIChwcmV2KSB0aHJvdyBlcnJvcl9wbGFjZW1lbnQoYGxlYWRpbmcgJHtwcmV2fWApO1xyXG5cdGxldCBuID0gY3BzLmxlbmd0aDtcclxuXHRsZXQgbGFzdCA9IC0xOyAvLyBwcmV2ZW50cyB0cmFpbGluZyBmcm9tIHRocm93aW5nXHJcblx0Zm9yIChsZXQgaSA9IDE7IGkgPCBuOyBpKyspIHtcclxuXHRcdGNwID0gY3BzW2ldO1xyXG5cdFx0bGV0IG1hdGNoID0gRkVOQ0VELmdldChjcCk7XHJcblx0XHRpZiAobWF0Y2gpIHtcclxuXHRcdFx0Ly8gc2luY2UgY3BzWzBdIGlzbid0IGZlbmNlZCwgY3BzWzFdIGNhbm5vdCB0aHJvd1xyXG5cdFx0XHRpZiAobGFzdCA9PSBpKSB0aHJvdyBlcnJvcl9wbGFjZW1lbnQoYCR7cHJldn0gKyAke21hdGNofWApO1xyXG5cdFx0XHRsYXN0ID0gaSArIDE7XHJcblx0XHRcdHByZXYgPSBtYXRjaDtcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKGxhc3QgPT0gbikgdGhyb3cgZXJyb3JfcGxhY2VtZW50KGB0cmFpbGluZyAke3ByZXZ9YCk7XHJcbn1cclxuXHJcbi8vIGNyZWF0ZSBhIHNhZmUgdG8gcHJpbnQgc3RyaW5nIFxyXG4vLyBpbnZpc2libGVzIGFyZSBlc2NhcGVkXHJcbi8vIGxlYWRpbmcgY20gdXNlcyBwbGFjZWhvbGRlclxyXG4vLyBpZiBjcHMgZXhjZWVkIG1heCwgbWlkZGxlIHRydW5jYXRlIHdpdGggZWxsaXBzaXNcclxuLy8gcXVvdGVyKGNwKSA9PiBzdHJpbmcsIGVnLiAzMDAwID0+IFwiezMwMDB9XCJcclxuLy8gbm90ZTogaW4gaHRtbCwgeW91J2QgY2FsbCB0aGlzIGZ1bmN0aW9uIHRoZW4gcmVwbGFjZSBbPD4mXSB3aXRoIGVudGl0aWVzXHJcbmZ1bmN0aW9uIHNhZmVfc3RyX2Zyb21fY3BzKGNwcywgbWF4ID0gSW5maW5pdHksIHF1b3RlciA9IHF1b3RlX2NwKSB7XHJcblx0Ly9pZiAoTnVtYmVyLmlzSW50ZWdlcihjcHMpKSBjcHMgPSBbY3BzXTtcclxuXHQvL2lmICghQXJyYXkuaXNBcnJheShjcHMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKGBleHBlY3RlZCBjb2RlcG9pbnRzYCk7XHJcblx0bGV0IGJ1ZiA9IFtdO1xyXG5cdGlmIChpc19jb21iaW5pbmdfbWFyayhjcHNbMF0pKSBidWYucHVzaCgn4peMJyk7XHJcblx0aWYgKGNwcy5sZW5ndGggPiBtYXgpIHtcclxuXHRcdG1heCA+Pj0gMTtcclxuXHRcdGNwcyA9IFsuLi5jcHMuc2xpY2UoMCwgbWF4KSwgMHgyMDI2LCAuLi5jcHMuc2xpY2UoLW1heCldO1xyXG5cdH1cclxuXHRsZXQgcHJldiA9IDA7XHJcblx0bGV0IG4gPSBjcHMubGVuZ3RoO1xyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcblx0XHRsZXQgY3AgPSBjcHNbaV07XHJcblx0XHRpZiAoc2hvdWxkX2VzY2FwZShjcCkpIHtcclxuXHRcdFx0YnVmLnB1c2goc3RyX2Zyb21fY3BzKGNwcy5zbGljZShwcmV2LCBpKSkpO1xyXG5cdFx0XHRidWYucHVzaChxdW90ZXIoY3ApKTtcclxuXHRcdFx0cHJldiA9IGkgKyAxO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRidWYucHVzaChzdHJfZnJvbV9jcHMoY3BzLnNsaWNlKHByZXYsIG4pKSk7XHJcblx0cmV0dXJuIGJ1Zi5qb2luKCcnKTtcclxufVxyXG5cclxuLy8gbm90ZTogc2V0KHMpIGNhbm5vdCBiZSBleHBvc2VkIGJlY2F1c2UgdGhleSBjYW4gYmUgbW9kaWZpZWRcclxuLy8gbm90ZTogT2JqZWN0LmZyZWV6ZSgpIGRvZXNuJ3Qgd29ya1xyXG5mdW5jdGlvbiBpc19jb21iaW5pbmdfbWFyayhjcCkge1xyXG5cdGluaXQoKTtcclxuXHRyZXR1cm4gQ00uaGFzKGNwKTtcclxufVxyXG5mdW5jdGlvbiBzaG91bGRfZXNjYXBlKGNwKSB7XHJcblx0aW5pdCgpO1xyXG5cdHJldHVybiBFU0NBUEUuaGFzKGNwKTtcclxufVxyXG5cclxuLy8gcmV0dXJuIGFsbCBzdXBwb3J0ZWQgZW1vamkgYXMgZnVsbHktcXVhbGlmaWVkIGVtb2ppIFxyXG4vLyBvcmRlcmVkIGJ5IGxlbmd0aCB0aGVuIGxleGljb2dyYXBoaWMgXHJcbmZ1bmN0aW9uIGVuc19lbW9qaSgpIHtcclxuXHRpbml0KCk7XHJcblx0cmV0dXJuIEVNT0pJX0xJU1QubWFwKHggPT4geC5zbGljZSgpKTsgLy8gZW1vamkgYXJlIGV4cG9zZWQgc28gY29weVxyXG59XHJcblxyXG5mdW5jdGlvbiBlbnNfbm9ybWFsaXplX2ZyYWdtZW50KGZyYWcsIGRlY29tcG9zZSkge1xyXG5cdGluaXQoKTtcclxuXHRsZXQgbmYgPSBkZWNvbXBvc2UgPyBuZmQgOiBuZmM7XHJcblx0cmV0dXJuIGZyYWcuc3BsaXQoU1RPUF9DSCkubWFwKGxhYmVsID0+IHN0cl9mcm9tX2Nwcyh0b2tlbnNfZnJvbV9zdHIoZXhwbG9kZV9jcChsYWJlbCksIG5mLCBmaWx0ZXJfZmUwZikuZmxhdCgpKSkuam9pbihTVE9QX0NIKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZW5zX25vcm1hbGl6ZShuYW1lKSB7XHJcblx0cmV0dXJuIGZsYXR0ZW4oc3BsaXQobmFtZSwgbmZjLCBmaWx0ZXJfZmUwZikpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBlbnNfYmVhdXRpZnkobmFtZSkge1xyXG5cdGxldCBsYWJlbHMgPSBzcGxpdChuYW1lLCBuZmMsIHggPT4geCk7IC8vIGVtb2ppIG5vdCBleHBvc2VkXHJcblx0Zm9yIChsZXQge3R5cGUsIG91dHB1dCwgZXJyb3J9IG9mIGxhYmVscykge1xyXG5cdFx0aWYgKGVycm9yKSBicmVhazsgLy8gZmxhdHRlbiB3aWxsIHRocm93XHJcblxyXG5cdFx0Ly8gcmVwbGFjZSBsZWFkaW5nL3RyYWlsaW5nIGh5cGhlblxyXG5cdFx0Ly8gMjAyMzAxMjE6IGNvbnNpZGVyIGJlYXV0aWZpbmcgYWxsIG9yIGxlYWRpbmcvdHJhaWxpbmcgaHlwaGVuIHRvIHVuaWNvZGUgdmFyaWFudFxyXG5cdFx0Ly8gbm90IGV4YWN0bHkgdGhlIHNhbWUgaW4gZXZlcnkgZm9udCwgYnV0IHZlcnkgc2ltaWxhcjogXCItXCIgdnMgXCLigJBcIlxyXG5cdFx0LypcclxuXHRcdGNvbnN0IFVOSUNPREVfSFlQSEVOID0gMHgyMDEwO1xyXG5cdFx0Ly8gbWF5YmUgdGhpcyBzaG91bGQgcmVwbGFjZSBhbGwgZm9yIHZpc3VhbCBjb25zaXN0YW5jeT9cclxuXHRcdC8vIGBub2RlIHRvb2xzL3JlZy1jb3VudC5qcyByZWdleCBeLVxcezIsXFx9YCA9PiA1OTJcclxuXHRcdC8vZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXQubGVuZ3RoOyBpKyspIGlmIChvdXRwdXRbaV0gPT0gMHgyRCkgb3V0cHV0W2ldID0gMHgyMDEwO1xyXG5cdFx0aWYgKG91dHB1dFswXSA9PSBIWVBIRU4pIG91dHB1dFswXSA9IFVOSUNPREVfSFlQSEVOO1xyXG5cdFx0bGV0IGVuZCA9IG91dHB1dC5sZW5ndGgtMTtcclxuXHRcdGlmIChvdXRwdXRbZW5kXSA9PSBIWVBIRU4pIG91dHB1dFtlbmRdID0gVU5JQ09ERV9IWVBIRU47XHJcblx0XHQqL1xyXG5cdFx0Ly8gMjAyMzAxMjM6IFdIQVRXRyBVUkwgdXNlcyBcIkNoZWNrSHlwaGVuc1wiIGZhbHNlXHJcblx0XHQvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2lkbmFcclxuXHJcblx0XHQvLyB1cGRhdGUgZXRoZXJldW0gc3ltYm9sXHJcblx0XHQvLyDOviA9PiDOniBpZiBub3QgZ3JlZWtcclxuXHRcdGlmICh0eXBlICE9PSAnR3JlZWsnKSBhcnJheV9yZXBsYWNlKG91dHB1dCwgMHgzQkUsIDB4MzlFKTtcclxuXHJcblx0XHQvLyAyMDIyMTIxMzogZml4ZXMgYmlkaSBzdWJkb21haW4gaXNzdWUsIGJ1dCBicmVha3MgaW52YXJpYW50ICgyMDBFIGlzIGRpc2FsbG93ZWQpXHJcblx0XHQvLyBjb3VsZCBiZSBmaXhlZCB3aXRoIHNwZWNpYWwgY2FzZSBmb3I6IDJEICguKSArIDIwMEUgKExUUilcclxuXHRcdC8vIGh0dHBzOi8vZGlzY3Vzcy5lbnMuZG9tYWlucy90L2JpZGktbGFiZWwtb3JkZXJpbmctc3Bvb2YvMTU4MjRcclxuXHRcdC8vb3V0cHV0LnNwbGljZSgwLCAwLCAweDIwMEUpO1xyXG5cdH1cclxuXHRyZXR1cm4gZmxhdHRlbihsYWJlbHMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhcnJheV9yZXBsYWNlKHYsIGEsIGIpIHtcclxuXHRsZXQgcHJldiA9IDA7XHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdGxldCBuZXh0ID0gdi5pbmRleE9mKGEsIHByZXYpO1xyXG5cdFx0aWYgKG5leHQgPCAwKSBicmVhaztcclxuXHRcdHZbbmV4dF0gPSBiOyBcclxuXHRcdHByZXYgPSBuZXh0ICsgMTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuc19zcGxpdChuYW1lLCBwcmVzZXJ2ZV9lbW9qaSkge1xyXG5cdHJldHVybiBzcGxpdChuYW1lLCBuZmMsIHByZXNlcnZlX2Vtb2ppID8geCA9PiB4LnNsaWNlKCkgOiBmaWx0ZXJfZmUwZik7IC8vIGVtb2ppIGFyZSBleHBvc2VkIHNvIGNvcHlcclxufVxyXG5cclxuZnVuY3Rpb24gc3BsaXQobmFtZSwgbmYsIGVmKSB7XHJcblx0aWYgKCFuYW1lKSByZXR1cm4gW107IC8vIDIwMjMwNzE5OiBlbXB0eSBuYW1lIGFsbG93YW5jZVxyXG5cdGluaXQoKTtcclxuXHRsZXQgb2Zmc2V0ID0gMDtcclxuXHQvLyBodHRwczovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHI0Ni8jVmFsaWRpdHlfQ3JpdGVyaWFcclxuXHQvLyA0LikgXCJUaGUgbGFiZWwgbXVzdCBub3QgY29udGFpbiBhIFUrMDAyRSAoIC4gKSBGVUxMIFNUT1AuXCJcclxuXHRyZXR1cm4gbmFtZS5zcGxpdChTVE9QX0NIKS5tYXAobGFiZWwgPT4ge1xyXG5cdFx0bGV0IGlucHV0ID0gZXhwbG9kZV9jcChsYWJlbCk7XHJcblx0XHRsZXQgaW5mbyA9IHtcclxuXHRcdFx0aW5wdXQsXHJcblx0XHRcdG9mZnNldCwgLy8gY29kZXBvaW50LCBub3Qgc3Vic3RyaW5nIVxyXG5cdFx0fTtcclxuXHRcdG9mZnNldCArPSBpbnB1dC5sZW5ndGggKyAxOyAvLyArIHN0b3BcclxuXHRcdHRyeSB7XHJcblx0XHRcdC8vIDEuKSBcIlRoZSBsYWJlbCBtdXN0IGJlIGluIFVuaWNvZGUgTm9ybWFsaXphdGlvbiBGb3JtIE5GQ1wiXHJcblx0XHRcdGxldCB0b2tlbnMgPSBpbmZvLnRva2VucyA9IHRva2Vuc19mcm9tX3N0cihpbnB1dCwgbmYsIGVmKTtcclxuXHRcdFx0bGV0IHRva2VuX2NvdW50ID0gdG9rZW5zLmxlbmd0aDtcclxuXHRcdFx0bGV0IHR5cGU7XHJcblx0XHRcdGlmICghdG9rZW5fY291bnQpIHsgLy8gdGhlIGxhYmVsIHdhcyBlZmZlY3RpdmVseSBlbXB0eSAoY291bGQgb2YgaGFkIGlnbm9yZWQgY2hhcmFjdGVycylcclxuXHRcdFx0XHQvL25vcm0gPSBbXTtcclxuXHRcdFx0XHQvL3R5cGUgPSAnTm9uZSc7IC8vIHVzZSB0aGlzIGluc3RlYWQgb2YgbmV4dCBtYXRjaCwgXCJBU0NJSVwiXHJcblx0XHRcdFx0Ly8gMjAyMzAxMjA6IGNoYW5nZSB0byBzdHJpY3RcclxuXHRcdFx0XHQvLyBodHRwczovL2Rpc2N1c3MuZW5zLmRvbWFpbnMvdC9lbnMtbmFtZS1ub3JtYWxpemF0aW9uLTJuZC8xNDU2NC81OVxyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihgZW1wdHkgbGFiZWxgKTtcclxuXHRcdFx0fSBcclxuXHRcdFx0bGV0IG5vcm0gPSBpbmZvLm91dHB1dCA9IHRva2Vucy5mbGF0KCk7XHJcblx0XHRcdGNoZWNrX2xlYWRpbmdfdW5kZXJzY29yZShub3JtKTtcclxuXHRcdFx0bGV0IGVtb2ppID0gaW5mby5lbW9qaSA9IHRva2VuX2NvdW50ID4gMSB8fCB0b2tlbnNbMF0uaXNfZW1vamk7IC8vIHNhbWUgYXM6IHRva2Vucy5zb21lKHggPT4geC5pc19lbW9qaSk7XHJcblx0XHRcdGlmICghZW1vamkgJiYgbm9ybS5ldmVyeShjcCA9PiBjcCA8IDB4ODApKSB7IC8vIHNwZWNpYWwgY2FzZSBmb3IgYXNjaWlcclxuXHRcdFx0XHQvLyAyMDIzMDEyMzogbWF0Y2hlcyBtYXRjaGVzIFdIQVRXRywgc2VlIG5vdGUgMy4zXHJcblx0XHRcdFx0Y2hlY2tfbGFiZWxfZXh0ZW5zaW9uKG5vcm0pOyAvLyBvbmx5IG5lZWRlZCBmb3IgYXNjaWlcclxuXHRcdFx0XHQvLyBjYW50IGhhdmUgZmVuY2VkXHJcblx0XHRcdFx0Ly8gY2FudCBoYXZlIGNtXHJcblx0XHRcdFx0Ly8gY2FudCBoYXZlIHdob2xlc1xyXG5cdFx0XHRcdC8vIHNlZSBkZXJpdmU6IFwiRmFzdHBhdGggQVNDSUlcIlxyXG5cdFx0XHRcdHR5cGUgPSAnQVNDSUknO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGxldCBjaGFycyA9IHRva2Vucy5mbGF0TWFwKHggPT4geC5pc19lbW9qaSA/IFtdIDogeCk7IC8vIGFsbCBvZiB0aGUgbmZjIHRva2VucyBjb25jYXQgdG9nZXRoZXJcclxuXHRcdFx0XHRpZiAoIWNoYXJzLmxlbmd0aCkgeyAvLyB0aGVyZXMgbm8gdGV4dCwganVzdCBlbW9qaVxyXG5cdFx0XHRcdFx0dHlwZSA9ICdFbW9qaSc7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdC8vIDUuKSBcIlRoZSBsYWJlbCBtdXN0IG5vdCBiZWdpbiB3aXRoIGEgY29tYmluaW5nIG1hcmssIHRoYXQgaXM6IEdlbmVyYWxfQ2F0ZWdvcnk9TWFyay5cIlxyXG5cdFx0XHRcdFx0aWYgKENNLmhhcyhub3JtWzBdKSkgdGhyb3cgZXJyb3JfcGxhY2VtZW50KCdsZWFkaW5nIGNvbWJpbmluZyBtYXJrJyk7XHJcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMTsgaSA8IHRva2VuX2NvdW50OyBpKyspIHsgLy8gd2UndmUgYWxyZWFkeSBjaGVja2VkIHRoZSBmaXJzdCB0b2tlblxyXG5cdFx0XHRcdFx0XHRsZXQgY3BzID0gdG9rZW5zW2ldO1xyXG5cdFx0XHRcdFx0XHRpZiAoIWNwcy5pc19lbW9qaSAmJiBDTS5oYXMoY3BzWzBdKSkgeyAvLyBldmVyeSB0ZXh0IHRva2VuIGhhcyBlbW9qaSBuZWlnaGJvcnMsIGVnLiBFdEVFRXRFdC4uLlxyXG5cdFx0XHRcdFx0XHRcdC8vIGJpZGlfcXEoKSBub3QgbmVlZGVkIHNpbmNlIGVtb2ppIGlzIExUUiBhbmQgY3BzIGlzIGEgQ01cclxuXHRcdFx0XHRcdFx0XHR0aHJvdyBlcnJvcl9wbGFjZW1lbnQoYGVtb2ppICsgY29tYmluaW5nIG1hcms6IFwiJHtzdHJfZnJvbV9jcHModG9rZW5zW2ktMV0pfSArICR7c2FmZV9zdHJfZnJvbV9jcHMoW2Nwc1swXV0pfVwiYCk7IFxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRjaGVja19mZW5jZWQobm9ybSk7XHJcblx0XHRcdFx0XHRsZXQgdW5pcXVlID0gQXJyYXlfZnJvbShuZXcgU2V0KGNoYXJzKSk7XHJcblx0XHRcdFx0XHRsZXQgW2ddID0gZGV0ZXJtaW5lX2dyb3VwKHVuaXF1ZSk7IC8vIHRha2UgdGhlIGZpcnN0IG1hdGNoXHJcblx0XHRcdFx0XHQvLyBzZWUgZGVyaXZlOiBcIk1hdGNoaW5nIEdyb3VwcyBoYXZlIFNhbWUgQ00gU3R5bGVcIlxyXG5cdFx0XHRcdFx0Ly8gYWx0ZXJuYXRpdmU6IGNvdWxkIGZvcm0gYSBoeWJyaWQgdHlwZTogTGF0aW4vSmFwYW5lc2UvLi4uXHRcclxuXHRcdFx0XHRcdGNoZWNrX2dyb3VwKGcsIGNoYXJzKTsgLy8gbmVlZCB0ZXh0IGluIG9yZGVyXHJcblx0XHRcdFx0XHRjaGVja193aG9sZShnLCB1bmlxdWUpOyAvLyBvbmx5IG5lZWQgdW5pcXVlIHRleHQgKG9yZGVyIHdvdWxkIGJlIHJlcXVpcmVkIGZvciBtdWx0aXBsZS1jaGFyIGNvbmZ1c2FibGVzKVxyXG5cdFx0XHRcdFx0dHlwZSA9IGcuTjtcclxuXHRcdFx0XHRcdC8vIDIwMjMwMTIxOiBjb25zaWRlciBleHBvc2luZyByZXN0cmljdGVkIGZsYWdcclxuXHRcdFx0XHRcdC8vIGl0J3Mgc2ltcGxlciB0byBqdXN0IGNoZWNrIGZvciAnUmVzdHJpY3RlZCdcclxuXHRcdFx0XHRcdC8vIG9yIGV2ZW4gYmV0dGVyOiB0eXBlLmVuZHNXaXRoKCddJylcclxuXHRcdFx0XHRcdC8vaWYgKGcuUikgaW5mby5yZXN0cmljdGVkID0gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aW5mby50eXBlID0gdHlwZTtcclxuXHRcdH0gY2F0Y2ggKGVycikge1xyXG5cdFx0XHRpbmZvLmVycm9yID0gZXJyOyAvLyB1c2UgZnVsbCBlcnJvciBvYmplY3RcclxuXHRcdH1cclxuXHRcdHJldHVybiBpbmZvO1xyXG5cdH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja193aG9sZShncm91cCwgdW5pcXVlKSB7XHJcblx0bGV0IG1ha2VyO1xyXG5cdGxldCBzaGFyZWQgPSBbXTtcclxuXHRmb3IgKGxldCBjcCBvZiB1bmlxdWUpIHtcclxuXHRcdGxldCB3aG9sZSA9IFdIT0xFX01BUC5nZXQoY3ApO1xyXG5cdFx0aWYgKHdob2xlID09PSBVTklRVUVfUEgpIHJldHVybjsgLy8gdW5pcXVlLCBub24tY29uZnVzYWJsZVxyXG5cdFx0aWYgKHdob2xlKSB7XHJcblx0XHRcdGxldCBzZXQgPSB3aG9sZS5NLmdldChjcCk7IC8vIGdyb3VwcyB3aGljaCBoYXZlIGEgY2hhcmFjdGVyIHRoYXQgbG9vay1saWtlIHRoaXMgY2hhcmFjdGVyXHJcblx0XHRcdG1ha2VyID0gbWFrZXIgPyBtYWtlci5maWx0ZXIoZyA9PiBzZXQuaGFzKGcpKSA6IEFycmF5X2Zyb20oc2V0KTtcclxuXHRcdFx0aWYgKCFtYWtlci5sZW5ndGgpIHJldHVybjsgLy8gY29uZnVzYWJsZSBpbnRlcnNlY3Rpb24gaXMgZW1wdHlcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHNoYXJlZC5wdXNoKGNwKTsgXHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChtYWtlcikge1xyXG5cdFx0Ly8gd2UgaGF2ZSAxKyBjb25mdXNhYmxlXHJcblx0XHQvLyBjaGVjayBpZiBhbnkgb2YgdGhlIHJlbWFpbmluZyBncm91cHNcclxuXHRcdC8vIGNvbnRhaW4gdGhlIHNoYXJlZCBjaGFyYWN0ZXJzIHRvb1xyXG5cdFx0Zm9yIChsZXQgZyBvZiBtYWtlcikge1xyXG5cdFx0XHRpZiAoc2hhcmVkLmV2ZXJ5KGNwID0+IGdyb3VwX2hhc19jcChnLCBjcCkpKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGB3aG9sZS1zY3JpcHQgY29uZnVzYWJsZTogJHtncm91cC5OfS8ke2cuTn1gKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuLy8gYXNzdW1wdGlvbjogdW5pcXVlLnNpemUgPiAwXHJcbi8vIHJldHVybnMgbGlzdCBvZiBtYXRjaGluZyBncm91cHNcclxuZnVuY3Rpb24gZGV0ZXJtaW5lX2dyb3VwKHVuaXF1ZSkge1xyXG5cdGxldCBncm91cHMgPSBHUk9VUFM7XHJcblx0Zm9yIChsZXQgY3Agb2YgdW5pcXVlKSB7XHJcblx0XHQvLyBub3RlOiB3ZSBuZWVkIHRvIGRvZGdlIENNIHRoYXQgYXJlIHdoaXRlbGlzdGVkXHJcblx0XHQvLyBidXQgdGhhdCBjb2RlIGlzbid0IGN1cnJlbnRseSBuZWNlc3NhcnlcclxuXHRcdGxldCBncyA9IGdyb3Vwcy5maWx0ZXIoZyA9PiBncm91cF9oYXNfY3AoZywgY3ApKTtcclxuXHRcdGlmICghZ3MubGVuZ3RoKSB7XHJcblx0XHRcdGlmICghR1JPVVBTLnNvbWUoZyA9PiBncm91cF9oYXNfY3AoZywgY3ApKSkgeyBcclxuXHRcdFx0XHQvLyB0aGUgY2hhcmFjdGVyIHdhcyBjb21wb3NlZCBvZiB2YWxpZCBwYXJ0c1xyXG5cdFx0XHRcdC8vIGJ1dCBpdCdzIE5GQyBmb3JtIGlzIGludmFsaWRcclxuXHRcdFx0XHQvLyAyMDIzMDcxNjogY2hhbmdlIHRvIG1vcmUgZXhhY3Qgc3RhdGVtZW50LCBzZWU6IEVOU05vcm1hbGl6ZS57Y3MsamF2YX1cclxuXHRcdFx0XHQvLyBub3RlOiB0aGlzIGRvZXNuJ3QgaGF2ZSB0byBiZSBhIGNvbXBvc2l0aW9uXHJcblx0XHRcdFx0Ly8gMjAyMzA3MjA6IGNoYW5nZSB0byBmdWxsIGNoZWNrXHJcblx0XHRcdFx0dGhyb3cgZXJyb3JfZGlzYWxsb3dlZChjcCk7IC8vIHRoaXMgc2hvdWxkIGJlIHJhcmVcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyB0aGVyZSBpcyBubyBncm91cCB0aGF0IGNvbnRhaW5zIGFsbCB0aGVzZSBjaGFyYWN0ZXJzXHJcblx0XHRcdFx0Ly8gdGhyb3cgdXNpbmcgdGhlIGhpZ2hlc3QgcHJpb3JpdHkgZ3JvdXAgdGhhdCBtYXRjaGVkXHJcblx0XHRcdFx0Ly8gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM5LyNtaXhlZF9zY3JpcHRfY29uZnVzYWJsZXNcclxuXHRcdFx0XHR0aHJvdyBlcnJvcl9ncm91cF9tZW1iZXIoZ3JvdXBzWzBdLCBjcCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGdyb3VwcyA9IGdzO1xyXG5cdFx0aWYgKGdzLmxlbmd0aCA9PSAxKSBicmVhazsgLy8gdGhlcmUgaXMgb25seSBvbmUgZ3JvdXAgbGVmdFxyXG5cdH1cclxuXHQvLyB0aGVyZSBhcmUgYXQgbGVhc3QgMSBncm91cChzKSB3aXRoIGFsbCBvZiB0aGVzZSBjaGFyYWN0ZXJzXHJcblx0cmV0dXJuIGdyb3VwcztcclxufVxyXG5cclxuLy8gdGhyb3cgb24gZmlyc3QgZXJyb3JcclxuZnVuY3Rpb24gZmxhdHRlbihzcGxpdCkge1xyXG5cdHJldHVybiBzcGxpdC5tYXAoKHtpbnB1dCwgZXJyb3IsIG91dHB1dH0pID0+IHtcclxuXHRcdGlmIChlcnJvcikge1xyXG5cdFx0XHQvLyBkb24ndCBwcmludCBsYWJlbCBhZ2FpbiBpZiBqdXN0IGEgc2luZ2xlIGxhYmVsXHJcblx0XHRcdGxldCBtc2cgPSBlcnJvci5tZXNzYWdlO1xyXG5cdFx0XHQvLyBiaWRpX3FxKCkgb25seSBuZWNlc3NhcnkgaWYgbXNnIGlzIGRpZ2l0c1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3Ioc3BsaXQubGVuZ3RoID09IDEgPyBtc2cgOiBgSW52YWxpZCBsYWJlbCAke2JpZGlfcXEoc2FmZV9zdHJfZnJvbV9jcHMoaW5wdXQsIDYzKSl9OiAke21zZ31gKTsgXHJcblx0XHR9XHJcblx0XHRyZXR1cm4gc3RyX2Zyb21fY3BzKG91dHB1dCk7XHJcblx0fSkuam9pbihTVE9QX0NIKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZXJyb3JfZGlzYWxsb3dlZChjcCkge1xyXG5cdC8vIFRPRE86IGFkZCBjcCB0byBlcnJvcj9cclxuXHRyZXR1cm4gbmV3IEVycm9yKGBkaXNhbGxvd2VkIGNoYXJhY3RlcjogJHtxdW90ZWRfY3AoY3ApfWApOyBcclxufVxyXG5mdW5jdGlvbiBlcnJvcl9ncm91cF9tZW1iZXIoZywgY3ApIHtcclxuXHRsZXQgcXVvdGVkID0gcXVvdGVkX2NwKGNwKTtcclxuXHRsZXQgZ2cgPSBHUk9VUFMuZmluZChnID0+IGcuUC5oYXMoY3ApKTsgLy8gb25seSBjaGVjayBwcmltYXJ5XHJcblx0aWYgKGdnKSB7XHJcblx0XHRxdW90ZWQgPSBgJHtnZy5OfSAke3F1b3RlZH1gO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IEVycm9yKGBpbGxlZ2FsIG1peHR1cmU6ICR7Zy5OfSArICR7cXVvdGVkfWApO1xyXG59XHJcbmZ1bmN0aW9uIGVycm9yX3BsYWNlbWVudCh3aGVyZSkge1xyXG5cdHJldHVybiBuZXcgRXJyb3IoYGlsbGVnYWwgcGxhY2VtZW50OiAke3doZXJlfWApO1xyXG59XHJcblxyXG4vLyBhc3N1bXB0aW9uOiBjcHMubGVuZ3RoID4gMFxyXG4vLyBhc3N1bXB0aW9uOiBjcHNbMF0gaXNuJ3QgYSBDTVxyXG4vLyBhc3N1bXB0aW9uOiB0aGUgcHJldmlvdXMgY2hhcmFjdGVyIGlzbid0IGFuIGVtb2ppXHJcbmZ1bmN0aW9uIGNoZWNrX2dyb3VwKGcsIGNwcykge1xyXG5cdGZvciAobGV0IGNwIG9mIGNwcykge1xyXG5cdFx0aWYgKCFncm91cF9oYXNfY3AoZywgY3ApKSB7XHJcblx0XHRcdC8vIGZvciB3aGl0ZWxpc3RlZCBzY3JpcHRzLCB0aGlzIHdpbGwgdGhyb3cgaWxsZWdhbCBtaXh0dXJlIG9uIGludmFsaWQgY20sIGVnLiBcImV7MzAwfXszMDB9XCJcclxuXHRcdFx0Ly8gYXQgdGhlIG1vbWVudCwgaXQncyB1bm5lY2Vzc2FyeSB0byBpbnRyb2R1Y2UgYW4gZXh0cmEgZXJyb3IgdHlwZVxyXG5cdFx0XHQvLyB1bnRpbCB0aGVyZSBleGlzdHMgYSB3aGl0ZWxpc3RlZCBtdWx0aS1jaGFyYWN0ZXJcclxuXHRcdFx0Ly8gICBlZy4gaWYgKE0gPCAwICYmIGlzX2NvbWJpbmluZ19tYXJrKGNwKSkgeyAuLi4gfVxyXG5cdFx0XHQvLyB0aGVyZSBhcmUgMyBjYXNlczpcclxuXHRcdFx0Ly8gICAxLiBpbGxlZ2FsIGNtIGZvciB3cm9uZyBncm91cCA9PiBtaXh0dXJlIGVycm9yXHJcblx0XHRcdC8vICAgMi4gaWxsZWdhbCBjbSBmb3Igc2FtZSBncm91cCA9PiBjbSBlcnJvclxyXG5cdFx0XHQvLyAgICAgICByZXF1aXJlcyBzZXQgb2Ygd2hpdGVsaXN0IGNtIHBlciBncm91cDogXHJcblx0XHRcdC8vICAgICAgICBlZy4gbmV3IFNldChbLi4uZy5QLCAuLi5nLlFdLmZsYXRNYXAobmZjKS5maWx0ZXIoY3AgPT4gQ00uaGFzKGNwKSkpXHJcblx0XHRcdC8vICAgMy4gd3JvbmcgZ3JvdXAgPT4gbWl4dHVyZSBlcnJvclxyXG5cdFx0XHR0aHJvdyBlcnJvcl9ncm91cF9tZW1iZXIoZywgY3ApO1xyXG5cdFx0fVxyXG5cdH1cclxuXHQvL2lmIChNID49IDApIHsgLy8gd2UgaGF2ZSBhIGtub3duIGZpeGVkIGNtIGNvdW50XHJcblx0aWYgKGcuTSkgeyAvLyB3ZSBuZWVkIHRvIGNoZWNrIGZvciBOU01cclxuXHRcdGxldCBkZWNvbXBvc2VkID0gbmZkKGNwcyk7XHJcblx0XHRmb3IgKGxldCBpID0gMSwgZSA9IGRlY29tcG9zZWQubGVuZ3RoOyBpIDwgZTsgaSsrKSB7IC8vIHNlZTogYXNzdW1wdGlvblxyXG5cdFx0XHQvLyAyMDIzMDIxMDogYnVnZml4OiB1c2luZyBjcHMgaW5zdGVhZCBvZiBkZWNvbXBvc2VkIGgvdCBDYXJib24yMjVcclxuXHRcdFx0LypcclxuXHRcdFx0aWYgKENNLmhhcyhkZWNvbXBvc2VkW2ldKSkge1xyXG5cdFx0XHRcdGxldCBqID0gaSArIDE7XHJcblx0XHRcdFx0d2hpbGUgKGogPCBlICYmIENNLmhhcyhkZWNvbXBvc2VkW2pdKSkgaisrO1xyXG5cdFx0XHRcdGlmIChqIC0gaSA+IE0pIHtcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgdG9vIG1hbnkgY29tYmluaW5nIG1hcmtzOiAke2cuTn0gJHtiaWRpX3FxKHN0cl9mcm9tX2NwcyhkZWNvbXBvc2VkLnNsaWNlKGktMSwgaikpKX0gKCR7ai1pfS8ke019KWApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpID0gajtcclxuXHRcdFx0fVxyXG5cdFx0XHQqL1xyXG5cdFx0XHQvLyAyMDIzMDIxNzogc3dpdGNoIHRvIE5TTSBjb3VudGluZ1xyXG5cdFx0XHQvLyBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzkvI09wdGlvbmFsX0RldGVjdGlvblxyXG5cdFx0XHRpZiAoTlNNLmhhcyhkZWNvbXBvc2VkW2ldKSkge1xyXG5cdFx0XHRcdGxldCBqID0gaSArIDE7XHJcblx0XHRcdFx0Zm9yIChsZXQgY3A7IGogPCBlICYmIE5TTS5oYXMoY3AgPSBkZWNvbXBvc2VkW2pdKTsgaisrKSB7XHJcblx0XHRcdFx0XHQvLyBhLiBGb3JiaWQgc2VxdWVuY2VzIG9mIHRoZSBzYW1lIG5vbnNwYWNpbmcgbWFyay5cclxuXHRcdFx0XHRcdGZvciAobGV0IGsgPSBpOyBrIDwgajsgaysrKSB7IC8vIE8obl4yKSBidXQgbiA8IDEwMFxyXG5cdFx0XHRcdFx0XHRpZiAoZGVjb21wb3NlZFtrXSA9PSBjcCkge1xyXG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgZHVwbGljYXRlIG5vbi1zcGFjaW5nIG1hcmtzOiAke3F1b3RlZF9jcChjcCl9YCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Ly8gcGFyc2UgdG8gZW5kIHNvIHdlIGhhdmUgZnVsbCBuc20gY291bnRcclxuXHRcdFx0XHQvLyBiLiBGb3JiaWQgc2VxdWVuY2VzIG9mIG1vcmUgdGhhbiA0IG5vbnNwYWNpbmcgbWFya3MgKGdjPU1uIG9yIGdjPU1lKS5cclxuXHRcdFx0XHRpZiAoaiAtIGkgPiBOU01fTUFYKSB7XHJcblx0XHRcdFx0XHQvLyBub3RlOiB0aGlzIHNsaWNlIHN0YXJ0cyB3aXRoIGEgYmFzZSBjaGFyIG9yIHNwYWNpbmctbWFyayBjbVxyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBleGNlc3NpdmUgbm9uLXNwYWNpbmcgbWFya3M6ICR7YmlkaV9xcShzYWZlX3N0cl9mcm9tX2NwcyhkZWNvbXBvc2VkLnNsaWNlKGktMSwgaikpKX0gKCR7ai1pfS8ke05TTV9NQVh9KWApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpID0gajtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHQvLyAqKiogdGhpcyBjb2RlIGN1cnJlbnRseSBpc24ndCBuZWVkZWQgKioqXHJcblx0LypcclxuXHRsZXQgY21fd2hpdGVsaXN0ID0gTSBpbnN0YW5jZW9mIE1hcDtcclxuXHRmb3IgKGxldCBpID0gMCwgZSA9IGNwcy5sZW5ndGg7IGkgPCBlOyApIHtcclxuXHRcdGxldCBjcCA9IGNwc1tpKytdO1xyXG5cdFx0bGV0IHNlcXMgPSBjbV93aGl0ZWxpc3QgJiYgTS5nZXQoY3ApO1xyXG5cdFx0aWYgKHNlcXMpIHsgXHJcblx0XHRcdC8vIGxpc3Qgb2YgY29kZXBvaW50cyB0aGF0IGNhbiBmb2xsb3dcclxuXHRcdFx0Ly8gaWYgdGhpcyBleGlzdHMsIHRoaXMgd2lsbCBhbHdheXMgYmUgMStcclxuXHRcdFx0bGV0IGogPSBpO1xyXG5cdFx0XHR3aGlsZSAoaiA8IGUgJiYgQ00uaGFzKGNwc1tqXSkpIGorKztcclxuXHRcdFx0bGV0IGNtcyA9IGNwcy5zbGljZShpLCBqKTtcclxuXHRcdFx0bGV0IG1hdGNoID0gc2Vxcy5maW5kKHNlcSA9PiAhY29tcGFyZV9hcnJheXMoc2VxLCBjbXMpKTtcclxuXHRcdFx0aWYgKCFtYXRjaCkgdGhyb3cgbmV3IEVycm9yKGBkaXNhbGxvd2VkIGNvbWJpbmluZyBtYXJrIHNlcXVlbmNlOiBcIiR7c2FmZV9zdHJfZnJvbV9jcHMoW2NwLCAuLi5jbXNdKX1cImApO1xyXG5cdFx0XHRpID0gajtcclxuXHRcdH0gZWxzZSBpZiAoIVYuaGFzKGNwKSkge1xyXG5cdFx0XHQvLyBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzkvI21peGVkX3NjcmlwdF9jb25mdXNhYmxlc1xyXG5cdFx0XHRsZXQgcXVvdGVkID0gcXVvdGVkX2NwKGNwKTtcclxuXHRcdFx0Zm9yIChsZXQgY3Agb2YgY3BzKSB7XHJcblx0XHRcdFx0bGV0IHUgPSBVTklRVUUuZ2V0KGNwKTtcclxuXHRcdFx0XHRpZiAodSAmJiB1ICE9PSBnKSB7XHJcblx0XHRcdFx0XHQvLyBpZiBib3RoIHNjcmlwdHMgYXJlIHJlc3RyaWN0ZWQgdGhpcyBlcnJvciBpcyBjb25mdXNpbmdcclxuXHRcdFx0XHRcdC8vIGJlY2F1c2Ugd2UgZG9uJ3QgZGlmZmVyZW50aWF0ZSBSZXN0cmljdGVkQSBmcm9tIFJlc3RyaWN0ZWRCIFxyXG5cdFx0XHRcdFx0aWYgKCF1LlIpIHF1b3RlZCA9IGAke3F1b3RlZH0gaXMgJHt1Lk59YDtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYGRpc2FsbG93ZWQgJHtnLk59IGNoYXJhY3RlcjogJHtxdW90ZWR9YCk7XHJcblx0XHRcdC8vdGhyb3cgbmV3IEVycm9yKGBkaXNhbGxvd2VkIGNoYXJhY3RlcjogJHtxdW90ZWR9IChleHBlY3RlZCAke2cuTn0pYCk7XHJcblx0XHRcdC8vdGhyb3cgbmV3IEVycm9yKGAke2cuTn0gZG9lcyBub3QgYWxsb3c6ICR7cXVvdGVkfWApO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAoIWNtX3doaXRlbGlzdCkge1xyXG5cdFx0bGV0IGRlY29tcG9zZWQgPSBuZmQoY3BzKTtcclxuXHRcdGZvciAobGV0IGkgPSAxLCBlID0gZGVjb21wb3NlZC5sZW5ndGg7IGkgPCBlOyBpKyspIHsgLy8gd2Uga25vdyBpdCBjYW4ndCBiZSBjbSBsZWFkaW5nXHJcblx0XHRcdGlmIChDTS5oYXMoZGVjb21wb3NlZFtpXSkpIHtcclxuXHRcdFx0XHRsZXQgaiA9IGkgKyAxO1xyXG5cdFx0XHRcdHdoaWxlIChqIDwgZSAmJiBDTS5oYXMoZGVjb21wb3NlZFtqXSkpIGorKztcclxuXHRcdFx0XHRpZiAoaiAtIGkgPiBNKSB7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYHRvbyBtYW55IGNvbWJpbmluZyBtYXJrczogXCIke3N0cl9mcm9tX2NwcyhkZWNvbXBvc2VkLnNsaWNlKGktMSwgaikpfVwiICgke2otaX0vJHtNfSlgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aSA9IGo7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0Ki9cclxufVxyXG5cclxuLy8gZ2l2ZW4gYSBsaXN0IG9mIGNvZGVwb2ludHNcclxuLy8gcmV0dXJucyBhIGxpc3Qgb2YgbGlzdHMsIHdoZXJlIGVtb2ppIGFyZSBhIGZ1bGx5LXF1YWxpZmllZCAoYXMgQXJyYXkgc3ViY2xhc3MpXHJcbi8vIGVnLiBleHBsb2RlX2NwKFwiYWJj8J+SqWRcIikgPT4gW1s2MSwgNjIsIDYzXSwgRW1vamlbMUY0QTksIEZFMEZdLCBbNjRdXVxyXG4vLyAyMDIzMDgxODogcmVuYW1lIGZvciAncHJvY2VzcycgbmFtZSBjb2xsaXNpb24gaC90IEphdmFyb21lXHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hZHJhZmZ5L2Vucy1ub3JtYWxpemUuanMvaXNzdWVzLzIzXHJcbmZ1bmN0aW9uIHRva2Vuc19mcm9tX3N0cihpbnB1dCwgbmYsIGVmKSB7XHJcblx0bGV0IHJldCA9IFtdO1xyXG5cdGxldCBjaGFycyA9IFtdO1xyXG5cdGlucHV0ID0gaW5wdXQuc2xpY2UoKS5yZXZlcnNlKCk7IC8vIGZsaXAgc28gd2UgY2FuIHBvcFxyXG5cdHdoaWxlIChpbnB1dC5sZW5ndGgpIHtcclxuXHRcdGxldCBlbW9qaSA9IGNvbnN1bWVfZW1vamlfcmV2ZXJzZWQoaW5wdXQpO1xyXG5cdFx0aWYgKGVtb2ppKSB7XHJcblx0XHRcdGlmIChjaGFycy5sZW5ndGgpIHtcclxuXHRcdFx0XHRyZXQucHVzaChuZihjaGFycykpO1xyXG5cdFx0XHRcdGNoYXJzID0gW107XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0LnB1c2goZWYoZW1vamkpKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGxldCBjcCA9IGlucHV0LnBvcCgpO1xyXG5cdFx0XHRpZiAoVkFMSUQuaGFzKGNwKSkge1xyXG5cdFx0XHRcdGNoYXJzLnB1c2goY3ApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGxldCBjcHMgPSBNQVBQRUQuZ2V0KGNwKTtcclxuXHRcdFx0XHRpZiAoY3BzKSB7XHJcblx0XHRcdFx0XHRjaGFycy5wdXNoKC4uLmNwcyk7IC8vIGxlc3MgdGhhbiAxMCBlbGVtZW50c1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIUlHTk9SRUQuaGFzKGNwKSkge1xyXG5cdFx0XHRcdFx0Ly8gMjAyMzA5MTI6IHVuaWNvZGUgMTUuMSBjaGFuZ2VkIHRoZSBvcmRlciBvZiBwcm9jZXNzaW5nIHN1Y2ggdGhhdFxyXG5cdFx0XHRcdFx0Ly8gZGlzYWxsb3dlZCBwYXJ0cyBhcmUgb25seSByZWplY3RlZCBhZnRlciBORkNcclxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjQ2LyNWYWxpZGl0eV9Dcml0ZXJpYVxyXG5cdFx0XHRcdFx0Ly8gdGhpcyBkb2Vzbid0IGltcGFjdCBub3JtYWxpemF0aW9uIGFzIG9mIHRvZGF5XHJcblx0XHRcdFx0XHQvLyB0ZWNobmljYWxseSwgdGhpcyBlcnJvciBjYW4gYmUgcmVtb3ZlZCBhcyB0aGUgZ3JvdXAgbG9naWMgd2lsbCBhcHBseSBzaW1pbGFyIGxvZ2ljXHJcblx0XHRcdFx0XHQvLyBob3dldmVyIHRoZSBlcnJvciB0eXBlIG1pZ2h0IGJlIGxlc3MgY2xlYXJcclxuXHRcdFx0XHRcdHRocm93IGVycm9yX2Rpc2FsbG93ZWQoY3ApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAoY2hhcnMubGVuZ3RoKSB7XHJcblx0XHRyZXQucHVzaChuZihjaGFycykpO1xyXG5cdH1cclxuXHRyZXR1cm4gcmV0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBmaWx0ZXJfZmUwZihjcHMpIHtcclxuXHRyZXR1cm4gY3BzLmZpbHRlcihjcCA9PiBjcCAhPSBGRTBGKTtcclxufVxyXG5cclxuLy8gZ2l2ZW4gYXJyYXkgb2YgY29kZXBvaW50c1xyXG4vLyByZXR1cm5zIHRoZSBsb25nZXN0IHZhbGlkIGVtb2ppIHNlcXVlbmNlIChvciB1bmRlZmluZWQgaWYgbm8gbWF0Y2gpXHJcbi8vICpNVVRBVEVTKiB0aGUgc3VwcGxpZWQgYXJyYXlcclxuLy8gZGlzYWxsb3dzIGludGVybGVhdmVkIGlnbm9yZWQgY2hhcmFjdGVyc1xyXG4vLyBmaWxscyAob3B0aW9uYWwpIGVhdGVuIGFycmF5IHdpdGggbWF0Y2hlZCBjb2RlcG9pbnRzXHJcbmZ1bmN0aW9uIGNvbnN1bWVfZW1vamlfcmV2ZXJzZWQoY3BzLCBlYXRlbikge1xyXG5cdGxldCBub2RlID0gRU1PSklfUk9PVDtcclxuXHRsZXQgZW1vamk7XHJcblx0bGV0IHBvcyA9IGNwcy5sZW5ndGg7XHJcblx0d2hpbGUgKHBvcykge1xyXG5cdFx0bm9kZSA9IG5vZGUuZ2V0KGNwc1stLXBvc10pO1xyXG5cdFx0aWYgKCFub2RlKSBicmVhaztcclxuXHRcdGxldCB7Vn0gPSBub2RlO1xyXG5cdFx0aWYgKFYpIHsgLy8gdGhpcyBpcyBhIHZhbGlkIGVtb2ppIChzbyBmYXIpXHJcblx0XHRcdGVtb2ppID0gVjtcclxuXHRcdFx0aWYgKGVhdGVuKSBlYXRlbi5wdXNoKC4uLmNwcy5zbGljZShwb3MpLnJldmVyc2UoKSk7IC8vIChvcHRpb25hbCkgY29weSBpbnB1dCwgdXNlZCBmb3IgZW5zX3Rva2VuaXplKClcclxuXHRcdFx0Y3BzLmxlbmd0aCA9IHBvczsgLy8gdHJ1bmNhdGVcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGVtb2ppO1xyXG59XHJcblxyXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuLy8gdG9rZW5pemVyIFxyXG5cclxuY29uc3QgVFlfVkFMSUQgPSAndmFsaWQnO1xyXG5jb25zdCBUWV9NQVBQRUQgPSAnbWFwcGVkJztcclxuY29uc3QgVFlfSUdOT1JFRCA9ICdpZ25vcmVkJztcclxuY29uc3QgVFlfRElTQUxMT1dFRCA9ICdkaXNhbGxvd2VkJztcclxuY29uc3QgVFlfRU1PSkkgPSAnZW1vamknO1xyXG5jb25zdCBUWV9ORkMgPSAnbmZjJztcclxuY29uc3QgVFlfU1RPUCA9ICdzdG9wJztcclxuXHJcbmZ1bmN0aW9uIGVuc190b2tlbml6ZShuYW1lLCB7XHJcblx0bmYgPSB0cnVlLCAvLyBjb2xsYXBzZSB1bm5vcm1hbGl6ZWQgcnVucyBpbnRvIGEgc2luZ2xlIHRva2VuXHJcbn0gPSB7fSkge1xyXG5cdGluaXQoKTtcclxuXHRsZXQgaW5wdXQgPSBleHBsb2RlX2NwKG5hbWUpLnJldmVyc2UoKTtcclxuXHRsZXQgZWF0ZW4gPSBbXTtcclxuXHRsZXQgdG9rZW5zID0gW107XHJcblx0d2hpbGUgKGlucHV0Lmxlbmd0aCkge1xyXG5cdFx0bGV0IGVtb2ppID0gY29uc3VtZV9lbW9qaV9yZXZlcnNlZChpbnB1dCwgZWF0ZW4pO1xyXG5cdFx0aWYgKGVtb2ppKSB7XHJcblx0XHRcdHRva2Vucy5wdXNoKHtcclxuXHRcdFx0XHR0eXBlOiBUWV9FTU9KSSxcclxuXHRcdFx0XHRlbW9qaTogZW1vamkuc2xpY2UoKSwgLy8gY29weSBlbW9qaVxyXG5cdFx0XHRcdGlucHV0OiBlYXRlbixcclxuXHRcdFx0XHRjcHM6IGZpbHRlcl9mZTBmKGVtb2ppKVxyXG5cdFx0XHR9KTtcclxuXHRcdFx0ZWF0ZW4gPSBbXTsgLy8gcmVzZXQgYnVmZmVyXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsZXQgY3AgPSBpbnB1dC5wb3AoKTtcclxuXHRcdFx0aWYgKGNwID09IFNUT1ApIHtcclxuXHRcdFx0XHR0b2tlbnMucHVzaCh7dHlwZTogVFlfU1RPUCwgY3B9KTtcclxuXHRcdFx0fSBlbHNlIGlmIChWQUxJRC5oYXMoY3ApKSB7XHJcblx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFRZX1ZBTElELCBjcHM6IFtjcF19KTtcclxuXHRcdFx0fSBlbHNlIGlmIChJR05PUkVELmhhcyhjcCkpIHtcclxuXHRcdFx0XHR0b2tlbnMucHVzaCh7dHlwZTogVFlfSUdOT1JFRCwgY3B9KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsZXQgY3BzID0gTUFQUEVELmdldChjcCk7XHJcblx0XHRcdFx0aWYgKGNwcykge1xyXG5cdFx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFRZX01BUFBFRCwgY3AsIGNwczogY3BzLnNsaWNlKCl9KTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFRZX0RJU0FMTE9XRUQsIGNwfSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChuZikge1xyXG5cdFx0Zm9yIChsZXQgaSA9IDAsIHN0YXJ0ID0gLTE7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0bGV0IHRva2VuID0gdG9rZW5zW2ldO1xyXG5cdFx0XHRpZiAoaXNfdmFsaWRfb3JfbWFwcGVkKHRva2VuLnR5cGUpKSB7XHJcblx0XHRcdFx0aWYgKHJlcXVpcmVzX2NoZWNrKHRva2VuLmNwcykpIHsgLy8gbm9ybWFsaXphdGlvbiBtaWdodCBiZSBuZWVkZWRcclxuXHRcdFx0XHRcdGxldCBlbmQgPSBpICsgMTtcclxuXHRcdFx0XHRcdGZvciAobGV0IHBvcyA9IGVuZDsgcG9zIDwgdG9rZW5zLmxlbmd0aDsgcG9zKyspIHsgLy8gZmluZCBhZGphY2VudCB0ZXh0XHJcblx0XHRcdFx0XHRcdGxldCB7dHlwZSwgY3BzfSA9IHRva2Vuc1twb3NdO1xyXG5cdFx0XHRcdFx0XHRpZiAoaXNfdmFsaWRfb3JfbWFwcGVkKHR5cGUpKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKCFyZXF1aXJlc19jaGVjayhjcHMpKSBicmVhaztcclxuXHRcdFx0XHRcdFx0XHRlbmQgPSBwb3MgKyAxO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHR5cGUgIT09IFRZX0lHTk9SRUQpIHsgLy8gfHwgdHlwZSAhPT0gVFlfRElTQUxMT1dFRCkgeyBcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBpO1xyXG5cdFx0XHRcdFx0bGV0IHNsaWNlID0gdG9rZW5zLnNsaWNlKHN0YXJ0LCBlbmQpO1xyXG5cdFx0XHRcdFx0bGV0IGNwczAgPSBzbGljZS5mbGF0TWFwKHggPT4gaXNfdmFsaWRfb3JfbWFwcGVkKHgudHlwZSkgPyB4LmNwcyA6IFtdKTsgLy8gc3RyaXAganVuayB0b2tlbnNcclxuXHRcdFx0XHRcdGxldCBjcHMgPSBuZmMoY3BzMCk7XHJcblx0XHRcdFx0XHRpZiAoY29tcGFyZV9hcnJheXMoY3BzLCBjcHMwKSkgeyAvLyBidW5kbGUgaW50byBhbiBuZmMgdG9rZW5cclxuXHRcdFx0XHRcdFx0dG9rZW5zLnNwbGljZShzdGFydCwgZW5kIC0gc3RhcnQsIHtcclxuXHRcdFx0XHRcdFx0XHR0eXBlOiBUWV9ORkMsIFxyXG5cdFx0XHRcdFx0XHRcdGlucHV0OiBjcHMwLCAvLyB0aGVyZSBhcmUgMyBzdGF0ZXM6IHRva2VuczAgPT0ocHJvY2Vzcyk9PiBpbnB1dCA9PShuZmMpPT4gdG9rZW5zL2Nwc1xyXG5cdFx0XHRcdFx0XHRcdGNwcywgXHJcblx0XHRcdFx0XHRcdFx0dG9rZW5zMDogY29sbGFwc2VfdmFsaWRfdG9rZW5zKHNsaWNlKSxcclxuXHRcdFx0XHRcdFx0XHR0b2tlbnM6IGVuc190b2tlbml6ZShzdHJfZnJvbV9jcHMoY3BzKSwge25mOiBmYWxzZX0pXHJcblx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0XHRpID0gc3RhcnQ7XHJcblx0XHRcdFx0XHR9IGVsc2UgeyBcclxuXHRcdFx0XHRcdFx0aSA9IGVuZCAtIDE7IC8vIHNraXAgdG8gZW5kIG9mIHNsaWNlXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRzdGFydCA9IC0xOyAvLyByZXNldFxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRzdGFydCA9IGk7IC8vIHJlbWVtYmVyIGxhc3RcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSBpZiAodG9rZW4udHlwZSAhPT0gVFlfSUdOT1JFRCkgeyAvLyAyMDIyMTAyNDogaXMgdGhpcyBjb3JyZWN0P1xyXG5cdFx0XHRcdHN0YXJ0ID0gLTE7IC8vIHJlc2V0XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGNvbGxhcHNlX3ZhbGlkX3Rva2Vucyh0b2tlbnMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc192YWxpZF9vcl9tYXBwZWQodHlwZSkge1xyXG5cdHJldHVybiB0eXBlID09IFRZX1ZBTElEIHx8IHR5cGUgPT0gVFlfTUFQUEVEO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXF1aXJlc19jaGVjayhjcHMpIHtcclxuXHRyZXR1cm4gY3BzLnNvbWUoY3AgPT4gTkZDX0NIRUNLLmhhcyhjcCkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb2xsYXBzZV92YWxpZF90b2tlbnModG9rZW5zKSB7XHJcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmICh0b2tlbnNbaV0udHlwZSA9PSBUWV9WQUxJRCkge1xyXG5cdFx0XHRsZXQgaiA9IGkgKyAxO1xyXG5cdFx0XHR3aGlsZSAoaiA8IHRva2Vucy5sZW5ndGggJiYgdG9rZW5zW2pdLnR5cGUgPT0gVFlfVkFMSUQpIGorKztcclxuXHRcdFx0dG9rZW5zLnNwbGljZShpLCBqIC0gaSwge3R5cGU6IFRZX1ZBTElELCBjcHM6IHRva2Vucy5zbGljZShpLCBqKS5mbGF0TWFwKHggPT4geC5jcHMpfSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiB0b2tlbnM7XHJcbn1cblxuZXhwb3J0IHsgZW5zX2JlYXV0aWZ5LCBlbnNfZW1vamksIGVuc19ub3JtYWxpemUsIGVuc19ub3JtYWxpemVfZnJhZ21lbnQsIGVuc19zcGxpdCwgZW5zX3Rva2VuaXplLCBpc19jb21iaW5pbmdfbWFyaywgbmZjLCBuZmQsIHNhZmVfc3RyX2Zyb21fY3BzLCBzaG91bGRfZXNjYXBlIH07XG4iXSwibmFtZXMiOlsiQ09NUFJFU1NFRCQxIiwiRkVOQ0VEIiwiTWFwIiwiTlNNX01BWCIsImRlY29kZV9hcml0aG1ldGljIiwiYnl0ZXMiLCJwb3MiLCJ1MTYiLCJzeW1ib2xfY291bnQiLCJ0b3RhbCIsImFjYyIsImkiLCJwdXNoIiwic2tpcCIsInBvc19wYXlsb2FkIiwicmVhZF93aWR0aCIsInJlYWRfYnVmZmVyIiwicmVhZF9iaXQiLCJOIiwiRlVMTCIsIkhBTEYiLCJRUlRSIiwiTUFTSyIsInJlZ2lzdGVyIiwic3ltYm9scyIsImxvdyIsInJhbmdlIiwidmFsdWUiLCJNYXRoIiwiZmxvb3IiLCJzdGFydCIsImVuZCIsIm1pZCIsImEiLCJiIiwib2Zmc2V0IiwibWFwIiwieCIsInJlYWRfcGF5bG9hZCIsInYiLCJyZWFkX2NvbXByZXNzZWRfcGF5bG9hZCIsInMiLCJ1bnNhZmVfYXRvYiIsImxvb2t1cCIsImZvckVhY2giLCJjIiwiY2hhckNvZGVBdCIsIm4iLCJsZW5ndGgiLCJyZXQiLCJVaW50OEFycmF5Iiwid2lkdGgiLCJjYXJyeSIsInNpZ25lZCIsInJlYWRfZGVsdGFzIiwibmV4dCIsIkFycmF5IiwicmVhZF9zb3J0ZWQiLCJwcmV2IiwicmVhZF9zb3J0ZWRfYXJyYXlzIiwicmVhZF9hcnJheV93aGlsZSIsInJlYWRfbWFwcGVkIiwidyIsInJlYWRfbGluZWFyX3RhYmxlIiwicmVhZF9yZXBsYWNlbWVudF90YWJsZSIsImZsYXQiLCJyZWFkX3RyYW5zcG9zZWQiLCJtIiwiZmlsbCIsImoiLCJkeCIsImR5Iiwidk4iLCJmbGF0TWFwIiwieXMiLCJfIiwial9keSIsInkiLCJzbGljZSIsInJlYWRfdHJpZSIsInNvcnRlZCIsImV4cGFuZCIsImRlY29kZSIsIlEiLCJTIiwiQiIsImNwcyIsInNhdmVkIiwiYnIiLCJjcCIsImhleF9jcCIsInRvU3RyaW5nIiwidG9VcHBlckNhc2UiLCJwYWRTdGFydCIsInF1b3RlX2NwIiwiZXhwbG9kZV9jcCIsImxlbiIsImNvZGVQb2ludEF0Iiwic3RyX2Zyb21fY3BzIiwiY2h1bmsiLCJTdHJpbmciLCJmcm9tQ29kZVBvaW50IiwiYnVmIiwiam9pbiIsImNvbXBhcmVfYXJyYXlzIiwiQ09NUFJFU1NFRCIsIlMwIiwiTDAiLCJWMCIsIlQwIiwiTF9DT1VOVCIsIlZfQ09VTlQiLCJUX0NPVU5UIiwiTl9DT1VOVCIsIlNfQ09VTlQiLCJTMSIsIkwxIiwiVjEiLCJUMSIsInVucGFja19jYyIsInBhY2tlZCIsInVucGFja19jcCIsIlNISUZURURfUkFOSyIsIkVYQ0xVU0lPTlMiLCJERUNPTVAiLCJSRUNPTVAiLCJpbml0JDEiLCJyIiwiU2V0IiwiaGFzIiwiYnVja2V0IiwiZ2V0Iiwic2V0IiwicmV2ZXJzZSIsImlzX2hhbmd1bCIsImNvbXBvc2VfcGFpciIsInJlY29tcCIsImRlY29tcG9zZWQiLCJjaGVja19vcmRlciIsImFkZCIsImNjIiwic19pbmRleCIsImxfaW5kZXgiLCJ2X2luZGV4IiwidF9pbmRleCIsIm1hcHBlZCIsInBvcCIsInByZXZfY2MiLCJ0bXAiLCJjb21wb3NlZF9mcm9tX2RlY29tcG9zZWQiLCJzdGFjayIsInByZXZfY3AiLCJjb21wb3NlZCIsIm5mZCIsIm5mYyIsIkhZUEhFTiIsIlNUT1AiLCJTVE9QX0NIIiwiRkUwRiIsIlVOSVFVRV9QSCIsIkFycmF5X2Zyb20iLCJmcm9tIiwiZ3JvdXBfaGFzX2NwIiwiZyIsIlAiLCJFbW9qaSIsImlzX2Vtb2ppIiwiTUFQUEVEIiwiSUdOT1JFRCIsIkNNIiwiTlNNIiwiRVNDQVBFIiwiTkZDX0NIRUNLIiwiR1JPVVBTIiwiV0hPTEVfVkFMSUQiLCJXSE9MRV9NQVAiLCJWQUxJRCIsIkVNT0pJX0xJU1QiLCJFTU9KSV9ST09UIiwiaW5pdCIsInJlYWRfc29ydGVkX2FycmF5IiwicmVhZF9zb3J0ZWRfc2V0Iiwic2V0X2FkZF9tYW55IiwiY2h1bmtzIiwidW5yZXN0cmljdGVkIiwicmVhZF9jaHVua2VkIiwiUiIsIk0iLCJ3aG9sZXMiLCJjb25jYXQiLCJzb3J0IiwiZCIsIlYiLCJ2YWx1ZXMiLCJyZWNzIiwiZ3MiLCJmaWx0ZXIiLCJyZWMiLCJmaW5kIiwiRyIsInNvbWUiLCJ1bmlvbiIsImNvbXBsZW1lbnQiLCJtdWx0aSIsImFkZF90b191bmlvbiIsIm5vZGUiLCJjaGlsZCIsInF1b3RlZF9jcCIsInNob3VsZF9lc2NhcGUiLCJiaWRpX3FxIiwic2FmZV9zdHJfZnJvbV9jcHMiLCJjaGVja19sYWJlbF9leHRlbnNpb24iLCJFcnJvciIsImNoZWNrX2xlYWRpbmdfdW5kZXJzY29yZSIsIlVOREVSU0NPUkUiLCJsYXN0SW5kZXhPZiIsImNoZWNrX2ZlbmNlZCIsImVycm9yX3BsYWNlbWVudCIsImxhc3QiLCJtYXRjaCIsIm1heCIsIkluZmluaXR5IiwicXVvdGVyIiwiaXNfY29tYmluaW5nX21hcmsiLCJlbnNfZW1vamkiLCJlbnNfbm9ybWFsaXplX2ZyYWdtZW50IiwiZnJhZyIsImRlY29tcG9zZSIsIm5mIiwic3BsaXQiLCJsYWJlbCIsInRva2Vuc19mcm9tX3N0ciIsImZpbHRlcl9mZTBmIiwiZW5zX25vcm1hbGl6ZSIsIm5hbWUiLCJmbGF0dGVuIiwiZW5zX2JlYXV0aWZ5IiwibGFiZWxzIiwidHlwZSIsIm91dHB1dCIsImVycm9yIiwiYXJyYXlfcmVwbGFjZSIsImluZGV4T2YiLCJlbnNfc3BsaXQiLCJwcmVzZXJ2ZV9lbW9qaSIsImVmIiwiaW5wdXQiLCJpbmZvIiwidG9rZW5zIiwidG9rZW5fY291bnQiLCJub3JtIiwiZW1vamkiLCJldmVyeSIsImNoYXJzIiwidW5pcXVlIiwiZGV0ZXJtaW5lX2dyb3VwIiwiY2hlY2tfZ3JvdXAiLCJjaGVja193aG9sZSIsImVyciIsImdyb3VwIiwibWFrZXIiLCJzaGFyZWQiLCJ3aG9sZSIsImdyb3VwcyIsImVycm9yX2Rpc2FsbG93ZWQiLCJlcnJvcl9ncm91cF9tZW1iZXIiLCJtc2ciLCJtZXNzYWdlIiwicXVvdGVkIiwiZ2ciLCJ3aGVyZSIsImUiLCJrIiwiY29uc3VtZV9lbW9qaV9yZXZlcnNlZCIsImVhdGVuIiwiVFlfVkFMSUQiLCJUWV9NQVBQRUQiLCJUWV9JR05PUkVEIiwiVFlfRElTQUxMT1dFRCIsIlRZX0VNT0pJIiwiVFlfTkZDIiwiVFlfU1RPUCIsImVuc190b2tlbml6ZSIsInRva2VuIiwiaXNfdmFsaWRfb3JfbWFwcGVkIiwicmVxdWlyZXNfY2hlY2siLCJjcHMwIiwic3BsaWNlIiwidG9rZW5zMCIsImNvbGxhcHNlX3ZhbGlkX3Rva2VucyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@adraffy/ens-normalize/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/_shortw_utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/_shortw_utils.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCurve: function() { return /* binding */ createCurve; },\n/* harmony export */   getHash: function() { return /* binding */ getHash; }\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n// connects noble-curves to noble-hashes\nfunction getHash(hash) {\n    return {\n        hash,\n        hmac: function(key) {\n            for(var _len = arguments.length, msgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                msgs[_key - 1] = arguments[_key];\n            }\n            return (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__.hmac)(hash, key, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...msgs));\n        },\n        randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes\n    };\n}\nfunction createCurve(curveDef, defHash) {\n    const create = (hash)=>(0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__.weierstrass)({\n            ...curveDef,\n            ...getHash(hash)\n        });\n    return Object.freeze({\n        ...create(defHash),\n        create\n    });\n} //# sourceMappingURL=_shortw_utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9fc2hvcnR3X3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEsb0VBQW9FLEdBQzFCO0FBQ3FCO0FBQ1A7QUFDeEQsd0NBQXdDO0FBQ2pDLFNBQVNJLFFBQVFDLElBQUk7SUFDeEIsT0FBTztRQUNIQTtRQUNBTCxNQUFNLFNBQUNNOzZDQUFRQztnQkFBQUE7O21CQUFTUCx3REFBSUEsQ0FBQ0ssTUFBTUMsS0FBS0wsZ0VBQVdBLElBQUlNOztRQUN2REwsV0FBV0EsOERBQUFBO0lBQ2Y7QUFDSjtBQUNPLFNBQVNNLFlBQVlDLFFBQVEsRUFBRUMsT0FBTztJQUN6QyxNQUFNQyxTQUFTLENBQUNOLE9BQVNGLHFFQUFXQSxDQUFDO1lBQUUsR0FBR00sUUFBUTtZQUFFLEdBQUdMLFFBQVFDLEtBQUs7UUFBQztJQUNyRSxPQUFPTyxPQUFPQyxNQUFNLENBQUM7UUFBRSxHQUFHRixPQUFPRCxRQUFRO1FBQUVDO0lBQU87QUFDdEQsRUFDQSx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL19zaG9ydHdfdXRpbHMuanM/ZjI0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBobWFjIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9obWFjJztcbmltcG9ydCB7IGNvbmNhdEJ5dGVzLCByYW5kb21CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMnO1xuaW1wb3J0IHsgd2VpZXJzdHJhc3MgfSBmcm9tICcuL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzJztcbi8vIGNvbm5lY3RzIG5vYmxlLWN1cnZlcyB0byBub2JsZS1oYXNoZXNcbmV4cG9ydCBmdW5jdGlvbiBnZXRIYXNoKGhhc2gpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBoYXNoLFxuICAgICAgICBobWFjOiAoa2V5LCAuLi5tc2dzKSA9PiBobWFjKGhhc2gsIGtleSwgY29uY2F0Qnl0ZXMoLi4ubXNncykpLFxuICAgICAgICByYW5kb21CeXRlcyxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUN1cnZlKGN1cnZlRGVmLCBkZWZIYXNoKSB7XG4gICAgY29uc3QgY3JlYXRlID0gKGhhc2gpID0+IHdlaWVyc3RyYXNzKHsgLi4uY3VydmVEZWYsIC4uLmdldEhhc2goaGFzaCkgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5jcmVhdGUoZGVmSGFzaCksIGNyZWF0ZSB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9zaG9ydHdfdXRpbHMuanMubWFwIl0sIm5hbWVzIjpbImhtYWMiLCJjb25jYXRCeXRlcyIsInJhbmRvbUJ5dGVzIiwid2VpZXJzdHJhc3MiLCJnZXRIYXNoIiwiaGFzaCIsImtleSIsIm1zZ3MiLCJjcmVhdGVDdXJ2ZSIsImN1cnZlRGVmIiwiZGVmSGFzaCIsImNyZWF0ZSIsIk9iamVjdCIsImZyZWV6ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/_shortw_utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/curve.js":
/*!**********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/curve.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   validateBasic: function() { return /* binding */ validateBasic; },\n/* harmony export */   wNAF: function() { return /* binding */ wNAF; }\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Abelian group utilities\n\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n    const constTimeNegate = (condition, item)=>{\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W)=>{\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return {\n            windows,\n            windowSize\n        };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder (elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while(n > _0n){\n                if (n & _1n) p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(1) * (Math.ceil( / ) + 1), where:\n         * -  is the window size\n         * -  is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */ precomputeWindow (elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for(let window = 0; window < windows; window++){\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for(let i = 1; i < windowSize; i++){\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */ wNAF (W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for(let window = 0; window < windows; window++){\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                } else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return {\n                p,\n                f\n            };\n        },\n        wNAFCached (P, precomputesMap, n, transform) {\n            // @ts-ignore\n            const W = P._WINDOW_SIZE || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    precomputesMap.set(P, transform(comp));\n                }\n            }\n            return this.wNAF(W, comp, n);\n        }\n    };\n}\nfunction validateBasic(curve) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(curve.Fp);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject)(curve, {\n        n: \"bigint\",\n        h: \"bigint\",\n        Gx: \"field\",\n        Gy: \"field\"\n    }, {\n        nBitLength: \"isSafeInteger\",\n        nByteLength: \"isSafeInteger\"\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{\n            p: curve.Fp.ORDER\n        }\n    });\n} //# sourceMappingURL=curve.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9jdXJ2ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUEsb0VBQW9FLEdBQ3BFLDBCQUEwQjtBQUM0QjtBQUNWO0FBQzVDLE1BQU1HLE1BQU1DLE9BQU87QUFDbkIsTUFBTUMsTUFBTUQsT0FBTztBQUNuQiw2REFBNkQ7QUFDN0QsbUdBQW1HO0FBQ25HLHlEQUF5RDtBQUN6RCw0REFBNEQ7QUFDNUQsK0VBQStFO0FBQy9FLG9HQUFvRztBQUNwRyxvR0FBb0c7QUFDcEcscUNBQXFDO0FBQ3JDLGtHQUFrRztBQUNsRyxnR0FBZ0c7QUFDaEcsOENBQThDO0FBQ3ZDLFNBQVNFLEtBQUtDLENBQUMsRUFBRUMsSUFBSTtJQUN4QixNQUFNQyxrQkFBa0IsQ0FBQ0MsV0FBV0M7UUFDaEMsTUFBTUMsTUFBTUQsS0FBS0UsTUFBTTtRQUN2QixPQUFPSCxZQUFZRSxNQUFNRDtJQUM3QjtJQUNBLE1BQU1HLE9BQU8sQ0FBQ0M7UUFDVixNQUFNQyxVQUFVQyxLQUFLQyxJQUFJLENBQUNWLE9BQU9PLEtBQUssR0FBRyxjQUFjO1FBQ3ZELE1BQU1JLGFBQWEsS0FBTUosQ0FBQUEsSUFBSSxJQUFJLDBCQUEwQjtRQUMzRCxPQUFPO1lBQUVDO1lBQVNHO1FBQVc7SUFDakM7SUFDQSxPQUFPO1FBQ0hWO1FBQ0EsdUNBQXVDO1FBQ3ZDVyxjQUFhQyxHQUFHLEVBQUVDLENBQUM7WUFDZixJQUFJQyxJQUFJaEIsRUFBRWlCLElBQUk7WUFDZCxJQUFJQyxJQUFJSjtZQUNSLE1BQU9DLElBQUluQixJQUFLO2dCQUNaLElBQUltQixJQUFJakIsS0FDSmtCLElBQUlBLEVBQUVHLEdBQUcsQ0FBQ0Q7Z0JBQ2RBLElBQUlBLEVBQUVFLE1BQU07Z0JBQ1pMLE1BQU1qQjtZQUNWO1lBQ0EsT0FBT2tCO1FBQ1g7UUFDQTs7Ozs7Ozs7O1NBU0MsR0FDREssa0JBQWlCUCxHQUFHLEVBQUVOLENB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TUMsRUFBRTtJQUN0QnhELHlEQUFjQSxDQUFDdUQsT0FBTztRQUNsQm5DLEdBQUc7UUFDSHFDLEdBQUc7UUFDSEMsSUFBSTtRQUNKQyxJQUFJO0lBQ1IsR0FBRztRQUNDQyxZQUFZO1FBQ1pDLGFBQWE7SUFDakI7SUFDQSxlQUFlO0lBQ2YsT0FBT0MsT0FBT0MsTUFBTSxDQUFDO1FBQ2pCLEdBQUdoRSxvREFBT0EsQ0FBQ3dELE1BQU1uQyxDQUFDLEVBQUVtQyxNQUFNSyxVQUFVLENBQUM7UUFDckMsR0FBR0wsS0FBSztRQUNSLEdBQUc7WUFBRWxDLEdBQUdrQyxNQUFNQyxFQUFFLENBQUNRLEtBQUs7UUFBQyxDQUFDO0lBQzVCO0FBQ0osRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2N1cnZlLmpzPzYxZDkiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gQWJlbGlhbiBncm91cCB1dGlsaXRpZXNcbmltcG9ydCB7IHZhbGlkYXRlRmllbGQsIG5MZW5ndGggfSBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0IHsgdmFsaWRhdGVPYmplY3QgfSBmcm9tICcuL3V0aWxzLmpzJztcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbi8vIEVsbGlwdGljIGN1cnZlIG11bHRpcGxpY2F0aW9uIG9mIFBvaW50IGJ5IHNjYWxhci4gRnJhZ2lsZS5cbi8vIFNjYWxhcnMgc2hvdWxkIGFsd2F5cyBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXI6IHRoaXMgc2hvdWxkIGJlIGNoZWNrZWQgaW5zaWRlIG9mIGEgY3VydmUgaXRzZWxmLlxuLy8gQ3JlYXRlcyBwcmVjb21wdXRhdGlvbiB0YWJsZXMgZm9yIGZhc3QgbXVsdGlwbGljYXRpb246XG4vLyAtIHByaXZhdGUgc2NhbGFyIGlzIHNwbGl0IGJ5IGZpeGVkIHNpemUgd2luZG93cyBvZiBXIGJpdHNcbi8vIC0gZXZlcnkgd2luZG93IHBvaW50IGlzIGNvbGxlY3RlZCBmcm9tIHdpbmRvdydzIHRhYmxlICYgYWRkZWQgdG8gYWNjdW11bGF0b3Jcbi8vIC0gc2luY2Ugd2luZG93cyBhcmUgZGlmZmVyZW50LCBzYW1lIHBvaW50IGluc2lkZSB0YWJsZXMgd29uJ3QgYmUgYWNjZXNzZWQgbW9yZSB0aGFuIG9uY2UgcGVyIGNhbGNcbi8vIC0gZWFjaCBtdWx0aXBsaWNhdGlvbiBpcyAnTWF0aC5jZWlsKENVUlZFX09SREVSIC8g8J2RiikgKyAxJyBwb2ludCBhZGRpdGlvbnMgKGZpeGVkIGZvciBhbnkgc2NhbGFyKVxuLy8gLSArMSB3aW5kb3cgaXMgbmVjY2Vzc2FyeSBmb3Igd05BRlxuLy8gLSB3TkFGIHJlZHVjZXMgdGFibGUgc2l6ZTogMnggbGVzcyBtZW1vcnkgKyAyeCBmYXN0ZXIgZ2VuZXJhdGlvbiwgYnV0IDEwJSBzbG93ZXIgbXVsdGlwbGljYXRpb25cbi8vIFRPRE86IFJlc2VhcmNoIHJldHVybmluZyAyZCBKUyBhcnJheSBvZiB3aW5kb3dzLCBpbnN0ZWFkIG9mIGEgc2luZ2xlIHdpbmRvdy4gVGhpcyB3b3VsZCBhbGxvd1xuLy8gd2luZG93cyB0byBiZSBpbiBkaWZmZXJlbnQgbWVtb3J5IGxvY2F0aW9uc1xuZXhwb3J0IGZ1bmN0aW9uIHdOQUYoYywgYml0cykge1xuICAgIGNvbnN0IGNvbnN0VGltZU5lZ2F0ZSA9IChjb25kaXRpb24sIGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgbmVnID0gaXRlbS5uZWdhdGUoKTtcbiAgICAgICAgcmV0dXJuIGNvbmRpdGlvbiA/IG5lZyA6IGl0ZW07XG4gICAgfTtcbiAgICBjb25zdCBvcHRzID0gKFcpID0+IHtcbiAgICAgICAgY29uc3Qgd2luZG93cyA9IE1hdGguY2VpbChiaXRzIC8gVykgKyAxOyAvLyArMSwgYmVjYXVzZVxuICAgICAgICBjb25zdCB3aW5kb3dTaXplID0gMiAqKiAoVyAtIDEpOyAvLyAtMSBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgICAgICByZXR1cm4geyB3aW5kb3dzLCB3aW5kb3dTaXplIH07XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb25zdFRpbWVOZWdhdGUsXG4gICAgICAgIC8vIG5vbi1jb25zdCB0aW1lIG11bHRpcGxpY2F0aW9uIGxhZGRlclxuICAgICAgICB1bnNhZmVMYWRkZXIoZWxtLCBuKSB7XG4gICAgICAgICAgICBsZXQgcCA9IGMuWkVSTztcbiAgICAgICAgICAgIGxldCBkID0gZWxtO1xuICAgICAgICAgICAgd2hpbGUgKG4gPiBfMG4pIHtcbiAgICAgICAgICAgICAgICBpZiAobiAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIG4gPj49IF8xbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHdOQUYgcHJlY29tcHV0YXRpb24gd2luZG93LiBVc2VkIGZvciBjYWNoaW5nLlxuICAgICAgICAgKiBEZWZhdWx0IHdpbmRvdyBzaXplIGlzIHNldCBieSBgdXRpbHMucHJlY29tcHV0ZSgpYCBhbmQgaXMgZXF1YWwgdG8gOC5cbiAgICAgICAgICogTnVtYmVyIG9mIHByZWNvbXB1dGVkIHBvaW50cyBkZXBlbmRzIG9uIHRoZSBjdXJ2ZSBzaXplOlxuICAgICAgICAgKiAyXijwnZGK4oiSMSkgKiAoTWF0aC5jZWlsKPCdkZsgLyDwnZGKKSArIDEpLCB3aGVyZTpcbiAgICAgICAgICogLSDwnZGKIGlzIHRoZSB3aW5kb3cgc2l6ZVxuICAgICAgICAgKiAtIPCdkZsgaXMgdGhlIGJpdGxlbmd0aCBvZiB0aGUgY3VydmUgb3JkZXIuXG4gICAgICAgICAqIEZvciBhIDI1Ni1iaXQgY3VydmUgYW5kIHdpbmRvdyBzaXplIDgsIHRoZSBudW1iZXIgb2YgcHJlY29tcHV0ZWQgcG9pbnRzIGlzIDEyOCAqIDMzID0gNDIyNC5cbiAgICAgICAgICogQHJldHVybnMgcHJlY29tcHV0ZWQgcG9pbnQgdGFibGVzIGZsYXR0ZW5lZCB0byBhIHNpbmdsZSBhcnJheVxuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZVdpbmRvdyhlbG0sIFcpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgd2luZG93cywgd2luZG93U2l6ZSB9ID0gb3B0cyhXKTtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgbGV0IHAgPSBlbG07XG4gICAgICAgICAgICBsZXQgYmFzZSA9IHA7XG4gICAgICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgICAgIGJhc2UgPSBwO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgICAgIC8vID0xLCBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgd2luZG93U2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2UgPSBiYXNlLmFkZChwKTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHAgPSBiYXNlLmRvdWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcGxlbWVudHMgZWMgbXVsdGlwbGljYXRpb24gdXNpbmcgcHJlY29tcHV0ZWQgdGFibGVzIGFuZCB3LWFyeSBub24tYWRqYWNlbnQgZm9ybS5cbiAgICAgICAgICogQHBhcmFtIFcgd2luZG93IHNpemVcbiAgICAgICAgICogQHBhcmFtIHByZWNvbXB1dGVzIHByZWNvbXB1dGVkIHRhYmxlc1xuICAgICAgICAgKiBAcGFyYW0gbiBzY2FsYXIgKHdlIGRvbid0IGNoZWNrIGhlcmUsIGJ1dCBzaG91bGQgYmUgbGVzcyB0aGFuIGN1cnZlIG9yZGVyKVxuICAgICAgICAgKiBAcmV0dXJucyByZWFsIGFuZCBmYWtlIChmb3IgY29uc3QtdGltZSkgcG9pbnRzXG4gICAgICAgICAqL1xuICAgICAgICB3TkFGKFcsIHByZWNvbXB1dGVzLCBuKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBtYXliZSBjaGVjayB0aGF0IHNjYWxhciBpcyBsZXNzIHRoYW4gZ3JvdXAgb3JkZXI/IHdOQUYgYmVoYXZpb3VzIGlzIHVuZGVmaW5lZCBvdGhlcndpc2VcbiAgICAgICAgICAgIC8vIEJ1dCBuZWVkIHRvIGNhcmVmdWxseSByZW1vdmUgb3RoZXIgY2hlY2tzIGJlZm9yZSB3TkFGLiBPUkRFUiA9PSBiaXRzIGhlcmVcbiAgICAgICAgICAgIGNvbnN0IHsgd2luZG93cywgd2luZG93U2l6ZSB9ID0gb3B0cyhXKTtcbiAgICAgICAgICAgIGxldCBwID0gYy5aRVJPO1xuICAgICAgICAgICAgbGV0IGYgPSBjLkJBU0U7XG4gICAgICAgICAgICBjb25zdCBtYXNrID0gQmlnSW50KDIgKiogVyAtIDEpOyAvLyBDcmVhdGUgbWFzayB3aXRoIFcgb25lczogMGIxMTExIGZvciBXPTQgZXRjLlxuICAgICAgICAgICAgY29uc3QgbWF4TnVtYmVyID0gMiAqKiBXO1xuICAgICAgICAgICAgY29uc3Qgc2hpZnRCeSA9IEJpZ0ludChXKTtcbiAgICAgICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gd2luZG93ICogd2luZG93U2l6ZTtcbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IFcgYml0cy5cbiAgICAgICAgICAgICAgICBsZXQgd2JpdHMgPSBOdW1iZXIobiAmIG1hc2spO1xuICAgICAgICAgICAgICAgIC8vIFNoaWZ0IG51bWJlciBieSBXIGJpdHMuXG4gICAgICAgICAgICAgICAgbiA+Pj0gc2hpZnRCeTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYml0cyBhcmUgYmlnZ2VyIHRoYW4gbWF4IHNpemUsIHdlJ2xsIHNwbGl0IHRob3NlLlxuICAgICAgICAgICAgICAgIC8vICsyMjQgPT4gMjU2IC0gMzJcbiAgICAgICAgICAgICAgICBpZiAod2JpdHMgPiB3aW5kb3dTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHdiaXRzIC09IG1heE51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgbiArPSBfMW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRoaXMgY29kZSB3YXMgZmlyc3Qgd3JpdHRlbiB3aXRoIGFzc3VtcHRpb24gdGhhdCAnZicgYW5kICdwJyB3aWxsIG5ldmVyIGJlIGluZmluaXR5IHBvaW50OlxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIGVhY2ggYWRkaXRpb24gaXMgbXVsdGlwbGllZCBieSAyICoqIFcsIGl0IGNhbm5vdCBjYW5jZWwgZWFjaCBvdGhlci4gSG93ZXZlcixcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSBpcyBuZWdhdGUgbm93OiBpdCBpcyBwb3NzaWJsZSB0aGF0IG5lZ2F0ZWQgZWxlbWVudCBmcm9tIGxvdyB2YWx1ZVxuICAgICAgICAgICAgICAgIC8vIHdvdWxkIGJlIHRoZSBzYW1lIGFzIGhpZ2ggZWxlbWVudCwgd2hpY2ggd2lsbCBjcmVhdGUgY2FycnkgaW50byBuZXh0IHdpbmRvdy5cbiAgICAgICAgICAgICAgICAvLyBJdCdzIG5vdCBvYnZpb3VzIGhvdyB0aGlzIGNhbiBmYWlsLCBidXQgc3RpbGwgd29ydGggaW52ZXN0aWdhdGluZyBsYXRlci5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSdyZSBvbnRvIFplcm8gcG9pbnQuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHJhbmRvbSBwb2ludCBpbnNpZGUgY3VycmVudCB3aW5kb3cgdG8gZi5cbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQxID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldDIgPSBvZmZzZXQgKyBNYXRoLmFicyh3Yml0cykgLSAxOyAvLyAtMSBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmQxID0gd2luZG93ICUgMiAhPT0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25kMiA9IHdiaXRzIDwgMDtcbiAgICAgICAgICAgICAgICBpZiAod2JpdHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG1vc3QgaW1wb3J0YW50IHBhcnQgZm9yIGNvbnN0LXRpbWUgZ2V0UHVibGljS2V5XG4gICAgICAgICAgICAgICAgICAgIGYgPSBmLmFkZChjb25zdFRpbWVOZWdhdGUoY29uZDEsIHByZWNvbXB1dGVzW29mZnNldDFdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwID0gcC5hZGQoY29uc3RUaW1lTmVnYXRlKGNvbmQyLCBwcmVjb21wdXRlc1tvZmZzZXQyXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEpJVC1jb21waWxlciBzaG91bGQgbm90IGVsaW1pbmF0ZSBmIGhlcmUsIHNpbmNlIGl0IHdpbGwgbGF0ZXIgYmUgdXNlZCBpbiBub3JtYWxpemVaKClcbiAgICAgICAgICAgIC8vIEV2ZW4gaWYgdGhlIHZhcmlhYmxlIGlzIHN0aWxsIHVudXNlZCwgdGhlcmUgYXJlIHNvbWUgY2hlY2tzIHdoaWNoIHdpbGxcbiAgICAgICAgICAgIC8vIHRocm93IGFuIGV4Y2VwdGlvbiwgc28gY29tcGlsZXIgbmVlZHMgdG8gcHJvdmUgdGhleSB3b24ndCBoYXBwZW4sIHdoaWNoIGlzIGhhcmQuXG4gICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHRoZXJlIGlzIGEgd2F5IHRvIEYgYmUgaW5maW5pdHktcG9pbnQgZXZlbiBpZiBwIGlzIG5vdCxcbiAgICAgICAgICAgIC8vIHdoaWNoIG1ha2VzIGl0IGxlc3MgY29uc3QtdGltZTogYXJvdW5kIDEgYmlnaW50IG11bHRpcGx5LlxuICAgICAgICAgICAgcmV0dXJuIHsgcCwgZiB9O1xuICAgICAgICB9LFxuICAgICAgICB3TkFGQ2FjaGVkKFAsIHByZWNvbXB1dGVzTWFwLCBuLCB0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IFcgPSBQLl9XSU5ET1dfU0laRSB8fCAxO1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHByZWNvbXB1dGVzIG9uIGEgZmlyc3QgcnVuLCByZXVzZSB0aGVtIGFmdGVyXG4gICAgICAgICAgICBsZXQgY29tcCA9IHByZWNvbXB1dGVzTWFwLmdldChQKTtcbiAgICAgICAgICAgIGlmICghY29tcCkge1xuICAgICAgICAgICAgICAgIGNvbXAgPSB0aGlzLnByZWNvbXB1dGVXaW5kb3coUCwgVyk7XG4gICAgICAgICAgICAgICAgaWYgKFcgIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY29tcHV0ZXNNYXAuc2V0KFAsIHRyYW5zZm9ybShjb21wKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMud05BRihXLCBjb21wLCBuKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQmFzaWMoY3VydmUpIHtcbiAgICB2YWxpZGF0ZUZpZWxkKGN1cnZlLkZwKTtcbiAgICB2YWxpZGF0ZU9iamVjdChjdXJ2ZSwge1xuICAgICAgICBuOiAnYmlnaW50JyxcbiAgICAgICAgaDogJ2JpZ2ludCcsXG4gICAgICAgIEd4OiAnZmllbGQnLFxuICAgICAgICBHeTogJ2ZpZWxkJyxcbiAgICB9LCB7XG4gICAgICAgIG5CaXRMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgbkJ5dGVMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICB9KTtcbiAgICAvLyBTZXQgZGVmYXVsdHNcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIC4uLm5MZW5ndGgoY3VydmUubiwgY3VydmUubkJpdExlbmd0aCksXG4gICAgICAgIC4uLmN1cnZlLFxuICAgICAgICAuLi57IHA6IGN1cnZlLkZwLk9SREVSIH0sXG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jdXJ2ZS5qcy5tYXAiXSwibmFtZXMiOlsidmFsaWRhdGVGaWVsZCIsIm5MZW5ndGgiLCJ2YWxpZGF0ZU9iamVjdCIsIl8wbiIsIkJpZ0ludCIsIl8xbiIsIndOQUYiLCJjIiwiYml0cyIsImNvbnN0VGltZU5lZ2F0ZSIsImNvbmRpdGlvbiIsIml0ZW0iLCJuZWciLCJuZWdhdGUiLCJvcHRzIiwiVyIsIndpbmRvd3MiLCJNYXRoIiwiY2VpbCIsIndpbmRvd1NpemUiLCJ1bnNhZmVMYWRkZXIiLCJlbG0iLCJuIiwicCIsIlpFUk8iLCJkIiwiYWRkIiwiZG91YmxlIiwicHJlY29tcHV0ZVdpbmRvdyIsInBvaW50cyIsImJhc2UiLCJ3aW5kb3ciLCJwdXNoIiwiaSIsInByZWNvbXB1dGVzIiwiZiIsIkJBU0UiLCJtYXNrIiwibWF4TnVtYmVyIiwic2hpZnRCeSIsIm9mZnNldCIsIndiaXRzIiwiTnVtYmVyIiwib2Zmc2V0MSIsIm9mZnNldDIiLCJhYnMiLCJjb25kMSIsImNvbmQyIiwid05BRkNhY2hlZCIsIlAiLCJwcmVjb21wdXRlc01hcCIsInRyYW5zZm9ybSIsIl9XSU5ET1dfU0laRSIsImNvbXAiLCJnZXQiLCJzZXQiLCJ2YWxpZGF0ZUJhc2ljIiwiY3VydmUiLCJGcCIsImgiLCJHeCIsIkd5IiwibkJpdExlbmd0aCIsIm5CeXRlTGVuZ3RoIiwiT2JqZWN0IiwiZnJlZXplIiwiT1JERVIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/curve.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js":
/*!******************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/hash-to-curve.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHasher: function() { return /* binding */ createHasher; },\n/* harmony export */   expand_message_xmd: function() { return /* binding */ expand_message_xmd; },\n/* harmony export */   expand_message_xof: function() { return /* binding */ expand_message_xof; },\n/* harmony export */   hash_to_field: function() { return /* binding */ hash_to_field; },\n/* harmony export */   isogenyMap: function() { return /* binding */ isogenyMap; }\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n\n\nfunction validateDST(dst) {\n    if (dst instanceof Uint8Array) return dst;\n    if (typeof dst === \"string\") return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(dst);\n    throw new Error(\"DST must be Uint8Array or string\");\n}\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    if (value < 0 || value >= 1 << 8 * length) {\n        throw new Error(\"bad I2OSP call: value=\".concat(value, \" length=\").concat(length));\n    }\n    const res = Array.from({\n        length\n    }).fill(0);\n    for(let i = length - 1; i >= 0; i--){\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for(let i = 0; i < a.length; i++){\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction isBytes(item) {\n    if (!(item instanceof Uint8Array)) throw new Error(\"Uint8Array expected\");\n}\nfunction isNum(item) {\n    if (!Number.isSafeInteger(item)) throw new Error(\"number expected\");\n}\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    isBytes(msg);\n    isBytes(DST);\n    isNum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255) DST = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(\"H2C-OVERSIZE-DST-\"), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (ell > 255) throw new Error(\"Invalid xmd length\");\n    const DST_prime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for(let i = 1; i <= ell; i++){\n        const args = [\n            strxor(b_0, b[i - 1]),\n            i2osp(i + 1, 1),\n            DST_prime\n        ];\n        b[i] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n// Produces a uniformly random byte string using an extendable-output function (XOF) H.\n// 1. The collision resistance of H MUST be at least k bits.\n// 2. H MUST be an XOF that has been proved indifferentiable from\n//    a random oracle under a reasonable cryptographic assumption.\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    isBytes(msg);\n    isBytes(DST);\n    isNum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil(2 * k / 8);\n        DST = H.create({\n            dkLen\n        }).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(\"H2C-OVERSIZE-DST-\")).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255) throw new Error(\"expand_message_xof: invalid lenInBytes\");\n    return H.create({\n        dkLen: lenInBytes\n    }).update(msg).update(i2osp(lenInBytes, 2))// 2. DST_prime = DST || I2OSP(len(DST), 1)\n    .update(DST).update(i2osp(DST.length, 1)).digest();\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://www.rfc-editor.org/rfc/rfc9380#section-5.2\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */ function hash_to_field(msg, count, options) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(options, {\n        DST: \"stringOrUint8Array\",\n        p: \"bigint\",\n        m: \"isSafeInteger\",\n        k: \"isSafeInteger\",\n        hash: \"hash\"\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    isBytes(msg);\n    isNum(count);\n    const DST = validateDST(_DST);\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === \"xmd\") {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    } else if (expand === \"xof\") {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    } else if (expand === \"_internal_pass\") {\n        // for internal tests only\n        prb = msg;\n    } else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for(let i = 0; i < count; i++){\n        const e = new Array(m);\n        for(let j = 0; j < m; j++){\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i)=>Array.from(i).reverse());\n    return (x, y)=>{\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val)=>val.reduce((acc, i)=>field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return {\n            x,\n            y\n        };\n    };\n}\nfunction createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== \"function\") throw new Error(\"mapToCurve() must be defined\");\n    return {\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve (msg, options) {\n            const u = hash_to_field(msg, 2, {\n                ...def,\n                DST: def.DST,\n                ...options\n            });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve (msg, options) {\n            const u = hash_to_field(msg, 1, {\n                ...def,\n                DST: def.encodeDST,\n                ...options\n            });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        }\n    };\n} //# sourceMappingURL=hash-to-curve.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBbUM7QUFDb0Q7QUFDdkYsU0FBU0ssWUFBWUMsR0FBRztJQUNwQixJQUFJQSxlQUFlQyxZQUNmLE9BQU9EO0lBQ1gsSUFBSSxPQUFPQSxRQUFRLFVBQ2YsT0FBT0gsc0RBQVdBLENBQUNHO0lBQ3ZCLE1BQU0sSUFBSUUsTUFBTTtBQUNwQjtBQUNBLDZGQUE2RjtBQUM3RixNQUFNQyxRQUFRUixzREFBZUE7QUFDN0IsNENBQTRDO0FBQzVDLFNBQVNTLE1BQU1DLEtBQUssRUFBRUMsTUFBTTtJQUN4QixJQUFJRCxRQUFRLEtBQUtBLFNBQVMsS0FBTSxJQUFJQyxRQUFTO1FBQ3pDLE1BQU0sSUFBSUosTUFBTSx5QkFBeUNJLE9BQWhCRCxPQUFNLFlBQWlCLE9BQVBDO0lBQzdEO0lBQ0EsTUFBTUMsTUFBTUMsTUFBTUMsSUFBSSxDQUFDO1FBQUVIO0lBQU8sR0FBR0ksSUFBSSxDQUFDO0lBQ3hDLElBQUssSUFBSUMsSUFBSUwsU0FBUyxHQUFHSyxLQUFLLEdBQUdBLElBQUs7UUFDbENKLEdBQUcsQ0FBQ0ksRUFBRSxHQUFHTixRQUFRO1FBQ2pCQSxXQUFXO0lBQ2Y7SUFDQSxPQUFPLElBQUlKLFdBQVdNO0FBQzFCO0FBQ0EsU0FBU0ssT0FBT0MsQ0FBQyxFQUFFQyxDQUFDO0lBQ2hCLE1BQU1DLE1BQU0sSUFBSWQsV0FBV1ksRUFBRVAsTUFBTTtJQUNuQyxJQUFLLElBQUlLLElBQUksR0FBR0EsSUFBSUUsRUFBRVAsTUFBTSxFQUFFSyxJQUFLO1FBQy9CSSxHQUFHLENBQUNKLEVBQUUsR0FBR0UsQ0FBQyxDQUFDRixFQUFFLEdBQUdHLENBQUMsQ0FBQ0gsRUFBRTtJQUN4QjtJQUNBLE9BQU9JO0FBQ1g7QUFDQSxTQUFTQyxRQUFRQyxJQUFJO0lBQ2pCLElBQUksQ0FBRUEsQ0FBQUEs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SixXQUFXekIsQ0FBQyxDQUFDLEVBQUU7WUFDM0MsTUFBTStCLElBQUlILEdBQUdSLEdBQUcsQ0FBQ1UsSUFBSUUsYUFBYTtZQUNsQ0QsRUFBRUUsY0FBYztZQUNoQixPQUFPRjtRQUNYO1FBQ0EseUNBQXlDO1FBQ3pDLHdFQUF3RTtRQUN4RUcsZUFBY3ZFLEdBQUcsRUFBRTBCLE9BQU87WUFDdEIsTUFBTVcsSUFBSWIsY0FBY3hCLEtBQUssR0FBRztnQkFBRSxHQUFHK0QsR0FBRztnQkFBRTlELEtBQUs4RCxJQUFJUyxTQUFTO2dCQUFFLEdBQUc5QyxPQUFPO1lBQUM7WUFDekUsTUFBTTBDLElBQUlQLE1BQU1LLFVBQVUsQ0FBQ0osV0FBV3pCLENBQUMsQ0FBQyxFQUFFLEdBQUdnQyxhQUFhO1lBQzFERCxFQUFFRSxjQUFjO1lBQ2hCLE9BQU9GO1FBQ1g7SUFDSjtBQUNKLEVBQ0EseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzPzIwZDIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbW9kIH0gZnJvbSAnLi9tb2R1bGFyLmpzJztcbmltcG9ydCB7IGJ5dGVzVG9OdW1iZXJCRSwgY29uY2F0Qnl0ZXMsIHV0ZjhUb0J5dGVzLCB2YWxpZGF0ZU9iamVjdCB9IGZyb20gJy4vdXRpbHMuanMnO1xuZnVuY3Rpb24gdmFsaWRhdGVEU1QoZHN0KSB7XG4gICAgaWYgKGRzdCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICAgIHJldHVybiBkc3Q7XG4gICAgaWYgKHR5cGVvZiBkc3QgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoZHN0KTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RTVCBtdXN0IGJlIFVpbnQ4QXJyYXkgb3Igc3RyaW5nJyk7XG59XG4vLyBPY3RldCBTdHJlYW0gdG8gSW50ZWdlci4gXCJzcGVjXCIgaW1wbGVtZW50YXRpb24gb2Ygb3MyaXAgaXMgMi41eCBzbG93ZXIgdnMgYnl0ZXNUb051bWJlckJFLlxuY29uc3Qgb3MyaXAgPSBieXRlc1RvTnVtYmVyQkU7XG4vLyBJbnRlZ2VyIHRvIE9jdGV0IFN0cmVhbSAobnVtYmVyVG9CeXRlc0JFKVxuZnVuY3Rpb24gaTJvc3AodmFsdWUsIGxlbmd0aCkge1xuICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPj0gMSA8PCAoOCAqIGxlbmd0aCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiYWQgSTJPU1AgY2FsbDogdmFsdWU9JHt2YWx1ZX0gbGVuZ3RoPSR7bGVuZ3RofWApO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoIH0pLmZpbGwoMCk7XG4gICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHJlc1tpXSA9IHZhbHVlICYgMHhmZjtcbiAgICAgICAgdmFsdWUgPj4+PSA4O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocmVzKTtcbn1cbmZ1bmN0aW9uIHN0cnhvcihhLCBiKSB7XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYS5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBhW2ldIF4gYltpXTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cbmZ1bmN0aW9uIGlzQnl0ZXMoaXRlbSkge1xuICAgIGlmICghKGl0ZW0gaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG59XG5mdW5jdGlvbiBpc051bShpdGVtKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihpdGVtKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdudW1iZXIgZXhwZWN0ZWQnKTtcbn1cbi8vIFByb2R1Y2VzIGEgdW5pZm9ybWx5IHJhbmRvbSBieXRlIHN0cmluZyB1c2luZyBhIGNyeXB0b2dyYXBoaWMgaGFzaCBmdW5jdGlvbiBIIHRoYXQgb3V0cHV0cyBiIGJpdHNcbi8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjFcbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRfbWVzc2FnZV94bWQobXNnLCBEU1QsIGxlbkluQnl0ZXMsIEgpIHtcbiAgICBpc0J5dGVzKG1zZyk7XG4gICAgaXNCeXRlcyhEU1QpO1xuICAgIGlzTnVtKGxlbkluQnl0ZXMpO1xuICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjNcbiAgICBpZiAoRFNULmxlbmd0aCA+IDI1NSlcbiAgICAgICAgRFNUID0gSChjb25jYXRCeXRlcyh1dGY4VG9CeXRlcygnSDJDLU9WRVJTSVpFLURTVC0nKSwgRFNUKSk7XG4gICAgY29uc3QgeyBvdXRwdXRMZW46IGJfaW5fYnl0ZXMsIGJsb2NrTGVuOiByX2luX2J5dGVzIH0gPSBIO1xuICAgIGNvbnN0IGVsbCA9IE1hdGguY2VpbChsZW5JbkJ5dGVzIC8gYl9pbl9ieXRlcyk7XG4gICAgaWYgKGVsbCA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHhtZCBsZW5ndGgnKTtcbiAgICBjb25zdCBEU1RfcHJpbWUgPSBjb25jYXRCeXRlcyhEU1QsIGkyb3NwKERTVC5sZW5ndGgsIDEpKTtcbiAgICBjb25zdCBaX3BhZCA9IGkyb3NwKDAsIHJfaW5fYnl0ZXMpO1xuICAgIGNvbnN0IGxfaV9iX3N0ciA9IGkyb3NwKGxlbkluQnl0ZXMsIDIpOyAvLyBsZW5faW5fYnl0ZXNfc3RyXG4gICAgY29uc3QgYiA9IG5ldyBBcnJheShlbGwpO1xuICAgIGNvbnN0IGJfMCA9IEgoY29uY2F0Qnl0ZXMoWl9wYWQsIG1zZywgbF9pX2Jfc3RyLCBpMm9zcCgwLCAxKSwgRFNUX3ByaW1lKSk7XG4gICAgYlswXSA9IEgoY29uY2F0Qnl0ZXMoYl8wLCBpMm9zcCgxLCAxKSwgRFNUX3ByaW1lKSk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gZWxsOyBpKyspIHtcbiAgICAgICAgY29uc3QgYXJncyA9IFtzdHJ4b3IoYl8wLCBiW2kgLSAxXSksIGkyb3NwKGkgKyAxLCAxKSwgRFNUX3ByaW1lXTtcbiAgICAgICAgYltpXSA9IEgoY29uY2F0Qnl0ZXMoLi4uYXJncykpO1xuICAgIH1cbiAgICBjb25zdCBwc2V1ZG9fcmFuZG9tX2J5dGVzID0gY29uY2F0Qnl0ZXMoLi4uYik7XG4gICAgcmV0dXJuIHBzZXVkb19yYW5kb21fYnl0ZXMuc2xpY2UoMCwgbGVuSW5CeXRlcyk7XG59XG4vLyBQcm9kdWNlcyBhIHVuaWZvcm1seSByYW5kb20gYnl0ZSBzdHJpbmcgdXNpbmcgYW4gZXh0ZW5kYWJsZS1vdXRwdXQgZnVuY3Rpb24gKFhPRikgSC5cbi8vIDEuIFRoZSBjb2xsaXNpb24gcmVzaXN0YW5jZSBvZiBIIE1VU1QgYmUgYXQgbGVhc3QgayBiaXRzLlxuLy8gMi4gSCBNVVNUIGJlIGFuIFhPRiB0aGF0IGhhcyBiZWVuIHByb3ZlZCBpbmRpZmZlcmVudGlhYmxlIGZyb21cbi8vICAgIGEgcmFuZG9tIG9yYWNsZSB1bmRlciBhIHJlYXNvbmFibGUgY3J5cHRvZ3JhcGhpYyBhc3N1bXB0aW9uLlxuLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuMlxuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZF9tZXNzYWdlX3hvZihtc2csIERTVCwgbGVuSW5CeXRlcywgaywgSCkge1xuICAgIGlzQnl0ZXMobXNnKTtcbiAgICBpc0J5dGVzKERTVCk7XG4gICAgaXNOdW0obGVuSW5CeXRlcyk7XG4gICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuM1xuICAgIC8vIERTVCA9IEgoJ0gyQy1PVkVSU0laRS1EU1QtJyB8fCBhX3ZlcnlfbG9uZ19EU1QsIE1hdGguY2VpbCgobGVuSW5CeXRlcyAqIGspIC8gOCkpO1xuICAgIGlmIChEU1QubGVuZ3RoID4gMjU1KSB7XG4gICAgICAgIGNvbnN0IGRrTGVuID0gTWF0aC5jZWlsKCgyICogaykgLyA4KTtcbiAgICAgICAgRFNUID0gSC5jcmVhdGUoeyBka0xlbiB9KS51cGRhdGUodXRmOFRvQnl0ZXMoJ0gyQy1PVkVSU0laRS1EU1QtJykpLnVwZGF0ZShEU1QpLmRpZ2VzdCgpO1xuICAgIH1cbiAgICBpZiAobGVuSW5CeXRlcyA+IDY1NTM1IHx8IERTVC5sZW5ndGggPiAyNTUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwYW5kX21lc3NhZ2VfeG9mOiBpbnZhbGlkIGxlbkluQnl0ZXMnKTtcbiAgICByZXR1cm4gKEguY3JlYXRlKHsgZGtMZW46IGxlbkluQnl0ZXMgfSlcbiAgICAgICAgLnVwZGF0ZShtc2cpXG4gICAgICAgIC51cGRhdGUoaTJvc3AobGVuSW5CeXRlcywgMikpXG4gICAgICAgIC8vIDIuIERTVF9wcmltZSA9IERTVCB8fCBJMk9TUChsZW4oRFNUKSwgMSlcbiAgICAgICAgLnVwZGF0ZShEU1QpXG4gICAgICAgIC51cGRhdGUoaTJvc3AoRFNULmxlbmd0aCwgMSkpXG4gICAgICAgIC5kaWdlc3QoKSk7XG59XG4vKipcbiAqIEhhc2hlcyBhcmJpdHJhcnktbGVuZ3RoIGJ5dGUgc3RyaW5ncyB0byBhIGxpc3Qgb2Ygb25lIG9yIG1vcmUgZWxlbWVudHMgb2YgYSBmaW5pdGUgZmllbGQgRlxuICogaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjJcbiAqIEBwYXJhbSBtc2cgYSBieXRlIHN0cmluZyBjb250YWluaW5nIHRoZSBtZXNzYWdlIHRvIGhhc2hcbiAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIG9mIEYgdG8gb3V0cHV0XG4gKiBAcGFyYW0gb3B0aW9ucyBge0RTVDogc3RyaW5nLCBwOiBiaWdpbnQsIG06IG51bWJlciwgazogbnVtYmVyLCBleHBhbmQ6ICd4bWQnIHwgJ3hvZicsIGhhc2g6IEh9YCwgc2VlIGFib3ZlXG4gKiBAcmV0dXJucyBbdV8wLCAuLi4sIHVfKGNvdW50IC0gMSldLCBhIGxpc3Qgb2YgZmllbGQgZWxlbWVudHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoX3RvX2ZpZWxkKG1zZywgY291bnQsIG9wdGlvbnMpIHtcbiAgICB2YWxpZGF0ZU9iamVjdChvcHRpb25zLCB7XG4gICAgICAgIERTVDogJ3N0cmluZ09yVWludDhBcnJheScsXG4gICAgICAgIHA6ICdiaWdpbnQnLFxuICAgICAgICBtOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIGs6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgaGFzaDogJ2hhc2gnLFxuICAgIH0pO1xuICAgIGNvbnN0IHsgcCwgaywgbSwgaGFzaCwgZXhwYW5kLCBEU1Q6IF9EU1QgfSA9IG9wdGlvbnM7XG4gICAgaXNCeXRlcyhtc2cpO1xuICAgIGlzTnVtKGNvdW50KTtcbiAgICBjb25zdCBEU1QgPSB2YWxpZGF0ZURTVChfRFNUKTtcbiAgICBjb25zdCBsb2cycCA9IHAudG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIGNvbnN0IEwgPSBNYXRoLmNlaWwoKGxvZzJwICsgaykgLyA4KTsgLy8gc2VjdGlvbiA1LjEgb2YgaWV0ZiBkcmFmdCBsaW5rIGFib3ZlXG4gICAgY29uc3QgbGVuX2luX2J5dGVzID0gY291bnQgKiBtICogTDtcbiAgICBsZXQgcHJiOyAvLyBwc2V1ZG9fcmFuZG9tX2J5dGVzXG4gICAgaWYgKGV4cGFuZCA9PT0gJ3htZCcpIHtcbiAgICAgICAgcHJiID0gZXhwYW5kX21lc3NhZ2VfeG1kKG1zZywgRFNULCBsZW5faW5fYnl0ZXMsIGhhc2gpO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHBhbmQgPT09ICd4b2YnKSB7XG4gICAgICAgIHByYiA9IGV4cGFuZF9tZXNzYWdlX3hvZihtc2csIERTVCwgbGVuX2luX2J5dGVzLCBrLCBoYXNoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwYW5kID09PSAnX2ludGVybmFsX3Bhc3MnKSB7XG4gICAgICAgIC8vIGZvciBpbnRlcm5hbCB0ZXN0cyBvbmx5XG4gICAgICAgIHByYiA9IG1zZztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwYW5kIG11c3QgYmUgXCJ4bWRcIiBvciBcInhvZlwiJyk7XG4gICAgfVxuICAgIGNvbnN0IHUgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBlID0gbmV3IEFycmF5KG0pO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG07IGorKykge1xuICAgICAgICAgICAgY29uc3QgZWxtX29mZnNldCA9IEwgKiAoaiArIGkgKiBtKTtcbiAgICAgICAgICAgIGNvbnN0IHR2ID0gcHJiLnN1YmFycmF5KGVsbV9vZmZzZXQsIGVsbV9vZmZzZXQgKyBMKTtcbiAgICAgICAgICAgIGVbal0gPSBtb2Qob3MyaXAodHYpLCBwKTtcbiAgICAgICAgfVxuICAgICAgICB1W2ldID0gZTtcbiAgICB9XG4gICAgcmV0dXJuIHU7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNvZ2VueU1hcChmaWVsZCwgbWFwKSB7XG4gICAgLy8gTWFrZSBzYW1lIG9yZGVyIGFzIGluIHNwZWNcbiAgICBjb25zdCBDT0VGRiA9IG1hcC5tYXAoKGkpID0+IEFycmF5LmZyb20oaSkucmV2ZXJzZSgpKTtcbiAgICByZXR1cm4gKHgsIHkpID0+IHtcbiAgICAgICAgY29uc3QgW3hOdW0sIHhEZW4sIHlOdW0sIHlEZW5dID0gQ09FRkYubWFwKCh2YWwpID0+IHZhbC5yZWR1Y2UoKGFjYywgaSkgPT4gZmllbGQuYWRkKGZpZWxkLm11bChhY2MsIHgpLCBpKSkpO1xuICAgICAgICB4ID0gZmllbGQuZGl2KHhOdW0sIHhEZW4pOyAvLyB4TnVtIC8geERlblxuICAgICAgICB5ID0gZmllbGQubXVsKHksIGZpZWxkLmRpdih5TnVtLCB5RGVuKSk7IC8vIHkgKiAoeU51bSAvIHlEZXYpXG4gICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhhc2hlcihQb2ludCwgbWFwVG9DdXJ2ZSwgZGVmKSB7XG4gICAgaWYgKHR5cGVvZiBtYXBUb0N1cnZlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmUoKSBtdXN0IGJlIGRlZmluZWQnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvLyBFbmNvZGVzIGJ5dGUgc3RyaW5nIHRvIGVsbGlwdGljIGN1cnZlLlxuICAgICAgICAvLyBoYXNoX3RvX2N1cnZlIGZyb20gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi0zXG4gICAgICAgIGhhc2hUb0N1cnZlKG1zZywgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdSA9IGhhc2hfdG9fZmllbGQobXNnLCAyLCB7IC4uLmRlZiwgRFNUOiBkZWYuRFNULCAuLi5vcHRpb25zIH0pO1xuICAgICAgICAgICAgY29uc3QgdTAgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUodVswXSkpO1xuICAgICAgICAgICAgY29uc3QgdTEgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUodVsxXSkpO1xuICAgICAgICAgICAgY29uc3QgUCA9IHUwLmFkZCh1MSkuY2xlYXJDb2ZhY3RvcigpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEVuY29kZXMgYnl0ZSBzdHJpbmcgdG8gZWxsaXB0aWMgY3VydmUuXG4gICAgICAgIC8vIGVuY29kZV90b19jdXJ2ZSBmcm9tIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tM1xuICAgICAgICBlbmNvZGVUb0N1cnZlKG1zZywgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdSA9IGhhc2hfdG9fZmllbGQobXNnLCAxLCB7IC4uLmRlZiwgRFNUOiBkZWYuZW5jb2RlRFNULCAuLi5vcHRpb25zIH0pO1xuICAgICAgICAgICAgY29uc3QgUCA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZSh1WzBdKSkuY2xlYXJDb2ZhY3RvcigpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhc2gtdG8tY3VydmUuanMubWFwIl0sIm5hbWVzIjpbIm1vZCIsImJ5dGVzVG9OdW1iZXJCRSIsImNvbmNhdEJ5dGVzIiwidXRmOFRvQnl0ZXMiLCJ2YWxpZGF0ZU9iamVjdCIsInZhbGlkYXRlRFNUIiwiZHN0IiwiVWludDhBcnJheSIsIkVycm9yIiwib3MyaXAiLCJpMm9zcCIsInZhbHVlIiwibGVuZ3RoIiwicmVzIiwiQXJyYXkiLCJmcm9tIiwiZmlsbCIsImkiLCJzdHJ4b3IiLCJhIiwiYiIsImFyciIsImlzQnl0ZXMiLCJpdGVtIiwiaXNOdW0iLCJOdW1iZXIiLCJpc1NhZmVJbnRlZ2VyIiwiZXhwYW5kX21lc3NhZ2VfeG1kIiwibXNnIiwiRFNUIiwibGVuSW5CeXRlcyIsIkgiLCJvdXRwdXRMZW4iLCJiX2luX2J5dGVzIiwiYmxvY2tMZW4iLCJyX2luX2J5dGVzIiwiZWxsIiwiTWF0aCIsImNlaWwiLCJEU1RfcHJpbWUiLCJaX3BhZCIsImxfaV9iX3N0ciIsImJfMCIsImFyZ3MiLCJwc2V1ZG9fcmFuZG9tX2J5dGVzIiwic2xpY2UiLCJleHBhbmRfbWVzc2FnZV94b2YiLCJrIiwiZGtMZW4iLCJjcmVhdGUiLCJ1cGRhdGUiLCJkaWdlc3QiLCJoYXNoX3RvX2ZpZWxkIiwiY291bnQiLCJvcHRpb25zIiwicCIsIm0iLCJoYXNoIiwiZXhwYW5kIiwiX0RTVCIsImxvZzJwIiwidG9TdHJpbmciLCJMIiwibGVuX2luX2J5dGVzIiwicHJiIiwidSIsImUiLCJqIiwiZWxtX29mZnNldCIsInR2Iiwic3ViYXJyYXkiLCJpc29nZW55TWFwIiwiZmllbGQiLCJtYXAiLCJDT0VGRiIsInJldmVyc2UiLCJ4IiwieSIsInhOdW0iLCJ4RGVuIiwieU51bSIsInlEZW4iLCJ2YWwiLCJyZWR1Y2UiLCJhY2MiLCJhZGQiLCJtdWwiLCJkaXYiLCJjcmVhdGVIYXNoZXIiLCJQb2ludCIsIm1hcFRvQ3VydmUiLCJkZWYiLCJoYXNoVG9DdXJ2ZSIsInUwIiwiZnJvbUFmZmluZSIsInUxIiwiUCIsImNsZWFyQ29mYWN0b3IiLCJhc3NlcnRWYWxpZGl0eSIsImVuY29kZVRvQ3VydmUiLCJlbmNvZGVEU1QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js":
/*!************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/modular.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: function() { return /* binding */ Field; },\n/* harmony export */   FpDiv: function() { return /* binding */ FpDiv; },\n/* harmony export */   FpInvertBatch: function() { return /* binding */ FpInvertBatch; },\n/* harmony export */   FpIsSquare: function() { return /* binding */ FpIsSquare; },\n/* harmony export */   FpPow: function() { return /* binding */ FpPow; },\n/* harmony export */   FpSqrt: function() { return /* binding */ FpSqrt; },\n/* harmony export */   FpSqrtEven: function() { return /* binding */ FpSqrtEven; },\n/* harmony export */   FpSqrtOdd: function() { return /* binding */ FpSqrtOdd; },\n/* harmony export */   getFieldBytesLength: function() { return /* binding */ getFieldBytesLength; },\n/* harmony export */   getMinHashLength: function() { return /* binding */ getMinHashLength; },\n/* harmony export */   hashToPrivateScalar: function() { return /* binding */ hashToPrivateScalar; },\n/* harmony export */   invert: function() { return /* binding */ invert; },\n/* harmony export */   isNegativeLE: function() { return /* binding */ isNegativeLE; },\n/* harmony export */   mapHashToField: function() { return /* binding */ mapHashToField; },\n/* harmony export */   mod: function() { return /* binding */ mod; },\n/* harmony export */   nLength: function() { return /* binding */ nLength; },\n/* harmony export */   pow: function() { return /* binding */ pow; },\n/* harmony export */   pow2: function() { return /* binding */ pow2; },\n/* harmony export */   tonelliShanks: function() { return /* binding */ tonelliShanks; },\n/* harmony export */   validateField: function() { return /* binding */ validateField; }\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Utilities for modular arithmetics and finite fields\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */ // TODO: use field version && remove\nfunction pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n) throw new Error(\"Expected power/modulo > 0\");\n    if (modulo === _1n) return _0n;\n    let res = _1n;\n    while(power > _0n){\n        if (power & _1n) res = res * num % modulo;\n        num = num * num % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while(power-- > _0n){\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n// Inverses number over modulo\nfunction invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(\"invert: expected positive integers, got n=\".concat(number, \" mod=\").concat(modulo));\n    }\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while(a !== _0n){\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n) throw new Error(\"invert: does not exist\");\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */ function tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p)  1    if a is a square (mod p)\n    // (a | p)  -1   if a is not a square (mod p)\n    // (a | p)  0    if a  0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for(Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++);\n    // Step 2: Select a non-square z such that (z | p)  -1 and set c  zq\n    for(Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++);\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be  -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE)) throw new Error(\"Cannot find square root\");\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while(!Fp.eql(b, Fp.ONE)){\n            if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for(let t2 = Fp.sqr(b); m < r; m++){\n                if (Fp.eql(t2, Fp.ONE)) break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nfunction FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P  3 (mod 4)\n    // n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n            return root;\n        };\n    }\n    // Atkin algorithm for q  5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n            return root;\n        };\n    }\n    // P  9 (mod 16)\n    if (P % _16n === _9n) {\n    // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n    // Means we cannot use sqrt for constants at all!\n    //\n    // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    // sqrt = (x) => {\n    //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n    //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n    //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n    //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n    //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n    //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n    //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n    //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n    //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n    //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n    // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n_c = FpSqrt;\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo)=>(mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    \"create\",\n    \"isValid\",\n    \"is0\",\n    \"neg\",\n    \"inv\",\n    \"sqrt\",\n    \"sqr\",\n    \"eql\",\n    \"add\",\n    \"sub\",\n    \"mul\",\n    \"pow\",\n    \"div\",\n    \"addN\",\n    \"subN\",\n    \"mulN\",\n    \"sqrN\"\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: \"bigint\",\n        MASK: \"bigint\",\n        BYTES: \"isSafeInteger\",\n        BITS: \"isSafeInteger\"\n    };\n    const opts = FIELD_FIELDS.reduce((map, val)=>{\n        map[val] = \"function\";\n        return map;\n    }, initial);\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */ function FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n) throw new Error(\"Expected power > 0\");\n    if (power === _0n) return f.ONE;\n    if (power === _1n) return num;\n    let p = f.ONE;\n    let d = num;\n    while(power > _0n){\n        if (power & _1n) p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n_c1 = FpPow;\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */ function FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i)=>{\n        if (f.is0(num)) return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i)=>{\n        if (f.is0(num)) return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\n_c2 = FpInvertBatch;\nfunction FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === \"bigint\" ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n_c3 = FpDiv;\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n    return (x)=>{\n        const p = f.pow(x, legendreConst);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n_c4 = FpIsSquare;\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return {\n        nBitLength: _nBitLength,\n        nByteLength\n    };\n}\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */ function Field(ORDER, bitLen) {\n    let isLE = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, redef = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n    if (ORDER <= _0n) throw new Error(\"Expected Field ORDER > 0, got \".concat(ORDER));\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048) throw new Error(\"Field lengths over 2048 bytes are not supported\");\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num)=>mod(num, ORDER),\n        isValid: (num)=>{\n            if (typeof num !== \"bigint\") throw new Error(\"Invalid field element: expected bigint, got \".concat(typeof num));\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num)=>num === _0n,\n        isOdd: (num)=>(num & _1n) === _1n,\n        neg: (num)=>mod(-num, ORDER),\n        eql: (lhs, rhs)=>lhs === rhs,\n        sqr: (num)=>mod(num * num, ORDER),\n        add: (lhs, rhs)=>mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs)=>mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs)=>mod(lhs * rhs, ORDER),\n        pow: (num, power)=>FpPow(f, num, power),\n        div: (lhs, rhs)=>mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num)=>num * num,\n        addN: (lhs, rhs)=>lhs + rhs,\n        subN: (lhs, rhs)=>lhs - rhs,\n        mulN: (lhs, rhs)=>lhs * rhs,\n        inv: (num)=>invert(num, ORDER),\n        sqrt: redef.sqrt || ((n)=>sqrtP(f, n)),\n        invertBatch: (lst)=>FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c)=>c ? b : a,\n        toBytes: (num)=>isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES),\n        fromBytes: (bytes)=>{\n            if (bytes.length !== BYTES) throw new Error(\"Fp.fromBytes: expected \".concat(BYTES, \", got \").concat(bytes.length));\n            return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);\n        }\n    });\n    return Object.freeze(f);\n}\n_c5 = Field;\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\n_c6 = FpSqrtOdd;\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n_c7 = FpSqrtEven;\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */ function hashToPrivateScalar(hash, groupOrder) {\n    let isLE = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"privateHash\", hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024) throw new Error(\"hashToPrivateScalar: expected \".concat(minLen, \"-1024 bytes of input, got \").concat(hashLen));\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */ function getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== \"bigint\") throw new Error(\"field order must be bigint\");\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */ function getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */ function mapHashToField(key, fieldOrder) {\n    let isLE = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024) throw new Error(\"expected \".concat(minLen, \"-1024 bytes of input, got \").concat(len));\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(key) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(reduced, fieldLen) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(reduced, fieldLen);\n} //# sourceMappingURL=modular.js.map\nvar _c, _c1, _c2, _c3, _c4, _c5, _c6, _c7;\n$RefreshReg$(_c, \"FpSqrt\");\n$RefreshReg$(_c1, \"FpPow\");\n$RefreshReg$(_c2, \"FpInvertBatch\");\n$RefreshReg$(_c3, \"FpDiv\");\n$RefreshReg$(_c4, \"FpIsSquare\");\n$RefreshReg$(_c5, \"Field\");\n$RefreshReg$(_c6, \"FpSqrtOdd\");\n$RefreshReg$(_c7, \"FpSqrtEven\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9tb2R1bGFyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLG9FQUFvRSxHQUNwRSxzREFBc0Q7QUFDaUY7QUFDdkksa0JBQWtCO0FBQ2xCLE1BQU1PLE1BQU1DLE9BQU8sSUFBSUMsTUFBTUQsT0FBTyxJQUFJRSxNQUFNRixPQUFPLElBQUlHLE1BQU1ILE9BQU87QUFDdEUsa0JBQWtCO0FBQ2xCLE1BQU1JLE1BQU1KLE9BQU8sSUFBSUssTUFBTUwsT0FBTyxJQUFJTSxNQUFNTixPQUFPO0FBQ3JELGtCQUFrQjtBQUNsQixNQUFNTyxNQUFNUCxPQUFPLElBQUlRLE9BQU9SLE9BQU87QUFDckMsd0JBQXdCO0FBQ2pCLFNBQVNTLElBQUlDLENBQUMsRUFBRUMsQ0FBQztJQUNwQixNQUFNQyxTQUFTRixJQUFJQztJQUNuQixPQUFPQyxVQUFVYixNQUFNYSxTQUFTRCxJQUFJQztBQUN4QztBQUNBOzs7OztDQUtDLEdBQ0Qsb0NBQW9DO0FBQzdCLFNBQVNDLElBQUlDLEdBQUcsRUFBRUMsS0FBSyxFQUFFQyxNQUFNO0lBQ2xDLElBQUlBLFVBQVVqQixPQUFPZ0IsUUFBUWhCLEtBQ3pCLE1BQU0sSUFBSWtCLE1BQU07SUFDcEIsSUFBSUQsV0FBV2YsS0FDWCxPQUFPRjtJQUNYLElBQUltQixNQUFNakI7SUFDVixNQUFPYyxRQUFRaEIsSUFBSztRQUNoQixJQUFJZ0IsUUFBUWQsS0FDUmlCLE1BQU0sTUFBT0osTUFBT0U7UUFDeEJGLE1BQU0sTUFBT0EsTUFBT0U7UUFDcEJELFVBQVVkO0lBQ2Q7SUFDQSxPQUFPaUI7QUFDWDtBQUNBLDBEQUEwRDtBQUNuRCxTQUFTQyxLQUFLQyxDQUFDLEVBQUVMLEtBQUssRUFBRUMsTUFBTTtJQUNqQyxJQUFJRSxNQUFNRTtJQUNWLE1BQU9MLFVBQVVoQixJQUFLO1FBQ2xCbUIsT0FBT0E7UUFD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O0lBQzNELE9BQU94SCxJQUFJSyxLQUFLb0gsYUFBYWpJLE9BQU9BO0FBQ3hDO0FBQ0E7Ozs7O0NBS0MsR0FDTSxTQUFTb0ksb0JBQW9CQyxVQUFVO0lBQzFDLElBQUksT0FBT0EsZUFBZSxVQUN0QixNQUFNLElBQUlySCxNQUFNO0lBQ3BCLE1BQU1zSCxZQUFZRCxXQUFXckMsUUFBUSxDQUFDLEdBQUdoQixNQUFNO0lBQy9DLE9BQU9rQixLQUFLQyxJQUFJLENBQUNtQyxZQUFZO0FBQ2pDO0FBQ0E7Ozs7OztDQU1DLEdBQ00sU0FBU0MsaUJBQWlCRixVQUFVO0lBQ3ZDLE1BQU1yRCxTQUFTb0Qsb0JBQW9CQztJQUNuQyxPQUFPckQsU0FBU2tCLEtBQUtDLElBQUksQ0FBQ25CLFNBQVM7QUFDdkM7QUFDQTs7Ozs7Ozs7Ozs7O0NBWUMsR0FDTSxTQUFTd0QsZUFBZUMsR0FBRyxFQUFFSixVQUFVO1FBQUUvQixPQUFBQSxpRUFBTztJQUNuRCxNQUFNb0MsTUFBTUQsSUFBSXpELE1BQU07SUFDdEIsTUFBTTJELFdBQVdQLG9CQUFvQkM7SUFDckMsTUFBTUYsU0FBU0ksaUJBQWlCRjtJQUNoQyxpR0FBaUc7SUFDakcsSUFBSUssTUFBTSxNQUFNQSxNQUFNUCxVQUFVTyxNQUFNLE1BQ2xDLE1BQU0sSUFBSTFILE1BQU0sWUFBK0MwSCxPQUFuQ1AsUUFBTyw4QkFBZ0MsT0FBSk87SUFDbkUsTUFBTTdILE1BQU15RixPQUFPNUcsMERBQWVBLENBQUMrSSxPQUFPOUksMERBQWVBLENBQUM4STtJQUMxRCwrRUFBK0U7SUFDL0UsTUFBTUcsVUFBVXBJLElBQUlLLEtBQUt3SCxhQUFhckksT0FBT0E7SUFDN0MsT0FBT3NHLE9BQU83RywwREFBZUEsQ0FBQ21KLFNBQVNELFlBQVluSiwwREFBZUEsQ0FBQ29KLFNBQVNEO0FBQ2hGLEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9tb2R1bGFyLmpzPzBjYTgiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gVXRpbGl0aWVzIGZvciBtb2R1bGFyIGFyaXRobWV0aWNzIGFuZCBmaW5pdGUgZmllbGRzXG5pbXBvcnQgeyBiaXRNYXNrLCBudW1iZXJUb0J5dGVzQkUsIG51bWJlclRvQnl0ZXNMRSwgYnl0ZXNUb051bWJlckJFLCBieXRlc1RvTnVtYmVyTEUsIGVuc3VyZUJ5dGVzLCB2YWxpZGF0ZU9iamVjdCwgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzNuID0gQmlnSW50KDMpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfNG4gPSBCaWdJbnQoNCksIF81biA9IEJpZ0ludCg1KSwgXzhuID0gQmlnSW50KDgpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfOW4gPSBCaWdJbnQoOSksIF8xNm4gPSBCaWdJbnQoMTYpO1xuLy8gQ2FsY3VsYXRlcyBhIG1vZHVsbyBiXG5leHBvcnQgZnVuY3Rpb24gbW9kKGEsIGIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhICUgYjtcbiAgICByZXR1cm4gcmVzdWx0ID49IF8wbiA/IHJlc3VsdCA6IGIgKyByZXN1bHQ7XG59XG4vKipcbiAqIEVmZmljaWVudGx5IHJhaXNlIG51bSB0byBwb3dlciBhbmQgZG8gbW9kdWxhciBkaXZpc2lvbi5cbiAqIFVuc2FmZSBpbiBzb21lIGNvbnRleHRzOiB1c2VzIGxhZGRlciwgc28gY2FuIGV4cG9zZSBiaWdpbnQgYml0cy5cbiAqIEBleGFtcGxlXG4gKiBwb3coMm4sIDZuLCAxMW4pIC8vIDY0biAlIDExbiA9PSA5blxuICovXG4vLyBUT0RPOiB1c2UgZmllbGQgdmVyc2lvbiAmJiByZW1vdmVcbmV4cG9ydCBmdW5jdGlvbiBwb3cobnVtLCBwb3dlciwgbW9kdWxvKSB7XG4gICAgaWYgKG1vZHVsbyA8PSBfMG4gfHwgcG93ZXIgPCBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcG93ZXIvbW9kdWxvID4gMCcpO1xuICAgIGlmIChtb2R1bG8gPT09IF8xbilcbiAgICAgICAgcmV0dXJuIF8wbjtcbiAgICBsZXQgcmVzID0gXzFuO1xuICAgIHdoaWxlIChwb3dlciA+IF8wbikge1xuICAgICAgICBpZiAocG93ZXIgJiBfMW4pXG4gICAgICAgICAgICByZXMgPSAocmVzICogbnVtKSAlIG1vZHVsbztcbiAgICAgICAgbnVtID0gKG51bSAqIG51bSkgJSBtb2R1bG87XG4gICAgICAgIHBvd2VyID4+PSBfMW47XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBEb2VzIHggXiAoMiBeIHBvd2VyKSBtb2QgcC4gcG93MigzMCwgNCkgPT0gMzAgXiAoMiBeIDQpXG5leHBvcnQgZnVuY3Rpb24gcG93Mih4LCBwb3dlciwgbW9kdWxvKSB7XG4gICAgbGV0IHJlcyA9IHg7XG4gICAgd2hpbGUgKHBvd2VyLS0gPiBfMG4pIHtcbiAgICAgICAgcmVzICo9IHJlcztcbiAgICAgICAgcmVzICU9IG1vZHVsbztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIEludmVyc2VzIG51bWJlciBvdmVyIG1vZHVsb1xuZXhwb3J0IGZ1bmN0aW9uIGludmVydChudW1iZXIsIG1vZHVsbykge1xuICAgIGlmIChudW1iZXIgPT09IF8wbiB8fCBtb2R1bG8gPD0gXzBuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52ZXJ0OiBleHBlY3RlZCBwb3NpdGl2ZSBpbnRlZ2VycywgZ290IG49JHtudW1iZXJ9IG1vZD0ke21vZHVsb31gKTtcbiAgICB9XG4gICAgLy8gRXVjbGlkZWFuIEdDRCBodHRwczovL2JyaWxsaWFudC5vcmcvd2lraS9leHRlbmRlZC1ldWNsaWRlYW4tYWxnb3JpdGhtL1xuICAgIC8vIEZlcm1hdCdzIGxpdHRsZSB0aGVvcmVtIFwiQ1QtbGlrZVwiIHZlcnNpb24gaW52KG4pID0gbl4obS0yKSBtb2QgbSBpcyAzMHggc2xvd2VyLlxuICAgIGxldCBhID0gbW9kKG51bWJlciwgbW9kdWxvKTtcbiAgICBsZXQgYiA9IG1vZHVsbztcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBsZXQgeCA9IF8wbiwgeSA9IF8xbiwgdSA9IF8xbiwgdiA9IF8wbjtcbiAgICB3aGlsZSAoYSAhPT0gXzBuKSB7XG4gICAgICAgIC8vIEpJVCBhcHBsaWVzIG9wdGltaXphdGlvbiBpZiB0aG9zZSB0d28gbGluZXMgZm9sbG93IGVhY2ggb3RoZXJcbiAgICAgICAgY29uc3QgcSA9IGIgLyBhO1xuICAgICAgICBjb25zdCByID0gYiAlIGE7XG4gICAgICAgIGNvbnN0IG0gPSB4IC0gdSAqIHE7XG4gICAgICAgIGNvbnN0IG4gPSB5IC0gdiAqIHE7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBiID0gYSwgYSA9IHIsIHggPSB1LCB5ID0gdiwgdSA9IG0sIHYgPSBuO1xuICAgIH1cbiAgICBjb25zdCBnY2QgPSBiO1xuICAgIGlmIChnY2QgIT09IF8xbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZlcnQ6IGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgcmV0dXJuIG1vZCh4LCBtb2R1bG8pO1xufVxuLyoqXG4gKiBUb25lbGxpLVNoYW5rcyBzcXVhcmUgcm9vdCBzZWFyY2ggYWxnb3JpdGhtLlxuICogMS4gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMi82ODUucGRmIChwYWdlIDEyKVxuICogMi4gU3F1YXJlIFJvb3RzIGZyb20gMTsgMjQsIDUxLCAxMCB0byBEYW4gU2hhbmtzXG4gKiBXaWxsIHN0YXJ0IGFuIGluZmluaXRlIGxvb3AgaWYgZmllbGQgb3JkZXIgUCBpcyBub3QgcHJpbWUuXG4gKiBAcGFyYW0gUCBmaWVsZCBvcmRlclxuICogQHJldHVybnMgZnVuY3Rpb24gdGhhdCB0YWtlcyBmaWVsZCBGcCAoY3JlYXRlZCBmcm9tIFApIGFuZCBudW1iZXIgblxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9uZWxsaVNoYW5rcyhQKSB7XG4gICAgLy8gTGVnZW5kcmUgY29uc3RhbnQ6IHVzZWQgdG8gY2FsY3VsYXRlIExlZ2VuZHJlIHN5bWJvbCAoYSB8IHApLFxuICAgIC8vIHdoaWNoIGRlbm90ZXMgdGhlIHZhbHVlIG9mIGFeKChwLTEpLzIpIChtb2QgcCkuXG4gICAgLy8gKGEgfCBwKSDiiaEgMSAgICBpZiBhIGlzIGEgc3F1YXJlIChtb2QgcClcbiAgICAvLyAoYSB8IHApIOKJoSAtMSAgIGlmIGEgaXMgbm90IGEgc3F1YXJlIChtb2QgcClcbiAgICAvLyAoYSB8IHApIOKJoSAwICAgIGlmIGEg4omhIDAgKG1vZCBwKVxuICAgIGNvbnN0IGxlZ2VuZHJlQyA9IChQIC0gXzFuKSAvIF8ybjtcbiAgICBsZXQgUSwgUywgWjtcbiAgICAvLyBTdGVwIDE6IEJ5IGZhY3RvcmluZyBvdXQgcG93ZXJzIG9mIDIgZnJvbSBwIC0gMSxcbiAgICAvLyBmaW5kIHEgYW5kIHMgc3VjaCB0aGF0IHAgLSAxID0gcSooMl5zKSB3aXRoIHEgb2RkXG4gICAgZm9yIChRID0gUCAtIF8xbiwgUyA9IDA7IFEgJSBfMm4gPT09IF8wbjsgUSAvPSBfMm4sIFMrKylcbiAgICAgICAgO1xuICAgIC8vIFN0ZXAgMjogU2VsZWN0IGEgbm9uLXNxdWFyZSB6IHN1Y2ggdGhhdCAoeiB8IHApIOKJoSAtMSBhbmQgc2V0IGMg4omhIHpxXG4gICAgZm9yIChaID0gXzJuOyBaIDwgUCAmJiBwb3coWiwgbGVnZW5kcmVDLCBQKSAhPT0gUCAtIF8xbjsgWisrKVxuICAgICAgICA7XG4gICAgLy8gRmFzdC1wYXRoXG4gICAgaWYgKFMgPT09IDEpIHtcbiAgICAgICAgY29uc3QgcDFkaXY0ID0gKFAgKyBfMW4pIC8gXzRuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gdG9uZWxsaUZhc3QoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5wb3cobiwgcDFkaXY0KTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFNsb3ctcGF0aFxuICAgIGNvbnN0IFExZGl2MiA9IChRICsgXzFuKSAvIF8ybjtcbiAgICByZXR1cm4gZnVuY3Rpb24gdG9uZWxsaVNsb3coRnAsIG4pIHtcbiAgICAgICAgLy8gU3RlcCAwOiBDaGVjayB0aGF0IG4gaXMgaW5kZWVkIGEgc3F1YXJlOiAobiB8IHApIHNob3VsZCBub3QgYmUg4omhIC0xXG4gICAgICAgIGlmIChGcC5wb3cobiwgbGVnZW5kcmVDKSA9PT0gRnAubmVnKEZwLk9ORSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgIGxldCByID0gUztcbiAgICAgICAgLy8gVE9ETzogd2lsbCBmYWlsIGF0IEZwMi9ldGNcbiAgICAgICAgbGV0IGcgPSBGcC5wb3coRnAubXVsKEZwLk9ORSwgWiksIFEpOyAvLyB3aWxsIHVwZGF0ZSBib3RoIHggYW5kIGJcbiAgICAgICAgbGV0IHggPSBGcC5wb3cobiwgUTFkaXYyKTsgLy8gZmlyc3QgZ3Vlc3MgYXQgdGhlIHNxdWFyZSByb290XG4gICAgICAgIGxldCBiID0gRnAucG93KG4sIFEpOyAvLyBmaXJzdCBndWVzcyBhdCB0aGUgZnVkZ2UgZmFjdG9yXG4gICAgICAgIHdoaWxlICghRnAuZXFsKGIsIEZwLk9ORSkpIHtcbiAgICAgICAgICAgIGlmIChGcC5lcWwoYiwgRnAuWkVSTykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZwLlpFUk87IC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RvbmVsbGklRTIlODAlOTNTaGFua3NfYWxnb3JpdGhtICg0LiBJZiB0ID0gMCwgcmV0dXJuIHIgPSAwKVxuICAgICAgICAgICAgLy8gRmluZCBtIHN1Y2ggYl4oMl5tKT09MVxuICAgICAgICAgICAgbGV0IG0gPSAxO1xuICAgICAgICAgICAgZm9yIChsZXQgdDIgPSBGcC5zcXIoYik7IG0gPCByOyBtKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoRnAuZXFsKHQyLCBGcC5PTkUpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB0MiA9IEZwLnNxcih0Mik7IC8vIHQyICo9IHQyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOT1RFOiByLW0tMSBjYW4gYmUgYmlnZ2VyIHRoYW4gMzIsIG5lZWQgdG8gY29udmVydCB0byBiaWdpbnQgYmVmb3JlIHNoaWZ0LCBvdGhlcndpc2UgdGhlcmUgd2lsbCBiZSBvdmVyZmxvd1xuICAgICAgICAgICAgY29uc3QgZ2UgPSBGcC5wb3coZywgXzFuIDw8IEJpZ0ludChyIC0gbSAtIDEpKTsgLy8gZ2UgPSAyXihyLW0tMSlcbiAgICAgICAgICAgIGcgPSBGcC5zcXIoZ2UpOyAvLyBnID0gZ2UgKiBnZVxuICAgICAgICAgICAgeCA9IEZwLm11bCh4LCBnZSk7IC8vIHggKj0gZ2VcbiAgICAgICAgICAgIGIgPSBGcC5tdWwoYiwgZyk7IC8vIGIgKj0gZ1xuICAgICAgICAgICAgciA9IG07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnQoUCkge1xuICAgIC8vIE5PVEU6IGRpZmZlcmVudCBhbGdvcml0aG1zIGNhbiBnaXZlIGRpZmZlcmVudCByb290cywgaXQgaXMgdXAgdG8gdXNlciB0byBkZWNpZGUgd2hpY2ggb25lIHRoZXkgd2FudC5cbiAgICAvLyBGb3IgZXhhbXBsZSB0aGVyZSBpcyBGcFNxcnRPZGQvRnBTcXJ0RXZlbiB0byBjaG9pY2Ugcm9vdCBiYXNlZCBvbiBvZGRuZXNzICh1c2VkIGZvciBoYXNoLXRvLWN1cnZlKS5cbiAgICAvLyBQIOKJoSAzIChtb2QgNClcbiAgICAvLyDiiJpuID0gbl4oKFArMSkvNClcbiAgICBpZiAoUCAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIE5vdCBhbGwgcm9vdHMgcG9zc2libGUhXG4gICAgICAgIC8vIGNvbnN0IE9SREVSID1cbiAgICAgICAgLy8gICAweDFhMDExMWVhMzk3ZmU2OWE0YjFiYTdiNjQzNGJhY2Q3NjQ3NzRiODRmMzg1MTJiZjY3MzBkMmEwZjZiMGY2MjQxZWFiZmZmZWIxNTNmZmZmYjlmZWZmZmZmZmZmYWFhYm47XG4gICAgICAgIC8vIGNvbnN0IE5VTSA9IDcyMDU3NTk0MDM3OTI3ODE2bjtcbiAgICAgICAgY29uc3QgcDFkaXY0ID0gKFAgKyBfMW4pIC8gXzRuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3FydDNtb2Q0KEZwLCBuKSB7XG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAucG93KG4sIHAxZGl2NCk7XG4gICAgICAgICAgICAvLyBUaHJvdyBpZiByb290KioyICE9IG5cbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEF0a2luIGFsZ29yaXRobSBmb3IgcSDiiaEgNSAobW9kIDgpLCBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGYgKHBhZ2UgMTApXG4gICAgaWYgKFAgJSBfOG4gPT09IF81bikge1xuICAgICAgICBjb25zdCBjMSA9IChQIC0gXzVuKSAvIF84bjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNxcnQ1bW9kOChGcCwgbikge1xuICAgICAgICAgICAgY29uc3QgbjIgPSBGcC5tdWwobiwgXzJuKTtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBGcC5wb3cobjIsIGMxKTtcbiAgICAgICAgICAgIGNvbnN0IG52ID0gRnAubXVsKG4sIHYpO1xuICAgICAgICAgICAgY29uc3QgaSA9IEZwLm11bChGcC5tdWwobnYsIF8ybiksIHYpO1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLm11bChudiwgRnAuc3ViKGksIEZwLk9ORSkpO1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gUCDiiaEgOSAobW9kIDE2KVxuICAgIGlmIChQICUgXzE2biA9PT0gXzluKSB7XG4gICAgICAgIC8vIE5PVEU6IHRvbmVsbGkgaXMgdG9vIHNsb3cgZm9yIGJscy1GcDIgY2FsY3VsYXRpb25zIGV2ZW4gb24gc3RhcnRcbiAgICAgICAgLy8gTWVhbnMgd2UgY2Fubm90IHVzZSBzcXJ0IGZvciBjb25zdGFudHMgYXQgYWxsIVxuICAgICAgICAvL1xuICAgICAgICAvLyBjb25zdCBjMSA9IEZwLnNxcnQoRnAubmVnYXRlKEZwLk9ORSkpOyAvLyAgMS4gYzEgPSBzcXJ0KC0xKSBpbiBGLCBpLmUuLCAoYzFeMikgPT0gLTEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjMiA9IEZwLnNxcnQoYzEpOyAgICAgICAgICAgICAgICAvLyAgMi4gYzIgPSBzcXJ0KGMxKSBpbiBGLCBpLmUuLCAoYzJeMikgPT0gYzEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjMyA9IEZwLnNxcnQoRnAubmVnYXRlKGMxKSk7ICAgICAvLyAgMy4gYzMgPSBzcXJ0KC1jMSkgaW4gRiwgaS5lLiwgKGMzXjIpID09IC1jMSBpbiBGXG4gICAgICAgIC8vIGNvbnN0IGM0ID0gKFAgKyBfN24pIC8gXzE2bjsgICAgICAgICAgIC8vICA0LiBjNCA9IChxICsgNykgLyAxNiAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICAgICAgLy8gc3FydCA9ICh4KSA9PiB7XG4gICAgICAgIC8vICAgbGV0IHR2MSA9IEZwLnBvdyh4LCBjNCk7ICAgICAgICAgICAgIC8vICAxLiB0djEgPSB4XmM0XG4gICAgICAgIC8vICAgbGV0IHR2MiA9IEZwLm11bChjMSwgdHYxKTsgICAgICAgICAgIC8vICAyLiB0djIgPSBjMSAqIHR2MVxuICAgICAgICAvLyAgIGNvbnN0IHR2MyA9IEZwLm11bChjMiwgdHYxKTsgICAgICAgICAvLyAgMy4gdHYzID0gYzIgKiB0djFcbiAgICAgICAgLy8gICBsZXQgdHY0ID0gRnAubXVsKGMzLCB0djEpOyAgICAgICAgICAgLy8gIDQuIHR2NCA9IGMzICogdHYxXG4gICAgICAgIC8vICAgY29uc3QgZTEgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MiksIHgpOyAvLyAgNS4gIGUxID0gKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgY29uc3QgZTIgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MyksIHgpOyAvLyAgNi4gIGUyID0gKHR2M14yKSA9PSB4XG4gICAgICAgIC8vICAgdHYxID0gRnAuY21vdih0djEsIHR2MiwgZTEpOyAvLyAgNy4gdHYxID0gQ01PVih0djEsIHR2MiwgZTEpICAjIFNlbGVjdCB0djIgaWYgKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgdHYyID0gRnAuY21vdih0djQsIHR2MywgZTIpOyAvLyAgOC4gdHYyID0gQ01PVih0djQsIHR2MywgZTIpICAjIFNlbGVjdCB0djMgaWYgKHR2M14yKSA9PSB4XG4gICAgICAgIC8vICAgY29uc3QgZTMgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MiksIHgpOyAvLyAgOS4gIGUzID0gKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgcmV0dXJuIEZwLmNtb3YodHYxLCB0djIsIGUzKTsgLy8gIDEwLiAgeiA9IENNT1YodHYxLCB0djIsIGUzKSAgIyBTZWxlY3QgdGhlIHNxcnQgZnJvbSB0djEgYW5kIHR2MlxuICAgICAgICAvLyB9XG4gICAgfVxuICAgIC8vIE90aGVyIGNhc2VzOiBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG1cbiAgICByZXR1cm4gdG9uZWxsaVNoYW5rcyhQKTtcbn1cbi8vIExpdHRsZS1lbmRpYW4gY2hlY2sgZm9yIGZpcnN0IExFIGJpdCAobGFzdCBCRSBiaXQpO1xuZXhwb3J0IGNvbnN0IGlzTmVnYXRpdmVMRSA9IChudW0sIG1vZHVsbykgPT4gKG1vZChudW0sIG1vZHVsbykgJiBfMW4pID09PSBfMW47XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IEZJRUxEX0ZJRUxEUyA9IFtcbiAgICAnY3JlYXRlJywgJ2lzVmFsaWQnLCAnaXMwJywgJ25lZycsICdpbnYnLCAnc3FydCcsICdzcXInLFxuICAgICdlcWwnLCAnYWRkJywgJ3N1YicsICdtdWwnLCAncG93JywgJ2RpdicsXG4gICAgJ2FkZE4nLCAnc3ViTicsICdtdWxOJywgJ3Nxck4nXG5dO1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlRmllbGQoZmllbGQpIHtcbiAgICBjb25zdCBpbml0aWFsID0ge1xuICAgICAgICBPUkRFUjogJ2JpZ2ludCcsXG4gICAgICAgIE1BU0s6ICdiaWdpbnQnLFxuICAgICAgICBCWVRFUzogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBCSVRTOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgfTtcbiAgICBjb25zdCBvcHRzID0gRklFTERfRklFTERTLnJlZHVjZSgobWFwLCB2YWwpID0+IHtcbiAgICAgICAgbWFwW3ZhbF0gPSAnZnVuY3Rpb24nO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH0sIGluaXRpYWwpO1xuICAgIHJldHVybiB2YWxpZGF0ZU9iamVjdChmaWVsZCwgb3B0cyk7XG59XG4vLyBHZW5lcmljIGZpZWxkIGZ1bmN0aW9uc1xuLyoqXG4gKiBTYW1lIGFzIGBwb3dgIGJ1dCBmb3IgRnA6IG5vbi1jb25zdGFudC10aW1lLlxuICogVW5zYWZlIGluIHNvbWUgY29udGV4dHM6IHVzZXMgbGFkZGVyLCBzbyBjYW4gZXhwb3NlIGJpZ2ludCBiaXRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gRnBQb3coZiwgbnVtLCBwb3dlcikge1xuICAgIC8vIFNob3VsZCBoYXZlIHNhbWUgc3BlZWQgYXMgcG93IGZvciBiaWdpbnRzXG4gICAgLy8gVE9ETzogYmVuY2htYXJrIVxuICAgIGlmIChwb3dlciA8IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwb3dlciA+IDAnKTtcbiAgICBpZiAocG93ZXIgPT09IF8wbilcbiAgICAgICAgcmV0dXJuIGYuT05FO1xuICAgIGlmIChwb3dlciA9PT0gXzFuKVxuICAgICAgICByZXR1cm4gbnVtO1xuICAgIGxldCBwID0gZi5PTkU7XG4gICAgbGV0IGQgPSBudW07XG4gICAgd2hpbGUgKHBvd2VyID4gXzBuKSB7XG4gICAgICAgIGlmIChwb3dlciAmIF8xbilcbiAgICAgICAgICAgIHAgPSBmLm11bChwLCBkKTtcbiAgICAgICAgZCA9IGYuc3FyKGQpO1xuICAgICAgICBwb3dlciA+Pj0gXzFuO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbn1cbi8qKlxuICogRWZmaWNpZW50bHkgaW52ZXJ0IGFuIGFycmF5IG9mIEZpZWxkIGVsZW1lbnRzLlxuICogYGludigwKWAgd2lsbCByZXR1cm4gYHVuZGVmaW5lZGAgaGVyZTogbWFrZSBzdXJlIHRvIHRocm93IGFuIGVycm9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gRnBJbnZlcnRCYXRjaChmLCBudW1zKSB7XG4gICAgY29uc3QgdG1wID0gbmV3IEFycmF5KG51bXMubGVuZ3RoKTtcbiAgICAvLyBXYWxrIGZyb20gZmlyc3QgdG8gbGFzdCwgbXVsdGlwbHkgdGhlbSBieSBlYWNoIG90aGVyIE1PRCBwXG4gICAgY29uc3QgbGFzdE11bHRpcGxpZWQgPSBudW1zLnJlZHVjZSgoYWNjLCBudW0sIGkpID0+IHtcbiAgICAgICAgaWYgKGYuaXMwKG51bSkpXG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB0bXBbaV0gPSBhY2M7XG4gICAgICAgIHJldHVybiBmLm11bChhY2MsIG51bSk7XG4gICAgfSwgZi5PTkUpO1xuICAgIC8vIEludmVydCBsYXN0IGVsZW1lbnRcbiAgICBjb25zdCBpbnZlcnRlZCA9IGYuaW52KGxhc3RNdWx0aXBsaWVkKTtcbiAgICAvLyBXYWxrIGZyb20gbGFzdCB0byBmaXJzdCwgbXVsdGlwbHkgdGhlbSBieSBpbnZlcnRlZCBlYWNoIG90aGVyIE1PRCBwXG4gICAgbnVtcy5yZWR1Y2VSaWdodCgoYWNjLCBudW0sIGkpID0+IHtcbiAgICAgICAgaWYgKGYuaXMwKG51bSkpXG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB0bXBbaV0gPSBmLm11bChhY2MsIHRtcFtpXSk7XG4gICAgICAgIHJldHVybiBmLm11bChhY2MsIG51bSk7XG4gICAgfSwgaW52ZXJ0ZWQpO1xuICAgIHJldHVybiB0bXA7XG59XG5leHBvcnQgZnVuY3Rpb24gRnBEaXYoZiwgbGhzLCByaHMpIHtcbiAgICByZXR1cm4gZi5tdWwobGhzLCB0eXBlb2YgcmhzID09PSAnYmlnaW50JyA/IGludmVydChyaHMsIGYuT1JERVIpIDogZi5pbnYocmhzKSk7XG59XG4vLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgVHJ1ZSB3aGVuZXZlciB0aGUgdmFsdWUgeCBpcyBhIHNxdWFyZSBpbiB0aGUgZmllbGQgRi5cbmV4cG9ydCBmdW5jdGlvbiBGcElzU3F1YXJlKGYpIHtcbiAgICBjb25zdCBsZWdlbmRyZUNvbnN0ID0gKGYuT1JERVIgLSBfMW4pIC8gXzJuOyAvLyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICByZXR1cm4gKHgpID0+IHtcbiAgICAgICAgY29uc3QgcCA9IGYucG93KHgsIGxlZ2VuZHJlQ29uc3QpO1xuICAgICAgICByZXR1cm4gZi5lcWwocCwgZi5aRVJPKSB8fCBmLmVxbChwLCBmLk9ORSk7XG4gICAgfTtcbn1cbi8vIENVUlZFLm4gbGVuZ3Roc1xuZXhwb3J0IGZ1bmN0aW9uIG5MZW5ndGgobiwgbkJpdExlbmd0aCkge1xuICAgIC8vIEJpdCBzaXplLCBieXRlIHNpemUgb2YgQ1VSVkUublxuICAgIGNvbnN0IF9uQml0TGVuZ3RoID0gbkJpdExlbmd0aCAhPT0gdW5kZWZpbmVkID8gbkJpdExlbmd0aCA6IG4udG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIGNvbnN0IG5CeXRlTGVuZ3RoID0gTWF0aC5jZWlsKF9uQml0TGVuZ3RoIC8gOCk7XG4gICAgcmV0dXJuIHsgbkJpdExlbmd0aDogX25CaXRMZW5ndGgsIG5CeXRlTGVuZ3RoIH07XG59XG4vKipcbiAqIEluaXRpYWxpemVzIGEgZmluaXRlIGZpZWxkIG92ZXIgcHJpbWUuICoqTm9uLXByaW1lcyBhcmUgbm90IHN1cHBvcnRlZC4qKlxuICogRG8gbm90IGluaXQgaW4gbG9vcDogc2xvdy4gVmVyeSBmcmFnaWxlOiBhbHdheXMgcnVuIGEgYmVuY2htYXJrIG9uIGEgY2hhbmdlLlxuICogTWFqb3IgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uczpcbiAqICogYSkgZGVub3JtYWxpemVkIG9wZXJhdGlvbnMgbGlrZSBtdWxOIGluc3RlYWQgb2YgbXVsXG4gKiAqIGIpIHNhbWUgb2JqZWN0IHNoYXBlOiBuZXZlciBhZGQgb3IgcmVtb3ZlIGtleXNcbiAqICogYykgT2JqZWN0LmZyZWV6ZVxuICogQHBhcmFtIE9SREVSIHByaW1lIHBvc2l0aXZlIGJpZ2ludFxuICogQHBhcmFtIGJpdExlbiBob3cgbWFueSBiaXRzIHRoZSBmaWVsZCBjb25zdW1lc1xuICogQHBhcmFtIGlzTEUgKGRlZjogZmFsc2UpIGlmIGVuY29kaW5nIC8gZGVjb2Rpbmcgc2hvdWxkIGJlIGluIGxpdHRsZS1lbmRpYW5cbiAqIEBwYXJhbSByZWRlZiBvcHRpb25hbCBmYXN0ZXIgcmVkZWZpbml0aW9ucyBvZiBzcXJ0IGFuZCBvdGhlciBtZXRob2RzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGaWVsZChPUkRFUiwgYml0TGVuLCBpc0xFID0gZmFsc2UsIHJlZGVmID0ge30pIHtcbiAgICBpZiAoT1JERVIgPD0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIEZpZWxkIE9SREVSID4gMCwgZ290ICR7T1JERVJ9YCk7XG4gICAgY29uc3QgeyBuQml0TGVuZ3RoOiBCSVRTLCBuQnl0ZUxlbmd0aDogQllURVMgfSA9IG5MZW5ndGgoT1JERVIsIGJpdExlbik7XG4gICAgaWYgKEJZVEVTID4gMjA0OClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaWVsZCBsZW5ndGhzIG92ZXIgMjA0OCBieXRlcyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgIGNvbnN0IHNxcnRQID0gRnBTcXJ0KE9SREVSKTtcbiAgICBjb25zdCBmID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIE9SREVSLFxuICAgICAgICBCSVRTLFxuICAgICAgICBCWVRFUyxcbiAgICAgICAgTUFTSzogYml0TWFzayhCSVRTKSxcbiAgICAgICAgWkVSTzogXzBuLFxuICAgICAgICBPTkU6IF8xbixcbiAgICAgICAgY3JlYXRlOiAobnVtKSA9PiBtb2QobnVtLCBPUkRFUiksXG4gICAgICAgIGlzVmFsaWQ6IChudW0pID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbnVtICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZmllbGQgZWxlbWVudDogZXhwZWN0ZWQgYmlnaW50LCBnb3QgJHt0eXBlb2YgbnVtfWApO1xuICAgICAgICAgICAgcmV0dXJuIF8wbiA8PSBudW0gJiYgbnVtIDwgT1JERVI7IC8vIDAgaXMgdmFsaWQgZWxlbWVudCwgYnV0IGl0J3Mgbm90IGludmVydGlibGVcbiAgICAgICAgfSxcbiAgICAgICAgaXMwOiAobnVtKSA9PiBudW0gPT09IF8wbixcbiAgICAgICAgaXNPZGQ6IChudW0pID0+IChudW0gJiBfMW4pID09PSBfMW4sXG4gICAgICAgIG5lZzogKG51bSkgPT4gbW9kKC1udW0sIE9SREVSKSxcbiAgICAgICAgZXFsOiAobGhzLCByaHMpID0+IGxocyA9PT0gcmhzLFxuICAgICAgICBzcXI6IChudW0pID0+IG1vZChudW0gKiBudW0sIE9SREVSKSxcbiAgICAgICAgYWRkOiAobGhzLCByaHMpID0+IG1vZChsaHMgKyByaHMsIE9SREVSKSxcbiAgICAgICAgc3ViOiAobGhzLCByaHMpID0+IG1vZChsaHMgLSByaHMsIE9SREVSKSxcbiAgICAgICAgbXVsOiAobGhzLCByaHMpID0+IG1vZChsaHMgKiByaHMsIE9SREVSKSxcbiAgICAgICAgcG93OiAobnVtLCBwb3dlcikgPT4gRnBQb3coZiwgbnVtLCBwb3dlciksXG4gICAgICAgIGRpdjogKGxocywgcmhzKSA9PiBtb2QobGhzICogaW52ZXJ0KHJocywgT1JERVIpLCBPUkRFUiksXG4gICAgICAgIC8vIFNhbWUgYXMgYWJvdmUsIGJ1dCBkb2Vzbid0IG5vcm1hbGl6ZVxuICAgICAgICBzcXJOOiAobnVtKSA9PiBudW0gKiBudW0sXG4gICAgICAgIGFkZE46IChsaHMsIHJocykgPT4gbGhzICsgcmhzLFxuICAgICAgICBzdWJOOiAobGhzLCByaHMpID0+IGxocyAtIHJocyxcbiAgICAgICAgbXVsTjogKGxocywgcmhzKSA9PiBsaHMgKiByaHMsXG4gICAgICAgIGludjogKG51bSkgPT4gaW52ZXJ0KG51bSwgT1JERVIpLFxuICAgICAgICBzcXJ0OiByZWRlZi5zcXJ0IHx8ICgobikgPT4gc3FydFAoZiwgbikpLFxuICAgICAgICBpbnZlcnRCYXRjaDogKGxzdCkgPT4gRnBJbnZlcnRCYXRjaChmLCBsc3QpLFxuICAgICAgICAvLyBUT0RPOiBkbyB3ZSByZWFsbHkgbmVlZCBjb25zdGFudCBjbW92P1xuICAgICAgICAvLyBXZSBkb24ndCBoYXZlIGNvbnN0LXRpbWUgYmlnaW50cyBhbnl3YXksIHNvIHByb2JhYmx5IHdpbGwgYmUgbm90IHZlcnkgdXNlZnVsXG4gICAgICAgIGNtb3Y6IChhLCBiLCBjKSA9PiAoYyA/IGIgOiBhKSxcbiAgICAgICAgdG9CeXRlczogKG51bSkgPT4gKGlzTEUgPyBudW1iZXJUb0J5dGVzTEUobnVtLCBCWVRFUykgOiBudW1iZXJUb0J5dGVzQkUobnVtLCBCWVRFUykpLFxuICAgICAgICBmcm9tQnl0ZXM6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gQllURVMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGcC5mcm9tQnl0ZXM6IGV4cGVjdGVkICR7QllURVN9LCBnb3QgJHtieXRlcy5sZW5ndGh9YCk7XG4gICAgICAgICAgICByZXR1cm4gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShieXRlcykgOiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKGYpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydE9kZChGcCwgZWxtKSB7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGaWVsZCBkb2Vzbid0IGhhdmUgaXNPZGRgKTtcbiAgICBjb25zdCByb290ID0gRnAuc3FydChlbG0pO1xuICAgIHJldHVybiBGcC5pc09kZChyb290KSA/IHJvb3QgOiBGcC5uZWcocm9vdCk7XG59XG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0RXZlbihGcCwgZWxtKSB7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGaWVsZCBkb2Vzbid0IGhhdmUgaXNPZGRgKTtcbiAgICBjb25zdCByb290ID0gRnAuc3FydChlbG0pO1xuICAgIHJldHVybiBGcC5pc09kZChyb290KSA/IEZwLm5lZyhyb290KSA6IHJvb3Q7XG59XG4vKipcbiAqIFwiQ29uc3RhbnQtdGltZVwiIHByaXZhdGUga2V5IGdlbmVyYXRpb24gdXRpbGl0eS5cbiAqIFNhbWUgYXMgbWFwS2V5VG9GaWVsZCwgYnV0IGFjY2VwdHMgbGVzcyBieXRlcyAoNDAgaW5zdGVhZCBvZiA0OCBmb3IgMzItYnl0ZSBmaWVsZCkuXG4gKiBXaGljaCBtYWtlcyBpdCBzbGlnaHRseSBtb3JlIGJpYXNlZCwgbGVzcyBzZWN1cmUuXG4gKiBAZGVwcmVjYXRlZCB1c2UgbWFwS2V5VG9GaWVsZCBpbnN0ZWFkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoVG9Qcml2YXRlU2NhbGFyKGhhc2gsIGdyb3VwT3JkZXIsIGlzTEUgPSBmYWxzZSkge1xuICAgIGhhc2ggPSBlbnN1cmVCeXRlcygncHJpdmF0ZUhhc2gnLCBoYXNoKTtcbiAgICBjb25zdCBoYXNoTGVuID0gaGFzaC5sZW5ndGg7XG4gICAgY29uc3QgbWluTGVuID0gbkxlbmd0aChncm91cE9yZGVyKS5uQnl0ZUxlbmd0aCArIDg7XG4gICAgaWYgKG1pbkxlbiA8IDI0IHx8IGhhc2hMZW4gPCBtaW5MZW4gfHwgaGFzaExlbiA+IDEwMjQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaGFzaFRvUHJpdmF0ZVNjYWxhcjogZXhwZWN0ZWQgJHttaW5MZW59LTEwMjQgYnl0ZXMgb2YgaW5wdXQsIGdvdCAke2hhc2hMZW59YCk7XG4gICAgY29uc3QgbnVtID0gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShoYXNoKSA6IGJ5dGVzVG9OdW1iZXJCRShoYXNoKTtcbiAgICByZXR1cm4gbW9kKG51bSwgZ3JvdXBPcmRlciAtIF8xbikgKyBfMW47XG59XG4vKipcbiAqIFJldHVybnMgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIGNvbnN1bWVkIGJ5IHRoZSBmaWVsZCBlbGVtZW50LlxuICogRm9yIGV4YW1wbGUsIDMyIGJ5dGVzIGZvciB1c3VhbCAyNTYtYml0IHdlaWVyc3RyYXNzIGN1cnZlLlxuICogQHBhcmFtIGZpZWxkT3JkZXIgbnVtYmVyIG9mIGZpZWxkIGVsZW1lbnRzLCB1c3VhbGx5IENVUlZFLm5cbiAqIEByZXR1cm5zIGJ5dGUgbGVuZ3RoIG9mIGZpZWxkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpIHtcbiAgICBpZiAodHlwZW9mIGZpZWxkT3JkZXIgIT09ICdiaWdpbnQnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpZWxkIG9yZGVyIG11c3QgYmUgYmlnaW50Jyk7XG4gICAgY29uc3QgYml0TGVuZ3RoID0gZmllbGRPcmRlci50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgcmV0dXJuIE1hdGguY2VpbChiaXRMZW5ndGggLyA4KTtcbn1cbi8qKlxuICogUmV0dXJucyBtaW5pbWFsIGFtb3VudCBvZiBieXRlcyB0aGF0IGNhbiBiZSBzYWZlbHkgcmVkdWNlZFxuICogYnkgZmllbGQgb3JkZXIuXG4gKiBTaG91bGQgYmUgMl4tMTI4IGZvciAxMjgtYml0IGN1cnZlIHN1Y2ggYXMgUDI1Ni5cbiAqIEBwYXJhbSBmaWVsZE9yZGVyIG51bWJlciBvZiBmaWVsZCBlbGVtZW50cywgdXN1YWxseSBDVVJWRS5uXG4gKiBAcmV0dXJucyBieXRlIGxlbmd0aCBvZiB0YXJnZXQgaGFzaFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWluSGFzaExlbmd0aChmaWVsZE9yZGVyKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKTtcbiAgICByZXR1cm4gbGVuZ3RoICsgTWF0aC5jZWlsKGxlbmd0aCAvIDIpO1xufVxuLyoqXG4gKiBcIkNvbnN0YW50LXRpbWVcIiBwcml2YXRlIGtleSBnZW5lcmF0aW9uIHV0aWxpdHkuXG4gKiBDYW4gdGFrZSAobiArIG4vMikgb3IgbW9yZSBieXRlcyBvZiB1bmlmb3JtIGlucHV0IGUuZy4gZnJvbSBDU1BSTkcgb3IgS0RGXG4gKiBhbmQgY29udmVydCB0aGVtIGludG8gcHJpdmF0ZSBzY2FsYXIsIHdpdGggdGhlIG1vZHVsbyBiaWFzIGJlaW5nIG5lZ2xpZ2libGUuXG4gKiBOZWVkcyBhdCBsZWFzdCA0OCBieXRlcyBvZiBpbnB1dCBmb3IgMzItYnl0ZSBwcml2YXRlIGtleS5cbiAqIGh0dHBzOi8vcmVzZWFyY2gua3VkZWxza2lzZWN1cml0eS5jb20vMjAyMC8wNy8yOC90aGUtZGVmaW5pdGl2ZS1ndWlkZS10by1tb2R1bG8tYmlhcy1hbmQtaG93LXRvLWF2b2lkLWl0L1xuICogRklQUyAxODYtNSwgQS4yIGh0dHBzOi8vY3NyYy5uaXN0Lmdvdi9wdWJsaWNhdGlvbnMvZGV0YWlsL2ZpcHMvMTg2LzUvZmluYWxcbiAqIFJGQyA5MzgwLCBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTVcbiAqIEBwYXJhbSBoYXNoIGhhc2ggb3V0cHV0IGZyb20gU0hBMyBvciBhIHNpbWlsYXIgZnVuY3Rpb25cbiAqIEBwYXJhbSBncm91cE9yZGVyIHNpemUgb2Ygc3ViZ3JvdXAgLSAoZS5nLiBzZWNwMjU2azEuQ1VSVkUubilcbiAqIEBwYXJhbSBpc0xFIGludGVycHJldCBoYXNoIGJ5dGVzIGFzIExFIG51bVxuICogQHJldHVybnMgdmFsaWQgcHJpdmF0ZSBzY2FsYXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcEhhc2hUb0ZpZWxkKGtleSwgZmllbGRPcmRlciwgaXNMRSA9IGZhbHNlKSB7XG4gICAgY29uc3QgbGVuID0ga2V5Lmxlbmd0aDtcbiAgICBjb25zdCBmaWVsZExlbiA9IGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgY29uc3QgbWluTGVuID0gZ2V0TWluSGFzaExlbmd0aChmaWVsZE9yZGVyKTtcbiAgICAvLyBObyBzbWFsbCBudW1iZXJzOiBuZWVkIHRvIHVuZGVyc3RhbmQgYmlhcyBzdG9yeS4gTm8gaHVnZSBudW1iZXJzOiBlYXNpZXIgdG8gZGV0ZWN0IEpTIHRpbWluZ3MuXG4gICAgaWYgKGxlbiA8IDE2IHx8IGxlbiA8IG1pbkxlbiB8fCBsZW4gPiAxMDI0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkICR7bWluTGVufS0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJHtsZW59YCk7XG4gICAgY29uc3QgbnVtID0gaXNMRSA/IGJ5dGVzVG9OdW1iZXJCRShrZXkpIDogYnl0ZXNUb051bWJlckxFKGtleSk7XG4gICAgLy8gYG1vZCh4LCAxMSlgIGNhbiBzb21ldGltZXMgcHJvZHVjZSAwLiBgbW9kKHgsIDEwKSArIDFgIGlzIHRoZSBzYW1lLCBidXQgbm8gMFxuICAgIGNvbnN0IHJlZHVjZWQgPSBtb2QobnVtLCBmaWVsZE9yZGVyIC0gXzFuKSArIF8xbjtcbiAgICByZXR1cm4gaXNMRSA/IG51bWJlclRvQnl0ZXNMRShyZWR1Y2VkLCBmaWVsZExlbikgOiBudW1iZXJUb0J5dGVzQkUocmVkdWNlZCwgZmllbGRMZW4pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxhci5qcy5tYXAiXSwibmFtZXMiOlsiYml0TWFzayIsIm51bWJlclRvQnl0ZXNCRSIsIm51bWJlclRvQnl0ZXNMRSIsImJ5dGVzVG9OdW1iZXJCRSIsImJ5dGVzVG9OdW1iZXJMRSIsImVuc3VyZUJ5dGVzIiwidmFsaWRhdGVPYmplY3QiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJfMm4iLCJfM24iLCJfNG4iLCJfNW4iLCJfOG4iLCJfOW4iLCJfMTZuIiwibW9kIiwiYSIsImIiLCJyZXN1bHQiLCJwb3ciLCJudW0iLCJwb3dlciIsIm1vZHVsbyIsIkVycm9yIiwicmVzIiwicG93MiIsIngiLCJpbnZlcnQiLCJudW1iZXIiLCJ5IiwidSIsInYiLCJxIiwiciIsIm0iLCJuIiwiZ2NkIiwidG9uZWxsaVNoYW5rcyIsIlAiLCJsZWdlbmRyZUMiLCJRIiwiUyIsIloiLCJwMWRpdjQiLCJ0b25lbGxpRmFzdCIsIkZwIiwicm9vdCIsImVxbCIsInNxciIsIlExZGl2MiIsInRvbmVsbGlTbG93IiwibmVnIiwiT05FIiwiZyIsIm11bCIsIlpFUk8iLCJ0MiIsImdlIiwiRnBTcXJ0Iiwic3FydDNtb2Q0IiwiYzEiLCJzcXJ0NW1vZDgiLCJuMiIsIm52IiwiaSIsInN1YiIsImlzTmVnYXRpdmVMRSIsIkZJRUxEX0ZJRUxEUyIsInZhbGlkYXRlRmllbGQiLCJmaWVsZCIsImluaXRpYWwiLCJPUkRFUiIsIk1BU0siLCJCWVRFUyIsIkJJVFMiLCJvcHRzIiwicmVkdWNlIiwibWFwIiwidmFsIiwiRnBQb3ciLCJmIiwicCIsImQiLCJGcEludmVydEJhdGNoIiwibnVtcyIsInRtcCIsIkFycmF5IiwibGVuZ3RoIiwibGFzdE11bHRpcGxpZWQiLCJhY2MiLCJpczAiLCJpbnZlcnRlZCIsImludiIsInJlZHVjZVJpZ2h0IiwiRnBEaXYiLCJsaHMiLCJyaHMiLCJGcElzU3F1YXJlIiwibGVnZW5kcmVDb25zdCIsIm5MZW5ndGgiLCJuQml0TGVuZ3RoIiwiX25CaXRMZW5ndGgiLCJ1bmRlZmluZWQiLCJ0b1N0cmluZyIsIm5CeXRlTGVuZ3RoIiwiTWF0aCIsImNlaWwiLCJGaWVsZCIsImJpdExlbiIsImlzTEUiLCJyZWRlZiIsInNxcnRQIiwiT2JqZWN0IiwiZnJlZXplIiwiY3JlYXRlIiwiaXNWYWxpZCIsImlzT2RkIiwiYWRkIiwiZGl2Iiwic3FyTiIsImFkZE4iLCJzdWJOIiwibXVsTiIsInNxcnQiLCJpbnZlcnRCYXRjaCIsImxzdCIsImNtb3YiLCJjIiwidG9CeXRlcyIsImZyb21CeXRlcyIsImJ5dGVzIiwiRnBTcXJ0T2RkIiwiZWxtIiwiRnBTcXJ0RXZlbiIsImhhc2hUb1ByaXZhdGVTY2FsYXIiLCJoYXNoIiwiZ3JvdXBPcmRlciIsImhhc2hMZW4iLCJtaW5MZW4iLCJnZXRGaWVsZEJ5dGVzTGVuZ3RoIiwiZmllbGRPcmRlciIsImJpdExlbmd0aCIsImdldE1pbkhhc2hMZW5ndGgiLCJtYXBIYXNoVG9GaWVsZCIsImtleSIsImxlbiIsImZpZWxkTGVuIiwicmVkdWNlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js":
/*!**********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/utils.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bitGet: function() { return /* binding */ bitGet; },\n/* harmony export */   bitLen: function() { return /* binding */ bitLen; },\n/* harmony export */   bitMask: function() { return /* binding */ bitMask; },\n/* harmony export */   bitSet: function() { return /* binding */ bitSet; },\n/* harmony export */   bytesToHex: function() { return /* binding */ bytesToHex; },\n/* harmony export */   bytesToNumberBE: function() { return /* binding */ bytesToNumberBE; },\n/* harmony export */   bytesToNumberLE: function() { return /* binding */ bytesToNumberLE; },\n/* harmony export */   concatBytes: function() { return /* binding */ concatBytes; },\n/* harmony export */   createHmacDrbg: function() { return /* binding */ createHmacDrbg; },\n/* harmony export */   ensureBytes: function() { return /* binding */ ensureBytes; },\n/* harmony export */   equalBytes: function() { return /* binding */ equalBytes; },\n/* harmony export */   hexToBytes: function() { return /* binding */ hexToBytes; },\n/* harmony export */   hexToNumber: function() { return /* binding */ hexToNumber; },\n/* harmony export */   numberToBytesBE: function() { return /* binding */ numberToBytesBE; },\n/* harmony export */   numberToBytesLE: function() { return /* binding */ numberToBytesLE; },\n/* harmony export */   numberToHexUnpadded: function() { return /* binding */ numberToHexUnpadded; },\n/* harmony export */   numberToVarBytesBE: function() { return /* binding */ numberToVarBytesBE; },\n/* harmony export */   utf8ToBytes: function() { return /* binding */ utf8ToBytes; },\n/* harmony export */   validateObject: function() { return /* binding */ validateObject; }\n/* harmony export */ });\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst u8a = (a)=>a instanceof Uint8Array;\nconst hexes = /* @__PURE__ */ Array.from({\n    length: 256\n}, (_, i)=>i.toString(16).padStart(2, \"0\"));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function bytesToHex(bytes) {\n    if (!u8a(bytes)) throw new Error(\"Uint8Array expected\");\n    // pre-caching improves the speed 6x\n    let hex = \"\";\n    for(let i = 0; i < bytes.length; i++){\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? \"0\".concat(hex) : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    // Big Endian\n    return BigInt(hex === \"\" ? \"0\" : \"0x\".concat(hex));\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function hexToBytes(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    const len = hex.length;\n    if (len % 2) throw new Error(\"padded hex string expected, got unpadded hex of length \" + len);\n    const array = new Uint8Array(len / 2);\n    for(let i = 0; i < array.length; i++){\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0) throw new Error(\"Invalid byte sequence\");\n        array[i] = byte;\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    if (!u8a(bytes)) throw new Error(\"Uint8Array expected\");\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, \"0\"));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */ function ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === \"string\") {\n        try {\n            res = hexToBytes(hex);\n        } catch (e) {\n            throw new Error(\"\".concat(title, ' must be valid hex string, got \"').concat(hex, '\". Cause: ').concat(e));\n        }\n    } else if (u8a(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    } else {\n        throw new Error(\"\".concat(title, \" must be hex string or Uint8Array\"));\n    }\n    const len = res.length;\n    if (typeof expectedLength === \"number\" && len !== expectedLength) throw new Error(\"\".concat(title, \" expected \").concat(expectedLength, \" bytes, got \").concat(len));\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */ function concatBytes() {\n    for(var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++){\n        arrays[_key] = arguments[_key];\n    }\n    const r = new Uint8Array(arrays.reduce((sum, a)=>sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a)=>{\n        if (!u8a(a)) throw new Error(\"Uint8Array expected\");\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\nfunction equalBytes(b1, b2) {\n    // We don't care about timing attacks here\n    if (b1.length !== b2.length) return false;\n    for(let i = 0; i < b1.length; i++)if (b1[i] !== b2[i]) return false;\n    return true;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ function utf8ToBytes(str) {\n    if (typeof str !== \"string\") throw new Error(\"utf8ToBytes expected string, got \".concat(typeof str));\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */ function bitLen(n) {\n    let len;\n    for(len = 0; n > _0n; n >>= _1n, len += 1);\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */ function bitGet(n, pos) {\n    return n >> BigInt(pos) & _1n;\n}\n/**\n * Sets single bit at position.\n */ const bitSet = (n, pos, value)=>{\n    return n | (value ? _1n : _0n) << BigInt(pos);\n};\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */ const bitMask = (n)=>(_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = (data)=>new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr)=>Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */ function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== \"number\" || hashLen < 2) throw new Error(\"hashLen must be a number\");\n    if (typeof qByteLen !== \"number\" || qByteLen < 2) throw new Error(\"qByteLen must be a number\");\n    if (typeof hmacFn !== \"function\") throw new Error(\"hmacFn must be a function\");\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = ()=>{\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = function() {\n        for(var _len = arguments.length, b = new Array(_len), _key = 0; _key < _len; _key++){\n            b[_key] = arguments[_key];\n        }\n        return hmacFn(k, v, ...b);\n    }; // hmac(k)(v, ...values)\n    const reseed = function() {\n        let seed = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : u8n();\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([\n            0x00\n        ]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0) return;\n        k = h(u8fr([\n            0x01\n        ]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = ()=>{\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000) throw new Error(\"drbg: tried 1000 values\");\n        let len = 0;\n        const out = [];\n        while(len < qByteLen){\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred)=>{\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while(!(res = pred(gen())))reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val)=>typeof val === \"bigint\",\n    function: (val)=>typeof val === \"function\",\n    boolean: (val)=>typeof val === \"boolean\",\n    string: (val)=>typeof val === \"string\",\n    stringOrUint8Array: (val)=>typeof val === \"string\" || val instanceof Uint8Array,\n    isSafeInteger: (val)=>Number.isSafeInteger(val),\n    array: (val)=>Array.isArray(val),\n    field: (val, object)=>object.Fp.isValid(val),\n    hash: (val)=>typeof val === \"function\" && Number.isSafeInteger(val.outputLen)\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators) {\n    let optValidators = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    const checkField = (fieldName, type, isOptional)=>{\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== \"function\") throw new Error('Invalid validator \"'.concat(type, '\", expected function'));\n        const val = object[fieldName];\n        if (isOptional && val === undefined) return;\n        if (!checkVal(val, object)) {\n            throw new Error(\"Invalid param \".concat(String(fieldName), \"=\").concat(val, \" (\").concat(typeof val, \"), expected \").concat(type));\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))checkField(fieldName, type, true);\n    return object;\n} // validate type tests\n // const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n // const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n // // Should fail type-check\n // const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n // const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n // const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n // const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsb0VBQW9FLEdBQ3BFLDBFQUEwRTtBQUMxRSw4REFBOEQ7QUFDOUQsK0VBQStFO0FBQy9FLHVDQUF1QztBQUN2QyxNQUFNQSxNQUFNQyxPQUFPO0FBQ25CLE1BQU1DLE1BQU1ELE9BQU87QUFDbkIsTUFBTUUsTUFBTUYsT0FBTztBQUNuQixNQUFNRyxNQUFNLENBQUNDLElBQU1BLGFBQWFDO0FBQ2hDLE1BQU1DLFFBQVEsYUFBYSxHQUFHQyxNQUFNQyxJQUFJLENBQUM7SUFBRUMsUUFBUTtBQUFJLEdBQUcsQ0FBQ0MsR0FBR0MsSUFBTUEsRUFBRUMsUUFBUSxDQUFDLElBQUlDLFFBQVEsQ0FBQyxHQUFHO0FBQy9GOztDQUVDLEdBQ00sU0FBU0MsV0FBV0MsS0FBSztJQUM1QixJQUFJLENBQUNaLElBQUlZLFFBQ0wsTUFBTSxJQUFJQyxNQUFNO0lBQ3BCLG9DQUFvQztJQUNwQyxJQUFJQyxNQUFNO0lBQ1YsSUFBSyxJQUFJTixJQUFJLEdBQUdBLElBQUlJLE1BQU1OLE1BQU0sRUFBRUUsSUFBSztRQUNuQ00sT0FBT1gsS0FBSyxDQUFDUyxLQUFLLENBQUNKLEVBQUUsQ0FBQztJQUMxQjtJQUNBLE9BQU9NO0FBQ1g7QUFDTyxTQUFTQyxvQkFBb0JDLEdBQUc7SUFDbkMsTUFBTUYsTUFBTUUsSUFBSVAsUUFBUSxDQUFDO0lBQ3pCLE9BQU9LLElBQUlSLE1BQU0sR0FBRyxJQUFJLElBQVEsT0FBSlEsT0FBUUE7QUFDeEM7QUFDTyxTQUFTRyxZQUFZSCxHQUFHO0lBQzNCLElBQUksT0FBT0EsUUFBUSxVQUNmLE1BQU0sSUFBSUQsTUFBTSw4QkFBOEIsT0FBT0M7SUFDekQsYUFBYTtJQUNiLE9BQU9qQixPQUFPaUIsUUFBUSxLQUFLLE1BQU0sS0FBUyxPQUFKQTtBQUMxQztB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MkIsT0FBTDJGLE1BQUs7UUFDL0MsTUFBTWxCLE1BQU1RLE1BQU0sQ0FBQ1MsVUFBVTtRQUM3QixJQUFJRSxjQUFjbkIsUUFBUUgsV0FDdEI7UUFDSixJQUFJLENBQUN1QixTQUFTcEIsS0FBS1EsU0FBUztZQUN4QixNQUFNLElBQUlqRixNQUFNLGlCQUFzQ3lFLE9BQXJCcUIsT0FBT0osWUFBVyxLQUFXLE9BQVJqQixLQUFJLE1BQTZCa0IsT0FBekIsT0FBT2xCLEtBQUksZ0JBQW1CLE9BQUxrQjtRQUMzRjtJQUNKO0lBQ0EsS0FBSyxNQUFNLENBQUNELFdBQVdDLEtBQUssSUFBSUksT0FBT0MsT0FBTyxDQUFDVCxZQUMzQ0UsV0FBV0MsV0FBV0MsTUFBTTtJQUNoQyxLQUFLLE1BQU0sQ0FBQ0QsV0FBV0MsS0FBSyxJQUFJSSxPQUFPQyxPQUFPLENBQUNSLGVBQzNDQyxXQUFXQyxXQUFXQyxNQUFNO0lBQ2hDLE9BQU9WO0FBQ1gsRUFDQSxzQkFBc0I7Q0FDdEIsdUVBQXVFO0NBQ3ZFLGdGQUFnRjtDQUNoRiw0QkFBNEI7Q0FDNUIsMkRBQTJEO0NBQzNELHFFQUFxRTtDQUNyRSwrREFBK0Q7Q0FDL0QsNERBQTREO0NBQzVELGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvdXRpbHMuanM/Yjc4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyAxMDAgbGluZXMgb2YgY29kZSBpbiB0aGUgZmlsZSBhcmUgZHVwbGljYXRlZCBmcm9tIG5vYmxlLWhhc2hlcyAodXRpbHMpLlxuLy8gVGhpcyBpcyBPSzogYGFic3RyYWN0YCBkaXJlY3RvcnkgZG9lcyBub3QgdXNlIG5vYmxlLWhhc2hlcy5cbi8vIFVzZXIgbWF5IG9wdC1pbiBpbnRvIHVzaW5nIGRpZmZlcmVudCBoYXNoaW5nIGxpYnJhcnkuIFRoaXMgd2F5LCBub2JsZS1oYXNoZXNcbi8vIHdvbid0IGJlIGluY2x1ZGVkIGludG8gdGhlaXIgYnVuZGxlLlxuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gQmlnSW50KDIpO1xuY29uc3QgdThhID0gKGEpID0+IGEgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuY29uc3QgaGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfLCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGlmICghdThhKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0hleFVucGFkZGVkKG51bSkge1xuICAgIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gYDAke2hleH1gIDogaGV4O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhleFRvTnVtYmVyKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIC8vIEJpZyBFbmRpYW5cbiAgICByZXR1cm4gQmlnSW50KGhleCA9PT0gJycgPyAnMCcgOiBgMHgke2hleH1gKTtcbn1cbi8qKlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICBjb25zdCBsZW4gPSBoZXgubGVuZ3RoO1xuICAgIGlmIChsZW4gJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRlZCBoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgbGVuKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGxlbiAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaiA9IGkgKiAyO1xuICAgICAgICBjb25zdCBoZXhCeXRlID0gaGV4LnNsaWNlKGosIGogKyAyKTtcbiAgICAgICAgY29uc3QgYnl0ZSA9IE51bWJlci5wYXJzZUludChoZXhCeXRlLCAxNik7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oYnl0ZSkgfHwgYnl0ZSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZSBzZXF1ZW5jZScpO1xuICAgICAgICBhcnJheVtpXSA9IGJ5dGU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8vIEJFOiBCaWcgRW5kaWFuLCBMRTogTGl0dGxlIEVuZGlhblxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJCRShieXRlcykge1xuICAgIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4KGJ5dGVzKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb051bWJlckxFKGJ5dGVzKSB7XG4gICAgaWYgKCF1OGEoYnl0ZXMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oYnl0ZXMpLnJldmVyc2UoKSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvQnl0ZXNCRShuLCBsZW4pIHtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhuLnRvU3RyaW5nKDE2KS5wYWRTdGFydChsZW4gKiAyLCAnMCcpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0J5dGVzTEUobiwgbGVuKSB7XG4gICAgcmV0dXJuIG51bWJlclRvQnl0ZXNCRShuLCBsZW4pLnJldmVyc2UoKTtcbn1cbi8vIFVucGFkZGVkLCByYXJlbHkgdXNlZFxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvVmFyQnl0ZXNCRShuKSB7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMobnVtYmVyVG9IZXhVbnBhZGRlZChuKSk7XG59XG4vKipcbiAqIFRha2VzIGhleCBzdHJpbmcgb3IgVWludDhBcnJheSwgY29udmVydHMgdG8gVWludDhBcnJheS5cbiAqIFZhbGlkYXRlcyBvdXRwdXQgbGVuZ3RoLlxuICogV2lsbCB0aHJvdyBlcnJvciBmb3Igb3RoZXIgdHlwZXMuXG4gKiBAcGFyYW0gdGl0bGUgZGVzY3JpcHRpdmUgdGl0bGUgZm9yIGFuIGVycm9yIGUuZy4gJ3ByaXZhdGUga2V5J1xuICogQHBhcmFtIGhleCBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXlcbiAqIEBwYXJhbSBleHBlY3RlZExlbmd0aCBvcHRpb25hbCwgd2lsbCBjb21wYXJlIHRvIHJlc3VsdCBhcnJheSdzIGxlbmd0aFxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZUJ5dGVzKHRpdGxlLCBoZXgsIGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgbGV0IHJlcztcbiAgICBpZiAodHlwZW9mIGhleCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlcyA9IGhleFRvQnl0ZXMoaGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RpdGxlfSBtdXN0IGJlIHZhbGlkIGhleCBzdHJpbmcsIGdvdCBcIiR7aGV4fVwiLiBDYXVzZTogJHtlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHU4YShoZXgpKSB7XG4gICAgICAgIC8vIFVpbnQ4QXJyYXkuZnJvbSgpIGluc3RlYWQgb2YgaGFzaC5zbGljZSgpIGJlY2F1c2Ugbm9kZS5qcyBCdWZmZXJcbiAgICAgICAgLy8gaXMgaW5zdGFuY2Ugb2YgVWludDhBcnJheSwgYW5kIGl0cyBzbGljZSgpIGNyZWF0ZXMgKiptdXRhYmxlKiogY29weVxuICAgICAgICByZXMgPSBVaW50OEFycmF5LmZyb20oaGV4KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aXRsZX0gbXVzdCBiZSBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXlgKTtcbiAgICB9XG4gICAgY29uc3QgbGVuID0gcmVzLmxlbmd0aDtcbiAgICBpZiAodHlwZW9mIGV4cGVjdGVkTGVuZ3RoID09PSAnbnVtYmVyJyAmJiBsZW4gIT09IGV4cGVjdGVkTGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IGV4cGVjdGVkICR7ZXhwZWN0ZWRMZW5ndGh9IGJ5dGVzLCBnb3QgJHtsZW59YCk7XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKlxuICogQ29waWVzIHNldmVyYWwgVWludDhBcnJheXMgaW50byBvbmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBjb25zdCByID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlzLnJlZHVjZSgoc3VtLCBhKSA9PiBzdW0gKyBhLmxlbmd0aCwgMCkpO1xuICAgIGxldCBwYWQgPSAwOyAvLyB3YWxrIHRocm91Z2ggZWFjaCBpdGVtLCBlbnN1cmUgdGhleSBoYXZlIHByb3BlciB0eXBlXG4gICAgYXJyYXlzLmZvckVhY2goKGEpID0+IHtcbiAgICAgICAgaWYgKCF1OGEoYSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgci5zZXQoYSwgcGFkKTtcbiAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuICAgIH0pO1xuICAgIHJldHVybiByO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFsQnl0ZXMoYjEsIGIyKSB7XG4gICAgLy8gV2UgZG9uJ3QgY2FyZSBhYm91dCB0aW1pbmcgYXR0YWNrcyBoZXJlXG4gICAgaWYgKGIxLmxlbmd0aCAhPT0gYjIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiMS5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKGIxW2ldICE9PSBiMltpXSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuLy8gQml0IG9wZXJhdGlvbnNcbi8qKlxuICogQ2FsY3VsYXRlcyBhbW91bnQgb2YgYml0cyBpbiBhIGJpZ2ludC5cbiAqIFNhbWUgYXMgYG4udG9TdHJpbmcoMikubGVuZ3RoYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYml0TGVuKG4pIHtcbiAgICBsZXQgbGVuO1xuICAgIGZvciAobGVuID0gMDsgbiA+IF8wbjsgbiA+Pj0gXzFuLCBsZW4gKz0gMSlcbiAgICAgICAgO1xuICAgIHJldHVybiBsZW47XG59XG4vKipcbiAqIEdldHMgc2luZ2xlIGJpdCBhdCBwb3NpdGlvbi5cbiAqIE5PVEU6IGZpcnN0IGJpdCBwb3NpdGlvbiBpcyAwIChzYW1lIGFzIGFycmF5cylcbiAqIFNhbWUgYXMgYCEhK0FycmF5LmZyb20obi50b1N0cmluZygyKSkucmV2ZXJzZSgpW3Bvc11gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaXRHZXQobiwgcG9zKSB7XG4gICAgcmV0dXJuIChuID4+IEJpZ0ludChwb3MpKSAmIF8xbjtcbn1cbi8qKlxuICogU2V0cyBzaW5nbGUgYml0IGF0IHBvc2l0aW9uLlxuICovXG5leHBvcnQgY29uc3QgYml0U2V0ID0gKG4sIHBvcywgdmFsdWUpID0+IHtcbiAgICByZXR1cm4gbiB8ICgodmFsdWUgPyBfMW4gOiBfMG4pIDw8IEJpZ0ludChwb3MpKTtcbn07XG4vKipcbiAqIENhbGN1bGF0ZSBtYXNrIGZvciBOIGJpdHMuIE5vdCB1c2luZyAqKiBvcGVyYXRvciB3aXRoIGJpZ2ludHMgYmVjYXVzZSBvZiBvbGQgZW5naW5lcy5cbiAqIFNhbWUgYXMgQmlnSW50KGAwYiR7QXJyYXkoaSkuZmlsbCgnMScpLmpvaW4oJycpfWApXG4gKi9cbmV4cG9ydCBjb25zdCBiaXRNYXNrID0gKG4pID0+IChfMm4gPDwgQmlnSW50KG4gLSAxKSkgLSBfMW47XG4vLyBEUkJHXG5jb25zdCB1OG4gPSAoZGF0YSkgPT4gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7IC8vIGNyZWF0ZXMgVWludDhBcnJheVxuY29uc3QgdThmciA9IChhcnIpID0+IFVpbnQ4QXJyYXkuZnJvbShhcnIpOyAvLyBhbm90aGVyIHNob3J0Y3V0XG4vKipcbiAqIE1pbmltYWwgSE1BQy1EUkJHIGZyb20gTklTVCA4MDAtOTAgZm9yIFJGQzY5Nzkgc2lncy5cbiAqIEByZXR1cm5zIGZ1bmN0aW9uIHRoYXQgd2lsbCBjYWxsIERSQkcgdW50aWwgMm5kIGFyZyByZXR1cm5zIHNvbWV0aGluZyBtZWFuaW5nZnVsXG4gKiBAZXhhbXBsZVxuICogICBjb25zdCBkcmJnID0gY3JlYXRlSG1hY0RSQkc8S2V5PigzMiwgMzIsIGhtYWMpO1xuICogICBkcmJnKHNlZWQsIGJ5dGVzVG9LZXkpOyAvLyBieXRlc1RvS2V5IG11c3QgcmV0dXJuIEtleSBvciB1bmRlZmluZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhtYWNEcmJnKGhhc2hMZW4sIHFCeXRlTGVuLCBobWFjRm4pIHtcbiAgICBpZiAodHlwZW9mIGhhc2hMZW4gIT09ICdudW1iZXInIHx8IGhhc2hMZW4gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hhc2hMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIGlmICh0eXBlb2YgcUJ5dGVMZW4gIT09ICdudW1iZXInIHx8IHFCeXRlTGVuIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdxQnl0ZUxlbiBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgaWYgKHR5cGVvZiBobWFjRm4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaG1hY0ZuIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIC8vIFN0ZXAgQiwgU3RlcCBDOiBzZXQgaGFzaExlbiB0byA4KmNlaWwoaGxlbi84KVxuICAgIGxldCB2ID0gdThuKGhhc2hMZW4pOyAvLyBNaW5pbWFsIG5vbi1mdWxsLXNwZWMgSE1BQy1EUkJHIGZyb20gTklTVCA4MDAtOTAgZm9yIFJGQzY5Nzkgc2lncy5cbiAgICBsZXQgayA9IHU4bihoYXNoTGVuKTsgLy8gU3RlcHMgQiBhbmQgQyBvZiBSRkM2OTc5IDMuMjogc2V0IGhhc2hMZW4sIGluIG91ciBjYXNlIGFsd2F5cyBzYW1lXG4gICAgbGV0IGkgPSAwOyAvLyBJdGVyYXRpb25zIGNvdW50ZXIsIHdpbGwgdGhyb3cgd2hlbiBvdmVyIDEwMDBcbiAgICBjb25zdCByZXNldCA9ICgpID0+IHtcbiAgICAgICAgdi5maWxsKDEpO1xuICAgICAgICBrLmZpbGwoMCk7XG4gICAgICAgIGkgPSAwO1xuICAgIH07XG4gICAgY29uc3QgaCA9ICguLi5iKSA9PiBobWFjRm4oaywgdiwgLi4uYik7IC8vIGhtYWMoaykodiwgLi4udmFsdWVzKVxuICAgIGNvbnN0IHJlc2VlZCA9IChzZWVkID0gdThuKCkpID0+IHtcbiAgICAgICAgLy8gSE1BQy1EUkJHIHJlc2VlZCgpIGZ1bmN0aW9uLiBTdGVwcyBELUdcbiAgICAgICAgayA9IGgodThmcihbMHgwMF0pLCBzZWVkKTsgLy8gayA9IGhtYWMoayB8fCB2IHx8IDB4MDAgfHwgc2VlZClcbiAgICAgICAgdiA9IGgoKTsgLy8gdiA9IGhtYWMoayB8fCB2KVxuICAgICAgICBpZiAoc2VlZC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGsgPSBoKHU4ZnIoWzB4MDFdKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAxIHx8IHNlZWQpXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICB9O1xuICAgIGNvbnN0IGdlbiA9ICgpID0+IHtcbiAgICAgICAgLy8gSE1BQy1EUkJHIGdlbmVyYXRlKCkgZnVuY3Rpb25cbiAgICAgICAgaWYgKGkrKyA+PSAxMDAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkcmJnOiB0cmllZCAxMDAwIHZhbHVlcycpO1xuICAgICAgICBsZXQgbGVuID0gMDtcbiAgICAgICAgY29uc3Qgb3V0ID0gW107XG4gICAgICAgIHdoaWxlIChsZW4gPCBxQnl0ZUxlbikge1xuICAgICAgICAgICAgdiA9IGgoKTtcbiAgICAgICAgICAgIGNvbnN0IHNsID0gdi5zbGljZSgpO1xuICAgICAgICAgICAgb3V0LnB1c2goc2wpO1xuICAgICAgICAgICAgbGVuICs9IHYubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25jYXRCeXRlcyguLi5vdXQpO1xuICAgIH07XG4gICAgY29uc3QgZ2VuVW50aWwgPSAoc2VlZCwgcHJlZCkgPT4ge1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXNlZWQoc2VlZCk7IC8vIFN0ZXBzIEQtR1xuICAgICAgICBsZXQgcmVzID0gdW5kZWZpbmVkOyAvLyBTdGVwIEg6IGdyaW5kIHVudGlsIGsgaXMgaW4gWzEuLm4tMV1cbiAgICAgICAgd2hpbGUgKCEocmVzID0gcHJlZChnZW4oKSkpKVxuICAgICAgICAgICAgcmVzZWVkKCk7XG4gICAgICAgIHJlc2V0KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICByZXR1cm4gZ2VuVW50aWw7XG59XG4vLyBWYWxpZGF0aW5nIGN1cnZlcyBhbmQgZmllbGRzXG5jb25zdCB2YWxpZGF0b3JGbnMgPSB7XG4gICAgYmlnaW50OiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnYmlnaW50JyxcbiAgICBmdW5jdGlvbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyxcbiAgICBib29sZWFuOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnYm9vbGVhbicsXG4gICAgc3RyaW5nOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyxcbiAgICBzdHJpbmdPclVpbnQ4QXJyYXk6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8IHZhbCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXksXG4gICAgaXNTYWZlSW50ZWdlcjogKHZhbCkgPT4gTnVtYmVyLmlzU2FmZUludGVnZXIodmFsKSxcbiAgICBhcnJheTogKHZhbCkgPT4gQXJyYXkuaXNBcnJheSh2YWwpLFxuICAgIGZpZWxkOiAodmFsLCBvYmplY3QpID0+IG9iamVjdC5GcC5pc1ZhbGlkKHZhbCksXG4gICAgaGFzaDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwub3V0cHV0TGVuKSxcbn07XG4vLyB0eXBlIFJlY29yZDxLIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyIHwgc3ltYm9sLCBUPiA9IHsgW1AgaW4gS106IFQ7IH1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZU9iamVjdChvYmplY3QsIHZhbGlkYXRvcnMsIG9wdFZhbGlkYXRvcnMgPSB7fSkge1xuICAgIGNvbnN0IGNoZWNrRmllbGQgPSAoZmllbGROYW1lLCB0eXBlLCBpc09wdGlvbmFsKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoZWNrVmFsID0gdmFsaWRhdG9yRm5zW3R5cGVdO1xuICAgICAgICBpZiAodHlwZW9mIGNoZWNrVmFsICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHZhbGlkYXRvciBcIiR7dHlwZX1cIiwgZXhwZWN0ZWQgZnVuY3Rpb25gKTtcbiAgICAgICAgY29uc3QgdmFsID0gb2JqZWN0W2ZpZWxkTmFtZV07XG4gICAgICAgIGlmIChpc09wdGlvbmFsICYmIHZhbCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIWNoZWNrVmFsKHZhbCwgb2JqZWN0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBhcmFtICR7U3RyaW5nKGZpZWxkTmFtZSl9PSR7dmFsfSAoJHt0eXBlb2YgdmFsfSksIGV4cGVjdGVkICR7dHlwZX1gKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyh2YWxpZGF0b3JzKSlcbiAgICAgICAgY2hlY2tGaWVsZChmaWVsZE5hbWUsIHR5cGUsIGZhbHNlKTtcbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIHR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdFZhbGlkYXRvcnMpKVxuICAgICAgICBjaGVja0ZpZWxkKGZpZWxkTmFtZSwgdHlwZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbi8vIHZhbGlkYXRlIHR5cGUgdGVzdHNcbi8vIGNvbnN0IG86IHsgYTogbnVtYmVyOyBiOiBudW1iZXI7IGM6IG51bWJlciB9ID0geyBhOiAxLCBiOiA1LCBjOiA2IH07XG4vLyBjb25zdCB6MCA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2lzU2FmZUludGVnZXInIH0sIHsgYzogJ2JpZ2ludCcgfSk7IC8vIE9rIVxuLy8gLy8gU2hvdWxkIGZhaWwgdHlwZS1jaGVja1xuLy8gY29uc3QgejEgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICd0bXAnIH0sIHsgYzogJ3p6JyB9KTtcbi8vIGNvbnN0IHoyID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnaXNTYWZlSW50ZWdlcicgfSwgeyBjOiAnenonIH0pO1xuLy8gY29uc3QgejMgPSB2YWxpZGF0ZU9iamVjdChvLCB7IHRlc3Q6ICdib29sZWFuJywgejogJ2J1ZycgfSk7XG4vLyBjb25zdCB6NCA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2Jvb2xlYW4nLCB6OiAnYnVnJyB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6WyJfMG4iLCJCaWdJbnQiLCJfMW4iLCJfMm4iLCJ1OGEiLCJhIiwiVWludDhBcnJheSIsImhleGVzIiwiQXJyYXkiLCJmcm9tIiwibGVuZ3RoIiwiXyIsImkiLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwiYnl0ZXNUb0hleCIsImJ5dGVzIiwiRXJyb3IiLCJoZXgiLCJudW1iZXJUb0hleFVucGFkZGVkIiwibnVtIiwiaGV4VG9OdW1iZXIiLCJoZXhUb0J5dGVzIiwibGVuIiwiYXJyYXkiLCJqIiwiaGV4Qnl0ZSIsInNsaWNlIiwiYnl0ZSIsIk51bWJlciIsInBhcnNlSW50IiwiaXNOYU4iLCJieXRlc1RvTnVtYmVyQkUiLCJieXRlc1RvTnVtYmVyTEUiLCJyZXZlcnNlIiwibnVtYmVyVG9CeXRlc0JFIiwibiIsIm51bWJlclRvQnl0ZXNMRSIsIm51bWJlclRvVmFyQnl0ZXNCRSIsImVuc3VyZUJ5dGVzIiwidGl0bGUiLCJleHBlY3RlZExlbmd0aCIsInJlcyIsImUiLCJjb25jYXRCeXRlcyIsImFycmF5cyIsInIiLCJyZWR1Y2UiLCJzdW0iLCJwYWQiLCJmb3JFYWNoIiwic2V0IiwiZXF1YWxCeXRlcyIsImIxIiwiYjIiLCJ1dGY4VG9CeXRlcyIsInN0ciIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwiYml0TGVuIiwiYml0R2V0IiwicG9zIiwiYml0U2V0IiwidmFsdWUiLCJiaXRNYXNrIiwidThuIiwiZGF0YSIsInU4ZnIiLCJhcnIiLCJjcmVhdGVIbWFjRHJiZyIsImhhc2hMZW4iLCJxQnl0ZUxlbiIsImhtYWNGbiIsInYiLCJrIiwicmVzZXQiLCJmaWxsIiwiaCIsImIiLCJyZXNlZWQiLCJzZWVkIiwiZ2VuIiwib3V0Iiwic2wiLCJwdXNoIiwiZ2VuVW50aWwiLCJwcmVkIiwidW5kZWZpbmVkIiwidmFsaWRhdG9yRm5zIiwiYmlnaW50IiwidmFsIiwiZnVuY3Rpb24iLCJib29sZWFuIiwic3RyaW5nIiwic3RyaW5nT3JVaW50OEFycmF5IiwiaXNTYWZlSW50ZWdlciIsImlzQXJyYXkiLCJmaWVsZCIsIm9iamVjdCIsIkZwIiwiaXNWYWxpZCIsImhhc2giLCJvdXRwdXRMZW4iLCJ2YWxpZGF0ZU9iamVjdCIsInZhbGlkYXRvcnMiLCJvcHRWYWxpZGF0b3JzIiwiY2hlY2tGaWVsZCIsImZpZWxkTmFtZSIsInR5cGUiLCJpc09wdGlvbmFsIiwiY2hlY2tWYWwiLCJTdHJpbmciLCJPYmplY3QiLCJlbnRyaWVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js":
/*!****************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/weierstrass.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DER: function() { return /* binding */ DER; },\n/* harmony export */   SWUFpSqrtRatio: function() { return /* binding */ SWUFpSqrtRatio; },\n/* harmony export */   mapToCurveSimpleSWU: function() { return /* binding */ mapToCurveSimpleSWU; },\n/* harmony export */   weierstrass: function() { return /* binding */ weierstrass; },\n/* harmony export */   weierstrassPoints: function() { return /* binding */ weierstrassPoints; }\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/curve.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Short Weierstrass curve. The formula is: y = x + ax + b\n\n\n\n\nfunction validatePointOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        a: \"field\",\n        b: \"field\"\n    }, {\n        allowedPrivateKeyLengths: \"array\",\n        wrapPrivateKey: \"boolean\",\n        isTorsionFree: \"function\",\n        clearCofactor: \"function\",\n        allowInfinityPoint: \"boolean\",\n        fromBytes: \"function\",\n        toBytes: \"function\"\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error(\"Endomorphism can only be defined for Koblitz curves that have a=0\");\n        }\n        if (typeof endo !== \"object\" || typeof endo.beta !== \"bigint\" || typeof endo.splitScalar !== \"function\") {\n            throw new Error(\"Expected endomorphism with beta: bigint and splitScalar: function\");\n        }\n    }\n    return Object.freeze({\n        ...opts\n    });\n}\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = _utils_js__WEBPACK_IMPORTED_MODULE_1__;\nconst DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = \"\"){\n            super(m);\n        }\n    },\n    _parseInt (data) {\n        const { Err: E } = DER;\n        if (data.length < 2 || data[0] !== 0x02) throw new E(\"Invalid signature integer tag\");\n        const len = data[1];\n        const res = data.subarray(2, len + 2);\n        if (!len || res.length !== len) throw new E(\"Invalid signature integer: wrong length\");\n        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n        // since we always use positive integers here. It must always be empty:\n        // - add zero byte if exists\n        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n        if (res[0] & 128) throw new E(\"Invalid signature integer: negative\");\n        if (res[0] === 0x00 && !(res[1] & 128)) throw new E(\"Invalid signature integer: unnecessary leading zero\");\n        return {\n            d: b2n(res),\n            l: data.subarray(len + 2)\n        }; // d is data, l is left\n    },\n    toSig (hex) {\n        // parse DER signature\n        const { Err: E } = DER;\n        const data = typeof hex === \"string\" ? h2b(hex) : hex;\n        if (!(data instanceof Uint8Array)) throw new Error(\"ui8a expected\");\n        let l = data.length;\n        if (l < 2 || data[0] != 0x30) throw new E(\"Invalid signature tag\");\n        if (data[1] !== l - 2) throw new E(\"Invalid signature: incorrect length\");\n        const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\n        const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\n        if (rBytesLeft.length) throw new E(\"Invalid signature: left bytes after parsing\");\n        return {\n            r,\n            s\n        };\n    },\n    hexFromSig (sig) {\n        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n        const slice = (s)=>Number.parseInt(s[0], 16) & 8 ? \"00\" + s : s;\n        const h = (num)=>{\n            const hex = num.toString(16);\n            return hex.length & 1 ? \"0\".concat(hex) : hex;\n        };\n        const s = slice(h(sig.s));\n        const r = slice(h(sig.r));\n        const shl = s.length / 2;\n        const rhl = r.length / 2;\n        const sl = h(shl);\n        const rl = h(rhl);\n        return \"30\".concat(h(rhl + shl + 4), \"02\").concat(rl).concat(r, \"02\").concat(sl).concat(s);\n    }\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const toBytes = CURVE.toBytes || ((_c, point, _isCompressed)=>{\n        const a = point.toAffine();\n        return _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(Uint8Array.from([\n            0x04\n        ]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n    });\n    const fromBytes = CURVE.fromBytes || ((bytes)=>{\n        // const head = bytes[0];\n        const tail = bytes.subarray(1);\n        // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n        return {\n            x,\n            y\n        };\n    });\n    /**\n     * y = x + ax + b: Short weierstrass curve formula\n     * @returns y\n     */ function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx))) throw new Error(\"bad generator point: equation left != right\");\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return typeof num === \"bigint\" && _0n < num && num < CURVE.n;\n    }\n    function assertGE(num) {\n        if (!isWithinCurveOrder(num)) throw new Error(\"Expected valid bigint: 0 < bigint < curve.n\");\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n        if (lengths && typeof key !== \"bigint\") {\n            if (key instanceof Uint8Array) key = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== \"string\" || !lengths.includes(key.length)) throw new Error(\"Invalid key\");\n            key = key.padStart(nByteLength * 2, \"0\");\n        }\n        let num;\n        try {\n            num = typeof key === \"bigint\" ? key : _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"private key\", key, nByteLength));\n        } catch (error) {\n            throw new Error(\"private key must be \".concat(nByteLength, \" bytes, hex or bigint, not \").concat(typeof key));\n        }\n        if (wrapPrivateKey) num = _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(num, n); // disabled by default, enabled for BLS\n        assertGE(num); // num in range [1..N-1]\n        return num;\n    }\n    const pointPrecomputes = new Map();\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point)) throw new Error(\"ProjectivePoint expected\");\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z)  (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */ class Point {\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error(\"invalid affine point\");\n            if (p instanceof Point) throw new Error(\"projective point not allowed\");\n            const is0 = (i)=>Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y)) return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */ static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p)=>p.pz));\n            return points.map((p, i)=>p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */ static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"pointHex\", hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            if (this.is0()) {\n                // (0, 1, 0) aka ZERO is invalid in most contexts.\n                // In BLS, ZERO can be serialized, so we allow it.\n                // (0, 0, 0) is wrong representation of ZERO and is always invalid.\n                if (CURVE.allowInfinityPoint && !Fp.is0(this.py)) return;\n                throw new Error(\"bad point: ZERO\");\n            }\n            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n            const { x, y } = this.toAffine();\n            // Check if x, y are valid field elements\n            if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error(\"bad point: x or y not FE\");\n            const left = Fp.sqr(y); // y\n            const right = weierstrassEquation(x); // x + ax + b\n            if (!Fp.eql(left, right)) throw new Error(\"bad point: equation left != right\");\n            if (!this.isTorsionFree()) throw new Error(\"bad point: not in prime-order subgroup\");\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd) return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */ equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */ negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp)=>{\n                const toInv = Fp.invertBatch(comp.map((p)=>p.pz));\n                return comp.map((p, i)=>p.toAffine(toInv[i])).map(Point.fromAffine);\n            });\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */ multiplyUnsafe(n) {\n            const I = Point.ZERO;\n            if (n === _0n) return I;\n            assertGE(n); // Will throw on 0\n            if (n === _1n) return this;\n            const { endo } = CURVE;\n            if (!endo) return wnaf.unsafeLadder(this, n);\n            // Apply endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while(k1 > _0n || k2 > _0n){\n                if (k1 & _1n) k1p = k1p.add(d);\n                if (k2 & _1n) k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg) k1p = k1p.negate();\n            if (k2neg) k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */ multiply(scalar) {\n            assertGE(scalar);\n            let n = scalar;\n            let point, fake; // Fake point is used to const-time mult\n            const { endo } = CURVE;\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            } else {\n                const { p, f } = this.wNAF(n);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([\n                point,\n                fake\n            ])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */ multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            )=>a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a);\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z)  (x=x/z, y=y/z)\n        toAffine(iz) {\n            const { px: x, py: y, pz: z } = this;\n            const is0 = this.is0();\n            // If invZ was 0, we return zero point. However we still want to execute\n            // all operations, so we replace invZ with a random number, 1.\n            if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);\n            const ax = Fp.mul(x, iz);\n            const ay = Fp.mul(y, iz);\n            const zz = Fp.mul(z, iz);\n            if (is0) return {\n                x: Fp.ZERO,\n                y: Fp.ZERO\n            };\n            if (!Fp.eql(zz, Fp.ONE)) throw new Error(\"invZ was invalid\");\n            return {\n                x: ax,\n                y: ay\n            };\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n) return true; // No subgroups, always torsion-free\n            if (isTorsionFree) return isTorsionFree(Point, this);\n            throw new Error(\"isTorsionFree() has not been declared for the elliptic curve\");\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n) return this; // Fast-path\n            if (clearCofactor) return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes() {\n            let isCompressed = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex() {\n            let isCompressed = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(this.toRawBytes(isCompressed));\n        }\n        constructor(px, py, pz){\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px)) throw new Error(\"x required\");\n            if (py == null || !Fp.isValid(py)) throw new Error(\"y required\");\n            if (pz == null || !Fp.isValid(pz)) throw new Error(\"z required\");\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder\n    };\n}\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        hash: \"hash\",\n        hmac: \"function\",\n        randomBytes: \"function\"\n    }, {\n        bits2int: \"function\",\n        bits2int_modN: \"function\",\n        lowS: \"boolean\"\n    });\n    return Object.freeze({\n        lowS: true,\n        ...opts\n    });\n}\nfunction weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function isValidFieldElement(num) {\n        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n    }\n    function modN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({\n        ...CURVE,\n        toBytes (_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes;\n            if (isCompressed) {\n                return cat(Uint8Array.from([\n                    point.hasEvenY() ? 0x02 : 0x03\n                ]), x);\n            } else {\n                return cat(Uint8Array.from([\n                    0x04\n                ]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes (bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(tail);\n                if (!isValidFieldElement(x)) throw new Error(\"Point is not on curve\");\n                const y2 = weierstrassEquation(x); // y = x + ax + b\n                let y = Fp.sqrt(y2); // y = y ^ (p+1)/4\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd) y = Fp.neg(y);\n                return {\n                    x,\n                    y\n                };\n            } else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return {\n                    x,\n                    y\n                };\n            } else {\n                throw new Error(\"Point of length \".concat(len, \" was invalid. Expected \").concat(compressedLen, \" compressed bytes or \").concat(uncompressedLen, \" uncompressed bytes\"));\n            }\n        }\n    });\n    const numToNByteStr = (num)=>_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to)=>_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */ class Signature {\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"compactSignature\", hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"DER\", hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            // can use assertGE here\n            if (!isWithinCurveOrder(this.r)) throw new Error(\"r must be 0 < r < CURVE.n\");\n            if (!isWithinCurveOrder(this.s)) throw new Error(\"s must be 0 < s < CURVE.n\");\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"msgHash\", msgHash)); // Truncate hash\n            if (rec == null || ![\n                0,\n                1,\n                2,\n                3\n            ].includes(rec)) throw new Error(\"recovery id invalid\");\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER) throw new Error(\"recovery id 2 or 3 invalid\");\n            const prefix = (rec & 1) === 0 ? \"02\" : \"03\";\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q) throw new Error(\"point at infinify\"); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig({\n                r: this.r,\n                s: this.s\n            });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n        constructor(r, s, recovery){\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n    }\n    const utils = {\n        isValidPrivateKey (privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            } catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */ randomPrivateKey: ()=>{\n            const length = _modular_js__WEBPACK_IMPORTED_MODULE_2__.getMinHashLength(CURVE.n);\n            return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */ precompute () {\n            let windowSize = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 8, point = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Point.BASE;\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        }\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */ function getPublicKey(privateKey) {\n        let isCompressed = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */ function isProbPub(item) {\n        const arr = item instanceof Uint8Array;\n        const str = typeof item === \"string\";\n        const len = (arr || str) && item.length;\n        if (arr) return len === compressedLen || len === uncompressedLen;\n        if (str) return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point) return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */ function getSharedSecret(privateA, publicB) {\n        let isCompressed = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;\n        if (isProbPub(privateA)) throw new Error(\"first arg must be private key\");\n        if (!isProbPub(publicB)) throw new Error(\"second arg must be public key\");\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int || function(bytes) {\n        // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n        // for some cases, since bytes.length * 8 is not actual bitLength.\n        const num = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(bytes); // check for == u8 done here\n        const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n        return delta > 0 ? num >> BigInt(delta) : num;\n    };\n    const bits2int_modN = CURVE.bits2int_modN || function(bytes) {\n        return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n    };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */ function int2octets(num) {\n        if (typeof num !== \"bigint\") throw new Error(\"bigint expected\");\n        if (!(_0n <= num && num < ORDER_MASK)) throw new Error(\"bigint expected < 2^\".concat(CURVE.nBitLength));\n        // works with order, can have different size than numToField!\n        return _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n    // Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey) {\n        let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultSigOpts;\n        if ([\n            \"recovered\",\n            \"canonical\"\n        ].some((k)=>k in opts)) throw new Error(\"sign() legacy options not supported\");\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"msgHash\", msgHash);\n        if (prehash) msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"prehashed msgHash\", hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [\n            int2octets(d),\n            int2octets(h1int)\n        ];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"extraEntropy\", e)); // check for being bytes\n        }\n        const seed = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n) return;\n            // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n) return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return {\n            seed,\n            k2sig\n        };\n    }\n    const defaultSigOpts = {\n        lowS: CURVE.lowS,\n        prehash: false\n    };\n    const defaultVerOpts = {\n        lowS: CURVE.lowS,\n        prehash: false\n    };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G  k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */ function sign(msgHash, privKey) {\n        let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultSigOpts;\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = _utils_js__WEBPACK_IMPORTED_MODULE_1__.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1G - U2P\n     *   mod(R.x, n) == r\n     * ```\n     */ function verify(signature, msgHash, publicKey) {\n        let opts = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : defaultVerOpts;\n        var _Point_BASE_multiplyAndAddUnsafe;\n        const sg = signature;\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"msgHash\", msgHash);\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"publicKey\", publicKey);\n        if (\"strict\" in opts) throw new Error(\"options.strict was renamed to lowS\");\n        const { lowS, prehash } = opts;\n        let _sig = undefined;\n        let P;\n        try {\n            if (typeof sg === \"string\" || sg instanceof Uint8Array) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    _sig = Signature.fromDER(sg);\n                } catch (derError) {\n                    if (!(derError instanceof DER.Err)) throw derError;\n                    _sig = Signature.fromCompact(sg);\n                }\n            } else if (typeof sg === \"object\" && typeof sg.r === \"bigint\" && typeof sg.s === \"bigint\") {\n                const { r, s } = sg;\n                _sig = new Signature(r, s);\n            } else {\n                throw new Error(\"PARSE\");\n            }\n            P = Point.fromHex(publicKey);\n        } catch (error) {\n            if (error.message === \"PARSE\") throw new Error(\"signature must be Signature instance, Uint8Array or hex string\");\n            return false;\n        }\n        if (lowS && _sig.hasHighS()) return false;\n        if (prehash) msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = (_Point_BASE_multiplyAndAddUnsafe = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)) === null || _Point_BASE_multiplyAndAddUnsafe === void 0 ? void 0 : _Point_BASE_multiplyAndAddUnsafe.toAffine(); // R = u1G + u2P\n        if (!R) return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */ function SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for(let o = q - _1n; o % _2n === _0n; o /= _2n)l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v)=>{\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for(let i = c1; i > _1n; i--){\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << tv5 - _1n; // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return {\n            isValid: isQR,\n            value: tv3\n        };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v)=>{\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return {\n                isValid: isQR,\n                value: y\n            }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n_c = SWUFpSqrtRatio;\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */ function mapToCurveSimpleSWU(Fp, opts) {\n    _modular_js__WEBPACK_IMPORTED_MODULE_2__.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z)) throw new Error(\"mapToCurveSimpleSWU: invalid opts\");\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd) throw new Error(\"Fp.isOdd is not implemented!\");\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u)=>{\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return {\n            x,\n            y\n        };\n    };\n} //# sourceMappingURL=weierstrass.js.map\nvar _c;\n$RefreshReg$(_c, \"SWUFpSqrtRatio\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBLG9FQUFvRSxHQUNwRSw0REFBNEQ7QUFDeEI7QUFDSDtBQUNRO0FBQ1E7QUFDakQsU0FBU0ssa0JBQWtCQyxLQUFLO0lBQzVCLE1BQU1DLE9BQU9ILHdEQUFhQSxDQUFDRTtJQUMzQkwscURBQWlCLENBQUNNLE1BQU07UUFDcEJFLEdBQUc7UUFDSEMsR0FBRztJQUNQLEdBQUc7UUFDQ0MsMEJBQTBCO1FBQzFCQyxnQkFBZ0I7UUFDaEJDLGVBQWU7UUFDZkMsZUFBZTtRQUNmQyxvQkFBb0I7UUFDcEJDLFdBQVc7UUFDWEMsU0FBUztJQUNiO0lBQ0EsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLEVBQUUsRUFBRVYsQ0FBQyxFQUFFLEdBQUdGO0lBQ3hCLElBQUlXLE1BQU07UUFDTixJQUFJLENBQUNDLEdBQUdDLEdBQUcsQ0FBQ1gsR0FBR1UsR0FBR0UsSUFBSSxHQUFHO1lBQ3JCLE1BQU0sSUFBSUMsTUFBTTtRQUNwQjtRQUNBLElBQUksT0FBT0osU0FBUyxZQUNoQixPQUFPQSxLQUFLSyxJQUFJLEtBQUssWUFDckIsT0FBT0wsS0FBS00sV0FBVyxLQUFLLFlBQVk7WUFDeEMsTUFBTSxJQUFJRixNQUFNO1FBQ3BCO0lBQ0o7SUFDQSxPQUFPRyxPQUFPQyxNQUFNLENBQUM7UUFBRSxHQUFHbkIsSUFBSTtJQUFDO0FBQ25DO0FBQ0EsK0JBQStCO0FBQy9CLE1BQU0sRUFBRW9CLGlCQUFpQkMsR0FBRyxFQUFFQyxZQUFZQyxHQUFHLEVBQUUsR0FBRzdCLHNDQUFFQTtBQUM3QyxNQUFNOEIsTUFBTTtJQUNmLDJCQUEyQjtJQUMzQkMsS0FBSyxNQUFNQyxlQUFlWDtRQUN0QlksWUFBWUMsSUFBSSxFQUFFLENBQUU7WUFDaEIsS0FBSyxDQUFDQTtRQUNWO0lBQ0o7SUFDQUMsV0FBVUMsSUFB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MU8sSUFBSTVELEdBQUdvRSxHQUFHLENBQUNSLEdBQUdvUCxRQUFRLG1CQUFtQjtRQUN6Q3JQLElBQUkzRCxHQUFHNlMsSUFBSSxDQUFDbFAsR0FBRzhPLEtBQUsvTSxVQUFVLHdDQUF3QztRQUN0RTlCLElBQUk1RCxHQUFHNlMsSUFBSSxDQUFDalAsR0FBR29QLE9BQU90TixVQUFVLHVDQUF1QztRQUN2RSxNQUFNcU4sS0FBSy9TLEdBQUdtSCxLQUFLLENBQUNtTCxPQUFPdFMsR0FBR21ILEtBQUssQ0FBQ3ZELElBQUksK0JBQStCO1FBQ3ZFQSxJQUFJNUQsR0FBRzZTLElBQUksQ0FBQzdTLEdBQUcrSCxHQUFHLENBQUNuRSxJQUFJQSxHQUFHbVAsS0FBSyw0QkFBNEI7UUFDM0RwUCxJQUFJM0QsR0FBR3VULEdBQUcsQ0FBQzVQLEdBQUdnUCxNQUFNLG9CQUFvQjtRQUN4QyxPQUFPO1lBQUVoUDtZQUFHQztRQUFFO0lBQ2xCO0FBQ0osRUFDQSx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzP2I1OGIiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gU2hvcnQgV2VpZXJzdHJhc3MgY3VydmUuIFRoZSBmb3JtdWxhIGlzOiB5wrIgPSB4wrMgKyBheCArIGJcbmltcG9ydCAqIGFzIG1vZCBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0ICogYXMgdXQgZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBlbnN1cmVCeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgd05BRiwgdmFsaWRhdGVCYXNpYyB9IGZyb20gJy4vY3VydmUuanMnO1xuZnVuY3Rpb24gdmFsaWRhdGVQb2ludE9wdHMoY3VydmUpIHtcbiAgICBjb25zdCBvcHRzID0gdmFsaWRhdGVCYXNpYyhjdXJ2ZSk7XG4gICAgdXQudmFsaWRhdGVPYmplY3Qob3B0cywge1xuICAgICAgICBhOiAnZmllbGQnLFxuICAgICAgICBiOiAnZmllbGQnLFxuICAgIH0sIHtcbiAgICAgICAgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzOiAnYXJyYXknLFxuICAgICAgICB3cmFwUHJpdmF0ZUtleTogJ2Jvb2xlYW4nLFxuICAgICAgICBpc1RvcnNpb25GcmVlOiAnZnVuY3Rpb24nLFxuICAgICAgICBjbGVhckNvZmFjdG9yOiAnZnVuY3Rpb24nLFxuICAgICAgICBhbGxvd0luZmluaXR5UG9pbnQ6ICdib29sZWFuJyxcbiAgICAgICAgZnJvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgICAgICB0b0J5dGVzOiAnZnVuY3Rpb24nLFxuICAgIH0pO1xuICAgIGNvbnN0IHsgZW5kbywgRnAsIGEgfSA9IG9wdHM7XG4gICAgaWYgKGVuZG8pIHtcbiAgICAgICAgaWYgKCFGcC5lcWwoYSwgRnAuWkVSTykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5kb21vcnBoaXNtIGNhbiBvbmx5IGJlIGRlZmluZWQgZm9yIEtvYmxpdHogY3VydmVzIHRoYXQgaGF2ZSBhPTAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVuZG8gIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICB0eXBlb2YgZW5kby5iZXRhICE9PSAnYmlnaW50JyB8fFxuICAgICAgICAgICAgdHlwZW9mIGVuZG8uc3BsaXRTY2FsYXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgZW5kb21vcnBoaXNtIHdpdGggYmV0YTogYmlnaW50IGFuZCBzcGxpdFNjYWxhcjogZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLm9wdHMgfSk7XG59XG4vLyBBU04uMSBERVIgZW5jb2RpbmcgdXRpbGl0aWVzXG5jb25zdCB7IGJ5dGVzVG9OdW1iZXJCRTogYjJuLCBoZXhUb0J5dGVzOiBoMmIgfSA9IHV0O1xuZXhwb3J0IGNvbnN0IERFUiA9IHtcbiAgICAvLyBhc24uMSBERVIgZW5jb2RpbmcgdXRpbHNcbiAgICBFcnI6IGNsYXNzIERFUkVyciBleHRlbmRzIEVycm9yIHtcbiAgICAgICAgY29uc3RydWN0b3IobSA9ICcnKSB7XG4gICAgICAgICAgICBzdXBlcihtKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgX3BhcnNlSW50KGRhdGEpIHtcbiAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgMiB8fCBkYXRhWzBdICE9PSAweDAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXIgdGFnJyk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGFbMV07XG4gICAgICAgIGNvbnN0IHJlcyA9IGRhdGEuc3ViYXJyYXkoMiwgbGVuICsgMik7XG4gICAgICAgIGlmICghbGVuIHx8IHJlcy5sZW5ndGggIT09IGxlbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB3cm9uZyBsZW5ndGgnKTtcbiAgICAgICAgLy8gaHR0cHM6Ly9jcnlwdG8uc3RhY2tleGNoYW5nZS5jb20vYS81NzczNCBMZWZ0bW9zdCBiaXQgb2YgZmlyc3QgYnl0ZSBpcyAnbmVnYXRpdmUnIGZsYWcsXG4gICAgICAgIC8vIHNpbmNlIHdlIGFsd2F5cyB1c2UgcG9zaXRpdmUgaW50ZWdlcnMgaGVyZS4gSXQgbXVzdCBhbHdheXMgYmUgZW1wdHk6XG4gICAgICAgIC8vIC0gYWRkIHplcm8gYnl0ZSBpZiBleGlzdHNcbiAgICAgICAgLy8gLSBpZiBuZXh0IGJ5dGUgZG9lc24ndCBoYXZlIGEgZmxhZywgbGVhZGluZyB6ZXJvIGlzIG5vdCBhbGxvd2VkIChtaW5pbWFsIGVuY29kaW5nKVxuICAgICAgICBpZiAocmVzWzBdICYgMGIxMDAwMDAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiBuZWdhdGl2ZScpO1xuICAgICAgICBpZiAocmVzWzBdID09PSAweDAwICYmICEocmVzWzFdICYgMGIxMDAwMDAwMCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogdW5uZWNlc3NhcnkgbGVhZGluZyB6ZXJvJyk7XG4gICAgICAgIHJldHVybiB7IGQ6IGIybihyZXMpLCBsOiBkYXRhLnN1YmFycmF5KGxlbiArIDIpIH07IC8vIGQgaXMgZGF0YSwgbCBpcyBsZWZ0XG4gICAgfSxcbiAgICB0b1NpZyhoZXgpIHtcbiAgICAgICAgLy8gcGFyc2UgREVSIHNpZ25hdHVyZVxuICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgICBjb25zdCBkYXRhID0gdHlwZW9mIGhleCA9PT0gJ3N0cmluZycgPyBoMmIoaGV4KSA6IGhleDtcbiAgICAgICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1aThhIGV4cGVjdGVkJyk7XG4gICAgICAgIGxldCBsID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGlmIChsIDwgMiB8fCBkYXRhWzBdICE9IDB4MzApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgdGFnJyk7XG4gICAgICAgIGlmIChkYXRhWzFdICE9PSBsIC0gMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZTogaW5jb3JyZWN0IGxlbmd0aCcpO1xuICAgICAgICBjb25zdCB7IGQ6IHIsIGw6IHNCeXRlcyB9ID0gREVSLl9wYXJzZUludChkYXRhLnN1YmFycmF5KDIpKTtcbiAgICAgICAgY29uc3QgeyBkOiBzLCBsOiByQnl0ZXNMZWZ0IH0gPSBERVIuX3BhcnNlSW50KHNCeXRlcyk7XG4gICAgICAgIGlmIChyQnl0ZXNMZWZ0Lmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nJyk7XG4gICAgICAgIHJldHVybiB7IHIsIHMgfTtcbiAgICB9LFxuICAgIGhleEZyb21TaWcoc2lnKSB7XG4gICAgICAgIC8vIEFkZCBsZWFkaW5nIHplcm8gaWYgZmlyc3QgYnl0ZSBoYXMgbmVnYXRpdmUgYml0IGVuYWJsZWQuIE1vcmUgZGV0YWlscyBpbiAnX3BhcnNlSW50J1xuICAgICAgICBjb25zdCBzbGljZSA9IChzKSA9PiAoTnVtYmVyLnBhcnNlSW50KHNbMF0sIDE2KSAmIDBiMTAwMCA/ICcwMCcgKyBzIDogcyk7XG4gICAgICAgIGNvbnN0IGggPSAobnVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gYDAke2hleH1gIDogaGV4O1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzID0gc2xpY2UoaChzaWcucykpO1xuICAgICAgICBjb25zdCByID0gc2xpY2UoaChzaWcucikpO1xuICAgICAgICBjb25zdCBzaGwgPSBzLmxlbmd0aCAvIDI7XG4gICAgICAgIGNvbnN0IHJobCA9IHIubGVuZ3RoIC8gMjtcbiAgICAgICAgY29uc3Qgc2wgPSBoKHNobCk7XG4gICAgICAgIGNvbnN0IHJsID0gaChyaGwpO1xuICAgICAgICByZXR1cm4gYDMwJHtoKHJobCArIHNobCArIDQpfTAyJHtybH0ke3J9MDIke3NsfSR7c31gO1xuICAgIH0sXG59O1xuLy8gQmUgZnJpZW5kbHkgdG8gYmFkIEVDTUFTY3JpcHQgcGFyc2VycyBieSBub3QgdXNpbmcgYmlnaW50IGxpdGVyYWxzXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKSwgXzRuID0gQmlnSW50KDQpO1xuZXhwb3J0IGZ1bmN0aW9uIHdlaWVyc3RyYXNzUG9pbnRzKG9wdHMpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlUG9pbnRPcHRzKG9wdHMpO1xuICAgIGNvbnN0IHsgRnAgfSA9IENVUlZFOyAvLyBBbGwgY3VydmVzIGhhcyBzYW1lIGZpZWxkIC8gZ3JvdXAgbGVuZ3RoIGFzIGZvciBub3csIGJ1dCB0aGV5IGNhbiBkaWZmZXJcbiAgICBjb25zdCB0b0J5dGVzID0gQ1VSVkUudG9CeXRlcyB8fFxuICAgICAgICAoKF9jLCBwb2ludCwgX2lzQ29tcHJlc3NlZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgICAgICAgICByZXR1cm4gdXQuY29uY2F0Qnl0ZXMoVWludDhBcnJheS5mcm9tKFsweDA0XSksIEZwLnRvQnl0ZXMoYS54KSwgRnAudG9CeXRlcyhhLnkpKTtcbiAgICAgICAgfSk7XG4gICAgY29uc3QgZnJvbUJ5dGVzID0gQ1VSVkUuZnJvbUJ5dGVzIHx8XG4gICAgICAgICgoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIC8vIGNvbnN0IGhlYWQgPSBieXRlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHRhaWwgPSBieXRlcy5zdWJhcnJheSgxKTtcbiAgICAgICAgICAgIC8vIGlmIChoZWFkICE9PSAweDA0KSB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgbm9uLWNvbXByZXNzZWQgZW5jb2RpbmcgaXMgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICBjb25zdCB4ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoMCwgRnAuQllURVMpKTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheShGcC5CWVRFUywgMiAqIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgIH0pO1xuICAgIC8qKlxuICAgICAqIHnCsiA9IHjCsyArIGF4ICsgYjogU2hvcnQgd2VpZXJzdHJhc3MgY3VydmUgZm9ybXVsYVxuICAgICAqIEByZXR1cm5zIHnCslxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdlaWVyc3RyYXNzRXF1YXRpb24oeCkge1xuICAgICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgICAgICBjb25zdCB4MiA9IEZwLnNxcih4KTsgLy8geCAqIHhcbiAgICAgICAgY29uc3QgeDMgPSBGcC5tdWwoeDIsIHgpOyAvLyB4MiAqIHhcbiAgICAgICAgcmV0dXJuIEZwLmFkZChGcC5hZGQoeDMsIEZwLm11bCh4LCBhKSksIGIpOyAvLyB4MyArIGEgKiB4ICsgYlxuICAgIH1cbiAgICAvLyBWYWxpZGF0ZSB3aGV0aGVyIHRoZSBwYXNzZWQgY3VydmUgcGFyYW1zIGFyZSB2YWxpZC5cbiAgICAvLyBXZSBjaGVjayBpZiBjdXJ2ZSBlcXVhdGlvbiB3b3JrcyBmb3IgZ2VuZXJhdG9yIHBvaW50LlxuICAgIC8vIGBhc3NlcnRWYWxpZGl0eSgpYCB3b24ndCB3b3JrOiBgaXNUb3JzaW9uRnJlZSgpYCBpcyBub3QgYXZhaWxhYmxlIGF0IHRoaXMgcG9pbnQgaW4gYmxzMTItMzgxLlxuICAgIC8vIFByb2plY3RpdmVQb2ludCBjbGFzcyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0LlxuICAgIGlmICghRnAuZXFsKEZwLnNxcihDVVJWRS5HeSksIHdlaWVyc3RyYXNzRXF1YXRpb24oQ1VSVkUuR3gpKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgZ2VuZXJhdG9yIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0Jyk7XG4gICAgLy8gVmFsaWQgZ3JvdXAgZWxlbWVudHMgcmVzaWRlIGluIHJhbmdlIDEuLm4tMVxuICAgIGZ1bmN0aW9uIGlzV2l0aGluQ3VydmVPcmRlcihudW0pIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBudW0gPT09ICdiaWdpbnQnICYmIF8wbiA8IG51bSAmJiBudW0gPCBDVVJWRS5uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc3NlcnRHRShudW0pIHtcbiAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIobnVtKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdmFsaWQgYmlnaW50OiAwIDwgYmlnaW50IDwgY3VydmUubicpO1xuICAgIH1cbiAgICAvLyBWYWxpZGF0ZXMgaWYgcHJpdiBrZXkgaXMgdmFsaWQgYW5kIGNvbnZlcnRzIGl0IHRvIGJpZ2ludC5cbiAgICAvLyBTdXBwb3J0cyBvcHRpb25zIGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RocyBhbmQgd3JhcFByaXZhdGVLZXkuXG4gICAgZnVuY3Rpb24gbm9ybVByaXZhdGVLZXlUb1NjYWxhcihrZXkpIHtcbiAgICAgICAgY29uc3QgeyBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHM6IGxlbmd0aHMsIG5CeXRlTGVuZ3RoLCB3cmFwUHJpdmF0ZUtleSwgbiB9ID0gQ1VSVkU7XG4gICAgICAgIGlmIChsZW5ndGhzICYmIHR5cGVvZiBrZXkgIT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICBpZiAoa2V5IGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgICAgICAgICBrZXkgPSB1dC5ieXRlc1RvSGV4KGtleSk7XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgdG8gaGV4IHN0cmluZywgcGFkLiBFLmcuIFA1MjEgd291bGQgbm9ybSAxMzAtMTMyIGNoYXIgaGV4IHRvIDEzMi1jaGFyIGJ5dGVzXG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycgfHwgIWxlbmd0aHMuaW5jbHVkZXMoa2V5Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGtleScpO1xuICAgICAgICAgICAga2V5ID0ga2V5LnBhZFN0YXJ0KG5CeXRlTGVuZ3RoICogMiwgJzAnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbnVtO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbnVtID1cbiAgICAgICAgICAgICAgICB0eXBlb2Yga2V5ID09PSAnYmlnaW50J1xuICAgICAgICAgICAgICAgICAgICA/IGtleVxuICAgICAgICAgICAgICAgICAgICA6IHV0LmJ5dGVzVG9OdW1iZXJCRShlbnN1cmVCeXRlcygncHJpdmF0ZSBrZXknLCBrZXksIG5CeXRlTGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHByaXZhdGUga2V5IG11c3QgYmUgJHtuQnl0ZUxlbmd0aH0gYnl0ZXMsIGhleCBvciBiaWdpbnQsIG5vdCAke3R5cGVvZiBrZXl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdyYXBQcml2YXRlS2V5KVxuICAgICAgICAgICAgbnVtID0gbW9kLm1vZChudW0sIG4pOyAvLyBkaXNhYmxlZCBieSBkZWZhdWx0LCBlbmFibGVkIGZvciBCTFNcbiAgICAgICAgYXNzZXJ0R0UobnVtKTsgLy8gbnVtIGluIHJhbmdlIFsxLi5OLTFdXG4gICAgICAgIHJldHVybiBudW07XG4gICAgfVxuICAgIGNvbnN0IHBvaW50UHJlY29tcHV0ZXMgPSBuZXcgTWFwKCk7XG4gICAgZnVuY3Rpb24gYXNzZXJ0UHJqUG9pbnQob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBQb2ludCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2plY3RpdmVQb2ludCBleHBlY3RlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9qZWN0aXZlIFBvaW50IHdvcmtzIGluIDNkIC8gcHJvamVjdGl2ZSAoaG9tb2dlbmVvdXMpIGNvb3JkaW5hdGVzOiAoeCwgeSwgeikg4oiLICh4PXgveiwgeT15L3opXG4gICAgICogRGVmYXVsdCBQb2ludCB3b3JrcyBpbiAyZCAvIGFmZmluZSBjb29yZGluYXRlczogKHgsIHkpXG4gICAgICogV2UncmUgZG9pbmcgY2FsY3VsYXRpb25zIGluIHByb2plY3RpdmUsIGJlY2F1c2UgaXRzIG9wZXJhdGlvbnMgZG9uJ3QgcmVxdWlyZSBjb3N0bHkgaW52ZXJzaW9uLlxuICAgICAqL1xuICAgIGNsYXNzIFBvaW50IHtcbiAgICAgICAgY29uc3RydWN0b3IocHgsIHB5LCBweikge1xuICAgICAgICAgICAgdGhpcy5weCA9IHB4O1xuICAgICAgICAgICAgdGhpcy5weSA9IHB5O1xuICAgICAgICAgICAgdGhpcy5weiA9IHB6O1xuICAgICAgICAgICAgaWYgKHB4ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneCByZXF1aXJlZCcpO1xuICAgICAgICAgICAgaWYgKHB5ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneSByZXF1aXJlZCcpO1xuICAgICAgICAgICAgaWYgKHB6ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHopKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneiByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvZXMgbm90IHZhbGlkYXRlIGlmIHRoZSBwb2ludCBpcyBvbi1jdXJ2ZS5cbiAgICAgICAgLy8gVXNlIGZyb21IZXggaW5zdGVhZCwgb3IgY2FsbCBhc3NlcnRWYWxpZGl0eSgpIGxhdGVyLlxuICAgICAgICBzdGF0aWMgZnJvbUFmZmluZShwKSB7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHAgfHwge307XG4gICAgICAgICAgICBpZiAoIXAgfHwgIUZwLmlzVmFsaWQoeCkgfHwgIUZwLmlzVmFsaWQoeSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFmZmluZSBwb2ludCcpO1xuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2plY3RpdmUgcG9pbnQgbm90IGFsbG93ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IGlzMCA9IChpKSA9PiBGcC5lcWwoaSwgRnAuWkVSTyk7XG4gICAgICAgICAgICAvLyBmcm9tQWZmaW5lKHg6MCwgeTowKSB3b3VsZCBwcm9kdWNlICh4OjAsIHk6MCwgejoxKSwgYnV0IHdlIG5lZWQgKHg6MCwgeToxLCB6OjApXG4gICAgICAgICAgICBpZiAoaXMwKHgpICYmIGlzMCh5KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gUG9pbnQuWkVSTztcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSwgRnAuT05FKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGFrZXMgYSBidW5jaCBvZiBQcm9qZWN0aXZlIFBvaW50cyBidXQgZXhlY3V0ZXMgb25seSBvbmVcbiAgICAgICAgICogaW52ZXJzaW9uIG9uIGFsbCBvZiB0aGVtLiBJbnZlcnNpb24gaXMgdmVyeSBzbG93IG9wZXJhdGlvbixcbiAgICAgICAgICogc28gdGhpcyBpbXByb3ZlcyBwZXJmb3JtYW5jZSBtYXNzaXZlbHkuXG4gICAgICAgICAqIE9wdGltaXphdGlvbjogY29udmVydHMgYSBsaXN0IG9mIHByb2plY3RpdmUgcG9pbnRzIHRvIGEgbGlzdCBvZiBpZGVudGljYWwgcG9pbnRzIHdpdGggWj0xLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIG5vcm1hbGl6ZVoocG9pbnRzKSB7XG4gICAgICAgICAgICBjb25zdCB0b0ludiA9IEZwLmludmVydEJhdGNoKHBvaW50cy5tYXAoKHApID0+IHAucHopKTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludHMubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50LmZyb21BZmZpbmUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBoYXNoIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFBvaW50LlxuICAgICAgICAgKiBAcGFyYW0gaGV4IHNob3J0L2xvbmcgRUNEU0EgaGV4XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKGZyb21CeXRlcyhlbnN1cmVCeXRlcygncG9pbnRIZXgnLCBoZXgpKSk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aXBsaWVzIGdlbmVyYXRvciBwb2ludCBieSBwcml2YXRlS2V5LlxuICAgICAgICBzdGF0aWMgZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIFBvaW50LkJBU0UubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gXCJQcml2YXRlIG1ldGhvZFwiLCBkb24ndCB1c2UgaXQgZGlyZWN0bHlcbiAgICAgICAgX3NldFdpbmRvd1NpemUod2luZG93U2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5fV0lORE9XX1NJWkUgPSB3aW5kb3dTaXplO1xuICAgICAgICAgICAgcG9pbnRQcmVjb21wdXRlcy5kZWxldGUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQSBwb2ludCBvbiBjdXJ2ZSBpcyB2YWxpZCBpZiBpdCBjb25mb3JtcyB0byBlcXVhdGlvbi5cbiAgICAgICAgYXNzZXJ0VmFsaWRpdHkoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pczAoKSkge1xuICAgICAgICAgICAgICAgIC8vICgwLCAxLCAwKSBha2EgWkVSTyBpcyBpbnZhbGlkIGluIG1vc3QgY29udGV4dHMuXG4gICAgICAgICAgICAgICAgLy8gSW4gQkxTLCBaRVJPIGNhbiBiZSBzZXJpYWxpemVkLCBzbyB3ZSBhbGxvdyBpdC5cbiAgICAgICAgICAgICAgICAvLyAoMCwgMCwgMCkgaXMgd3JvbmcgcmVwcmVzZW50YXRpb24gb2YgWkVSTyBhbmQgaXMgYWx3YXlzIGludmFsaWQuXG4gICAgICAgICAgICAgICAgaWYgKENVUlZFLmFsbG93SW5maW5pdHlQb2ludCAmJiAhRnAuaXMwKHRoaXMucHkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IFpFUk8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNvbWUgM3JkLXBhcnR5IHRlc3QgdmVjdG9ycyByZXF1aXJlIGRpZmZlcmVudCB3b3JkaW5nIGJldHdlZW4gaGVyZSAmIGBmcm9tQ29tcHJlc3NlZEhleGBcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgeCwgeSBhcmUgdmFsaWQgZmllbGQgZWxlbWVudHNcbiAgICAgICAgICAgIGlmICghRnAuaXNWYWxpZCh4KSB8fCAhRnAuaXNWYWxpZCh5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogeCBvciB5IG5vdCBGRScpO1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IEZwLnNxcih5KTsgLy8gecKyXG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHdlaWVyc3RyYXNzRXF1YXRpb24oeCk7IC8vIHjCsyArIGF4ICsgYlxuICAgICAgICAgICAgaWYgKCFGcC5lcWwobGVmdCwgcmlnaHQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0Jyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNUb3JzaW9uRnJlZSgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBub3QgaW4gcHJpbWUtb3JkZXIgc3ViZ3JvdXAnKTtcbiAgICAgICAgfVxuICAgICAgICBoYXNFdmVuWSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgaWYgKEZwLmlzT2RkKVxuICAgICAgICAgICAgICAgIHJldHVybiAhRnAuaXNPZGQoeSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCBkb2Vzbid0IHN1cHBvcnQgaXNPZGRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXBhcmUgb25lIHBvaW50IHRvIGFub3RoZXIuXG4gICAgICAgICAqL1xuICAgICAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgICAgIGFzc2VydFByalBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBjb25zdCBVMSA9IEZwLmVxbChGcC5tdWwoWDEsIFoyKSwgRnAubXVsKFgyLCBaMSkpO1xuICAgICAgICAgICAgY29uc3QgVTIgPSBGcC5lcWwoRnAubXVsKFkxLCBaMiksIEZwLm11bChZMiwgWjEpKTtcbiAgICAgICAgICAgIHJldHVybiBVMSAmJiBVMjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRmxpcHMgcG9pbnQgdG8gb25lIGNvcnJlc3BvbmRpbmcgdG8gKHgsIC15KSBpbiBBZmZpbmUgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBuZWdhdGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMucHgsIEZwLm5lZyh0aGlzLnB5KSwgdGhpcy5weik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGRvdWJsaW5nIGZvcm11bGEuXG4gICAgICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gM1xuICAgICAgICAvLyBDb3N0OiA4TSArIDNTICsgMyphICsgMipiMyArIDE1YWRkLlxuICAgICAgICBkb3VibGUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgICAgICAgICAgY29uc3QgYjMgPSBGcC5tdWwoYiwgXzNuKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCBYMyA9IEZwLlpFUk8sIFkzID0gRnAuWkVSTywgWjMgPSBGcC5aRVJPOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGxldCB0MCA9IEZwLm11bChYMSwgWDEpOyAvLyBzdGVwIDFcbiAgICAgICAgICAgIGxldCB0MSA9IEZwLm11bChZMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMSk7XG4gICAgICAgICAgICBsZXQgdDMgPSBGcC5tdWwoWDEsIFkxKTtcbiAgICAgICAgICAgIHQzID0gRnAuYWRkKHQzLCB0Myk7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgWjMgPSBGcC5tdWwoWDEsIFoxKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChhLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChiMywgdDIpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWDMsIFkzKTsgLy8gc3RlcCAxMFxuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFkzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWTMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKGIzLCBaMyk7IC8vIHN0ZXAgMTVcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQwLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLm11bChhLCB0Myk7XG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgdDAgPSBGcC5hZGQoWjMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKHQwLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MCwgdDMpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKFkxLCBaMSk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQyID0gRnAuYWRkKHQyLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MiwgdDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIoWDMsIHQwKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQyLCB0MSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpOyAvLyBzdGVwIDMwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW5lcy1Db3N0ZWxsby1CYXRpbmEgZXhjZXB0aW9uLWZyZWUgYWRkaXRpb24gZm9ybXVsYS5cbiAgICAgICAgLy8gVGhlcmUgaXMgMzAlIGZhc3RlciBKYWNvYmlhbiBmb3JtdWxhLCBidXQgaXQgaXMgbm90IGNvbXBsZXRlLlxuICAgICAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE1LzEwNjAsIGFsZ29yaXRobSAxXG4gICAgICAgIC8vIENvc3Q6IDEyTSArIDBTICsgMyphICsgMypiMyArIDIzYWRkLlxuICAgICAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgICAgIGFzc2VydFByalBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBhID0gQ1VSVkUuYTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKENVUlZFLmIsIF8zbik7XG4gICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgyKTsgLy8gc3RlcCAxXG4gICAgICAgICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkyKTtcbiAgICAgICAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjIpO1xuICAgICAgICAgICAgbGV0IHQzID0gRnAuYWRkKFgxLCBZMSk7XG4gICAgICAgICAgICBsZXQgdDQgPSBGcC5hZGQoWDIsIFkyKTsgLy8gc3RlcCA1XG4gICAgICAgICAgICB0MyA9IEZwLm11bCh0MywgdDQpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDAsIHQxKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQzLCB0NCk7XG4gICAgICAgICAgICB0NCA9IEZwLmFkZChYMSwgWjEpO1xuICAgICAgICAgICAgbGV0IHQ1ID0gRnAuYWRkKFgyLCBaMik7IC8vIHN0ZXAgMTBcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKHQ0LCB0NSk7XG4gICAgICAgICAgICB0NSA9IEZwLmFkZCh0MCwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5zdWIodDQsIHQ1KTtcbiAgICAgICAgICAgIHQ1ID0gRnAuYWRkKFkxLCBaMSk7XG4gICAgICAgICAgICBYMyA9IEZwLmFkZChZMiwgWjIpOyAvLyBzdGVwIDE1XG4gICAgICAgICAgICB0NSA9IEZwLm11bCh0NSwgWDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgICAgICAgIHQ1ID0gRnAuc3ViKHQ1LCBYMyk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bChhLCB0NCk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChiMywgdDIpOyAvLyBzdGVwIDIwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChYMywgWjMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQxLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWjMpO1xuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyNVxuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKGIzLCB0NCk7XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MSwgdDIpO1xuICAgICAgICAgICAgdDIgPSBGcC5zdWIodDAsIHQyKTsgLy8gc3RlcCAzMFxuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDQsIHQyKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQxLCB0NCk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChZMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDUsIHQ0KTsgLy8gc3RlcCAzNVxuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MywgdDEpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwodDUsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCB0MCk7IC8vIHN0ZXAgNDBcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaXMwKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKFBvaW50LlpFUk8pO1xuICAgICAgICB9XG4gICAgICAgIHdOQUYobikge1xuICAgICAgICAgICAgcmV0dXJuIHduYWYud05BRkNhY2hlZCh0aGlzLCBwb2ludFByZWNvbXB1dGVzLCBuLCAoY29tcCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvSW52ID0gRnAuaW52ZXJ0QmF0Y2goY29tcC5tYXAoKHApID0+IHAucHopKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcC5tYXAoKHAsIGkpID0+IHAudG9BZmZpbmUodG9JbnZbaV0pKS5tYXAoUG9pbnQuZnJvbUFmZmluZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTm9uLWNvbnN0YW50LXRpbWUgbXVsdGlwbGljYXRpb24uIFVzZXMgZG91YmxlLWFuZC1hZGQgYWxnb3JpdGhtLlxuICAgICAgICAgKiBJdCdzIGZhc3RlciwgYnV0IHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiB5b3UgZG9uJ3QgY2FyZSBhYm91dFxuICAgICAgICAgKiBhbiBleHBvc2VkIHByaXZhdGUga2V5IGUuZy4gc2lnIHZlcmlmaWNhdGlvbiwgd2hpY2ggd29ya3Mgb3ZlciAqcHVibGljKiBrZXlzLlxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHlVbnNhZmUobikge1xuICAgICAgICAgICAgY29uc3QgSSA9IFBvaW50LlpFUk87XG4gICAgICAgICAgICBpZiAobiA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybiBJO1xuICAgICAgICAgICAgYXNzZXJ0R0Uobik7IC8vIFdpbGwgdGhyb3cgb24gMFxuICAgICAgICAgICAgaWYgKG4gPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbyB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoIWVuZG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHduYWYudW5zYWZlTGFkZGVyKHRoaXMsIG4pO1xuICAgICAgICAgICAgLy8gQXBwbHkgZW5kb21vcnBoaXNtXG4gICAgICAgICAgICBsZXQgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gZW5kby5zcGxpdFNjYWxhcihuKTtcbiAgICAgICAgICAgIGxldCBrMXAgPSBJO1xuICAgICAgICAgICAgbGV0IGsycCA9IEk7XG4gICAgICAgICAgICBsZXQgZCA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZSAoazEgPiBfMG4gfHwgazIgPiBfMG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoazEgJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIGsxcCA9IGsxcC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgaWYgKGsyICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBrMnAgPSBrMnAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIGsxID4+PSBfMW47XG4gICAgICAgICAgICAgICAgazIgPj49IF8xbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrMW5lZylcbiAgICAgICAgICAgICAgICBrMXAgPSBrMXAubmVnYXRlKCk7XG4gICAgICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICAgICAgazJwID0gazJwLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgazJwID0gbmV3IFBvaW50KEZwLm11bChrMnAucHgsIGVuZG8uYmV0YSksIGsycC5weSwgazJwLnB6KTtcbiAgICAgICAgICAgIHJldHVybiBrMXAuYWRkKGsycCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0YW50IHRpbWUgbXVsdGlwbGljYXRpb24uXG4gICAgICAgICAqIFVzZXMgd05BRiBtZXRob2QuIFdpbmRvd2VkIG1ldGhvZCBtYXkgYmUgMTAlIGZhc3RlcixcbiAgICAgICAgICogYnV0IHRha2VzIDJ4IGxvbmdlciB0byBnZW5lcmF0ZSBhbmQgY29uc3VtZXMgMnggbWVtb3J5LlxuICAgICAgICAgKiBVc2VzIHByZWNvbXB1dGVzIHdoZW4gYXZhaWxhYmxlLlxuICAgICAgICAgKiBVc2VzIGVuZG9tb3JwaGlzbSBmb3IgS29ibGl0eiBjdXJ2ZXMuXG4gICAgICAgICAqIEBwYXJhbSBzY2FsYXIgYnkgd2hpY2ggdGhlIHBvaW50IHdvdWxkIGJlIG11bHRpcGxpZWRcbiAgICAgICAgICogQHJldHVybnMgTmV3IHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseShzY2FsYXIpIHtcbiAgICAgICAgICAgIGFzc2VydEdFKHNjYWxhcik7XG4gICAgICAgICAgICBsZXQgbiA9IHNjYWxhcjtcbiAgICAgICAgICAgIGxldCBwb2ludCwgZmFrZTsgLy8gRmFrZSBwb2ludCBpcyB1c2VkIHRvIGNvbnN0LXRpbWUgbXVsdFxuICAgICAgICAgICAgY29uc3QgeyBlbmRvIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChlbmRvKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gZW5kby5zcGxpdFNjYWxhcihuKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMXAsIGY6IGYxcCB9ID0gdGhpcy53TkFGKGsxKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMnAsIGY6IGYycCB9ID0gdGhpcy53TkFGKGsyKTtcbiAgICAgICAgICAgICAgICBrMXAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMW5lZywgazFwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMm5lZywgazJwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSBuZXcgUG9pbnQoRnAubXVsKGsycC5weCwgZW5kby5iZXRhKSwgazJwLnB5LCBrMnAucHopO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gazFwLmFkZChrMnApO1xuICAgICAgICAgICAgICAgIGZha2UgPSBmMXAuYWRkKGYycCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHAsIGYgfSA9IHRoaXMud05BRihuKTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IHA7XG4gICAgICAgICAgICAgICAgZmFrZSA9IGY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgYHpgIGZvciBib3RoIHBvaW50cywgYnV0IHJldHVybiBvbmx5IHJlYWwgb25lXG4gICAgICAgICAgICByZXR1cm4gUG9pbnQubm9ybWFsaXplWihbcG9pbnQsIGZha2VdKVswXTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRWZmaWNpZW50bHkgY2FsY3VsYXRlIGBhUCArIGJRYC4gVW5zYWZlLCBjYW4gZXhwb3NlIHByaXZhdGUga2V5LCBpZiB1c2VkIGluY29ycmVjdGx5LlxuICAgICAgICAgKiBOb3QgdXNpbmcgU3RyYXVzcy1TaGFtaXIgdHJpY2s6IHByZWNvbXB1dGF0aW9uIHRhYmxlcyBhcmUgZmFzdGVyLlxuICAgICAgICAgKiBUaGUgdHJpY2sgY291bGQgYmUgdXNlZnVsIGlmIGJvdGggUCBhbmQgUSBhcmUgbm90IEcgKG5vdCBpbiBvdXIgY2FzZSkuXG4gICAgICAgICAqIEByZXR1cm5zIG5vbi16ZXJvIGFmZmluZSBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHlBbmRBZGRVbnNhZmUoUSwgYSwgYikge1xuICAgICAgICAgICAgY29uc3QgRyA9IFBvaW50LkJBU0U7IC8vIE5vIFN0cmF1c3MtU2hhbWlyIHRyaWNrOiB3ZSBoYXZlIDEwJSBmYXN0ZXIgRyBwcmVjb21wdXRlc1xuICAgICAgICAgICAgY29uc3QgbXVsID0gKFAsIGEgLy8gU2VsZWN0IGZhc3RlciBtdWx0aXBseSgpIG1ldGhvZFxuICAgICAgICAgICAgKSA9PiAoYSA9PT0gXzBuIHx8IGEgPT09IF8xbiB8fCAhUC5lcXVhbHMoRykgPyBQLm11bHRpcGx5VW5zYWZlKGEpIDogUC5tdWx0aXBseShhKSk7XG4gICAgICAgICAgICBjb25zdCBzdW0gPSBtdWwodGhpcywgYSkuYWRkKG11bChRLCBiKSk7XG4gICAgICAgICAgICByZXR1cm4gc3VtLmlzMCgpID8gdW5kZWZpbmVkIDogc3VtO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnZlcnRzIFByb2plY3RpdmUgcG9pbnQgdG8gYWZmaW5lICh4LCB5KSBjb29yZGluYXRlcy5cbiAgICAgICAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXG4gICAgICAgIC8vICh4LCB5LCB6KSDiiIsgKHg9eC96LCB5PXkveilcbiAgICAgICAgdG9BZmZpbmUoaXopIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IHgsIHB5OiB5LCBwejogeiB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGlzMCA9IHRoaXMuaXMwKCk7XG4gICAgICAgICAgICAvLyBJZiBpbnZaIHdhcyAwLCB3ZSByZXR1cm4gemVybyBwb2ludC4gSG93ZXZlciB3ZSBzdGlsbCB3YW50IHRvIGV4ZWN1dGVcbiAgICAgICAgICAgIC8vIGFsbCBvcGVyYXRpb25zLCBzbyB3ZSByZXBsYWNlIGludlogd2l0aCBhIHJhbmRvbSBudW1iZXIsIDEuXG4gICAgICAgICAgICBpZiAoaXogPT0gbnVsbClcbiAgICAgICAgICAgICAgICBpeiA9IGlzMCA/IEZwLk9ORSA6IEZwLmludih6KTtcbiAgICAgICAgICAgIGNvbnN0IGF4ID0gRnAubXVsKHgsIGl6KTtcbiAgICAgICAgICAgIGNvbnN0IGF5ID0gRnAubXVsKHksIGl6KTtcbiAgICAgICAgICAgIGNvbnN0IHp6ID0gRnAubXVsKHosIGl6KTtcbiAgICAgICAgICAgIGlmIChpczApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogRnAuWkVSTywgeTogRnAuWkVSTyB9O1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoenosIEZwLk9ORSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZaIHdhcyBpbnZhbGlkJyk7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBheCwgeTogYXkgfTtcbiAgICAgICAgfVxuICAgICAgICBpc1RvcnNpb25GcmVlKCkge1xuICAgICAgICAgICAgY29uc3QgeyBoOiBjb2ZhY3RvciwgaXNUb3JzaW9uRnJlZSB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gTm8gc3ViZ3JvdXBzLCBhbHdheXMgdG9yc2lvbi1mcmVlXG4gICAgICAgICAgICBpZiAoaXNUb3JzaW9uRnJlZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNUb3JzaW9uRnJlZShQb2ludCwgdGhpcyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lzVG9yc2lvbkZyZWUoKSBoYXMgbm90IGJlZW4gZGVjbGFyZWQgZm9yIHRoZSBlbGxpcHRpYyBjdXJ2ZScpO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyQ29mYWN0b3IoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGg6IGNvZmFjdG9yLCBjbGVhckNvZmFjdG9yIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChjb2ZhY3RvciA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBGYXN0LXBhdGhcbiAgICAgICAgICAgIGlmIChjbGVhckNvZmFjdG9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBjbGVhckNvZmFjdG9yKFBvaW50LCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5VW5zYWZlKENVUlZFLmgpO1xuICAgICAgICB9XG4gICAgICAgIHRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRvQnl0ZXMoUG9pbnQsIHRoaXMsIGlzQ29tcHJlc3NlZCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9IZXgoaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmJ5dGVzVG9IZXgodGhpcy50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFBvaW50LkJBU0UgPSBuZXcgUG9pbnQoQ1VSVkUuR3gsIENVUlZFLkd5LCBGcC5PTkUpO1xuICAgIFBvaW50LlpFUk8gPSBuZXcgUG9pbnQoRnAuWkVSTywgRnAuT05FLCBGcC5aRVJPKTtcbiAgICBjb25zdCBfYml0cyA9IENVUlZFLm5CaXRMZW5ndGg7XG4gICAgY29uc3Qgd25hZiA9IHdOQUYoUG9pbnQsIENVUlZFLmVuZG8gPyBNYXRoLmNlaWwoX2JpdHMgLyAyKSA6IF9iaXRzKTtcbiAgICAvLyBWYWxpZGF0ZSBpZiBnZW5lcmF0b3IgcG9pbnQgaXMgb24gY3VydmVcbiAgICByZXR1cm4ge1xuICAgICAgICBDVVJWRSxcbiAgICAgICAgUHJvamVjdGl2ZVBvaW50OiBQb2ludCxcbiAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcixcbiAgICAgICAgd2VpZXJzdHJhc3NFcXVhdGlvbixcbiAgICAgICAgaXNXaXRoaW5DdXJ2ZU9yZGVyLFxuICAgIH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU9wdHMoY3VydmUpIHtcbiAgICBjb25zdCBvcHRzID0gdmFsaWRhdGVCYXNpYyhjdXJ2ZSk7XG4gICAgdXQudmFsaWRhdGVPYmplY3Qob3B0cywge1xuICAgICAgICBoYXNoOiAnaGFzaCcsXG4gICAgICAgIGhtYWM6ICdmdW5jdGlvbicsXG4gICAgICAgIHJhbmRvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgIH0sIHtcbiAgICAgICAgYml0czJpbnQ6ICdmdW5jdGlvbicsXG4gICAgICAgIGJpdHMyaW50X21vZE46ICdmdW5jdGlvbicsXG4gICAgICAgIGxvd1M6ICdib29sZWFuJyxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IGxvd1M6IHRydWUsIC4uLm9wdHMgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gd2VpZXJzdHJhc3MoY3VydmVEZWYpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlT3B0cyhjdXJ2ZURlZik7XG4gICAgY29uc3QgeyBGcCwgbjogQ1VSVkVfT1JERVIgfSA9IENVUlZFO1xuICAgIGNvbnN0IGNvbXByZXNzZWRMZW4gPSBGcC5CWVRFUyArIDE7IC8vIGUuZy4gMzMgZm9yIDMyXG4gICAgY29uc3QgdW5jb21wcmVzc2VkTGVuID0gMiAqIEZwLkJZVEVTICsgMTsgLy8gZS5nLiA2NSBmb3IgMzJcbiAgICBmdW5jdGlvbiBpc1ZhbGlkRmllbGRFbGVtZW50KG51bSkge1xuICAgICAgICByZXR1cm4gXzBuIDwgbnVtICYmIG51bSA8IEZwLk9SREVSOyAvLyAwIGlzIGJhbm5lZCBzaW5jZSBpdCdzIG5vdCBpbnZlcnRpYmxlIEZFXG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vZE4oYSkge1xuICAgICAgICByZXR1cm4gbW9kLm1vZChhLCBDVVJWRV9PUkRFUik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludk4oYSkge1xuICAgICAgICByZXR1cm4gbW9kLmludmVydChhLCBDVVJWRV9PUkRFUik7XG4gICAgfVxuICAgIGNvbnN0IHsgUHJvamVjdGl2ZVBvaW50OiBQb2ludCwgbm9ybVByaXZhdGVLZXlUb1NjYWxhciwgd2VpZXJzdHJhc3NFcXVhdGlvbiwgaXNXaXRoaW5DdXJ2ZU9yZGVyLCB9ID0gd2VpZXJzdHJhc3NQb2ludHMoe1xuICAgICAgICAuLi5DVVJWRSxcbiAgICAgICAgdG9CeXRlcyhfYywgcG9pbnQsIGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgY29uc3QgYSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgICAgICAgICBjb25zdCB4ID0gRnAudG9CeXRlcyhhLngpO1xuICAgICAgICAgICAgY29uc3QgY2F0ID0gdXQuY29uY2F0Qnl0ZXM7XG4gICAgICAgICAgICBpZiAoaXNDb21wcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhdChVaW50OEFycmF5LmZyb20oW3BvaW50Lmhhc0V2ZW5ZKCkgPyAweDAyIDogMHgwM10pLCB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXQoVWludDhBcnJheS5mcm9tKFsweDA0XSksIHgsIEZwLnRvQnl0ZXMoYS55KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZyb21CeXRlcyhieXRlcykge1xuICAgICAgICAgICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgaGVhZCA9IGJ5dGVzWzBdO1xuICAgICAgICAgICAgY29uc3QgdGFpbCA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgICAgICAgICAgLy8gdGhpcy5hc3NlcnRWYWxpZGl0eSgpIGlzIGRvbmUgaW5zaWRlIG9mIGZyb21IZXhcbiAgICAgICAgICAgIGlmIChsZW4gPT09IGNvbXByZXNzZWRMZW4gJiYgKGhlYWQgPT09IDB4MDIgfHwgaGVhZCA9PT0gMHgwMykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gdXQuYnl0ZXNUb051bWJlckJFKHRhaWwpO1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEZpZWxkRWxlbWVudCh4KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBpcyBub3Qgb24gY3VydmUnKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5MiA9IHdlaWVyc3RyYXNzRXF1YXRpb24oeCk7IC8vIHnCsiA9IHjCsyArIGF4ICsgYlxuICAgICAgICAgICAgICAgIGxldCB5ID0gRnAuc3FydCh5Mik7IC8vIHkgPSB5wrIgXiAocCsxKS80XG4gICAgICAgICAgICAgICAgY29uc3QgaXNZT2RkID0gKHkgJiBfMW4pID09PSBfMW47XG4gICAgICAgICAgICAgICAgLy8gRUNEU0FcbiAgICAgICAgICAgICAgICBjb25zdCBpc0hlYWRPZGQgPSAoaGVhZCAmIDEpID09PSAxO1xuICAgICAgICAgICAgICAgIGlmIChpc0hlYWRPZGQgIT09IGlzWU9kZClcbiAgICAgICAgICAgICAgICAgICAgeSA9IEZwLm5lZyh5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsZW4gPT09IHVuY29tcHJlc3NlZExlbiAmJiBoZWFkID09PSAweDA0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvaW50IG9mIGxlbmd0aCAke2xlbn0gd2FzIGludmFsaWQuIEV4cGVjdGVkICR7Y29tcHJlc3NlZExlbn0gY29tcHJlc3NlZCBieXRlcyBvciAke3VuY29tcHJlc3NlZExlbn0gdW5jb21wcmVzc2VkIGJ5dGVzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgY29uc3QgbnVtVG9OQnl0ZVN0ciA9IChudW0pID0+IHV0LmJ5dGVzVG9IZXgodXQubnVtYmVyVG9CeXRlc0JFKG51bSwgQ1VSVkUubkJ5dGVMZW5ndGgpKTtcbiAgICBmdW5jdGlvbiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIobnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IEhBTEYgPSBDVVJWRV9PUkRFUiA+PiBfMW47XG4gICAgICAgIHJldHVybiBudW1iZXIgPiBIQUxGO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub3JtYWxpemVTKHMpIHtcbiAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSA/IG1vZE4oLXMpIDogcztcbiAgICB9XG4gICAgLy8gc2xpY2UgYnl0ZXMgbnVtXG4gICAgY29uc3Qgc2xjTnVtID0gKGIsIGZyb20sIHRvKSA9PiB1dC5ieXRlc1RvTnVtYmVyQkUoYi5zbGljZShmcm9tLCB0bykpO1xuICAgIC8qKlxuICAgICAqIEVDRFNBIHNpZ25hdHVyZSB3aXRoIGl0cyAociwgcykgcHJvcGVydGllcy4gU3VwcG9ydHMgREVSICYgY29tcGFjdCByZXByZXNlbnRhdGlvbnMuXG4gICAgICovXG4gICAgY2xhc3MgU2lnbmF0dXJlIHtcbiAgICAgICAgY29uc3RydWN0b3IociwgcywgcmVjb3ZlcnkpIHtcbiAgICAgICAgICAgIHRoaXMuciA9IHI7XG4gICAgICAgICAgICB0aGlzLnMgPSBzO1xuICAgICAgICAgICAgdGhpcy5yZWNvdmVyeSA9IHJlY292ZXJ5O1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhaXIgKGJ5dGVzIG9mIHIsIGJ5dGVzIG9mIHMpXG4gICAgICAgIHN0YXRpYyBmcm9tQ29tcGFjdChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBDVVJWRS5uQnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGhleCA9IGVuc3VyZUJ5dGVzKCdjb21wYWN0U2lnbmF0dXJlJywgaGV4LCBsICogMik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShzbGNOdW0oaGV4LCAwLCBsKSwgc2xjTnVtKGhleCwgbCwgMiAqIGwpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBERVIgZW5jb2RlZCBFQ0RTQSBzaWduYXR1cmVcbiAgICAgICAgLy8gaHR0cHM6Ly9iaXRjb2luLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy81NzY0NC93aGF0LWFyZS10aGUtcGFydHMtb2YtYS1iaXRjb2luLXRyYW5zYWN0aW9uLWlucHV0LXNjcmlwdFxuICAgICAgICBzdGF0aWMgZnJvbURFUihoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcyB9ID0gREVSLnRvU2lnKGVuc3VyZUJ5dGVzKCdERVInLCBoZXgpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICAgICAgLy8gY2FuIHVzZSBhc3NlcnRHRSBoZXJlXG4gICAgICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcih0aGlzLnIpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignciBtdXN0IGJlIDAgPCByIDwgQ1VSVkUubicpO1xuICAgICAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIodGhpcy5zKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3MgbXVzdCBiZSAwIDwgcyA8IENVUlZFLm4nKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRSZWNvdmVyeUJpdChyZWNvdmVyeSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUodGhpcy5yLCB0aGlzLnMsIHJlY292ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZWNvdmVyUHVibGljS2V5KG1zZ0hhc2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcywgcmVjb3Zlcnk6IHJlYyB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGggPSBiaXRzMmludF9tb2ROKGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCkpOyAvLyBUcnVuY2F0ZSBoYXNoXG4gICAgICAgICAgICBpZiAocmVjID09IG51bGwgfHwgIVswLCAxLCAyLCAzXS5pbmNsdWRlcyhyZWMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjb3ZlcnkgaWQgaW52YWxpZCcpO1xuICAgICAgICAgICAgY29uc3QgcmFkaiA9IHJlYyA9PT0gMiB8fCByZWMgPT09IDMgPyByICsgQ1VSVkUubiA6IHI7XG4gICAgICAgICAgICBpZiAocmFkaiA+PSBGcC5PUkRFUilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIDIgb3IgMyBpbnZhbGlkJyk7XG4gICAgICAgICAgICBjb25zdCBwcmVmaXggPSAocmVjICYgMSkgPT09IDAgPyAnMDInIDogJzAzJztcbiAgICAgICAgICAgIGNvbnN0IFIgPSBQb2ludC5mcm9tSGV4KHByZWZpeCArIG51bVRvTkJ5dGVTdHIocmFkaikpO1xuICAgICAgICAgICAgY29uc3QgaXIgPSBpbnZOKHJhZGopOyAvLyByXi0xXG4gICAgICAgICAgICBjb25zdCB1MSA9IG1vZE4oLWggKiBpcik7IC8vIC1ocl4tMVxuICAgICAgICAgICAgY29uc3QgdTIgPSBtb2ROKHMgKiBpcik7IC8vIHNyXi0xXG4gICAgICAgICAgICBjb25zdCBRID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShSLCB1MSwgdTIpOyAvLyAoc3JeLTEpUi0oaHJeLTEpRyA9IC0oaHJeLTEpRyArIChzcl4tMSlcbiAgICAgICAgICAgIGlmICghUSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvaW50IGF0IGluZmluaWZ5Jyk7IC8vIHVuc2FmZSBpcyBmaW5lOiBubyBwcml2IGRhdGEgbGVha2VkXG4gICAgICAgICAgICBRLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaWduYXR1cmVzIHNob3VsZCBiZSBsb3ctcywgdG8gcHJldmVudCBtYWxsZWFiaWxpdHkuXG4gICAgICAgIGhhc0hpZ2hTKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcih0aGlzLnMpO1xuICAgICAgICB9XG4gICAgICAgIG5vcm1hbGl6ZVMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNIaWdoUygpID8gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIG1vZE4oLXRoaXMucyksIHRoaXMucmVjb3ZlcnkpIDogdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBERVItZW5jb2RlZFxuICAgICAgICB0b0RFUlJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0RFUkhleCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0b0RFUkhleCgpIHtcbiAgICAgICAgICAgIHJldHVybiBERVIuaGV4RnJvbVNpZyh7IHI6IHRoaXMuciwgczogdGhpcy5zIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhZGRlZCBieXRlcyBvZiByLCB0aGVuIHBhZGRlZCBieXRlcyBvZiBzXG4gICAgICAgIHRvQ29tcGFjdFJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0NvbXBhY3RIZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9Db21wYWN0SGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bVRvTkJ5dGVTdHIodGhpcy5yKSArIG51bVRvTkJ5dGVTdHIodGhpcy5zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1dGlscyA9IHtcbiAgICAgICAgaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyOiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLFxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZXMgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHByaXZhdGUga2V5IGZyb20gcmFuZG9tIG9mIHNpemVcbiAgICAgICAgICogKGdyb3VwTGVuICsgY2VpbChncm91cExlbiAvIDIpKSB3aXRoIG1vZHVsbyBiaWFzIGJlaW5nIG5lZ2xpZ2libGUuXG4gICAgICAgICAqL1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBtb2QuZ2V0TWluSGFzaExlbmd0aChDVVJWRS5uKTtcbiAgICAgICAgICAgIHJldHVybiBtb2QubWFwSGFzaFRvRmllbGQoQ1VSVkUucmFuZG9tQnl0ZXMobGVuZ3RoKSwgQ1VSVkUubik7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIHByZWNvbXB1dGUgdGFibGUgZm9yIGFuIGFyYml0cmFyeSBFQyBwb2ludC4gTWFrZXMgcG9pbnQgXCJjYWNoZWRcIi5cbiAgICAgICAgICogQWxsb3dzIHRvIG1hc3NpdmVseSBzcGVlZC11cCBgcG9pbnQubXVsdGlwbHkoc2NhbGFyKWAuXG4gICAgICAgICAqIEByZXR1cm5zIGNhY2hlZCBwb2ludFxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBjb25zdCBmYXN0ID0gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuZnJvbUhleChzb21lb25lc1B1YktleSkpO1xuICAgICAgICAgKiBmYXN0Lm11bHRpcGx5KHByaXZLZXkpOyAvLyBtdWNoIGZhc3RlciBFQ0RIIG5vd1xuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZSh3aW5kb3dTaXplID0gOCwgcG9pbnQgPSBQb2ludC5CQVNFKSB7XG4gICAgICAgICAgICBwb2ludC5fc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKTtcbiAgICAgICAgICAgIHBvaW50Lm11bHRpcGx5KEJpZ0ludCgzKSk7IC8vIDMgaXMgYXJiaXRyYXJ5LCBqdXN0IG5lZWQgYW55IG51bWJlciBoZXJlXG4gICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBwdWJsaWMga2V5IGZvciBhIHByaXZhdGUga2V5LiBDaGVja3MgZm9yIHZhbGlkaXR5IG9mIHRoZSBwcml2YXRlIGtleS5cbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUtleSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG4gICAgICogQHJldHVybnMgUHVibGljIGtleSwgZnVsbCB3aGVuIGlzQ29tcHJlc3NlZD1mYWxzZTsgc2hvcnQgd2hlbiBpc0NvbXByZXNzZWQ9dHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFB1YmxpY0tleShwcml2YXRlS2V5LCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBQb2ludC5mcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1aWNrIGFuZCBkaXJ0eSBjaGVjayBmb3IgaXRlbSBiZWluZyBwdWJsaWMga2V5LiBEb2VzIG5vdCB2YWxpZGF0ZSBoZXgsIG9yIGJlaW5nIG9uLWN1cnZlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUHJvYlB1YihpdGVtKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IGl0ZW0gaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuICAgICAgICBjb25zdCBzdHIgPSB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZyc7XG4gICAgICAgIGNvbnN0IGxlbiA9IChhcnIgfHwgc3RyKSAmJiBpdGVtLmxlbmd0aDtcbiAgICAgICAgaWYgKGFycilcbiAgICAgICAgICAgIHJldHVybiBsZW4gPT09IGNvbXByZXNzZWRMZW4gfHwgbGVuID09PSB1bmNvbXByZXNzZWRMZW47XG4gICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICByZXR1cm4gbGVuID09PSAyICogY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IDIgKiB1bmNvbXByZXNzZWRMZW47XG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFQ0RIIChFbGxpcHRpYyBDdXJ2ZSBEaWZmaWUgSGVsbG1hbikuXG4gICAgICogQ29tcHV0ZXMgc2hhcmVkIHB1YmxpYyBrZXkgZnJvbSBwcml2YXRlIGtleSBhbmQgcHVibGljIGtleS5cbiAgICAgKiBDaGVja3M6IDEpIHByaXZhdGUga2V5IHZhbGlkaXR5IDIpIHNoYXJlZCBrZXkgaXMgb24tY3VydmUuXG4gICAgICogRG9lcyBOT1QgaGFzaCB0aGUgcmVzdWx0LlxuICAgICAqIEBwYXJhbSBwcml2YXRlQSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBwdWJsaWNCIGRpZmZlcmVudCBwdWJsaWMga2V5XG4gICAgICogQHBhcmFtIGlzQ29tcHJlc3NlZCB3aGV0aGVyIHRvIHJldHVybiBjb21wYWN0IChkZWZhdWx0KSwgb3IgZnVsbCBrZXlcbiAgICAgKiBAcmV0dXJucyBzaGFyZWQgcHVibGljIGtleVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFNoYXJlZFNlY3JldChwcml2YXRlQSwgcHVibGljQiwgaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICBpZiAoaXNQcm9iUHViKHByaXZhdGVBKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJnIG11c3QgYmUgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgaWYgKCFpc1Byb2JQdWIocHVibGljQikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlY29uZCBhcmcgbXVzdCBiZSBwdWJsaWMga2V5Jyk7XG4gICAgICAgIGNvbnN0IGIgPSBQb2ludC5mcm9tSGV4KHB1YmxpY0IpOyAvLyBjaGVjayBmb3IgYmVpbmcgb24tY3VydmVcbiAgICAgICAgcmV0dXJuIGIubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlQSkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgICB9XG4gICAgLy8gUkZDNjk3OTogZW5zdXJlIEVDRFNBIG1zZyBpcyBYIGJ5dGVzIGFuZCA8IE4uIFJGQyBzdWdnZXN0cyBvcHRpb25hbCB0cnVuY2F0aW5nIHZpYSBiaXRzMm9jdGV0cy5cbiAgICAvLyBGSVBTIDE4Ni00IDQuNiBzdWdnZXN0cyB0aGUgbGVmdG1vc3QgbWluKG5CaXRMZW4sIG91dExlbikgYml0cywgd2hpY2ggbWF0Y2hlcyBiaXRzMmludC5cbiAgICAvLyBiaXRzMmludCBjYW4gcHJvZHVjZSByZXM+Tiwgd2UgY2FuIGRvIG1vZChyZXMsIE4pIHNpbmNlIHRoZSBiaXRMZW4gaXMgdGhlIHNhbWUuXG4gICAgLy8gaW50Mm9jdGV0cyBjYW4ndCBiZSB1c2VkOyBwYWRzIHNtYWxsIG1zZ3Mgd2l0aCAwOiB1bmFjY2VwdGF0YmxlIGZvciB0cnVuYyBhcyBwZXIgUkZDIHZlY3RvcnNcbiAgICBjb25zdCBiaXRzMmludCA9IENVUlZFLmJpdHMyaW50IHx8XG4gICAgICAgIGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICAgICAgLy8gRm9yIGN1cnZlcyB3aXRoIG5CaXRMZW5ndGggJSA4ICE9PSAwOiBiaXRzMm9jdGV0cyhiaXRzMm9jdGV0cyhtKSkgIT09IGJpdHMyb2N0ZXRzKG0pXG4gICAgICAgICAgICAvLyBmb3Igc29tZSBjYXNlcywgc2luY2UgYnl0ZXMubGVuZ3RoICogOCBpcyBub3QgYWN0dWFsIGJpdExlbmd0aC5cbiAgICAgICAgICAgIGNvbnN0IG51bSA9IHV0LmJ5dGVzVG9OdW1iZXJCRShieXRlcyk7IC8vIGNoZWNrIGZvciA9PSB1OCBkb25lIGhlcmVcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gYnl0ZXMubGVuZ3RoICogOCAtIENVUlZFLm5CaXRMZW5ndGg7IC8vIHRydW5jYXRlIHRvIG5CaXRMZW5ndGggbGVmdG1vc3QgYml0c1xuICAgICAgICAgICAgcmV0dXJuIGRlbHRhID4gMCA/IG51bSA+PiBCaWdJbnQoZGVsdGEpIDogbnVtO1xuICAgICAgICB9O1xuICAgIGNvbnN0IGJpdHMyaW50X21vZE4gPSBDVVJWRS5iaXRzMmludF9tb2ROIHx8XG4gICAgICAgIGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICAgICAgcmV0dXJuIG1vZE4oYml0czJpbnQoYnl0ZXMpKTsgLy8gY2FuJ3QgdXNlIGJ5dGVzVG9OdW1iZXJCRSBoZXJlXG4gICAgICAgIH07XG4gICAgLy8gTk9URTogcGFkcyBvdXRwdXQgd2l0aCB6ZXJvIGFzIHBlciBzcGVjXG4gICAgY29uc3QgT1JERVJfTUFTSyA9IHV0LmJpdE1hc2soQ1VSVkUubkJpdExlbmd0aCk7XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdG8gYnl0ZXMuIENoZWNrcyBpZiBudW0gaW4gYFswLi5PUkRFUl9NQVNLLTFdYCBlLmcuOiBgWzAuLjJeMjU2LTFdYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnQyb2N0ZXRzKG51bSkge1xuICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpZ2ludCBleHBlY3RlZCcpO1xuICAgICAgICBpZiAoIShfMG4gPD0gbnVtICYmIG51bSA8IE9SREVSX01BU0spKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiaWdpbnQgZXhwZWN0ZWQgPCAyXiR7Q1VSVkUubkJpdExlbmd0aH1gKTtcbiAgICAgICAgLy8gd29ya3Mgd2l0aCBvcmRlciwgY2FuIGhhdmUgZGlmZmVyZW50IHNpemUgdGhhbiBudW1Ub0ZpZWxkIVxuICAgICAgICByZXR1cm4gdXQubnVtYmVyVG9CeXRlc0JFKG51bSwgQ1VSVkUubkJ5dGVMZW5ndGgpO1xuICAgIH1cbiAgICAvLyBTdGVwcyBBLCBEIG9mIFJGQzY5NzkgMy4yXG4gICAgLy8gQ3JlYXRlcyBSRkM2OTc5IHNlZWQ7IGNvbnZlcnRzIG1zZy9wcml2S2V5IHRvIG51bWJlcnMuXG4gICAgLy8gVXNlZCBvbmx5IGluIHNpZ24sIG5vdCBpbiB2ZXJpZnkuXG4gICAgLy8gTk9URTogd2UgY2Fubm90IGFzc3VtZSBoZXJlIHRoYXQgbXNnSGFzaCBoYXMgc2FtZSBhbW91bnQgb2YgYnl0ZXMgYXMgY3VydmUgb3JkZXIsIHRoaXMgd2lsbCBiZSB3cm9uZyBhdCBsZWFzdCBmb3IgUDUyMS5cbiAgICAvLyBBbHNvIGl0IGNhbiBiZSBiaWdnZXIgZm9yIFAyMjQgKyBTSEEyNTZcbiAgICBmdW5jdGlvbiBwcmVwU2lnKG1zZ0hhc2gsIHByaXZhdGVLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBpZiAoWydyZWNvdmVyZWQnLCAnY2Fub25pY2FsJ10uc29tZSgoaykgPT4gayBpbiBvcHRzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbigpIGxlZ2FjeSBvcHRpb25zIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgY29uc3QgeyBoYXNoLCByYW5kb21CeXRlcyB9ID0gQ1VSVkU7XG4gICAgICAgIGxldCB7IGxvd1MsIHByZWhhc2gsIGV4dHJhRW50cm9weTogZW50IH0gPSBvcHRzOyAvLyBnZW5lcmF0ZXMgbG93LXMgc2lncyBieSBkZWZhdWx0XG4gICAgICAgIGlmIChsb3dTID09IG51bGwpXG4gICAgICAgICAgICBsb3dTID0gdHJ1ZTsgLy8gUkZDNjk3OSAzLjI6IHdlIHNraXAgc3RlcCBBLCBiZWNhdXNlIHdlIGFscmVhZHkgcHJvdmlkZSBoYXNoXG4gICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpO1xuICAgICAgICBpZiAocHJlaGFzaClcbiAgICAgICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygncHJlaGFzaGVkIG1zZ0hhc2gnLCBoYXNoKG1zZ0hhc2gpKTtcbiAgICAgICAgLy8gV2UgY2FuJ3QgbGF0ZXIgY2FsbCBiaXRzMm9jdGV0cywgc2luY2UgbmVzdGVkIGJpdHMyaW50IGlzIGJyb2tlbiBmb3IgY3VydmVzXG4gICAgICAgIC8vIHdpdGggbkJpdExlbmd0aCAlIDggIT09IDAuIEJlY2F1c2Ugb2YgdGhhdCwgd2UgdW53cmFwIGl0IGhlcmUgYXMgaW50Mm9jdGV0cyBjYWxsLlxuICAgICAgICAvLyBjb25zdCBiaXRzMm9jdGV0cyA9IChiaXRzKSA9PiBpbnQyb2N0ZXRzKGJpdHMyaW50X21vZE4oYml0cykpXG4gICAgICAgIGNvbnN0IGgxaW50ID0gYml0czJpbnRfbW9kTihtc2dIYXNoKTtcbiAgICAgICAgY29uc3QgZCA9IG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSk7IC8vIHZhbGlkYXRlIHByaXZhdGUga2V5LCBjb252ZXJ0IHRvIGJpZ2ludFxuICAgICAgICBjb25zdCBzZWVkQXJncyA9IFtpbnQyb2N0ZXRzKGQpLCBpbnQyb2N0ZXRzKGgxaW50KV07XG4gICAgICAgIC8vIGV4dHJhRW50cm9weS4gUkZDNjk3OSAzLjY6IGFkZGl0aW9uYWwgaycgKG9wdGlvbmFsKS5cbiAgICAgICAgaWYgKGVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBLID0gSE1BQ19LKFYgfHwgMHgwMCB8fCBpbnQyb2N0ZXRzKHgpIHx8IGJpdHMyb2N0ZXRzKGgxKSB8fCBrJylcbiAgICAgICAgICAgIGNvbnN0IGUgPSBlbnQgPT09IHRydWUgPyByYW5kb21CeXRlcyhGcC5CWVRFUykgOiBlbnQ7IC8vIGdlbmVyYXRlIHJhbmRvbSBieXRlcyBPUiBwYXNzIGFzLWlzXG4gICAgICAgICAgICBzZWVkQXJncy5wdXNoKGVuc3VyZUJ5dGVzKCdleHRyYUVudHJvcHknLCBlKSk7IC8vIGNoZWNrIGZvciBiZWluZyBieXRlc1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlZWQgPSB1dC5jb25jYXRCeXRlcyguLi5zZWVkQXJncyk7IC8vIFN0ZXAgRCBvZiBSRkM2OTc5IDMuMlxuICAgICAgICBjb25zdCBtID0gaDFpbnQ7IC8vIE5PVEU6IG5vIG5lZWQgdG8gY2FsbCBiaXRzMmludCBzZWNvbmQgdGltZSBoZXJlLCBpdCBpcyBpbnNpZGUgdHJ1bmNhdGVIYXNoIVxuICAgICAgICAvLyBDb252ZXJ0cyBzaWduYXR1cmUgcGFyYW1zIGludG8gcG9pbnQgdyByL3MsIGNoZWNrcyByZXN1bHQgZm9yIHZhbGlkaXR5LlxuICAgICAgICBmdW5jdGlvbiBrMnNpZyhrQnl0ZXMpIHtcbiAgICAgICAgICAgIC8vIFJGQyA2OTc5IFNlY3Rpb24gMy4yLCBzdGVwIDM6IGsgPSBiaXRzMmludChUKVxuICAgICAgICAgICAgY29uc3QgayA9IGJpdHMyaW50KGtCeXRlcyk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKGspKVxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gSW1wb3J0YW50OiBhbGwgbW9kKCkgY2FsbHMgaGVyZSBtdXN0IGJlIGRvbmUgb3ZlciBOXG4gICAgICAgICAgICBjb25zdCBpayA9IGludk4oayk7IC8vIGteLTEgbW9kIG5cbiAgICAgICAgICAgIGNvbnN0IHEgPSBQb2ludC5CQVNFLm11bHRpcGx5KGspLnRvQWZmaW5lKCk7IC8vIHEgPSBHa1xuICAgICAgICAgICAgY29uc3QgciA9IG1vZE4ocS54KTsgLy8gciA9IHEueCBtb2QgblxuICAgICAgICAgICAgaWYgKHIgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBDYW4gdXNlIHNjYWxhciBibGluZGluZyBiXi0xKGJtICsgYmRyKSB3aGVyZSBiIOKIiCBbMSxx4oiSMV0gYWNjb3JkaW5nIHRvXG4gICAgICAgICAgICAvLyBodHRwczovL3RjaGVzLmlhY3Iub3JnL2luZGV4LnBocC9UQ0hFUy9hcnRpY2xlL3ZpZXcvNzMzNy82NTA5LiBXZSd2ZSBkZWNpZGVkIGFnYWluc3QgaXQ6XG4gICAgICAgICAgICAvLyBhKSBkZXBlbmRlbmN5IG9uIENTUFJORyBiKSAxNSUgc2xvd2Rvd24gYykgZG9lc24ndCByZWFsbHkgaGVscCBzaW5jZSBiaWdpbnRzIGFyZSBub3QgQ1RcbiAgICAgICAgICAgIGNvbnN0IHMgPSBtb2ROKGlrICogbW9kTihtICsgciAqIGQpKTsgLy8gTm90IHVzaW5nIGJsaW5kaW5nIGhlcmVcbiAgICAgICAgICAgIGlmIChzID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHJlY292ZXJ5ID0gKHEueCA9PT0gciA/IDAgOiAyKSB8IE51bWJlcihxLnkgJiBfMW4pOyAvLyByZWNvdmVyeSBiaXQgKDIgb3IgMywgd2hlbiBxLnggPiBuKVxuICAgICAgICAgICAgbGV0IG5vcm1TID0gcztcbiAgICAgICAgICAgIGlmIChsb3dTICYmIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSkge1xuICAgICAgICAgICAgICAgIG5vcm1TID0gbm9ybWFsaXplUyhzKTsgLy8gaWYgbG93UyB3YXMgcGFzc2VkLCBlbnN1cmUgcyBpcyBhbHdheXNcbiAgICAgICAgICAgICAgICByZWNvdmVyeSBePSAxOyAvLyAvLyBpbiB0aGUgYm90dG9tIGhhbGYgb2YgTlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgbm9ybVMsIHJlY292ZXJ5KTsgLy8gdXNlIG5vcm1TLCBub3Qgc1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHNlZWQsIGsyc2lnIH07XG4gICAgfVxuICAgIGNvbnN0IGRlZmF1bHRTaWdPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIGNvbnN0IGRlZmF1bHRWZXJPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIC8qKlxuICAgICAqIFNpZ25zIG1lc3NhZ2UgaGFzaCB3aXRoIGEgcHJpdmF0ZSBrZXkuXG4gICAgICogYGBgXG4gICAgICogc2lnbihtLCBkLCBrKSB3aGVyZVxuICAgICAqICAgKHgsIHkpID0gRyDDlyBrXG4gICAgICogICByID0geCBtb2QgblxuICAgICAqICAgcyA9IChtICsgZHIpL2sgbW9kIG5cbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gbXNnSGFzaCBOT1QgbWVzc2FnZS4gbXNnIG5lZWRzIHRvIGJlIGhhc2hlZCB0byBgbXNnSGFzaGAsIG9yIHVzZSBgcHJlaGFzaGAuXG4gICAgICogQHBhcmFtIHByaXZLZXkgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0gb3B0cyBsb3dTIGZvciBub24tbWFsbGVhYmxlIHNpZ3MuIGV4dHJhRW50cm9weSBmb3IgbWl4aW5nIHJhbmRvbW5lc3MgaW50byBrLiBwcmVoYXNoIHdpbGwgaGFzaCBmaXJzdCBhcmcuXG4gICAgICogQHJldHVybnMgc2lnbmF0dXJlIHdpdGggcmVjb3ZlcnkgcGFyYW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaWduKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBjb25zdCB7IHNlZWQsIGsyc2lnIH0gPSBwcmVwU2lnKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMpOyAvLyBTdGVwcyBBLCBEIG9mIFJGQzY5NzkgMy4yLlxuICAgICAgICBjb25zdCBDID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IGRyYmcgPSB1dC5jcmVhdGVIbWFjRHJiZyhDLmhhc2gub3V0cHV0TGVuLCBDLm5CeXRlTGVuZ3RoLCBDLmhtYWMpO1xuICAgICAgICByZXR1cm4gZHJiZyhzZWVkLCBrMnNpZyk7IC8vIFN0ZXBzIEIsIEMsIEQsIEUsIEYsIEdcbiAgICB9XG4gICAgLy8gRW5hYmxlIHByZWNvbXB1dGVzLiBTbG93cyBkb3duIGZpcnN0IHB1YmxpY0tleSBjb21wdXRhdGlvbiBieSAyMG1zLlxuICAgIFBvaW50LkJBU0UuX3NldFdpbmRvd1NpemUoOCk7XG4gICAgLy8gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuQkFTRSlcbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBhIHNpZ25hdHVyZSBhZ2FpbnN0IG1lc3NhZ2UgaGFzaCBhbmQgcHVibGljIGtleS5cbiAgICAgKiBSZWplY3RzIGxvd1Mgc2lnbmF0dXJlcyBieSBkZWZhdWx0OiB0byBvdmVycmlkZSxcbiAgICAgKiBzcGVjaWZ5IG9wdGlvbiBge2xvd1M6IGZhbHNlfWAuIEltcGxlbWVudHMgc2VjdGlvbiA0LjEuNCBmcm9tIGh0dHBzOi8vd3d3LnNlY2cub3JnL3NlYzEtdjIucGRmOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogdmVyaWZ5KHIsIHMsIGgsIFApIHdoZXJlXG4gICAgICogICBVMSA9IGhzXi0xIG1vZCBuXG4gICAgICogICBVMiA9IHJzXi0xIG1vZCBuXG4gICAgICogICBSID0gVTHii4VHIC0gVTLii4VQXG4gICAgICogICBtb2QoUi54LCBuKSA9PSByXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmVyaWZ5KHNpZ25hdHVyZSwgbXNnSGFzaCwgcHVibGljS2V5LCBvcHRzID0gZGVmYXVsdFZlck9wdHMpIHtcbiAgICAgICAgY29uc3Qgc2cgPSBzaWduYXR1cmU7XG4gICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpO1xuICAgICAgICBwdWJsaWNLZXkgPSBlbnN1cmVCeXRlcygncHVibGljS2V5JywgcHVibGljS2V5KTtcbiAgICAgICAgaWYgKCdzdHJpY3QnIGluIG9wdHMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMuc3RyaWN0IHdhcyByZW5hbWVkIHRvIGxvd1MnKTtcbiAgICAgICAgY29uc3QgeyBsb3dTLCBwcmVoYXNoIH0gPSBvcHRzO1xuICAgICAgICBsZXQgX3NpZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IFA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNnID09PSAnc3RyaW5nJyB8fCBzZyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgICAvLyBTaWduYXR1cmUgY2FuIGJlIHJlcHJlc2VudGVkIGluIDIgd2F5czogY29tcGFjdCAoMipuQnl0ZUxlbmd0aCkgJiBERVIgKHZhcmlhYmxlLWxlbmd0aCkuXG4gICAgICAgICAgICAgICAgLy8gU2luY2UgREVSIGNhbiBhbHNvIGJlIDIqbkJ5dGVMZW5ndGggYnl0ZXMsIHdlIGNoZWNrIGZvciBpdCBmaXJzdC5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21ERVIoc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZGVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZGVyRXJyb3IgaW5zdGFuY2VvZiBERVIuRXJyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRlckVycm9yO1xuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21Db21wYWN0KHNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2cgPT09ICdvYmplY3QnICYmIHR5cGVvZiBzZy5yID09PSAnYmlnaW50JyAmJiB0eXBlb2Ygc2cucyA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHIsIHMgfSA9IHNnO1xuICAgICAgICAgICAgICAgIF9zaWcgPSBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQQVJTRScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUCA9IFBvaW50LmZyb21IZXgocHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlID09PSAnUEFSU0UnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc2lnbmF0dXJlIG11c3QgYmUgU2lnbmF0dXJlIGluc3RhbmNlLCBVaW50OEFycmF5IG9yIGhleCBzdHJpbmdgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG93UyAmJiBfc2lnLmhhc0hpZ2hTKCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnSGFzaCA9IENVUlZFLmhhc2gobXNnSGFzaCk7XG4gICAgICAgIGNvbnN0IHsgciwgcyB9ID0gX3NpZztcbiAgICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4obXNnSGFzaCk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgY29uc3QgaXMgPSBpbnZOKHMpOyAvLyBzXi0xXG4gICAgICAgIGNvbnN0IHUxID0gbW9kTihoICogaXMpOyAvLyB1MSA9IGhzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IHUyID0gbW9kTihyICogaXMpOyAvLyB1MiA9IHJzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IFIgPSBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFAsIHUxLCB1Mik/LnRvQWZmaW5lKCk7IC8vIFIgPSB1MeKLhUcgKyB1MuKLhVBcbiAgICAgICAgaWYgKCFSKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCB2ID0gbW9kTihSLngpO1xuICAgICAgICByZXR1cm4gdiA9PT0gcjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIGdldFB1YmxpY0tleSxcbiAgICAgICAgZ2V0U2hhcmVkU2VjcmV0LFxuICAgICAgICBzaWduLFxuICAgICAgICB2ZXJpZnksXG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIFNpZ25hdHVyZSxcbiAgICAgICAgdXRpbHMsXG4gICAgfTtcbn1cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFNoYWxsdWUgYW5kIHZhbiBkZSBXb2VzdGlqbmUgbWV0aG9kIGZvciBhbnkgd2VpZXJzdHJhc3MgY3VydmUuXG4gKiBUT0RPOiBjaGVjayBpZiB0aGVyZSBpcyBhIHdheSB0byBtZXJnZSB0aGlzIHdpdGggdXZSYXRpbyBpbiBFZHdhcmRzOyBtb3ZlIHRvIG1vZHVsYXIuXG4gKiBiID0gVHJ1ZSBhbmQgeSA9IHNxcnQodSAvIHYpIGlmICh1IC8gdikgaXMgc3F1YXJlIGluIEYsIGFuZFxuICogYiA9IEZhbHNlIGFuZCB5ID0gc3FydChaICogKHUgLyB2KSkgb3RoZXJ3aXNlLlxuICogQHBhcmFtIEZwXG4gKiBAcGFyYW0gWlxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFNXVUZwU3FydFJhdGlvKEZwLCBaKSB7XG4gICAgLy8gR2VuZXJpYyBpbXBsZW1lbnRhdGlvblxuICAgIGNvbnN0IHEgPSBGcC5PUkRFUjtcbiAgICBsZXQgbCA9IF8wbjtcbiAgICBmb3IgKGxldCBvID0gcSAtIF8xbjsgbyAlIF8ybiA9PT0gXzBuOyBvIC89IF8ybilcbiAgICAgICAgbCArPSBfMW47XG4gICAgY29uc3QgYzEgPSBsOyAvLyAxLiBjMSwgdGhlIGxhcmdlc3QgaW50ZWdlciBzdWNoIHRoYXQgMl5jMSBkaXZpZGVzIHEgLSAxLlxuICAgIC8vIFdlIG5lZWQgMm4gKiogYzEgYW5kIDJuICoqIChjMS0xKS4gV2UgY2FuJ3QgdXNlICoqOyBidXQgd2UgY2FuIHVzZSA8PC5cbiAgICAvLyAybiAqKiBjMSA9PSAybiA8PCAoYzEtMSlcbiAgICBjb25zdCBfMm5fcG93X2MxXzEgPSBfMm4gPDwgKGMxIC0gXzFuIC0gXzFuKTtcbiAgICBjb25zdCBfMm5fcG93X2MxID0gXzJuX3Bvd19jMV8xICogXzJuO1xuICAgIGNvbnN0IGMyID0gKHEgLSBfMW4pIC8gXzJuX3Bvd19jMTsgLy8gMi4gYzIgPSAocSAtIDEpIC8gKDJeYzEpICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGMzID0gKGMyIC0gXzFuKSAvIF8ybjsgLy8gMy4gYzMgPSAoYzIgLSAxKSAvIDIgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM0ID0gXzJuX3Bvd19jMSAtIF8xbjsgLy8gNC4gYzQgPSAyXmMxIC0gMSAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM1ID0gXzJuX3Bvd19jMV8xOyAvLyA1LiBjNSA9IDJeKGMxIC0gMSkgICAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM2ID0gRnAucG93KFosIGMyKTsgLy8gNi4gYzYgPSBaXmMyXG4gICAgY29uc3QgYzcgPSBGcC5wb3coWiwgKGMyICsgXzFuKSAvIF8ybik7IC8vIDcuIGM3ID0gWl4oKGMyICsgMSkgLyAyKVxuICAgIGxldCBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICBsZXQgdHYxID0gYzY7IC8vIDEuIHR2MSA9IGM2XG4gICAgICAgIGxldCB0djIgPSBGcC5wb3codiwgYzQpOyAvLyAyLiB0djIgPSB2XmM0XG4gICAgICAgIGxldCB0djMgPSBGcC5zcXIodHYyKTsgLy8gMy4gdHYzID0gdHYyXjJcbiAgICAgICAgdHYzID0gRnAubXVsKHR2Mywgdik7IC8vIDQuIHR2MyA9IHR2MyAqIHZcbiAgICAgICAgbGV0IHR2NSA9IEZwLm11bCh1LCB0djMpOyAvLyA1LiB0djUgPSB1ICogdHYzXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djUsIGMzKTsgLy8gNi4gdHY1ID0gdHY1XmMzXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djUsIHR2Mik7IC8vIDcuIHR2NSA9IHR2NSAqIHR2MlxuICAgICAgICB0djIgPSBGcC5tdWwodHY1LCB2KTsgLy8gOC4gdHYyID0gdHY1ICogdlxuICAgICAgICB0djMgPSBGcC5tdWwodHY1LCB1KTsgLy8gOS4gdHYzID0gdHY1ICogdVxuICAgICAgICBsZXQgdHY0ID0gRnAubXVsKHR2MywgdHYyKTsgLy8gMTAuIHR2NCA9IHR2MyAqIHR2MlxuICAgICAgICB0djUgPSBGcC5wb3codHY0LCBjNSk7IC8vIDExLiB0djUgPSB0djReYzVcbiAgICAgICAgbGV0IGlzUVIgPSBGcC5lcWwodHY1LCBGcC5PTkUpOyAvLyAxMi4gaXNRUiA9IHR2NSA9PSAxXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djMsIGM3KTsgLy8gMTMuIHR2MiA9IHR2MyAqIGM3XG4gICAgICAgIHR2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDE0LiB0djUgPSB0djQgKiB0djFcbiAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgaXNRUik7IC8vIDE1LiB0djMgPSBDTU9WKHR2MiwgdHYzLCBpc1FSKVxuICAgICAgICB0djQgPSBGcC5jbW92KHR2NSwgdHY0LCBpc1FSKTsgLy8gMTYuIHR2NCA9IENNT1YodHY1LCB0djQsIGlzUVIpXG4gICAgICAgIC8vIDE3LiBmb3IgaSBpbiAoYzEsIGMxIC0gMSwgLi4uLCAyKTpcbiAgICAgICAgZm9yIChsZXQgaSA9IGMxOyBpID4gXzFuOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB0djUgPSBpIC0gXzJuOyAvLyAxOC4gICAgdHY1ID0gaSAtIDJcbiAgICAgICAgICAgIHR2NSA9IF8ybiA8PCAodHY1IC0gXzFuKTsgLy8gMTkuICAgIHR2NSA9IDJedHY1XG4gICAgICAgICAgICBsZXQgdHZ2NSA9IEZwLnBvdyh0djQsIHR2NSk7IC8vIDIwLiAgICB0djUgPSB0djRedHY1XG4gICAgICAgICAgICBjb25zdCBlMSA9IEZwLmVxbCh0dnY1LCBGcC5PTkUpOyAvLyAyMS4gICAgZTEgPSB0djUgPT0gMVxuICAgICAgICAgICAgdHYyID0gRnAubXVsKHR2MywgdHYxKTsgLy8gMjIuICAgIHR2MiA9IHR2MyAqIHR2MVxuICAgICAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgdHYxKTsgLy8gMjMuICAgIHR2MSA9IHR2MSAqIHR2MVxuICAgICAgICAgICAgdHZ2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDI0LiAgICB0djUgPSB0djQgKiB0djFcbiAgICAgICAgICAgIHR2MyA9IEZwLmNtb3YodHYyLCB0djMsIGUxKTsgLy8gMjUuICAgIHR2MyA9IENNT1YodHYyLCB0djMsIGUxKVxuICAgICAgICAgICAgdHY0ID0gRnAuY21vdih0dnY1LCB0djQsIGUxKTsgLy8gMjYuICAgIHR2NCA9IENNT1YodHY1LCB0djQsIGUxKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGlzUVIsIHZhbHVlOiB0djMgfTtcbiAgICB9O1xuICAgIGlmIChGcC5PUkRFUiAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIHNxcnRfcmF0aW9fM21vZDQodSwgdilcbiAgICAgICAgY29uc3QgYzEgPSAoRnAuT1JERVIgLSBfM24pIC8gXzRuOyAvLyAxLiBjMSA9IChxIC0gMykgLyA0ICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgICAgICBjb25zdCBjMiA9IEZwLnNxcnQoRnAubmVnKFopKTsgLy8gMi4gYzIgPSBzcXJ0KC1aKVxuICAgICAgICBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICAgICAgbGV0IHR2MSA9IEZwLnNxcih2KTsgLy8gMS4gdHYxID0gdl4yXG4gICAgICAgICAgICBjb25zdCB0djIgPSBGcC5tdWwodSwgdik7IC8vIDIuIHR2MiA9IHUgKiB2XG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djIpOyAvLyAzLiB0djEgPSB0djEgKiB0djJcbiAgICAgICAgICAgIGxldCB5MSA9IEZwLnBvdyh0djEsIGMxKTsgLy8gNC4geTEgPSB0djFeYzFcbiAgICAgICAgICAgIHkxID0gRnAubXVsKHkxLCB0djIpOyAvLyA1LiB5MSA9IHkxICogdHYyXG4gICAgICAgICAgICBjb25zdCB5MiA9IEZwLm11bCh5MSwgYzIpOyAvLyA2LiB5MiA9IHkxICogYzJcbiAgICAgICAgICAgIGNvbnN0IHR2MyA9IEZwLm11bChGcC5zcXIoeTEpLCB2KTsgLy8gNy4gdHYzID0geTFeMjsgOC4gdHYzID0gdHYzICogdlxuICAgICAgICAgICAgY29uc3QgaXNRUiA9IEZwLmVxbCh0djMsIHUpOyAvLyA5LiBpc1FSID0gdHYzID09IHVcbiAgICAgICAgICAgIGxldCB5ID0gRnAuY21vdih5MiwgeTEsIGlzUVIpOyAvLyAxMC4geSA9IENNT1YoeTIsIHkxLCBpc1FSKVxuICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHkgfTsgLy8gMTEuIHJldHVybiAoaXNRUiwgeSkgaXNRUiA/IHkgOiB5KmMyXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIE5vIGN1cnZlcyB1c2VzIHRoYXRcbiAgICAvLyBpZiAoRnAuT1JERVIgJSBfOG4gPT09IF81bikgLy8gc3FydF9yYXRpb181bW9kOFxuICAgIHJldHVybiBzcXJ0UmF0aW87XG59XG4vKipcbiAqIFNpbXBsaWZpZWQgU2hhbGx1ZS12YW4gZGUgV29lc3Rpam5lLVVsYXMgTWV0aG9kXG4gKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTYuNi4yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwLCBvcHRzKSB7XG4gICAgbW9kLnZhbGlkYXRlRmllbGQoRnApO1xuICAgIGlmICghRnAuaXNWYWxpZChvcHRzLkEpIHx8ICFGcC5pc1ZhbGlkKG9wdHMuQikgfHwgIUZwLmlzVmFsaWQob3B0cy5aKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlU2ltcGxlU1dVOiBpbnZhbGlkIG9wdHMnKTtcbiAgICBjb25zdCBzcXJ0UmF0aW8gPSBTV1VGcFNxcnRSYXRpbyhGcCwgb3B0cy5aKTtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZwLmlzT2RkIGlzIG5vdCBpbXBsZW1lbnRlZCEnKTtcbiAgICAvLyBJbnB1dDogdSwgYW4gZWxlbWVudCBvZiBGLlxuICAgIC8vIE91dHB1dDogKHgsIHkpLCBhIHBvaW50IG9uIEUuXG4gICAgcmV0dXJuICh1KSA9PiB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBsZXQgdHYxLCB0djIsIHR2MywgdHY0LCB0djUsIHR2NiwgeCwgeTtcbiAgICAgICAgdHYxID0gRnAuc3FyKHUpOyAvLyAxLiAgdHYxID0gdV4yXG4gICAgICAgIHR2MSA9IEZwLm11bCh0djEsIG9wdHMuWik7IC8vIDIuICB0djEgPSBaICogdHYxXG4gICAgICAgIHR2MiA9IEZwLnNxcih0djEpOyAvLyAzLiAgdHYyID0gdHYxXjJcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHYxKTsgLy8gNC4gIHR2MiA9IHR2MiArIHR2MVxuICAgICAgICB0djMgPSBGcC5hZGQodHYyLCBGcC5PTkUpOyAvLyA1LiAgdHYzID0gdHYyICsgMVxuICAgICAgICB0djMgPSBGcC5tdWwodHYzLCBvcHRzLkIpOyAvLyA2LiAgdHYzID0gQiAqIHR2M1xuICAgICAgICB0djQgPSBGcC5jbW92KG9wdHMuWiwgRnAubmVnKHR2MiksICFGcC5lcWwodHYyLCBGcC5aRVJPKSk7IC8vIDcuICB0djQgPSBDTU9WKFosIC10djIsIHR2MiAhPSAwKVxuICAgICAgICB0djQgPSBGcC5tdWwodHY0LCBvcHRzLkEpOyAvLyA4LiAgdHY0ID0gQSAqIHR2NFxuICAgICAgICB0djIgPSBGcC5zcXIodHYzKTsgLy8gOS4gIHR2MiA9IHR2M14yXG4gICAgICAgIHR2NiA9IEZwLnNxcih0djQpOyAvLyAxMC4gdHY2ID0gdHY0XjJcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5BKTsgLy8gMTEuIHR2NSA9IEEgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTIuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB0djIgPSBGcC5tdWwodHYyLCB0djMpOyAvLyAxMy4gdHYyID0gdHYyICogdHYzXG4gICAgICAgIHR2NiA9IEZwLm11bCh0djYsIHR2NCk7IC8vIDE0LiB0djYgPSB0djYgKiB0djRcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5CKTsgLy8gMTUuIHR2NSA9IEIgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTYuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB4ID0gRnAubXVsKHR2MSwgdHYzKTsgLy8gMTcuICAgeCA9IHR2MSAqIHR2M1xuICAgICAgICBjb25zdCB7IGlzVmFsaWQsIHZhbHVlIH0gPSBzcXJ0UmF0aW8odHYyLCB0djYpOyAvLyAxOC4gKGlzX2d4MV9zcXVhcmUsIHkxKSA9IHNxcnRfcmF0aW8odHYyLCB0djYpXG4gICAgICAgIHkgPSBGcC5tdWwodHYxLCB1KTsgLy8gMTkuICAgeSA9IHR2MSAqIHUgIC0+IFogKiB1XjMgKiB5MVxuICAgICAgICB5ID0gRnAubXVsKHksIHZhbHVlKTsgLy8gMjAuICAgeSA9IHkgKiB5MVxuICAgICAgICB4ID0gRnAuY21vdih4LCB0djMsIGlzVmFsaWQpOyAvLyAyMS4gICB4ID0gQ01PVih4LCB0djMsIGlzX2d4MV9zcXVhcmUpXG4gICAgICAgIHkgPSBGcC5jbW92KHksIHZhbHVlLCBpc1ZhbGlkKTsgLy8gMjIuICAgeSA9IENNT1YoeSwgeTEsIGlzX2d4MV9zcXVhcmUpXG4gICAgICAgIGNvbnN0IGUxID0gRnAuaXNPZGQodSkgPT09IEZwLmlzT2RkKHkpOyAvLyAyMy4gIGUxID0gc2duMCh1KSA9PSBzZ24wKHkpXG4gICAgICAgIHkgPSBGcC5jbW92KEZwLm5lZyh5KSwgeSwgZTEpOyAvLyAyNC4gICB5ID0gQ01PVigteSwgeSwgZTEpXG4gICAgICAgIHggPSBGcC5kaXYoeCwgdHY0KTsgLy8gMjUuICAgeCA9IHggLyB0djRcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWllcnN0cmFzcy5qcy5tYXAiXSwibmFtZXMiOlsibW9kIiwidXQiLCJlbnN1cmVCeXRlcyIsIndOQUYiLCJ2YWxpZGF0ZUJhc2ljIiwidmFsaWRhdGVQb2ludE9wdHMiLCJjdXJ2ZSIsIm9wdHMiLCJ2YWxpZGF0ZU9iamVjdCIsImEiLCJiIiwiYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzIiwid3JhcFByaXZhdGVLZXkiLCJpc1RvcnNpb25GcmVlIiwiY2xlYXJDb2ZhY3RvciIsImFsbG93SW5maW5pdHlQb2ludCIsImZyb21CeXRlcyIsInRvQnl0ZXMiLCJlbmRvIiwiRnAiLCJlcWwiLCJaRVJPIiwiRXJyb3IiLCJiZXRhIiwic3BsaXRTY2FsYXIiLCJPYmplY3QiLCJmcmVlemUiLCJieXRlc1RvTnVtYmVyQkUiLCJiMm4iLCJoZXhUb0J5dGVzIiwiaDJiIiwiREVSIiwiRXJyIiwiREVSRXJyIiwiY29uc3RydWN0b3IiLCJtIiwiX3BhcnNlSW50IiwiZGF0YSIsIkUiLCJsZW5ndGgiLCJsZW4iLCJyZXMiLCJzdWJhcnJheSIsImQiLCJsIiwidG9TaWciLCJoZXgiLCJVaW50OEFycmF5IiwiciIsInNCeXRlcyIsInMiLCJyQnl0ZXNMZWZ0IiwiaGV4RnJvbVNpZyIsInNpZyIsInNsaWNlIiwiTnVtYmVyIiwicGFyc2VJbnQiLCJoIiwibnVtIiwidG9TdHJpbmciLCJzaGwiLCJyaGwiLCJzbCIsInJsIiwiXzBuIiwiQmlnSW50IiwiXzFuIiwiXzJuIiwiXzNuIiwiXzRuIiwid2VpZXJzdHJhc3NQb2ludHMiLCJDVVJWRSIsIl9jIiwicG9pbnQiLCJfaXNDb21wcmVzc2VkIiwidG9BZmZpbmUiLCJjb25jYXRCeXRlcyIsImZyb20iLCJ4IiwieSIsImJ5dGVzIiwidGFpbCIsIkJZVEVTIiwid2VpZXJzdHJhc3NFcXVhdGlvbiIsIngyIiwic3FyIiwieDMiLCJtdWwiLCJhZGQiLCJHeSIsIkd4IiwiaXNXaXRoaW5DdXJ2ZU9yZGVyIiwibiIsImFzc2VydEdFIiwibm9ybVByaXZhdGVLZXlUb1NjYWxhciIsImtleSIsImxlbmd0aHMiLCJuQnl0ZUxlbmd0aCIsImJ5dGVzVG9IZXgiLCJpbmNsdWRlcyIsInBhZFN0YXJ0IiwiZXJyb3IiLCJwb2ludFByZWNvbXB1dGVzIiwiTWFwIiwiYXNzZXJ0UHJqUG9pbnQiLCJvdGhlciIsIlBvaW50IiwiZnJvbUFmZmluZSIsInAiLCJpc1ZhbGlkIiwiaXMwIiwiaSIsIk9ORSIsIm5vcm1hbGl6ZVoiLCJwb2ludHMiLCJ0b0ludiIsImludmVydEJhdGNoIiwibWFwIiwicHoiLCJmcm9tSGV4IiwiUCIsImFzc2VydFZhbGlkaXR5IiwiZnJvbVByaXZhdGVLZXkiLCJwcml2YXRlS2V5IiwiQkFTRSIsIm11bHRpcGx5IiwiX3NldFdpbmRvd1NpemUiLCJ3aW5kb3dTaXplIiwiX1dJTkRPV19TSVpFIiwiZGVsZXRlIiwicHkiLCJsZWZ0IiwicmlnaHQiLCJoYXNFdmVuWSIsImlzT2RkIiwiZXF1YWxzIiwicHgiLCJYMSIsIlkxIiwiWjEiLCJYMiIsIlkyIiwiWjIiLCJVMSIsIlUyIiwibmVnYXRlIiwibmVnIiwiZG91YmxlIiwiYjMiLCJYMyIsIlkzIiwiWjMiLCJ0MCIsInQxIiwidDIiLCJ0MyIsInN1YiIsInQ0IiwidDUiLCJzdWJ0cmFjdCIsInduYWYiLCJ3TkFGQ2FjaGVkIiwiY29tcCIsIm11bHRpcGx5VW5zYWZlIiwiSSIsInVuc2FmZUxhZGRlciIsImsxbmVnIiwiazEiLCJrMm5lZyIsImsyIiwiazFwIiwiazJwIiwic2NhbGFyIiwiZmFrZSIsImYiLCJmMXAiLCJmMnAiLCJjb25zdFRpbWVOZWdhdGUiLCJtdWx0aXBseUFuZEFkZFVuc2FmZSIsIlEiLCJHIiwic3VtIiwidW5kZWZpbmVkIiwiaXoiLCJ6IiwiaW52IiwiYXgiLCJheSIsInp6IiwiY29mYWN0b3IiLCJ0b1Jhd0J5dGVzIiwiaXNDb21wcmVzc2VkIiwidG9IZXgiLCJfYml0cyIsIm5CaXRMZW5ndGgiLCJNYXRoIiwiY2VpbCIsIlByb2plY3RpdmVQb2ludCIsInZhbGlkYXRlT3B0cyIsImhhc2giLCJobWFjIiwicmFuZG9tQnl0ZXMiLCJiaXRzMmludCIsImJpdHMyaW50X21vZE4iLCJsb3dTIiwid2VpZXJzdHJhc3MiLCJjdXJ2ZURlZiIsIkNVUlZFX09SREVSIiwiY29tcHJlc3NlZExlbiIsInVuY29tcHJlc3NlZExlbiIsImlzVmFsaWRGaWVsZEVsZW1lbnQiLCJPUkRFUiIsIm1vZE4iLCJpbnZOIiwiaW52ZXJ0IiwiY2F0IiwiaGVhZCIsInkyIiwic3FydCIsImlzWU9kZCIsImlzSGVhZE9kZCIsIm51bVRvTkJ5dGVTdHIiLCJudW1iZXJUb0J5dGVzQkUiLCJpc0JpZ2dlclRoYW5IYWxmT3JkZXIiLCJudW1iZXIiLCJIQUxGIiwibm9ybWFsaXplUyIsInNsY051bSIsInRvIiwiU2lnbmF0dXJlIiwiZnJvbUNvbXBhY3QiLCJmcm9tREVSIiwiYWRkUmVjb3ZlcnlCaXQiLCJyZWNvdmVyeSIsInJlY292ZXJQdWJsaWNLZXkiLCJtc2dIYXNoIiwicmVjIiwicmFkaiIsInByZWZpeCIsIlIiLCJpciIsInUxIiwidTIiLCJoYXNIaWdoUyIsInRvREVSUmF3Qnl0ZXMiLCJ0b0RFUkhleCIsInRvQ29tcGFjdFJhd0J5dGVzIiwidG9Db21wYWN0SGV4IiwidXRpbHMiLCJpc1ZhbGlkUHJpdmF0ZUtleSIsInJhbmRvbVByaXZhdGVLZXkiLCJnZXRNaW5IYXNoTGVuZ3RoIiwibWFwSGFzaFRvRmllbGQiLCJwcmVjb21wdXRlIiwiZ2V0UHVibGljS2V5IiwiaXNQcm9iUHViIiwiaXRlbSIsImFyciIsInN0ciIsImdldFNoYXJlZFNlY3JldCIsInByaXZhdGVBIiwicHVibGljQiIsImRlbHRhIiwiT1JERVJfTUFTSyIsImJpdE1hc2siLCJpbnQyb2N0ZXRzIiwicHJlcFNpZyIsImRlZmF1bHRTaWdPcHRzIiwic29tZSIsImsiLCJwcmVoYXNoIiwiZXh0cmFFbnRyb3B5IiwiZW50IiwiaDFpbnQiLCJzZWVkQXJncyIsImUiLCJwdXNoIiwic2VlZCIsImsyc2lnIiwia0J5dGVzIiwiaWsiLCJxIiwibm9ybVMiLCJkZWZhdWx0VmVyT3B0cyIsInNpZ24iLCJwcml2S2V5IiwiQyIsImRyYmciLCJjcmVhdGVIbWFjRHJiZyIsIm91dHB1dExlbiIsInZlcmlmeSIsInNpZ25hdHVyZSIsInB1YmxpY0tleSIsInNnIiwiX3NpZyIsImRlckVycm9yIiwibWVzc2FnZSIsImlzIiwidiIsIlNXVUZwU3FydFJhdGlvIiwiWiIsIm8iLCJjMSIsIl8ybl9wb3dfYzFfMSIsIl8ybl9wb3dfYzEiLCJjMiIsImMzIiwiYzQiLCJjNSIsImM2IiwicG93IiwiYzciLCJzcXJ0UmF0aW8iLCJ1IiwidHYxIiwidHYyIiwidHYzIiwidHY1IiwidHY0IiwiaXNRUiIsImNtb3YiLCJ0dnY1IiwiZTEiLCJ2YWx1ZSIsInkxIiwibWFwVG9DdXJ2ZVNpbXBsZVNXVSIsInZhbGlkYXRlRmllbGQiLCJBIiwiQiIsInR2NiIsImRpdiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/secp256k1.js":
/*!*****************************************************!*\
  !*** ./node_modules/@noble/curves/esm/secp256k1.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeToCurve: function() { return /* binding */ encodeToCurve; },\n/* harmony export */   hashToCurve: function() { return /* binding */ hashToCurve; },\n/* harmony export */   schnorr: function() { return /* binding */ schnorr; },\n/* harmony export */   secp256k1: function() { return /* binding */ secp256k1; }\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_shortw_utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/_shortw_utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n\n\n\n\nconst secp256k1P = BigInt(\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\");\nconst secp256k1N = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b)=>(a + b / _2n) / b;\n/**\n * n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */ function sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = y * y * y % P; // x^3, 11\n    const b3 = b2 * b2 * y % P; // x^7\n    const b6 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b3, _3n, P) * b3 % P;\n    const b9 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b6, _3n, P) * b3 % P;\n    const b11 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b9, _2n, P) * b2 % P;\n    const b22 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b11, _11n, P) * b11 % P;\n    const b44 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b22, _22n, P) * b22 % P;\n    const b88 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b44, _44n, P) * b44 % P;\n    const b176 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b88, _88n, P) * b88 % P;\n    const b220 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b176, _44n, P) * b44 % P;\n    const b223 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b220, _3n, P) * b3 % P;\n    const t1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b223, _23n, P) * b22 % P;\n    const t2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t1, _6n, P) * b2 % P;\n    const root = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t2, _2n, P);\n    if (!Fp.eql(Fp.sqr(root), y)) throw new Error(\"Cannot find square root\");\n    return root;\n}\nconst Fp = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(secp256k1P, undefined, undefined, {\n    sqrt: sqrtMod\n});\nconst secp256k1 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__.createCurve)({\n    a: BigInt(0),\n    b: BigInt(7),\n    Fp,\n    n: secp256k1N,\n    // Base point (x, y) aka generator point\n    Gx: BigInt(\"55066263022277343669578718895168534326250603453777594175500187360389116729240\"),\n    Gy: BigInt(\"32670510020758816978083085130507043184471273380659243275938904335757337482424\"),\n    h: BigInt(1),\n    lowS: true,\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */ endo: {\n        beta: BigInt(\"0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\"),\n        splitScalar: (k)=>{\n            const n = secp256k1N;\n            const a1 = BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\");\n            const b1 = -_1n * BigInt(\"0xe4437ed6010e88286f547fa90abfe4c3\");\n            const a2 = BigInt(\"0x114ca50f7a8e2f3f657c1108d9d44cfd8\");\n            const b2 = a1;\n            const POW_2_128 = BigInt(\"0x100000000000000000000000000000000\"); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg) k1 = n - k1;\n            if (k2neg) k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error(\"splitScalar: Endomorphism failed, k=\" + k);\n            }\n            return {\n                k1neg,\n                k1,\n                k2neg,\n                k2\n            };\n        }\n    }\n}, _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\nconst fe = (x)=>typeof x === \"bigint\" && _0n < x && x < secp256k1P;\nconst ge = (x)=>typeof x === \"bigint\" && _0n < x && x < secp256k1N;\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */ const TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag) {\n    for(var _len = arguments.length, messages = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        messages[_key - 1] = arguments[_key];\n    }\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)(Uint8Array.from(tag, (c)=>c.charCodeAt(0)));\n        tagP = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point)=>point.toRawBytes(true).slice(1);\nconst numTo32b = (n)=>(0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE)(n, 32);\nconst modP = (x)=>(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1P);\nconst modN = (x)=>(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1N);\nconst Point = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b)=>Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n_c = GmulAdd;\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'G; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return {\n        scalar: scalar,\n        bytes: pointToBytes(p)\n    };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */ function lift_x(x) {\n    if (!fe(x)) throw new Error(\"bad x: need 0 < x < p\"); // Fail if x  p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n) y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */ function challenge() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    return modN((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(taggedHash(\"BIP0340/challenge\", ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */ function schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'n. Ret bytes(d'G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */ function schnorrSign(message, privateKey) {\n    let auxRand = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.randomBytes)(32);\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"message\", message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"auxRand\", auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(taggedHash(\"BIP0340/aux\", a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash(\"BIP0340/nonce\", t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n) throw new Error(\"sign failed: k is zero\"); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'G.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px)) throw new Error(\"sign: Invalid signature produced\");\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */ function schnorrVerify(signature, message, publicKey) {\n    const sig = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"signature\", signature, 64);\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"message\", message);\n    const pub = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"publicKey\", publicKey, 32);\n    try {\n        const P = lift_x((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r  p.\n        if (!fe(r)) return false;\n        const s = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s  n.\n        if (!ge(s)) return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = sG - eP\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r) return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R)  r.\n    } catch (error) {\n        return false;\n    }\n}\nconst schnorr = /* @__PURE__ */ (()=>({\n        getPublicKey: schnorrGetPublicKey,\n        sign: schnorrSign,\n        verify: schnorrVerify,\n        utils: {\n            randomPrivateKey: secp256k1.utils.randomPrivateKey,\n            lift_x,\n            pointToBytes,\n            numberToBytesBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE,\n            bytesToNumberBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE,\n            taggedHash,\n            mod: _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod\n        }\n    }))();\nconst isoMap = /* @__PURE__ */ (()=>(0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.isogenyMap)(Fp, [\n        // xNum\n        [\n            \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7\",\n            \"0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581\",\n            \"0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262\",\n            \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c\"\n        ],\n        // xDen\n        [\n            \"0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b\",\n            \"0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14\",\n            \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n        ],\n        // yNum\n        [\n            \"0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c\",\n            \"0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3\",\n            \"0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931\",\n            \"0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84\"\n        ],\n        // yDen\n        [\n            \"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b\",\n            \"0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573\",\n            \"0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f\",\n            \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n        ]\n    ].map((i)=>i.map((j)=>BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (()=>(0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__.mapToCurveSimpleSWU)(Fp, {\n        A: BigInt(\"0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533\"),\n        B: BigInt(\"1771\"),\n        Z: Fp.create(BigInt(\"-11\"))\n    }))();\nconst htf = /* @__PURE__ */ (()=>(0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.createHasher)(secp256k1.ProjectivePoint, (scalars)=>{\n        const { x, y } = mapSWU(Fp.create(scalars[0]));\n        return isoMap(x, y);\n    }, {\n        DST: \"secp256k1_XMD:SHA-256_SSWU_RO_\",\n        encodeDST: \"secp256k1_XMD:SHA-256_SSWU_NU_\",\n        p: Fp.ORDER,\n        m: 1,\n        k: 128,\n        expand: \"xmd\",\n        hash: _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256\n    }))();\nconst hashToCurve = /* @__PURE__ */ (()=>htf.hashToCurve)();\nconst encodeToCurve = /* @__PURE__ */ (()=>htf.encodeToCurve)(); //# sourceMappingURL=secp256k1.js.map\nvar _c;\n$RefreshReg$(_c, \"GmulAdd\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9zZWNwMjU2azEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQSxvRUFBb0UsR0FDdEI7QUFDSTtBQUNPO0FBQ087QUFDaUM7QUFDMUI7QUFDdEI7QUFDakQsTUFBTWEsYUFBYUMsT0FBTztBQUMxQixNQUFNQyxhQUFhRCxPQUFPO0FBQzFCLE1BQU1FLE1BQU1GLE9BQU87QUFDbkIsTUFBTUcsTUFBTUgsT0FBTztBQUNuQixNQUFNSSxhQUFhLENBQUNDLEdBQUdDLElBQU0sQ0FBQ0QsSUFBSUMsSUFBSUgsR0FBRSxJQUFLRztBQUM3Qzs7O0NBR0MsR0FDRCxTQUFTQyxRQUFRQyxDQUFDO0lBQ2QsTUFBTUMsSUFBSVY7SUFDVixrQkFBa0I7SUFDbEIsTUFBTVcsTUFBTVYsT0FBTyxJQUFJVyxNQUFNWCxPQUFPLElBQUlZLE9BQU9aLE9BQU8sS0FBS2EsT0FBT2IsT0FBTztJQUN6RSxrQkFBa0I7SUFDbEIsTUFBTWMsT0FBT2QsT0FBTyxLQUFLZSxPQUFPZixPQUFPLEtBQUtnQixPQUFPaEIsT0FBTztJQUMxRCxNQUFNaUIsS0FBSyxJQUFLVCxJQUFJQSxJQUFLQyxHQUFHLFVBQVU7SUFDdEMsTUFBTVMsS0FBSyxLQUFNRCxLQUFLVCxJQUFLQyxHQUFHLE1BQU07SUFDcEMsTUFBTVUsS0FBSywyREFBTUQsSUFBSVIsS0FBS0QsS0FBS1MsS0FBTVQ7SUFDckMsTUFBTVcsS0FBSywyREFBTUQsSUFBSVQsS0FBS0QsS0FBS1MsS0FBTVQ7SUFDckMsTUFBTVksTUFBTSwyREFBTUQsSUFBSWpCLEtBQUtNLEtBQUtRLEtBQU1SO0lBQ3RDLE1BQU1hLE1BQU0sMkRBQU1ELEtBQUtULE1BQU1ILEtBQUtZLE1BQU9aO0lBQ3pDLE1BQU1jLE1BQU0sMkRBQU1ELEtBQUtULE1BQU1KLEtBQUthLE1BQU9iO0lBQ3pDLE1BQU1lLE1BQU0sMkRBQU1ELEtBQUtSLE1BQU1OLEtB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LENBQUMsRUFBRTtRQUM1QyxPQUFPVixPQUFPdEUsR0FBR25EO0lBQ3JCLEdBQUc7UUFDQ29JLEtBQUs7UUFDTEMsV0FBVztRQUNYcEQsR0FBRzFELEdBQUcrRyxLQUFLO1FBQ1h0QyxHQUFHO1FBQ0gxRCxHQUFHO1FBQ0hpRyxRQUFRO1FBQ1JDLE1BQU05Six3REFBTUE7SUFDaEIsRUFBQztBQUNNLE1BQU0rSixjQUE4QixhQUFILEdBQUksS0FBTVAsSUFBSU8sV0FBVyxJQUFJO0FBQzlELE1BQU1DLGdCQUFnQyxhQUFILEdBQUksS0FBTVIsSUFBSVEsYUFBYSxJQUFJLENBQ3pFLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vc2VjcDI1NmsxLmpzP2QxMjEiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyNTYnO1xuaW1wb3J0IHsgcmFuZG9tQnl0ZXMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzJztcbmltcG9ydCB7IEZpZWxkLCBtb2QsIHBvdzIgfSBmcm9tICcuL2Fic3RyYWN0L21vZHVsYXIuanMnO1xuaW1wb3J0IHsgbWFwVG9DdXJ2ZVNpbXBsZVNXVSB9IGZyb20gJy4vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMnO1xuaW1wb3J0IHsgYnl0ZXNUb051bWJlckJFLCBjb25jYXRCeXRlcywgZW5zdXJlQnl0ZXMsIG51bWJlclRvQnl0ZXNCRSB9IGZyb20gJy4vYWJzdHJhY3QvdXRpbHMuanMnO1xuaW1wb3J0IHsgY3JlYXRlSGFzaGVyLCBpc29nZW55TWFwIH0gZnJvbSAnLi9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzJztcbmltcG9ydCB7IGNyZWF0ZUN1cnZlIH0gZnJvbSAnLi9fc2hvcnR3X3V0aWxzLmpzJztcbmNvbnN0IHNlY3AyNTZrMVAgPSBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZmMyZicpO1xuY29uc3Qgc2VjcDI1NmsxTiA9IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxJyk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSBCaWdJbnQoMik7XG5jb25zdCBkaXZOZWFyZXN0ID0gKGEsIGIpID0+IChhICsgYiAvIF8ybikgLyBiO1xuLyoqXG4gKiDiiJpuID0gbl4oKHArMSkvNCkgZm9yIGZpZWxkcyBwID0gMyBtb2QgNC4gV2UgdW53cmFwIHRoZSBsb29wIGFuZCBtdWx0aXBseSBiaXQtYnktYml0LlxuICogKFArMW4vNG4pLnRvU3RyaW5nKDIpIHdvdWxkIHByb2R1Y2UgYml0cyBbMjIzeCAxLCAwLCAyMnggMSwgNHggMCwgMTEsIDAwXVxuICovXG5mdW5jdGlvbiBzcXJ0TW9kKHkpIHtcbiAgICBjb25zdCBQID0gc2VjcDI1NmsxUDtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBjb25zdCBfM24gPSBCaWdJbnQoMyksIF82biA9IEJpZ0ludCg2KSwgXzExbiA9IEJpZ0ludCgxMSksIF8yMm4gPSBCaWdJbnQoMjIpO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IF8yM24gPSBCaWdJbnQoMjMpLCBfNDRuID0gQmlnSW50KDQ0KSwgXzg4biA9IEJpZ0ludCg4OCk7XG4gICAgY29uc3QgYjIgPSAoeSAqIHkgKiB5KSAlIFA7IC8vIHheMywgMTFcbiAgICBjb25zdCBiMyA9IChiMiAqIGIyICogeSkgJSBQOyAvLyB4XjdcbiAgICBjb25zdCBiNiA9IChwb3cyKGIzLCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCBiOSA9IChwb3cyKGI2LCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCBiMTEgPSAocG93MihiOSwgXzJuLCBQKSAqIGIyKSAlIFA7XG4gICAgY29uc3QgYjIyID0gKHBvdzIoYjExLCBfMTFuLCBQKSAqIGIxMSkgJSBQO1xuICAgIGNvbnN0IGI0NCA9IChwb3cyKGIyMiwgXzIybiwgUCkgKiBiMjIpICUgUDtcbiAgICBjb25zdCBiODggPSAocG93MihiNDQsIF80NG4sIFApICogYjQ0KSAlIFA7XG4gICAgY29uc3QgYjE3NiA9IChwb3cyKGI4OCwgXzg4biwgUCkgKiBiODgpICUgUDtcbiAgICBjb25zdCBiMjIwID0gKHBvdzIoYjE3NiwgXzQ0biwgUCkgKiBiNDQpICUgUDtcbiAgICBjb25zdCBiMjIzID0gKHBvdzIoYjIyMCwgXzNuLCBQKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgdDEgPSAocG93MihiMjIzLCBfMjNuLCBQKSAqIGIyMikgJSBQO1xuICAgIGNvbnN0IHQyID0gKHBvdzIodDEsIF82biwgUCkgKiBiMikgJSBQO1xuICAgIGNvbnN0IHJvb3QgPSBwb3cyKHQyLCBfMm4sIFApO1xuICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgeSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICByZXR1cm4gcm9vdDtcbn1cbmNvbnN0IEZwID0gRmllbGQoc2VjcDI1NmsxUCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHsgc3FydDogc3FydE1vZCB9KTtcbmV4cG9ydCBjb25zdCBzZWNwMjU2azEgPSBjcmVhdGVDdXJ2ZSh7XG4gICAgYTogQmlnSW50KDApLFxuICAgIGI6IEJpZ0ludCg3KSxcbiAgICBGcCxcbiAgICBuOiBzZWNwMjU2azFOLFxuICAgIC8vIEJhc2UgcG9pbnQgKHgsIHkpIGFrYSBnZW5lcmF0b3IgcG9pbnRcbiAgICBHeDogQmlnSW50KCc1NTA2NjI2MzAyMjI3NzM0MzY2OTU3ODcxODg5NTE2ODUzNDMyNjI1MDYwMzQ1Mzc3NzU5NDE3NTUwMDE4NzM2MDM4OTExNjcyOTI0MCcpLFxuICAgIEd5OiBCaWdJbnQoJzMyNjcwNTEwMDIwNzU4ODE2OTc4MDgzMDg1MTMwNTA3MDQzMTg0NDcxMjczMzgwNjU5MjQzMjc1OTM4OTA0MzM1NzU3MzM3NDgyNDI0JyksXG4gICAgaDogQmlnSW50KDEpLFxuICAgIGxvd1M6IHRydWUsXG4gICAgLyoqXG4gICAgICogc2VjcDI1NmsxIGJlbG9uZ3MgdG8gS29ibGl0eiBjdXJ2ZXM6IGl0IGhhcyBlZmZpY2llbnRseSBjb21wdXRhYmxlIGVuZG9tb3JwaGlzbS5cbiAgICAgKiBFbmRvbW9ycGhpc20gdXNlcyAyeCBsZXNzIFJBTSwgc3BlZWRzIHVwIHByZWNvbXB1dGF0aW9uIGJ5IDJ4IGFuZCBFQ0RIIC8ga2V5IHJlY292ZXJ5IGJ5IDIwJS5cbiAgICAgKiBGb3IgcHJlY29tcHV0ZWQgd05BRiBpdCB0cmFkZXMgb2ZmIDEvMiBpbml0IHRpbWUgJiAxLzMgcmFtIGZvciAyMCUgcGVyZiBoaXQuXG4gICAgICogRXhwbGFuYXRpb246IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxtaWxsci9lYjY3MDgwNjc5M2U4NGRmNjI4YTdjNDM0YTg3MzA2NlxuICAgICAqL1xuICAgIGVuZG86IHtcbiAgICAgICAgYmV0YTogQmlnSW50KCcweDdhZTk2YTJiNjU3YzA3MTA2ZTY0NDc5ZWFjMzQzNGU5OWNmMDQ5NzUxMmY1ODk5NWMxMzk2YzI4NzE5NTAxZWUnKSxcbiAgICAgICAgc3BsaXRTY2FsYXI6IChrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuID0gc2VjcDI1NmsxTjtcbiAgICAgICAgICAgIGNvbnN0IGExID0gQmlnSW50KCcweDMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1Jyk7XG4gICAgICAgICAgICBjb25zdCBiMSA9IC1fMW4gKiBCaWdJbnQoJzB4ZTQ0MzdlZDYwMTBlODgyODZmNTQ3ZmE5MGFiZmU0YzMnKTtcbiAgICAgICAgICAgIGNvbnN0IGEyID0gQmlnSW50KCcweDExNGNhNTBmN2E4ZTJmM2Y2NTdjMTEwOGQ5ZDQ0Y2ZkOCcpO1xuICAgICAgICAgICAgY29uc3QgYjIgPSBhMTtcbiAgICAgICAgICAgIGNvbnN0IFBPV18yXzEyOCA9IEJpZ0ludCgnMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKTsgLy8gKDJuKioxMjhuKS50b1N0cmluZygxNilcbiAgICAgICAgICAgIGNvbnN0IGMxID0gZGl2TmVhcmVzdChiMiAqIGssIG4pO1xuICAgICAgICAgICAgY29uc3QgYzIgPSBkaXZOZWFyZXN0KC1iMSAqIGssIG4pO1xuICAgICAgICAgICAgbGV0IGsxID0gbW9kKGsgLSBjMSAqIGExIC0gYzIgKiBhMiwgbik7XG4gICAgICAgICAgICBsZXQgazIgPSBtb2QoLWMxICogYjEgLSBjMiAqIGIyLCBuKTtcbiAgICAgICAgICAgIGNvbnN0IGsxbmVnID0gazEgPiBQT1dfMl8xMjg7XG4gICAgICAgICAgICBjb25zdCBrMm5lZyA9IGsyID4gUE9XXzJfMTI4O1xuICAgICAgICAgICAgaWYgKGsxbmVnKVxuICAgICAgICAgICAgICAgIGsxID0gbiAtIGsxO1xuICAgICAgICAgICAgaWYgKGsybmVnKVxuICAgICAgICAgICAgICAgIGsyID0gbiAtIGsyO1xuICAgICAgICAgICAgaWYgKGsxID4gUE9XXzJfMTI4IHx8IGsyID4gUE9XXzJfMTI4KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzcGxpdFNjYWxhcjogRW5kb21vcnBoaXNtIGZhaWxlZCwgaz0nICsgayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBrMW5lZywgazEsIGsybmVnLCBrMiB9O1xuICAgICAgICB9LFxuICAgIH0sXG59LCBzaGEyNTYpO1xuLy8gU2Nobm9yciBzaWduYXR1cmVzIGFyZSBzdXBlcmlvciB0byBFQ0RTQSBmcm9tIGFib3ZlLiBCZWxvdyBpcyBTY2hub3JyLXNwZWNpZmljIEJJUDAzNDAgY29kZS5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAzNDAubWVkaWF3aWtpXG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBmZSA9ICh4KSA9PiB0eXBlb2YgeCA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgeCAmJiB4IDwgc2VjcDI1NmsxUDtcbmNvbnN0IGdlID0gKHgpID0+IHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiBfMG4gPCB4ICYmIHggPCBzZWNwMjU2azFOO1xuLyoqIEFuIG9iamVjdCBtYXBwaW5nIHRhZ3MgdG8gdGhlaXIgdGFnZ2VkIGhhc2ggcHJlZml4IG9mIFtTSEEyNTYodGFnKSB8IFNIQTI1Nih0YWcpXSAqL1xuY29uc3QgVEFHR0VEX0hBU0hfUFJFRklYRVMgPSB7fTtcbmZ1bmN0aW9uIHRhZ2dlZEhhc2godGFnLCAuLi5tZXNzYWdlcykge1xuICAgIGxldCB0YWdQID0gVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXTtcbiAgICBpZiAodGFnUCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHRhZ0ggPSBzaGEyNTYoVWludDhBcnJheS5mcm9tKHRhZywgKGMpID0+IGMuY2hhckNvZGVBdCgwKSkpO1xuICAgICAgICB0YWdQID0gY29uY2F0Qnl0ZXModGFnSCwgdGFnSCk7XG4gICAgICAgIFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ10gPSB0YWdQO1xuICAgIH1cbiAgICByZXR1cm4gc2hhMjU2KGNvbmNhdEJ5dGVzKHRhZ1AsIC4uLm1lc3NhZ2VzKSk7XG59XG4vLyBFQ0RTQSBjb21wYWN0IHBvaW50cyBhcmUgMzMtYnl0ZS4gU2Nobm9yciBpcyAzMjogd2Ugc3RyaXAgZmlyc3QgYnl0ZSAweDAyIG9yIDB4MDNcbmNvbnN0IHBvaW50VG9CeXRlcyA9IChwb2ludCkgPT4gcG9pbnQudG9SYXdCeXRlcyh0cnVlKS5zbGljZSgxKTtcbmNvbnN0IG51bVRvMzJiID0gKG4pID0+IG51bWJlclRvQnl0ZXNCRShuLCAzMik7XG5jb25zdCBtb2RQID0gKHgpID0+IG1vZCh4LCBzZWNwMjU2azFQKTtcbmNvbnN0IG1vZE4gPSAoeCkgPT4gbW9kKHgsIHNlY3AyNTZrMU4pO1xuY29uc3QgUG9pbnQgPSBzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50O1xuY29uc3QgR211bEFkZCA9IChRLCBhLCBiKSA9PiBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFEsIGEsIGIpO1xuLy8gQ2FsY3VsYXRlIHBvaW50LCBzY2FsYXIgYW5kIGJ5dGVzXG5mdW5jdGlvbiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXYpIHtcbiAgICBsZXQgZF8gPSBzZWNwMjU2azEudXRpbHMubm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2KTsgLy8gc2FtZSBtZXRob2QgZXhlY3V0ZWQgaW4gZnJvbVByaXZhdGVLZXlcbiAgICBsZXQgcCA9IFBvaW50LmZyb21Qcml2YXRlS2V5KGRfKTsgLy8gUCA9IGQn4ouFRzsgMCA8IGQnIDwgbiBjaGVjayBpcyBkb25lIGluc2lkZVxuICAgIGNvbnN0IHNjYWxhciA9IHAuaGFzRXZlblkoKSA/IGRfIDogbW9kTigtZF8pO1xuICAgIHJldHVybiB7IHNjYWxhcjogc2NhbGFyLCBieXRlczogcG9pbnRUb0J5dGVzKHApIH07XG59XG4vKipcbiAqIGxpZnRfeCBmcm9tIEJJUDM0MC4gQ29udmVydCAzMi1ieXRlIHggY29vcmRpbmF0ZSB0byBlbGxpcHRpYyBjdXJ2ZSBwb2ludC5cbiAqIEByZXR1cm5zIHZhbGlkIHBvaW50IGNoZWNrZWQgZm9yIGJlaW5nIG9uLWN1cnZlXG4gKi9cbmZ1bmN0aW9uIGxpZnRfeCh4KSB7XG4gICAgaWYgKCFmZSh4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgeDogbmVlZCAwIDwgeCA8IHAnKTsgLy8gRmFpbCBpZiB4IOKJpSBwLlxuICAgIGNvbnN0IHh4ID0gbW9kUCh4ICogeCk7XG4gICAgY29uc3QgYyA9IG1vZFAoeHggKiB4ICsgQmlnSW50KDcpKTsgLy8gTGV0IGMgPSB4wrMgKyA3IG1vZCBwLlxuICAgIGxldCB5ID0gc3FydE1vZChjKTsgLy8gTGV0IHkgPSBjXihwKzEpLzQgbW9kIHAuXG4gICAgaWYgKHkgJSBfMm4gIT09IF8wbilcbiAgICAgICAgeSA9IG1vZFAoLXkpOyAvLyBSZXR1cm4gdGhlIHVuaXF1ZSBwb2ludCBQIHN1Y2ggdGhhdCB4KFApID0geCBhbmRcbiAgICBjb25zdCBwID0gbmV3IFBvaW50KHgsIHksIF8xbik7IC8vIHkoUCkgPSB5IGlmIHkgbW9kIDIgPSAwIG9yIHkoUCkgPSBwLXkgb3RoZXJ3aXNlLlxuICAgIHAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICByZXR1cm4gcDtcbn1cbi8qKlxuICogQ3JlYXRlIHRhZ2dlZCBoYXNoLCBjb252ZXJ0IGl0IHRvIGJpZ2ludCwgcmVkdWNlIG1vZHVsby1uLlxuICovXG5mdW5jdGlvbiBjaGFsbGVuZ2UoLi4uYXJncykge1xuICAgIHJldHVybiBtb2ROKGJ5dGVzVG9OdW1iZXJCRSh0YWdnZWRIYXNoKCdCSVAwMzQwL2NoYWxsZW5nZScsIC4uLmFyZ3MpKSk7XG59XG4vKipcbiAqIFNjaG5vcnIgcHVibGljIGtleSBpcyBqdXN0IGB4YCBjb29yZGluYXRlIG9mIFBvaW50IGFzIHBlciBCSVAzNDAuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJHZXRQdWJsaWNLZXkocHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpLmJ5dGVzOyAvLyBkJz1pbnQoc2spLiBGYWlsIGlmIGQnPTAgb3IgZCfiiaVuLiBSZXQgYnl0ZXMoZCfii4VHKVxufVxuLyoqXG4gKiBDcmVhdGVzIFNjaG5vcnIgc2lnbmF0dXJlIGFzIHBlciBCSVAzNDAuIFZlcmlmaWVzIGl0c2VsZiBiZWZvcmUgcmV0dXJuaW5nIGFueXRoaW5nLlxuICogYXV4UmFuZCBpcyBvcHRpb25hbCBhbmQgaXMgbm90IHRoZSBzb2xlIHNvdXJjZSBvZiBrIGdlbmVyYXRpb246IGJhZCBDU1BSTkcgd29uJ3QgYmUgZGFuZ2Vyb3VzLlxuICovXG5mdW5jdGlvbiBzY2hub3JyU2lnbihtZXNzYWdlLCBwcml2YXRlS2V5LCBhdXhSYW5kID0gcmFuZG9tQnl0ZXMoMzIpKSB7XG4gICAgY29uc3QgbSA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgY29uc3QgeyBieXRlczogcHgsIHNjYWxhcjogZCB9ID0gc2Nobm9yckdldEV4dFB1YktleShwcml2YXRlS2V5KTsgLy8gY2hlY2tzIGZvciBpc1dpdGhpbkN1cnZlT3JkZXJcbiAgICBjb25zdCBhID0gZW5zdXJlQnl0ZXMoJ2F1eFJhbmQnLCBhdXhSYW5kLCAzMik7IC8vIEF1eGlsaWFyeSByYW5kb20gZGF0YSBhOiBhIDMyLWJ5dGUgYXJyYXlcbiAgICBjb25zdCB0ID0gbnVtVG8zMmIoZCBeIGJ5dGVzVG9OdW1iZXJCRSh0YWdnZWRIYXNoKCdCSVAwMzQwL2F1eCcsIGEpKSk7IC8vIExldCB0IGJlIHRoZSBieXRlLXdpc2UgeG9yIG9mIGJ5dGVzKGQpIGFuZCBoYXNoL2F1eChhKVxuICAgIGNvbnN0IHJhbmQgPSB0YWdnZWRIYXNoKCdCSVAwMzQwL25vbmNlJywgdCwgcHgsIG0pOyAvLyBMZXQgcmFuZCA9IGhhc2gvbm9uY2UodCB8fCBieXRlcyhQKSB8fCBtKVxuICAgIGNvbnN0IGtfID0gbW9kTihieXRlc1RvTnVtYmVyQkUocmFuZCkpOyAvLyBMZXQgaycgPSBpbnQocmFuZCkgbW9kIG5cbiAgICBpZiAoa18gPT09IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduIGZhaWxlZDogayBpcyB6ZXJvJyk7IC8vIEZhaWwgaWYgaycgPSAwLlxuICAgIGNvbnN0IHsgYnl0ZXM6IHJ4LCBzY2FsYXI6IGsgfSA9IHNjaG5vcnJHZXRFeHRQdWJLZXkoa18pOyAvLyBMZXQgUiA9IGsn4ouFRy5cbiAgICBjb25zdCBlID0gY2hhbGxlbmdlKHJ4LCBweCwgbSk7IC8vIExldCBlID0gaW50KGhhc2gvY2hhbGxlbmdlKGJ5dGVzKFIpIHx8IGJ5dGVzKFApIHx8IG0pKSBtb2Qgbi5cbiAgICBjb25zdCBzaWcgPSBuZXcgVWludDhBcnJheSg2NCk7IC8vIExldCBzaWcgPSBieXRlcyhSKSB8fCBieXRlcygoayArIGVkKSBtb2QgbikuXG4gICAgc2lnLnNldChyeCwgMCk7XG4gICAgc2lnLnNldChudW1UbzMyYihtb2ROKGsgKyBlICogZCkpLCAzMik7XG4gICAgLy8gSWYgVmVyaWZ5KGJ5dGVzKFApLCBtLCBzaWcpIChzZWUgYmVsb3cpIHJldHVybnMgZmFpbHVyZSwgYWJvcnRcbiAgICBpZiAoIXNjaG5vcnJWZXJpZnkoc2lnLCBtLCBweCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbjogSW52YWxpZCBzaWduYXR1cmUgcHJvZHVjZWQnKTtcbiAgICByZXR1cm4gc2lnO1xufVxuLyoqXG4gKiBWZXJpZmllcyBTY2hub3JyIHNpZ25hdHVyZS5cbiAqIFdpbGwgc3dhbGxvdyBlcnJvcnMgJiByZXR1cm4gZmFsc2UgZXhjZXB0IGZvciBpbml0aWFsIHR5cGUgdmFsaWRhdGlvbiBvZiBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJWZXJpZnkoc2lnbmF0dXJlLCBtZXNzYWdlLCBwdWJsaWNLZXkpIHtcbiAgICBjb25zdCBzaWcgPSBlbnN1cmVCeXRlcygnc2lnbmF0dXJlJywgc2lnbmF0dXJlLCA2NCk7XG4gICAgY29uc3QgbSA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgY29uc3QgcHViID0gZW5zdXJlQnl0ZXMoJ3B1YmxpY0tleScsIHB1YmxpY0tleSwgMzIpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IFAgPSBsaWZ0X3goYnl0ZXNUb051bWJlckJFKHB1YikpOyAvLyBQID0gbGlmdF94KGludChwaykpOyBmYWlsIGlmIHRoYXQgZmFpbHNcbiAgICAgICAgY29uc3QgciA9IGJ5dGVzVG9OdW1iZXJCRShzaWcuc3ViYXJyYXkoMCwgMzIpKTsgLy8gTGV0IHIgPSBpbnQoc2lnWzA6MzJdKTsgZmFpbCBpZiByIOKJpSBwLlxuICAgICAgICBpZiAoIWZlKHIpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBzID0gYnl0ZXNUb051bWJlckJFKHNpZy5zdWJhcnJheSgzMiwgNjQpKTsgLy8gTGV0IHMgPSBpbnQoc2lnWzMyOjY0XSk7IGZhaWwgaWYgcyDiiaUgbi5cbiAgICAgICAgaWYgKCFnZShzKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgZSA9IGNoYWxsZW5nZShudW1UbzMyYihyKSwgcG9pbnRUb0J5dGVzKFApLCBtKTsgLy8gaW50KGNoYWxsZW5nZShieXRlcyhyKXx8Ynl0ZXMoUCl8fG0pKSVuXG4gICAgICAgIGNvbnN0IFIgPSBHbXVsQWRkKFAsIHMsIG1vZE4oLWUpKTsgLy8gUiA9IHPii4VHIC0gZeKLhVBcbiAgICAgICAgaWYgKCFSIHx8ICFSLmhhc0V2ZW5ZKCkgfHwgUi50b0FmZmluZSgpLnggIT09IHIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIC1lUCA9PSAobi1lKVBcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIEZhaWwgaWYgaXNfaW5maW5pdGUoUikgLyBub3QgaGFzX2V2ZW5feShSKSAvIHgoUikg4omgIHIuXG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IHNjaG5vcnIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+ICh7XG4gICAgZ2V0UHVibGljS2V5OiBzY2hub3JyR2V0UHVibGljS2V5LFxuICAgIHNpZ246IHNjaG5vcnJTaWduLFxuICAgIHZlcmlmeTogc2Nobm9yclZlcmlmeSxcbiAgICB1dGlsczoge1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiBzZWNwMjU2azEudXRpbHMucmFuZG9tUHJpdmF0ZUtleSxcbiAgICAgICAgbGlmdF94LFxuICAgICAgICBwb2ludFRvQnl0ZXMsXG4gICAgICAgIG51bWJlclRvQnl0ZXNCRSxcbiAgICAgICAgYnl0ZXNUb051bWJlckJFLFxuICAgICAgICB0YWdnZWRIYXNoLFxuICAgICAgICBtb2QsXG4gICAgfSxcbn0pKSgpO1xuY29uc3QgaXNvTWFwID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBpc29nZW55TWFwKEZwLCBbXG4gICAgLy8geE51bVxuICAgIFtcbiAgICAgICAgJzB4OGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGRhYWFhYThjNycsXG4gICAgICAgICcweDdkM2Q0YzgwYmMzMjFkNWI5ZjMxNWNlYTdmZDQ0YzVkNTk1ZDJmYzBiZjYzYjkyZGZmZjEwNDRmMTdjNjU4MScsXG4gICAgICAgICcweDUzNGMzMjhkMjNmMjM0ZTZlMmE0MTNkZWNhMjVjYWVjZTQ1MDYxNDQwMzdjNDAzMTRlY2JkMGI1M2Q5ZGQyNjInLFxuICAgICAgICAnMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhODhjJyxcbiAgICBdLFxuICAgIC8vIHhEZW5cbiAgICBbXG4gICAgICAgICcweGQzNTc3MTE5M2Q5NDkxOGE5Y2EzNGNjYmI3YjY0MGRkODZjZDQwOTU0MmY4NDg3ZDlmZTZiNzQ1NzgxZWI0OWInLFxuICAgICAgICAnMHhlZGFkYzZmNjQzODNkYzFkZjdjNGIyZDUxYjU0MjI1NDA2ZDM2YjY0MWY1ZTQxYmJjNTJhNTY2MTJhOGM2ZDE0JyxcbiAgICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsIC8vIExBU1QgMVxuICAgIF0sXG4gICAgLy8geU51bVxuICAgIFtcbiAgICAgICAgJzB4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGI4ZTM4ZTIzYycsXG4gICAgICAgICcweGM3NWUwYzMyZDVjYjdjMGZhOWQwYTU0YjEyYTBhNmQ1NjQ3YWIwNDZkNjg2ZGE2ZmRmZmM5MGZjMjAxZDcxYTMnLFxuICAgICAgICAnMHgyOWE2MTk0NjkxZjkxYTczNzE1MjA5ZWY2NTEyZTU3NjcyMjgzMGEyMDFiZTIwMThhNzY1ZTg1YTllY2VlOTMxJyxcbiAgICAgICAgJzB4MmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmYzOGUzOGQ4NCcsXG4gICAgXSxcbiAgICAvLyB5RGVuXG4gICAgW1xuICAgICAgICAnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmOTNiJyxcbiAgICAgICAgJzB4N2EwNjUzNGJiOGJkYjQ5ZmQ1ZTllNjYzMjcyMmMyOTg5NDY3YzFiZmM4ZThkOTc4ZGZiNDI1ZDI2ODVjMjU3MycsXG4gICAgICAgICcweDY0ODRhYTcxNjU0NWNhMmNmM2E3MGMzZmE4ZmUzMzdlMGEzZDIxMTYyZjBkNjI5OWE3YmY4MTkyYmZkMmE3NmYnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgXSxcbl0ubWFwKChpKSA9PiBpLm1hcCgoaikgPT4gQmlnSW50KGopKSkpKSgpO1xuY29uc3QgbWFwU1dVID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwLCB7XG4gICAgQTogQmlnSW50KCcweDNmODczMWFiZGQ2NjFhZGNhMDhhNTU1OGYwZjVkMjcyZTk1M2QzNjNjYjZmMGU1ZDQwNTQ0N2MwMWE0NDQ1MzMnKSxcbiAgICBCOiBCaWdJbnQoJzE3NzEnKSxcbiAgICBaOiBGcC5jcmVhdGUoQmlnSW50KCctMTEnKSksXG59KSkoKTtcbmNvbnN0IGh0ZiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gY3JlYXRlSGFzaGVyKHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQsIChzY2FsYXJzKSA9PiB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBtYXBTV1UoRnAuY3JlYXRlKHNjYWxhcnNbMF0pKTtcbiAgICByZXR1cm4gaXNvTWFwKHgsIHkpO1xufSwge1xuICAgIERTVDogJ3NlY3AyNTZrMV9YTUQ6U0hBLTI1Nl9TU1dVX1JPXycsXG4gICAgZW5jb2RlRFNUOiAnc2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfTlVfJyxcbiAgICBwOiBGcC5PUkRFUixcbiAgICBtOiAxLFxuICAgIGs6IDEyOCxcbiAgICBleHBhbmQ6ICd4bWQnLFxuICAgIGhhc2g6IHNoYTI1Nixcbn0pKSgpO1xuZXhwb3J0IGNvbnN0IGhhc2hUb0N1cnZlID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBodGYuaGFzaFRvQ3VydmUpKCk7XG5leHBvcnQgY29uc3QgZW5jb2RlVG9DdXJ2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gaHRmLmVuY29kZVRvQ3VydmUpKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWNwMjU2azEuanMubWFwIl0sIm5hbWVzIjpbInNoYTI1NiIsInJhbmRvbUJ5dGVzIiwiRmllbGQiLCJtb2QiLCJwb3cyIiwibWFwVG9DdXJ2ZVNpbXBsZVNXVSIsImJ5dGVzVG9OdW1iZXJCRSIsImNvbmNhdEJ5dGVzIiwiZW5zdXJlQnl0ZXMiLCJudW1iZXJUb0J5dGVzQkUiLCJjcmVhdGVIYXNoZXIiLCJpc29nZW55TWFwIiwiY3JlYXRlQ3VydmUiLCJzZWNwMjU2azFQIiwiQmlnSW50Iiwic2VjcDI1NmsxTiIsIl8xbiIsIl8ybiIsImRpdk5lYXJlc3QiLCJhIiwiYiIsInNxcnRNb2QiLCJ5IiwiUCIsIl8zbiIsIl82biIsIl8xMW4iLCJfMjJuIiwiXzIzbiIsIl80NG4iLCJfODhuIiwiYjIiLCJiMyIsImI2IiwiYjkiLCJiMTEiLCJiMjIiLCJiNDQiLCJiODgiLCJiMTc2IiwiYjIyMCIsImIyMjMiLCJ0MSIsInQyIiwicm9vdCIsIkZwIiwiZXFsIiwic3FyIiwiRXJyb3IiLCJ1bmRlZmluZWQiLCJzcXJ0Iiwic2VjcDI1NmsxIiwibiIsIkd4IiwiR3kiLCJoIiwibG93UyIsImVuZG8iLCJiZXRhIiwic3BsaXRTY2FsYXIiLCJrIiwiYTEiLCJiMSIsImEyIiwiUE9XXzJfMTI4IiwiYzEiLCJjMiIsImsxIiwiazIiLCJrMW5lZyIsImsybmVnIiwiXzBuIiwiZmUiLCJ4IiwiZ2UiLCJUQUdHRURfSEFTSF9QUkVGSVhFUyIsInRhZ2dlZEhhc2giLCJ0YWciLCJtZXNzYWdlcyIsInRhZ1AiLCJ0YWdIIiwiVWludDhBcnJheSIsImZyb20iLCJjIiwiY2hhckNvZGVBdCIsInBvaW50VG9CeXRlcyIsInBvaW50IiwidG9SYXdCeXRlcyIsInNsaWNlIiwibnVtVG8zMmIiLCJtb2RQIiwibW9kTiIsIlBvaW50IiwiUHJvamVjdGl2ZVBvaW50IiwiR211bEFkZCIsIlEiLCJCQVNFIiwibXVsdGlwbHlBbmRBZGRVbnNhZmUiLCJzY2hub3JyR2V0RXh0UHViS2V5IiwicHJpdiIsImRfIiwidXRpbHMiLCJub3JtUHJpdmF0ZUtleVRvU2NhbGFyIiwicCIsImZyb21Qcml2YXRlS2V5Iiwic2NhbGFyIiwiaGFzRXZlblkiLCJieXRlcyIsImxpZnRfeCIsInh4IiwiYXNzZXJ0VmFsaWRpdHkiLCJjaGFsbGVuZ2UiLCJhcmdzIiwic2Nobm9yckdldFB1YmxpY0tleSIsInByaXZhdGVLZXkiLCJzY2hub3JyU2lnbiIsIm1lc3NhZ2UiLCJhdXhSYW5kIiwibSIsInB4IiwiZCIsInQiLCJyYW5kIiwia18iLCJyeCIsImUiLCJzaWciLCJzZXQiLCJzY2hub3JyVmVyaWZ5Iiwic2lnbmF0dXJlIiwicHVibGljS2V5IiwicHViIiwiciIsInN1YmFycmF5IiwicyIsIlIiLCJ0b0FmZmluZSIsImVycm9yIiwic2Nobm9yciIsImdldFB1YmxpY0tleSIsInNpZ24iLCJ2ZXJpZnkiLCJyYW5kb21Qcml2YXRlS2V5IiwiaXNvTWFwIiwibWFwIiwiaSIsImoiLCJtYXBTV1UiLCJBIiwiQiIsIloiLCJjcmVhdGUiLCJodGYiLCJzY2FsYXJzIiwiRFNUIiwiZW5jb2RlRFNUIiwiT1JERVIiLCJleHBhbmQiLCJoYXNoIiwiaGFzaFRvQ3VydmUiLCJlbmNvZGVUb0N1cnZlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/secp256k1.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/hashes/esm/_assert.js":
/*!***************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_assert.js ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: function() { return /* binding */ bool; },\n/* harmony export */   bytes: function() { return /* binding */ bytes; },\n/* harmony export */   exists: function() { return /* binding */ exists; },\n/* harmony export */   hash: function() { return /* binding */ hash; },\n/* harmony export */   number: function() { return /* binding */ number; },\n/* harmony export */   output: function() { return /* binding */ output; }\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0) throw new Error(\"Wrong positive integer: \".concat(n));\n}\nfunction bool(b) {\n    if (typeof b !== \"boolean\") throw new Error(\"Expected boolean, not \".concat(b));\n}\nfunction bytes(b) {\n    for(var _len = arguments.length, lengths = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        lengths[_key - 1] = arguments[_key];\n    }\n    if (!(b instanceof Uint8Array)) throw new Error(\"Expected Uint8Array\");\n    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error(\"Expected Uint8Array of length \".concat(lengths, \", not of length=\").concat(b.length));\n}\nfunction hash(hash) {\n    if (typeof hash !== \"function\" || typeof hash.create !== \"function\") throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance) {\n    let checkFinished = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n    if (instance.destroyed) throw new Error(\"Hash instance has been destroyed\");\n    if (checkFinished && instance.finished) throw new Error(\"Hash#digest() has already been called\");\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(\"digestInto() expects output buffer of length at least \".concat(min));\n    }\n}\n\nconst assert = {\n    number,\n    bool,\n    bytes,\n    hash,\n    exists,\n    output\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (assert); //# sourceMappingURL=_assert.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fYXNzZXJ0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBLFNBQVNBLE9BQU9DLENBQUM7SUFDYixJQUFJLENBQUNDLE9BQU9DLGFBQWEsQ0FBQ0YsTUFBTUEsSUFBSSxHQUNoQyxNQUFNLElBQUlHLE1BQU0sMkJBQTZCLE9BQUZIO0FBQ25EO0FBQ0EsU0FBU0ksS0FBS0MsQ0FBQztJQUNYLElBQUksT0FBT0EsTUFBTSxXQUNiLE1BQU0sSUFBSUYsTUFBTSx5QkFBMkIsT0FBRkU7QUFDakQ7QUFDQSxTQUFTQyxNQUFNRCxDQUFDO0lBQUU7UUFBR0UsUUFBSCwyQkFBVTs7SUFDeEIsSUFBSSxDQUFFRixDQUFBQSxhQUFhRyxVQUFTLEdBQ3hCLE1BQU0sSUFBSUwsTUFBTTtJQUNwQixJQUFJSSxRQUFRRSxNQUFNLEdBQUcsS0FBSyxDQUFDRixRQUFRRyxRQUFRLENBQUNMLEVBQUVJLE1BQU0sR0FDaEQsTUFBTSxJQUFJTixNQUFNLGlDQUEyREUsT0FBMUJFLFNBQVEsb0JBQTJCLE9BQVRGLEVBQUVJLE1BQU07QUFDM0Y7QUFDQSxTQUFTRSxLQUFLQSxJQUFJO0lBQ2QsSUFBSSxPQUFPQSxTQUFTLGNBQWMsT0FBT0EsS0FBS0MsTUFBTSxLQUFLLFlBQ3JELE1BQU0sSUFBSVQsTUFBTTtJQUNwQkosT0FBT1ksS0FBS0UsU0FBUztJQUNyQmQsT0FBT1ksS0FBS0csUUFBUTtBQUN4QjtBQUNBLFNBQVNDLE9BQU9DLFFBQVE7UUFBRUMsZ0JBQUFBLGlFQUFnQjtJQUN0QyxJQUFJRCxTQUFTRSxTQUFTLEVBQ2xCLE1BQU0sSUFBSWYsTUFBTTtJQUNwQixJQUFJYyxpQkFBaUJELFNBQVNHLFFBQVEsRUFDbEMsTUFBTSxJQUFJaEIsTUFBTTtBQUN4QjtBQUNBLFNBQVNpQixPQUFPQyxHQUFHLEVBQUVMLFFBQVE7SUFDekJWLE1BQU1lO0lBQ04sTUFBTUMsTUFBTU4sU0FBU0gsU0FBUztJQUM5QixJQUFJUSxJQUFJWixNQUFNLEdBQUdhLEtBQUs7UUFDbEIsTUFBTSxJQUFJbkIsTUFBTSx5REFBNkQsT0FBSm1CO0lBQzdFO0FBQ0o7QUFDcUQ7QUFDckQsTUFBTUMsU0FBUztJQUFFeEI7SUFBUUs7SUFBTUU7SUFBT0s7SUFBTUk7SUFBUUs7QUFBTztBQUMzRCwrREFBZUcsTUFBTUEsRUFBQyxDQUN0QixtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19hc3NlcnQuanM/MjcwZSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBudW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgcG9zaXRpdmUgaW50ZWdlcjogJHtufWApO1xufVxuZnVuY3Rpb24gYm9vbChiKSB7XG4gICAgaWYgKHR5cGVvZiBiICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYm9vbGVhbiwgbm90ICR7Yn1gKTtcbn1cbmZ1bmN0aW9uIGJ5dGVzKGIsIC4uLmxlbmd0aHMpIHtcbiAgICBpZiAoIShiIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgVWludDhBcnJheScpO1xuICAgIGlmIChsZW5ndGhzLmxlbmd0aCA+IDAgJiYgIWxlbmd0aHMuaW5jbHVkZXMoYi5sZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIFVpbnQ4QXJyYXkgb2YgbGVuZ3RoICR7bGVuZ3Roc30sIG5vdCBvZiBsZW5ndGg9JHtiLmxlbmd0aH1gKTtcbn1cbmZ1bmN0aW9uIGhhc2goaGFzaCkge1xuICAgIGlmICh0eXBlb2YgaGFzaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaGFzaC5jcmVhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBzaG91bGQgYmUgd3JhcHBlZCBieSB1dGlscy53cmFwQ29uc3RydWN0b3InKTtcbiAgICBudW1iZXIoaGFzaC5vdXRwdXRMZW4pO1xuICAgIG51bWJlcihoYXNoLmJsb2NrTGVuKTtcbn1cbmZ1bmN0aW9uIGV4aXN0cyhpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xufVxuZnVuY3Rpb24gb3V0cHV0KG91dCwgaW5zdGFuY2UpIHtcbiAgICBieXRlcyhvdXQpO1xuICAgIGNvbnN0IG1pbiA9IGluc3RhbmNlLm91dHB1dExlbjtcbiAgICBpZiAob3V0Lmxlbmd0aCA8IG1pbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpZ2VzdEludG8oKSBleHBlY3RzIG91dHB1dCBidWZmZXIgb2YgbGVuZ3RoIGF0IGxlYXN0ICR7bWlufWApO1xuICAgIH1cbn1cbmV4cG9ydCB7IG51bWJlciwgYm9vbCwgYnl0ZXMsIGhhc2gsIGV4aXN0cywgb3V0cHV0IH07XG5jb25zdCBhc3NlcnQgPSB7IG51bWJlciwgYm9vbCwgYnl0ZXMsIGhhc2gsIGV4aXN0cywgb3V0cHV0IH07XG5leHBvcnQgZGVmYXVsdCBhc3NlcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fYXNzZXJ0LmpzLm1hcCJdLCJuYW1lcyI6WyJudW1iZXIiLCJuIiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsIkVycm9yIiwiYm9vbCIsImIiLCJieXRlcyIsImxlbmd0aHMiLCJVaW50OEFycmF5IiwibGVuZ3RoIiwiaW5jbHVkZXMiLCJoYXNoIiwiY3JlYXRlIiwib3V0cHV0TGVuIiwiYmxvY2tMZW4iLCJleGlzdHMiLCJpbnN0YW5jZSIsImNoZWNrRmluaXNoZWQiLCJkZXN0cm95ZWQiLCJmaW5pc2hlZCIsIm91dHB1dCIsIm91dCIsIm1pbiIsImFzc2VydCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/hashes/esm/_assert.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/hashes/esm/_sha2.js":
/*!*************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_sha2.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA2: function() { return /* binding */ SHA2; }\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === \"function\") return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number(value >> _32n & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        const len = data.length;\n        for(let pos = 0; pos < len;){\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for(; blockLen <= len - pos; pos += blockLen)this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.output)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 128;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for(let i = pos; i < blockLen; i++)buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4) throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length) throw new Error(\"_sha2: outputLen bigger than state\");\n        for(let i = 0; i < outLen; i++)oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen) to.buffer.set(buffer);\n        return to;\n    }\n    constructor(blockLen, outputLen, padOffset, isLE){\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n} //# sourceMappingURL=_sha2.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fc2hhMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBOEM7QUFDUztBQUN2RCx5QkFBeUI7QUFDekIsU0FBU0ssYUFBYUMsSUFBSSxFQUFFQyxVQUFVLEVBQUVDLEtBQUssRUFBRUMsSUFBSTtJQUMvQyxJQUFJLE9BQU9ILEtBQUtELFlBQVksS0FBSyxZQUM3QixPQUFPQyxLQUFLRCxZQUFZLENBQUNFLFlBQVlDLE9BQU9DO0lBQ2hELE1BQU1DLE9BQU9DLE9BQU87SUFDcEIsTUFBTUMsV0FBV0QsT0FBTztJQUN4QixNQUFNRSxLQUFLQyxPQUFPLFNBQVVKLE9BQVFFO0lBQ3BDLE1BQU1HLEtBQUtELE9BQU9OLFFBQVFJO0lBQzFCLE1BQU1JLElBQUlQLE9BQU8sSUFBSTtJQUNyQixNQUFNUSxJQUFJUixPQUFPLElBQUk7SUFDckJILEtBQUtZLFNBQVMsQ0FBQ1gsYUFBYVMsR0FBR0gsSUFBSUo7SUFDbkNILEtBQUtZLFNBQVMsQ0FBQ1gsYUFBYVUsR0FBR0YsSUFBSU47QUFDdkM7QUFDQSw2QkFBNkI7QUFDdEIsTUFBTVUsYUFBYWpCLDJDQUFJQTtJQWMxQmtCLE9BQU9DLElBQUksRUFBRTtRQUNUckIsa0RBQU1BLENBQUMsSUFBSTtRQUNYLE1BQU0sRUFBRU0sSUFBSSxFQUFFZ0IsTUFBTSxFQUFFQyxRQUFRLEVBQUUsR0FBRyxJQUFJO1FBQ3ZDRixPQUFPakIsa0RBQU9BLENBQUNpQjtRQUNmLE1BQU1HLE1BQU1ILEtBQUtJLE1BQU07UUFDdkIsSUFBSyxJQUFJQyxNQUFNLEdBQUdBLE1BQU1GLEtBQU07WUFDMUIsTUFBTUcsT0FBT0MsS0FBS0MsR0FBRyxDQUFDTixXQUFXLElBQUksQ0FBQ0csR0FBRyxFQUFFRixNQUFNRTtZQUNqRCw4RUFBOEU7WUFDOUUsSUFBSUMsU0FBU0osVUFBVTtnQkFDbkIsTUFBTU8sV0FBVzNCLHFEQUFVQSxDQUFDa0I7Z0JBQzVCLE1B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WjJCLEdBQUcxQixHQUFHLEdBQUdBO1FBQ1QwQixHQUFHZixRQUFRLEdBQUdBO1FBQ2RlLEdBQUdFLFNBQVMsR0FBR0E7UUFDZixJQUFJN0IsU0FBU0YsVUFDVDZCLEdBQUc5QixNQUFNLENBQUNVLEdBQUcsQ0FBQ1Y7UUFDbEIsT0FBTzhCO0lBQ1g7SUE5RkFDLFlBQVk5QixRQUFRLEVBQUVtQixTQUFTLEVBQUVILFNBQVMsRUFBRTlCLElBQUksQ0FBRTtRQUM5QyxLQUFLO1FBQ0wsSUFBSSxDQUFDYyxRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ21CLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDSCxTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQzlCLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUM0QixRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDWixNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUNDLEdBQUcsR0FBRztRQUNYLElBQUksQ0FBQzRCLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNoQyxNQUFNLEdBQUcsSUFBSWlDLFdBQVdoQztRQUM3QixJQUFJLENBQUNqQixJQUFJLEdBQUdILHFEQUFVQSxDQUFDLElBQUksQ0FBQ21CLE1BQU07SUFDdEM7QUFtRkosRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19zaGEyLmpzPzljZTQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXhpc3RzLCBvdXRwdXQgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuaW1wb3J0IHsgSGFzaCwgY3JlYXRlVmlldywgdG9CeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gUG9seWZpbGwgZm9yIFNhZmFyaSAxNFxuZnVuY3Rpb24gc2V0QmlnVWludDY0KHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKSB7XG4gICAgaWYgKHR5cGVvZiB2aWV3LnNldEJpZ1VpbnQ2NCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHZpZXcuc2V0QmlnVWludDY0KGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKTtcbiAgICBjb25zdCBfMzJuID0gQmlnSW50KDMyKTtcbiAgICBjb25zdCBfdTMyX21heCA9IEJpZ0ludCgweGZmZmZmZmZmKTtcbiAgICBjb25zdCB3aCA9IE51bWJlcigodmFsdWUgPj4gXzMybikgJiBfdTMyX21heCk7XG4gICAgY29uc3Qgd2wgPSBOdW1iZXIodmFsdWUgJiBfdTMyX21heCk7XG4gICAgY29uc3QgaCA9IGlzTEUgPyA0IDogMDtcbiAgICBjb25zdCBsID0gaXNMRSA/IDAgOiA0O1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBoLCB3aCwgaXNMRSk7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGwsIHdsLCBpc0xFKTtcbn1cbi8vIEJhc2UgU0hBMiBjbGFzcyAoUkZDIDYyMzQpXG5leHBvcnQgY2xhc3MgU0hBMiBleHRlbmRzIEhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBvdXRwdXRMZW4sIHBhZE9mZnNldCwgaXNMRSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0aGlzLnBhZE9mZnNldCA9IHBhZE9mZnNldDtcbiAgICAgICAgdGhpcy5pc0xFID0gaXNMRTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIHRoaXMudmlldyA9IGNyZWF0ZVZpZXcodGhpcy5idWZmZXIpO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBleGlzdHModGhpcyk7XG4gICAgICAgIGNvbnN0IHsgdmlldywgYnVmZmVyLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgZGF0YSA9IHRvQnl0ZXMoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIC8vIEZhc3QgcGF0aDogd2UgaGF2ZSBhdCBsZWFzdCBvbmUgYmxvY2sgaW4gaW5wdXQsIGNhc3QgaXQgdG8gdmlldyBhbmQgcHJvY2Vzc1xuICAgICAgICAgICAgaWYgKHRha2UgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVZpZXcgPSBjcmVhdGVWaWV3KGRhdGEpO1xuICAgICAgICAgICAgICAgIGZvciAoOyBibG9ja0xlbiA8PSBsZW4gLSBwb3M7IHBvcyArPSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKGRhdGFWaWV3LCBwb3MpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyLnNldChkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgdGFrZSksIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IHRha2U7XG4gICAgICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICB0aGlzLnJvdW5kQ2xlYW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGV4aXN0cyh0aGlzKTtcbiAgICAgICAgb3V0cHV0KG91dCwgdGhpcyk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAvLyBQYWRkaW5nXG4gICAgICAgIC8vIFdlIGNhbiBhdm9pZCBhbGxvY2F0aW9uIG9mIGJ1ZmZlciBmb3IgcGFkZGluZyBjb21wbGV0ZWx5IGlmIGl0XG4gICAgICAgIC8vIHdhcyBwcmV2aW91c2x5IG5vdCBhbGxvY2F0ZWQgaGVyZS4gQnV0IGl0IHdvbid0IGNoYW5nZSBwZXJmb3JtYW5jZS5cbiAgICAgICAgY29uc3QgeyBidWZmZXIsIHZpZXcsIGJsb2NrTGVuLCBpc0xFIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBwb3MgfSA9IHRoaXM7XG4gICAgICAgIC8vIGFwcGVuZCB0aGUgYml0ICcxJyB0byB0aGUgbWVzc2FnZVxuICAgICAgICBidWZmZXJbcG9zKytdID0gMGIxMDAwMDAwMDtcbiAgICAgICAgdGhpcy5idWZmZXIuc3ViYXJyYXkocG9zKS5maWxsKDApO1xuICAgICAgICAvLyB3ZSBoYXZlIGxlc3MgdGhhbiBwYWRPZmZzZXQgbGVmdCBpbiBidWZmZXIsIHNvIHdlIGNhbm5vdCBwdXQgbGVuZ3RoIGluIGN1cnJlbnQgYmxvY2ssIG5lZWQgcHJvY2VzcyBpdCBhbmQgcGFkIGFnYWluXG4gICAgICAgIGlmICh0aGlzLnBhZE9mZnNldCA+IGJsb2NrTGVuIC0gcG9zKSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICBwb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhZCB1bnRpbCBmdWxsIGJsb2NrIGJ5dGUgd2l0aCB6ZXJvc1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zOyBpIDwgYmxvY2tMZW47IGkrKylcbiAgICAgICAgICAgIGJ1ZmZlcltpXSA9IDA7XG4gICAgICAgIC8vIE5vdGU6IHNoYTUxMiByZXF1aXJlcyBsZW5ndGggdG8gYmUgMTI4Yml0IGludGVnZXIsIGJ1dCBsZW5ndGggaW4gSlMgd2lsbCBvdmVyZmxvdyBiZWZvcmUgdGhhdFxuICAgICAgICAvLyBZb3UgbmVlZCB0byB3cml0ZSBhcm91bmQgMiBleGFieXRlcyAodTY0X21heCAvIDggLyAoMTAyNCoqNikpIGZvciB0aGlzIHRvIGhhcHBlbi5cbiAgICAgICAgLy8gU28gd2UganVzdCB3cml0ZSBsb3dlc3QgNjQgYml0cyBvZiB0aGF0IHZhbHVlLlxuICAgICAgICBzZXRCaWdVaW50NjQodmlldywgYmxvY2tMZW4gLSA4LCBCaWdJbnQodGhpcy5sZW5ndGggKiA4KSwgaXNMRSk7XG4gICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgY29uc3Qgb3ZpZXcgPSBjcmVhdGVWaWV3KG91dCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMub3V0cHV0TGVuO1xuICAgICAgICAvLyBOT1RFOiB3ZSBkbyBkaXZpc2lvbiBieSA0IGxhdGVyLCB3aGljaCBzaG91bGQgYmUgZnVzZWQgaW4gc2luZ2xlIG9wIHdpdGggbW9kdWxvIGJ5IEpJVFxuICAgICAgICBpZiAobGVuICUgNClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBzaG91bGQgYmUgYWxpZ25lZCB0byAzMmJpdCcpO1xuICAgICAgICBjb25zdCBvdXRMZW4gPSBsZW4gLyA0O1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0KCk7XG4gICAgICAgIGlmIChvdXRMZW4gPiBzdGF0ZS5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gYmlnZ2VyIHRoYW4gc3RhdGUnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRMZW47IGkrKylcbiAgICAgICAgICAgIG92aWV3LnNldFVpbnQzMig0ICogaSwgc3RhdGVbaV0sIGlzTEUpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhidWZmZXIpO1xuICAgICAgICBjb25zdCByZXMgPSBidWZmZXIuc2xpY2UoMCwgb3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgdG8gfHwgKHRvID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKSk7XG4gICAgICAgIHRvLnNldCguLi50aGlzLmdldCgpKTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgYnVmZmVyLCBsZW5ndGgsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIHBvcyB9ID0gdGhpcztcbiAgICAgICAgdG8ubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0by5wb3MgPSBwb3M7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgaWYgKGxlbmd0aCAlIGJsb2NrTGVuKVxuICAgICAgICAgICAgdG8uYnVmZmVyLnNldChidWZmZXIpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3NoYTIuanMubWFwIl0sIm5hbWVzIjpbImV4aXN0cyIsIm91dHB1dCIsIkhhc2giLCJjcmVhdGVWaWV3IiwidG9CeXRlcyIsInNldEJpZ1VpbnQ2NCIsInZpZXciLCJieXRlT2Zmc2V0IiwidmFsdWUiLCJpc0xFIiwiXzMybiIsIkJpZ0ludCIsIl91MzJfbWF4Iiwid2giLCJOdW1iZXIiLCJ3bCIsImgiLCJsIiwic2V0VWludDMyIiwiU0hBMiIsInVwZGF0ZSIsImRhdGEiLCJidWZmZXIiLCJibG9ja0xlbiIsImxlbiIsImxlbmd0aCIsInBvcyIsInRha2UiLCJNYXRoIiwibWluIiwiZGF0YVZpZXciLCJwcm9jZXNzIiwic2V0Iiwic3ViYXJyYXkiLCJyb3VuZENsZWFuIiwiZGlnZXN0SW50byIsIm91dCIsImZpbmlzaGVkIiwiZmlsbCIsInBhZE9mZnNldCIsImkiLCJvdmlldyIsIm91dHB1dExlbiIsIkVycm9yIiwib3V0TGVuIiwic3RhdGUiLCJnZXQiLCJkaWdlc3QiLCJyZXMiLCJzbGljZSIsImRlc3Ryb3kiLCJfY2xvbmVJbnRvIiwidG8iLCJjb25zdHJ1Y3RvciIsImRlc3Ryb3llZCIsIlVpbnQ4QXJyYXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/hashes/esm/_sha2.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/hashes/esm/_u64.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_u64.js ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: function() { return /* binding */ add; },\n/* harmony export */   add3H: function() { return /* binding */ add3H; },\n/* harmony export */   add3L: function() { return /* binding */ add3L; },\n/* harmony export */   add4H: function() { return /* binding */ add4H; },\n/* harmony export */   add4L: function() { return /* binding */ add4L; },\n/* harmony export */   add5H: function() { return /* binding */ add5H; },\n/* harmony export */   add5L: function() { return /* binding */ add5L; },\n/* harmony export */   fromBig: function() { return /* binding */ fromBig; },\n/* harmony export */   rotlBH: function() { return /* binding */ rotlBH; },\n/* harmony export */   rotlBL: function() { return /* binding */ rotlBL; },\n/* harmony export */   rotlSH: function() { return /* binding */ rotlSH; },\n/* harmony export */   rotlSL: function() { return /* binding */ rotlSL; },\n/* harmony export */   rotr32H: function() { return /* binding */ rotr32H; },\n/* harmony export */   rotr32L: function() { return /* binding */ rotr32L; },\n/* harmony export */   rotrBH: function() { return /* binding */ rotrBH; },\n/* harmony export */   rotrBL: function() { return /* binding */ rotrBL; },\n/* harmony export */   rotrSH: function() { return /* binding */ rotrSH; },\n/* harmony export */   rotrSL: function() { return /* binding */ rotrSL; },\n/* harmony export */   shrSH: function() { return /* binding */ shrSH; },\n/* harmony export */   shrSL: function() { return /* binding */ shrSL; },\n/* harmony export */   split: function() { return /* binding */ split; },\n/* harmony export */   toBig: function() { return /* binding */ toBig; }\n/* harmony export */ });\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n) {\n    let le = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n    if (le) return {\n        h: Number(n & U32_MASK64),\n        l: Number(n >> _32n & U32_MASK64)\n    };\n    return {\n        h: Number(n >> _32n & U32_MASK64) | 0,\n        l: Number(n & U32_MASK64) | 0\n    };\n}\nfunction split(lst) {\n    let le = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for(let i = 0; i < lst.length; i++){\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [\n            h,\n            l\n        ];\n    }\n    return [\n        Ah,\n        Al\n    ];\n}\nconst toBig = (h, l)=>BigInt(h >>> 0) << _32n | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s)=>h >>> s;\nconst shrSL = (h, l, s)=>h << 32 - s | l >>> s;\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s)=>h >>> s | l << 32 - s;\nconst rotrSL = (h, l, s)=>h << 32 - s | l >>> s;\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s)=>h << 64 - s | l >>> s - 32;\nconst rotrBL = (h, l, s)=>h >>> s - 32 | l << 64 - s;\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l)=>l;\nconst rotr32L = (h, _l)=>h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s)=>h << s | l >>> 32 - s;\nconst rotlSL = (h, l, s)=>l << s | h >>> 32 - s;\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s)=>l << s - 32 | h >>> 64 - s;\nconst rotlBL = (h, l, s)=>h << s - 32 | l >>> 64 - s;\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return {\n        h: Ah + Bh + (l / 2 ** 32 | 0) | 0,\n        l: l | 0\n    };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch)=>Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;\nconst add4L = (Al, Bl, Cl, Dl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh)=>Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh)=>Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;\n// prettier-ignore\n\n// prettier-ignore\nconst u64 = {\n    fromBig,\n    split,\n    toBig,\n    shrSH,\n    shrSL,\n    rotrSH,\n    rotrSL,\n    rotrBH,\n    rotrBL,\n    rotr32H,\n    rotr32L,\n    rotlSH,\n    rotlSL,\n    rotlBH,\n    rotlBL,\n    add,\n    add3L,\n    add3H,\n    add4L,\n    add4H,\n    add5H,\n    add5L\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (u64); //# sourceMappingURL=_u64.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fdTY0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxNQUFNQSxhQUFhLGFBQWEsR0FBR0MsT0FBTyxLQUFLLEtBQUs7QUFDcEQsTUFBTUMsT0FBTyxhQUFhLEdBQUdELE9BQU87QUFDcEMsK0VBQStFO0FBQy9FLFNBQVNFLFFBQVFDLENBQUM7UUFBRUMsS0FBQUEsaUVBQUs7SUFDckIsSUFBSUEsSUFDQSxPQUFPO1FBQUVDLEdBQUdDLE9BQU9ILElBQUlKO1FBQWFRLEdBQUdELE9BQU8sS0FBTUwsT0FBUUY7SUFBWTtJQUM1RSxPQUFPO1FBQUVNLEdBQUdDLE9BQU8sS0FBTUwsT0FBUUYsY0FBYztRQUFHUSxHQUFHRCxPQUFPSCxJQUFJSixjQUFjO0lBQUU7QUFDcEY7QUFDQSxTQUFTUyxNQUFNQyxHQUFHO1FBQUVMLEtBQUFBLGlFQUFLO0lBQ3JCLElBQUlNLEtBQUssSUFBSUMsWUFBWUYsSUFBSUcsTUFBTTtJQUNuQyxJQUFJQyxLQUFLLElBQUlGLFlBQVlGLElBQUlHLE1BQU07SUFDbkMsSUFBSyxJQUFJRSxJQUFJLEdBQUdBLElBQUlMLElBQUlHLE1BQU0sRUFBRUUsSUFBSztRQUNqQyxNQUFNLEVBQUVULENBQUMsRUFBRUUsQ0FBQyxFQUFFLEdBQUdMLFFBQVFPLEdBQUcsQ0FBQ0ssRUFBRSxFQUFFVjtRQUNqQyxDQUFDTSxFQUFFLENBQUNJLEVBQUUsRUFBRUQsRUFBRSxDQUFDQyxFQUFFLENBQUMsR0FBRztZQUFDVDtZQUFHRTtTQUFFO0lBQzNCO0lBQ0EsT0FBTztRQUFDRztRQUFJRztLQUFHO0FBQ25CO0FBQ0EsTUFBTUUsUUFBUSxDQUFDVixHQUFHRSxJQUFNLE9BQVFGLE1BQU0sTUFBTUosT0FBUUQsT0FBT08sTUFBTTtBQUNqRSx1QkFBdUI7QUFDdkIsTUFBTVMsUUFBUSxDQUFDWCxHQUFHWSxJQUFJQyxJQUFNYixN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QSxFQUFDLENBQ25CLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3U2NC5qcz83ZGMwIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFUzMl9NQVNLNjQgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDIgKiogMzIgLSAxKTtcbmNvbnN0IF8zMm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDMyKTtcbi8vIFdlIGFyZSBub3QgdXNpbmcgQmlnVWludDY0QXJyYXksIGJlY2F1c2UgdGhleSBhcmUgZXh0cmVtZWx5IHNsb3cgYXMgcGVyIDIwMjJcbmZ1bmN0aW9uIGZyb21CaWcobiwgbGUgPSBmYWxzZSkge1xuICAgIGlmIChsZSlcbiAgICAgICAgcmV0dXJuIHsgaDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSwgbDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfTtcbiAgICByZXR1cm4geyBoOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB8IDAsIGw6IE51bWJlcihuICYgVTMyX01BU0s2NCkgfCAwIH07XG59XG5mdW5jdGlvbiBzcGxpdChsc3QsIGxlID0gZmFsc2UpIHtcbiAgICBsZXQgQWggPSBuZXcgVWludDMyQXJyYXkobHN0Lmxlbmd0aCk7XG4gICAgbGV0IEFsID0gbmV3IFVpbnQzMkFycmF5KGxzdC5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbHN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHsgaCwgbCB9ID0gZnJvbUJpZyhsc3RbaV0sIGxlKTtcbiAgICAgICAgW0FoW2ldLCBBbFtpXV0gPSBbaCwgbF07XG4gICAgfVxuICAgIHJldHVybiBbQWgsIEFsXTtcbn1cbmNvbnN0IHRvQmlnID0gKGgsIGwpID0+IChCaWdJbnQoaCA+Pj4gMCkgPDwgXzMybikgfCBCaWdJbnQobCA+Pj4gMCk7XG4vLyBmb3IgU2hpZnQgaW4gWzAsIDMyKVxuY29uc3Qgc2hyU0ggPSAoaCwgX2wsIHMpID0+IGggPj4+IHM7XG5jb25zdCBzaHJTTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdHJTSCA9IChoLCBsLCBzKSA9PiAoaCA+Pj4gcykgfCAobCA8PCAoMzIgLSBzKSk7XG5jb25zdCByb3RyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiAoMzIsIDY0KSwgTk9URTogMzIgaXMgc3BlY2lhbCBjYXNlLlxuY29uc3Qgcm90ckJIID0gKGgsIGwsIHMpID0+IChoIDw8ICg2NCAtIHMpKSB8IChsID4+PiAocyAtIDMyKSk7XG5jb25zdCByb3RyQkwgPSAoaCwgbCwgcykgPT4gKGggPj4+IChzIC0gMzIpKSB8IChsIDw8ICg2NCAtIHMpKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3Igc2hpZnQ9PT0zMiAoanVzdCBzd2FwcyBsJmgpXG5jb25zdCByb3RyMzJIID0gKF9oLCBsKSA9PiBsO1xuY29uc3Qgcm90cjMyTCA9IChoLCBfbCkgPT4gaDtcbi8vIExlZnQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RsU0ggPSAoaCwgbCwgcykgPT4gKGggPDwgcykgfCAobCA+Pj4gKDMyIC0gcykpO1xuY29uc3Qgcm90bFNMID0gKGgsIGwsIHMpID0+IChsIDw8IHMpIHwgKGggPj4+ICgzMiAtIHMpKTtcbi8vIExlZnQgcm90YXRlIGZvciBTaGlmdCBpbiAoMzIsIDY0KSwgTk9URTogMzIgaXMgc3BlY2lhbCBjYXNlLlxuY29uc3Qgcm90bEJIID0gKGgsIGwsIHMpID0+IChsIDw8IChzIC0gMzIpKSB8IChoID4+PiAoNjQgLSBzKSk7XG5jb25zdCByb3RsQkwgPSAoaCwgbCwgcykgPT4gKGggPDwgKHMgLSAzMikpIHwgKGwgPj4+ICg2NCAtIHMpKTtcbi8vIEpTIHVzZXMgMzItYml0IHNpZ25lZCBpbnRlZ2VycyBmb3IgYml0d2lzZSBvcGVyYXRpb25zIHdoaWNoIG1lYW5zIHdlIGNhbm5vdFxuLy8gc2ltcGxlIHRha2UgY2Fycnkgb3V0IG9mIGxvdyBiaXQgc3VtIGJ5IHNoaWZ0LCB3ZSBuZWVkIHRvIHVzZSBkaXZpc2lvbi5cbmZ1bmN0aW9uIGFkZChBaCwgQWwsIEJoLCBCbCkge1xuICAgIGNvbnN0IGwgPSAoQWwgPj4+IDApICsgKEJsID4+PiAwKTtcbiAgICByZXR1cm4geyBoOiAoQWggKyBCaCArICgobCAvIDIgKiogMzIpIHwgMCkpIHwgMCwgbDogbCB8IDAgfTtcbn1cbi8vIEFkZGl0aW9uIHdpdGggbW9yZSB0aGFuIDIgZWxlbWVudHNcbmNvbnN0IGFkZDNMID0gKEFsLCBCbCwgQ2wpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKTtcbmNvbnN0IGFkZDNIID0gKGxvdywgQWgsIEJoLCBDaCkgPT4gKEFoICsgQmggKyBDaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuY29uc3QgYWRkNEwgPSAoQWwsIEJsLCBDbCwgRGwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCk7XG5jb25zdCBhZGQ0SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmNvbnN0IGFkZDVMID0gKEFsLCBCbCwgQ2wsIERsLCBFbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKSArIChFbCA+Pj4gMCk7XG5jb25zdCBhZGQ1SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoLCBFaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgRWggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbi8vIHByZXR0aWVyLWlnbm9yZVxuZXhwb3J0IHsgZnJvbUJpZywgc3BsaXQsIHRvQmlnLCBzaHJTSCwgc2hyU0wsIHJvdHJTSCwgcm90clNMLCByb3RyQkgsIHJvdHJCTCwgcm90cjMySCwgcm90cjMyTCwgcm90bFNILCByb3RsU0wsIHJvdGxCSCwgcm90bEJMLCBhZGQsIGFkZDNMLCBhZGQzSCwgYWRkNEwsIGFkZDRILCBhZGQ1SCwgYWRkNUwsIH07XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IHU2NCA9IHtcbiAgICBmcm9tQmlnLCBzcGxpdCwgdG9CaWcsXG4gICAgc2hyU0gsIHNoclNMLFxuICAgIHJvdHJTSCwgcm90clNMLCByb3RyQkgsIHJvdHJCTCxcbiAgICByb3RyMzJILCByb3RyMzJMLFxuICAgIHJvdGxTSCwgcm90bFNMLCByb3RsQkgsIHJvdGxCTCxcbiAgICBhZGQsIGFkZDNMLCBhZGQzSCwgYWRkNEwsIGFkZDRILCBhZGQ1SCwgYWRkNUwsXG59O1xuZXhwb3J0IGRlZmF1bHQgdTY0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3U2NC5qcy5tYXAiXSwibmFtZXMiOlsiVTMyX01BU0s2NCIsIkJpZ0ludCIsIl8zMm4iLCJmcm9tQmlnIiwibiIsImxlIiwiaCIsIk51bWJlciIsImwiLCJzcGxpdCIsImxzdCIsIkFoIiwiVWludDMyQXJyYXkiLCJsZW5ndGgiLCJBbCIsImkiLCJ0b0JpZyIsInNoclNIIiwiX2wiLCJzIiwic2hyU0wiLCJyb3RyU0giLCJyb3RyU0wiLCJyb3RyQkgiLCJyb3RyQkwiLCJyb3RyMzJIIiwiX2giLCJyb3RyMzJMIiwicm90bFNIIiwicm90bFNMIiwicm90bEJIIiwicm90bEJMIiwiYWRkIiwiQmgiLCJCbCIsImFkZDNMIiwiQ2wiLCJhZGQzSCIsImxvdyIsIkNoIiwiYWRkNEwiLCJEbCIsImFkZDRIIiwiRGgiLCJhZGQ1TCIsIkVsIiwiYWRkNUgiLCJFaCIsInU2NCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/hashes/esm/_u64.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/hashes/esm/crypto.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/crypto.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: function() { return /* binding */ crypto; }\n/* harmony export */ });\nconst crypto = typeof globalThis === \"object\" && \"crypto\" in globalThis ? globalThis.crypto : undefined; //# sourceMappingURL=crypto.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9jcnlwdG8uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLE1BQU1BLFNBQVMsT0FBT0MsZUFBZSxZQUFZLFlBQVlBLGFBQWFBLFdBQVdELE1BQU0sR0FBR0UsVUFBVSxDQUMvRyxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2NyeXB0by5qcz9iMGE5Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBjcnlwdG8gPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcgJiYgJ2NyeXB0bycgaW4gZ2xvYmFsVGhpcyA/IGdsb2JhbFRoaXMuY3J5cHRvIDogdW5kZWZpbmVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3J5cHRvLmpzLm1hcCJdLCJuYW1lcyI6WyJjcnlwdG8iLCJnbG9iYWxUaGlzIiwidW5kZWZpbmVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/hashes/esm/crypto.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/hashes/esm/hmac.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/hmac.js ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: function() { return /* binding */ HMAC; },\n/* harmony export */   hmac: function() { return /* binding */ hmac; }\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n\n\n// HMAC (RFC 2104)\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    update(buf) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.bytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n    constructor(hash, _key){\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.hash)(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== \"function\") throw new Error(\"Expected instance of class which extends utils.Hash\");\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */ const hmac = (hash, key, message)=>new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key)=>new HMAC(hash, key); //# sourceMappingURL=hmac.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9obWFjLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBZ0c7QUFDckQ7QUFDM0Msa0JBQWtCO0FBQ1gsTUFBTVEsYUFBYUYsMkNBQUlBO0lBMkIxQkcsT0FBT0MsR0FBRyxFQUFFO1FBQ1JMLGtEQUFZQSxDQUFDLElBQUk7UUFDakIsSUFBSSxDQUFDTSxLQUFLLENBQUNGLE1BQU0sQ0FBQ0M7UUFDbEIsT0FBTyxJQUFJO0lBQ2Y7SUFDQUUsV0FBV0MsR0FBRyxFQUFFO1FBQ1pSLGtEQUFZQSxDQUFDLElBQUk7UUFDakJGLGlEQUFXQSxDQUFDVSxLQUFLLElBQUksQ0FBQ0MsU0FBUztRQUMvQixJQUFJLENBQUNDLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNKLEtBQUssQ0FBQ0MsVUFBVSxDQUFDQztRQUN0QixJQUFJLENBQUNHLEtBQUssQ0FBQ1AsTUFBTSxDQUFDSTtRQUNsQixJQUFJLENBQUNHLEtBQUssQ0FBQ0osVUFBVSxDQUFDQztRQUN0QixJQUFJLENBQUNJLE9BQU87SUFDaEI7SUFDQUMsU0FBUztRQUNMLE1BQU1MLE1BQU0sSUFBSU0sV0FBVyxJQUFJLENBQUNILEtBQUssQ0FBQ0YsU0FBUztRQUMvQyxJQUFJLENBQUNGLFVBQVUsQ0FBQ0M7UUFDaEIsT0FBT0E7SUFDWDtJQUNBTyxXQUFXQyxFQUFFLEVBQUU7UUFDWCxtR0FBbUc7UUFDbkdBLE1BQU9BLENBQUFBLEtBQUtDLE9BQU9DLE1BQU0sQ0FBQ0QsT0FBT0UsY0FBYyxDQUFDLElBQUksR0FBRyxDQUFDLEVBQUM7UUFDekQsTUFBTSxFQUFFUixLQUFLLEVBQUVMLEtBQUssRUFBRUksUUFBUSxFQUFFVSxTQUFTLEVBQUVDLFFBQVEsRUFBRVosU0FBUyxFQUFFLEdBQUcsSUFBSTtRQUN2RU8sS0FBS0E7UUFDTEEsR0FBR04sUUFBUSxHQUFHQTtRQUNkTSxHQUFHSSxTQUFTLEdBQUdBO1FBQ2ZKLEdBQUdLLFFBQVEsR0FBR0E7UUFDZEwsR0FBR1AsU0FBUyxHQUFHQTtRQUNmTyxHQUFHTCxLQUFLLEdBQUdBLE1BQU1JLFVBQVUsQ0FBQ0MsR0FBR0wsS0FBSztRQUNwQ0ssR0FBR1YsS0FBSyxHQUFHQSxNQUFNUyxVQUFVLENBQUNDLEdBQUdWLEtBQUs7UUFDcEMsT0FBT1U7SUFDWDtJQUNBSixVQUFVO1FBQ04sSUFBSSxDQUFDUSxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDVCxLQUFLLENBQUNDLE9BQU87UUFDbEIsSUFBSSxDQUFDTixLQUFLLENBQUNNLE9BQU87SUFDdEI7SUE5REFVLFlBQVkzQixJQUFJLEVBQUU0QixJQUFJLENBQUU7UUFDcEIsS0FBSztRQUNMLElBQUksQ0FBQ2IsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ1UsU0FBUyxHQUFHO1FBQ2pCeEIsZ0RBQVVBLENBQUNEO1FBQ1gsTUFBTTZCLE1BQU10QixrREFBT0EsQ0FBQ3FCO1FBQ3BCLElBQUksQ0FBQ2pCLEtBQUssR0FBR1gsS0FBS3VCLE1BQU07UUFDeEIsSUFBSSxPQUFPLElBQUksQ0FBQ1osS0FBSyxDQUFDRixNQUFNLEtBQUssWUFDN0IsTUFBTSxJQUFJcUIsTUFBTTtRQUNwQixJQUFJLENBQUNKLFFBQVEsR0FBRyxJQUFJLENBQUNmLEtBQUssQ0FBQ2UsUUFBUTtRQUNuQyxJQUFJLENBQUNaLFNBQVMsR0FBRyxJQUFJLENBQUNILEtBQUssQ0FBQ0csU0FBUztRQUNyQyxNQUFNWSxXQUFXLElBQUksQ0FBQ0EsUUFBUTtRQUM5QixNQUFNSyxNQUFNLElBQUlaLFdBQVdPO1FBQzNCLHdDQUF3QztRQUN4Q0ssSUFBSUMsR0FBRyxDQUFDSCxJQUFJSSxNQUFNLEdBQUdQLFdBQVcxQixLQUFLdUIsTUFBTSxHQUFHZCxNQUFNLENBQUNvQixLQUFLWCxNQUFNLEtBQUtXO1FBQ3JFLElBQUssSUFBSUssSUFBSSxHQUFHQSxJQUFJSCxJQUFJRSxNQUFNLEVBQUVDLElBQzVCSCxHQUFHLENBQUNHLEVBQUUsSUFBSTtRQUNkLElBQUksQ0FBQ3ZCLEtBQUssQ0FBQ0YsTUFBTSxDQUFDc0I7UUFDbEIsbUhBQW1IO1FBQ25ILElBQUksQ0FBQ2YsS0FBSyxHQUFHaEIsS0FBS3VCLE1BQU07UUFDeEIsdUNBQXVDO1FBQ3ZDLElBQUssSUFBSVcsSUFBSSxHQUFHQSxJQUFJSCxJQUFJRSxNQUFNLEVBQUVDLElBQzVCSCxHQUFHLENBQUNHLEVBQUUsSUFBSSxPQUFPO1FBQ3JCLElBQUksQ0FBQ2xCLEtBQUssQ0FBQ1AsTUFBTSxDQUFDc0I7UUFDbEJBLElBQUlJLElBQUksQ0FBQztJQUNiO0FBc0NKO0FBQ0E7Ozs7O0NBS0MsR0FDTSxNQUFNQyxPQUFPLENBQUNwQyxNQUFNNkIsS0FBS1EsVUFBWSxJQUFJN0IsS0FBS1IsTUFBTTZCLEtBQUtwQixNQUFNLENBQUM0QixTQUFTbkIsTUFBTSxHQUFHO0FBQ3pGa0IsS0FBS2IsTUFBTSxHQUFHLENBQUN2QixNQUFNNkIsTUFBUSxJQUFJckIsS0FBS1IsTUFBTTZCLE1BQzVDLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vaG1hYy5qcz8wY2NhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGhhc2ggYXMgYXNzZXJ0SGFzaCwgYnl0ZXMgYXMgYXNzZXJ0Qnl0ZXMsIGV4aXN0cyBhcyBhc3NlcnRFeGlzdHMgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuaW1wb3J0IHsgSGFzaCwgdG9CeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gSE1BQyAoUkZDIDIxMDQpXG5leHBvcnQgY2xhc3MgSE1BQyBleHRlbmRzIEhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGhhc2gsIF9rZXkpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICBhc3NlcnRIYXNoKGhhc2gpO1xuICAgICAgICBjb25zdCBrZXkgPSB0b0J5dGVzKF9rZXkpO1xuICAgICAgICB0aGlzLmlIYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmlIYXNoLnVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgaW5zdGFuY2Ugb2YgY2xhc3Mgd2hpY2ggZXh0ZW5kcyB1dGlscy5IYXNoJyk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSB0aGlzLmlIYXNoLmJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IHRoaXMuaUhhc2gub3V0cHV0TGVuO1xuICAgICAgICBjb25zdCBibG9ja0xlbiA9IHRoaXMuYmxvY2tMZW47XG4gICAgICAgIGNvbnN0IHBhZCA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgLy8gYmxvY2tMZW4gY2FuIGJlIGJpZ2dlciB0aGFuIG91dHB1dExlblxuICAgICAgICBwYWQuc2V0KGtleS5sZW5ndGggPiBibG9ja0xlbiA/IGhhc2guY3JlYXRlKCkudXBkYXRlKGtleSkuZGlnZXN0KCkgOiBrZXkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2O1xuICAgICAgICB0aGlzLmlIYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICAvLyBCeSBkb2luZyB1cGRhdGUgKHByb2Nlc3Npbmcgb2YgZmlyc3QgYmxvY2spIG9mIG91dGVyIGhhc2ggaGVyZSB3ZSBjYW4gcmUtdXNlIGl0IGJldHdlZW4gbXVsdGlwbGUgY2FsbHMgdmlhIGNsb25lXG4gICAgICAgIHRoaXMub0hhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICAvLyBVbmRvIGludGVybmFsIFhPUiAmJiBhcHBseSBvdXRlciBYT1JcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNiBeIDB4NWM7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIHBhZC5maWxsKDApO1xuICAgIH1cbiAgICB1cGRhdGUoYnVmKSB7XG4gICAgICAgIGFzc2VydEV4aXN0cyh0aGlzKTtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUoYnVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGFzc2VydEV4aXN0cyh0aGlzKTtcbiAgICAgICAgYXNzZXJ0Qnl0ZXMob3V0LCB0aGlzLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmlIYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUob3V0KTtcbiAgICAgICAgdGhpcy5vSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KHRoaXMub0hhc2gub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgLy8gQ3JlYXRlIG5ldyBpbnN0YW5jZSB3aXRob3V0IGNhbGxpbmcgY29uc3RydWN0b3Igc2luY2Uga2V5IGFscmVhZHkgaW4gc3RhdGUgYW5kIHdlIGRvbid0IGtub3cgaXQuXG4gICAgICAgIHRvIHx8ICh0byA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLCB7fSkpO1xuICAgICAgICBjb25zdCB7IG9IYXNoLCBpSGFzaCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgYmxvY2tMZW4sIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdG8gPSB0bztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICB0by5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRvLm9IYXNoID0gb0hhc2guX2Nsb25lSW50byh0by5vSGFzaCk7XG4gICAgICAgIHRvLmlIYXNoID0gaUhhc2guX2Nsb25lSW50byh0by5pSGFzaCk7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9IYXNoLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5pSGFzaC5kZXN0cm95KCk7XG4gICAgfVxufVxuLyoqXG4gKiBITUFDOiBSRkMyMTA0IG1lc3NhZ2UgYXV0aGVudGljYXRpb24gY29kZS5cbiAqIEBwYXJhbSBoYXNoIC0gZnVuY3Rpb24gdGhhdCB3b3VsZCBiZSB1c2VkIGUuZy4gc2hhMjU2XG4gKiBAcGFyYW0ga2V5IC0gbWVzc2FnZSBrZXlcbiAqIEBwYXJhbSBtZXNzYWdlIC0gbWVzc2FnZSBkYXRhXG4gKi9cbmV4cG9ydCBjb25zdCBobWFjID0gKGhhc2gsIGtleSwgbWVzc2FnZSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KS51cGRhdGUobWVzc2FnZSkuZGlnZXN0KCk7XG5obWFjLmNyZWF0ZSA9IChoYXNoLCBrZXkpID0+IG5ldyBITUFDKGhhc2gsIGtleSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1obWFjLmpzLm1hcCJdLCJuYW1lcyI6WyJoYXNoIiwiYXNzZXJ0SGFzaCIsImJ5dGVzIiwiYXNzZXJ0Qnl0ZXMiLCJleGlzdHMiLCJhc3NlcnRFeGlzdHMiLCJIYXNoIiwidG9CeXRlcyIsIkhNQUMiLCJ1cGRhdGUiLCJidWYiLCJpSGFzaCIsImRpZ2VzdEludG8iLCJvdXQiLCJvdXRwdXRMZW4iLCJmaW5pc2hlZCIsIm9IYXNoIiwiZGVzdHJveSIsImRpZ2VzdCIsIlVpbnQ4QXJyYXkiLCJfY2xvbmVJbnRvIiwidG8iLCJPYmplY3QiLCJjcmVhdGUiLCJnZXRQcm90b3R5cGVPZiIsImRlc3Ryb3llZCIsImJsb2NrTGVuIiwiY29uc3RydWN0b3IiLCJfa2V5Iiwia2V5IiwiRXJyb3IiLCJwYWQiLCJzZXQiLCJsZW5ndGgiLCJpIiwiZmlsbCIsImhtYWMiLCJtZXNzYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/hashes/esm/hmac.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/hashes/esm/pbkdf2.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/pbkdf2.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pbkdf2: function() { return /* binding */ pbkdf2; },\n/* harmony export */   pbkdf2Async: function() { return /* binding */ pbkdf2Async; }\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _hmac_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hmac.js */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// Common prologue and epilogue for sync/async functions\nfunction pbkdf2Init(hash, _password, _salt, _opts) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.hash)(hash);\n    const opts = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.checkOpts)({\n        dkLen: 32,\n        asyncTick: 10\n    }, _opts);\n    const { c, dkLen, asyncTick } = opts;\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.number)(c);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.number)(dkLen);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.number)(asyncTick);\n    if (c < 1) throw new Error(\"PBKDF2: iterations (c) should be >= 1\");\n    const password = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(_password);\n    const salt = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(_salt);\n    // DK = PBKDF2(PRF, Password, Salt, c, dkLen);\n    const DK = new Uint8Array(dkLen);\n    // U1 = PRF(Password, Salt + INT_32_BE(i))\n    const PRF = _hmac_js__WEBPACK_IMPORTED_MODULE_2__.hmac.create(hash, password);\n    const PRFSalt = PRF._cloneInto().update(salt);\n    return {\n        c,\n        dkLen,\n        asyncTick,\n        DK,\n        PRF,\n        PRFSalt\n    };\n}\nfunction pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {\n    PRF.destroy();\n    PRFSalt.destroy();\n    if (prfW) prfW.destroy();\n    u.fill(0);\n    return DK;\n}\n/**\n * PBKDF2-HMAC: RFC 2898 key derivation function\n * @param hash - hash function that would be used e.g. sha256\n * @param password - password from which a derived key is generated\n * @param salt - cryptographic salt\n * @param opts - {c, dkLen} where c is work factor and dkLen is output message size\n */ function pbkdf2(hash, password, salt, opts) {\n    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 +  + Tdklen/hlen\n    for(let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen){\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        for(let ui = 1; ui < c; ui++){\n            // Uc = PRF(Password, Uc1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for(let i = 0; i < Ti.length; i++)Ti[i] ^= u[i];\n        }\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\nasync function pbkdf2Async(hash, password, salt, opts) {\n    const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 +  + Tdklen/hlen\n    for(let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen){\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        await (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.asyncLoop)(c - 1, asyncTick, ()=>{\n            // Uc = PRF(Password, Uc1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for(let i = 0; i < Ti.length; i++)Ti[i] ^= u[i];\n        });\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n} //# sourceMappingURL=pbkdf2.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9wYmtkZjIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBMEU7QUFDekM7QUFDc0M7QUFDdkUsd0RBQXdEO0FBQ3hELFNBQVNTLFdBQVdULElBQUksRUFBRVUsU0FBUyxFQUFFQyxLQUFLLEVBQUVDLEtBQUs7SUFDN0NYLGdEQUFVQSxDQUFDRDtJQUNYLE1BQU1hLE9BQU9OLG9EQUFTQSxDQUFDO1FBQUVPLE9BQU87UUFBSUMsV0FBVztJQUFHLEdBQUdIO0lBQ3JELE1BQU0sRUFBRUksQ0FBQyxFQUFFRixLQUFLLEVBQUVDLFNBQVMsRUFBRSxHQUFHRjtJQUNoQ1Ysa0RBQVlBLENBQUNhO0lBQ2JiLGtEQUFZQSxDQUFDVztJQUNiWCxrREFBWUEsQ0FBQ1k7SUFDYixJQUFJQyxJQUFJLEdBQ0osTUFBTSxJQUFJQyxNQUFNO0lBQ3BCLE1BQU1DLFdBQVdaLGtEQUFPQSxDQUFDSTtJQUN6QixNQUFNUyxPQUFPYixrREFBT0EsQ0FBQ0s7SUFDckIsOENBQThDO0lBQzlDLE1BQU1TLEtBQUssSUFBSUMsV0FBV1A7SUFDMUIsMENBQTBDO0lBQzFDLE1BQU1RLE1BQU1sQiwwQ0FBSUEsQ0FBQ21CLE1BQU0sQ0FBQ3ZCLE1BQU1rQjtJQUM5QixNQUFNTSxVQUFVRixJQUFJRyxVQUFVLEdBQUdDLE1BQU0sQ0FBQ1A7SUFDeEMsT0FBTztRQUFFSDtRQUFHRjtRQUFPQztRQUFXSztRQUFJRTtRQUFLRTtJQUFRO0FBQ25EO0FBQ0EsU0FBU0csYUFBYUwsR0FBRyxFQUFFRSxPQUFPLEVBQUVKLEVBQUUsRUFBRVEsSUFBSSxFQUFFQyxDQUFDO0lBQzNDUCxJQUFJUSxPQUFPO0lBQ1hOLFFBQVFNLE9BQU87SUFDZixJQUFJRixNQUNBQSxLQUFLRSxPQUFPO0lBQ2hCRCxFQUFFRSxJQUFJLENBQUM7SUFDUCxPQUFPWDtBQUNYO0FBQ0E7Ozs7OztDQU1DLEdBQ00sU0FBU1ksT0FBT2hDLElB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QVNKLElBQUlRLE1BQU1DO0FBQ2hELEVBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9wYmtkZjIuanM/ZjRmMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBoYXNoIGFzIGFzc2VydEhhc2gsIG51bWJlciBhcyBhc3NlcnROdW1iZXIgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuaW1wb3J0IHsgaG1hYyB9IGZyb20gJy4vaG1hYy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVWaWV3LCB0b0J5dGVzLCBjaGVja09wdHMsIGFzeW5jTG9vcCB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gQ29tbW9uIHByb2xvZ3VlIGFuZCBlcGlsb2d1ZSBmb3Igc3luYy9hc3luYyBmdW5jdGlvbnNcbmZ1bmN0aW9uIHBia2RmMkluaXQoaGFzaCwgX3Bhc3N3b3JkLCBfc2FsdCwgX29wdHMpIHtcbiAgICBhc3NlcnRIYXNoKGhhc2gpO1xuICAgIGNvbnN0IG9wdHMgPSBjaGVja09wdHMoeyBka0xlbjogMzIsIGFzeW5jVGljazogMTAgfSwgX29wdHMpO1xuICAgIGNvbnN0IHsgYywgZGtMZW4sIGFzeW5jVGljayB9ID0gb3B0cztcbiAgICBhc3NlcnROdW1iZXIoYyk7XG4gICAgYXNzZXJ0TnVtYmVyKGRrTGVuKTtcbiAgICBhc3NlcnROdW1iZXIoYXN5bmNUaWNrKTtcbiAgICBpZiAoYyA8IDEpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUEJLREYyOiBpdGVyYXRpb25zIChjKSBzaG91bGQgYmUgPj0gMScpO1xuICAgIGNvbnN0IHBhc3N3b3JkID0gdG9CeXRlcyhfcGFzc3dvcmQpO1xuICAgIGNvbnN0IHNhbHQgPSB0b0J5dGVzKF9zYWx0KTtcbiAgICAvLyBESyA9IFBCS0RGMihQUkYsIFBhc3N3b3JkLCBTYWx0LCBjLCBka0xlbik7XG4gICAgY29uc3QgREsgPSBuZXcgVWludDhBcnJheShka0xlbik7XG4gICAgLy8gVTEgPSBQUkYoUGFzc3dvcmQsIFNhbHQgKyBJTlRfMzJfQkUoaSkpXG4gICAgY29uc3QgUFJGID0gaG1hYy5jcmVhdGUoaGFzaCwgcGFzc3dvcmQpO1xuICAgIGNvbnN0IFBSRlNhbHQgPSBQUkYuX2Nsb25lSW50bygpLnVwZGF0ZShzYWx0KTtcbiAgICByZXR1cm4geyBjLCBka0xlbiwgYXN5bmNUaWNrLCBESywgUFJGLCBQUkZTYWx0IH07XG59XG5mdW5jdGlvbiBwYmtkZjJPdXRwdXQoUFJGLCBQUkZTYWx0LCBESywgcHJmVywgdSkge1xuICAgIFBSRi5kZXN0cm95KCk7XG4gICAgUFJGU2FsdC5kZXN0cm95KCk7XG4gICAgaWYgKHByZlcpXG4gICAgICAgIHByZlcuZGVzdHJveSgpO1xuICAgIHUuZmlsbCgwKTtcbiAgICByZXR1cm4gREs7XG59XG4vKipcbiAqIFBCS0RGMi1ITUFDOiBSRkMgMjg5OCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvblxuICogQHBhcmFtIGhhc2ggLSBoYXNoIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCBlLmcuIHNoYTI1NlxuICogQHBhcmFtIHBhc3N3b3JkIC0gcGFzc3dvcmQgZnJvbSB3aGljaCBhIGRlcml2ZWQga2V5IGlzIGdlbmVyYXRlZFxuICogQHBhcmFtIHNhbHQgLSBjcnlwdG9ncmFwaGljIHNhbHRcbiAqIEBwYXJhbSBvcHRzIC0ge2MsIGRrTGVufSB3aGVyZSBjIGlzIHdvcmsgZmFjdG9yIGFuZCBka0xlbiBpcyBvdXRwdXQgbWVzc2FnZSBzaXplXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYmtkZjIoaGFzaCwgcGFzc3dvcmQsIHNhbHQsIG9wdHMpIHtcbiAgICBjb25zdCB7IGMsIGRrTGVuLCBESywgUFJGLCBQUkZTYWx0IH0gPSBwYmtkZjJJbml0KGhhc2gsIHBhc3N3b3JkLCBzYWx0LCBvcHRzKTtcbiAgICBsZXQgcHJmVzsgLy8gV29ya2luZyBjb3B5XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgY29uc3QgdmlldyA9IGNyZWF0ZVZpZXcoYXJyKTtcbiAgICBjb25zdCB1ID0gbmV3IFVpbnQ4QXJyYXkoUFJGLm91dHB1dExlbik7XG4gICAgLy8gREsgPSBUMSArIFQyICsg4ouvICsgVGRrbGVuL2hsZW5cbiAgICBmb3IgKGxldCB0aSA9IDEsIHBvcyA9IDA7IHBvcyA8IGRrTGVuOyB0aSsrLCBwb3MgKz0gUFJGLm91dHB1dExlbikge1xuICAgICAgICAvLyBUaSA9IEYoUGFzc3dvcmQsIFNhbHQsIGMsIGkpXG4gICAgICAgIGNvbnN0IFRpID0gREsuc3ViYXJyYXkocG9zLCBwb3MgKyBQUkYub3V0cHV0TGVuKTtcbiAgICAgICAgdmlldy5zZXRJbnQzMigwLCB0aSwgZmFsc2UpO1xuICAgICAgICAvLyBGKFBhc3N3b3JkLCBTYWx0LCBjLCBpKSA9IFUxIF4gVTIgXiDii68gXiBVY1xuICAgICAgICAvLyBVMSA9IFBSRihQYXNzd29yZCwgU2FsdCArIElOVF8zMl9CRShpKSlcbiAgICAgICAgKHByZlcgPSBQUkZTYWx0Ll9jbG9uZUludG8ocHJmVykpLnVwZGF0ZShhcnIpLmRpZ2VzdEludG8odSk7XG4gICAgICAgIFRpLnNldCh1LnN1YmFycmF5KDAsIFRpLmxlbmd0aCkpO1xuICAgICAgICBmb3IgKGxldCB1aSA9IDE7IHVpIDwgYzsgdWkrKykge1xuICAgICAgICAgICAgLy8gVWMgPSBQUkYoUGFzc3dvcmQsIFVj4oiSMSlcbiAgICAgICAgICAgIFBSRi5fY2xvbmVJbnRvKHByZlcpLnVwZGF0ZSh1KS5kaWdlc3RJbnRvKHUpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBUaS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBUaVtpXSBePSB1W2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYmtkZjJPdXRwdXQoUFJGLCBQUkZTYWx0LCBESywgcHJmVywgdSk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcGJrZGYyQXN5bmMoaGFzaCwgcGFzc3dvcmQsIHNhbHQsIG9wdHMpIHtcbiAgICBjb25zdCB7IGMsIGRrTGVuLCBhc3luY1RpY2ssIERLLCBQUkYsIFBSRlNhbHQgfSA9IHBia2RmMkluaXQoaGFzaCwgcGFzc3dvcmQsIHNhbHQsIG9wdHMpO1xuICAgIGxldCBwcmZXOyAvLyBXb3JraW5nIGNvcHlcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICBjb25zdCB2aWV3ID0gY3JlYXRlVmlldyhhcnIpO1xuICAgIGNvbnN0IHUgPSBuZXcgVWludDhBcnJheShQUkYub3V0cHV0TGVuKTtcbiAgICAvLyBESyA9IFQxICsgVDIgKyDii68gKyBUZGtsZW4vaGxlblxuICAgIGZvciAobGV0IHRpID0gMSwgcG9zID0gMDsgcG9zIDwgZGtMZW47IHRpKyssIHBvcyArPSBQUkYub3V0cHV0TGVuKSB7XG4gICAgICAgIC8vIFRpID0gRihQYXNzd29yZCwgU2FsdCwgYywgaSlcbiAgICAgICAgY29uc3QgVGkgPSBESy5zdWJhcnJheShwb3MsIHBvcyArIFBSRi5vdXRwdXRMZW4pO1xuICAgICAgICB2aWV3LnNldEludDMyKDAsIHRpLCBmYWxzZSk7XG4gICAgICAgIC8vIEYoUGFzc3dvcmQsIFNhbHQsIGMsIGkpID0gVTEgXiBVMiBeIOKLryBeIFVjXG4gICAgICAgIC8vIFUxID0gUFJGKFBhc3N3b3JkLCBTYWx0ICsgSU5UXzMyX0JFKGkpKVxuICAgICAgICAocHJmVyA9IFBSRlNhbHQuX2Nsb25lSW50byhwcmZXKSkudXBkYXRlKGFycikuZGlnZXN0SW50byh1KTtcbiAgICAgICAgVGkuc2V0KHUuc3ViYXJyYXkoMCwgVGkubGVuZ3RoKSk7XG4gICAgICAgIGF3YWl0IGFzeW5jTG9vcChjIC0gMSwgYXN5bmNUaWNrLCAoKSA9PiB7XG4gICAgICAgICAgICAvLyBVYyA9IFBSRihQYXNzd29yZCwgVWPiiJIxKVxuICAgICAgICAgICAgUFJGLl9jbG9uZUludG8ocHJmVykudXBkYXRlKHUpLmRpZ2VzdEludG8odSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IFRpLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIFRpW2ldIF49IHVbaV07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcGJrZGYyT3V0cHV0KFBSRiwgUFJGU2FsdCwgREssIHByZlcsIHUpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGJrZGYyLmpzLm1hcCJdLCJuYW1lcyI6WyJoYXNoIiwiYXNzZXJ0SGFzaCIsIm51bWJlciIsImFzc2VydE51bWJlciIsImhtYWMiLCJjcmVhdGVWaWV3IiwidG9CeXRlcyIsImNoZWNrT3B0cyIsImFzeW5jTG9vcCIsInBia2RmMkluaXQiLCJfcGFzc3dvcmQiLCJfc2FsdCIsIl9vcHRzIiwib3B0cyIsImRrTGVuIiwiYXN5bmNUaWNrIiwiYyIsIkVycm9yIiwicGFzc3dvcmQiLCJzYWx0IiwiREsiLCJVaW50OEFycmF5IiwiUFJGIiwiY3JlYXRlIiwiUFJGU2FsdCIsIl9jbG9uZUludG8iLCJ1cGRhdGUiLCJwYmtkZjJPdXRwdXQiLCJwcmZXIiwidSIsImRlc3Ryb3kiLCJmaWxsIiwicGJrZGYyIiwiYXJyIiwidmlldyIsIm91dHB1dExlbiIsInRpIiwicG9zIiwiVGkiLCJzdWJhcnJheSIsInNldEludDMyIiwiZGlnZXN0SW50byIsInNldCIsImxlbmd0aCIsInVpIiwiaSIsInBia2RmMkFzeW5jIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/hashes/esm/pbkdf2.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/hashes/esm/sha256.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/sha256.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha224: function() { return /* binding */ sha224; },\n/* harmony export */   sha256: function() { return /* binding */ sha256; }\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_sha2.js */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Choice: a ? b : c\nconst Chi = (a, b, c)=>a & b ^ ~a & c;\n_c = Chi;\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c)=>a & b ^ a & c ^ b & c;\n_c1 = Maj;\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98,\n    0x71374491,\n    0xb5c0fbcf,\n    0xe9b5dba5,\n    0x3956c25b,\n    0x59f111f1,\n    0x923f82a4,\n    0xab1c5ed5,\n    0xd807aa98,\n    0x12835b01,\n    0x243185be,\n    0x550c7dc3,\n    0x72be5d74,\n    0x80deb1fe,\n    0x9bdc06a7,\n    0xc19bf174,\n    0xe49b69c1,\n    0xefbe4786,\n    0x0fc19dc6,\n    0x240ca1cc,\n    0x2de92c6f,\n    0x4a7484aa,\n    0x5cb0a9dc,\n    0x76f988da,\n    0x983e5152,\n    0xa831c66d,\n    0xb00327c8,\n    0xbf597fc7,\n    0xc6e00bf3,\n    0xd5a79147,\n    0x06ca6351,\n    0x14292967,\n    0x27b70a85,\n    0x2e1b2138,\n    0x4d2c6dfc,\n    0x53380d13,\n    0x650a7354,\n    0x766a0abb,\n    0x81c2c92e,\n    0x92722c85,\n    0xa2bfe8a1,\n    0xa81a664b,\n    0xc24b8b70,\n    0xc76c51a3,\n    0xd192e819,\n    0xd6990624,\n    0xf40e3585,\n    0x106aa070,\n    0x19a4c116,\n    0x1e376c08,\n    0x2748774c,\n    0x34b0bcb5,\n    0x391c0cb3,\n    0x4ed8aa4a,\n    0x5b9cca4f,\n    0x682e6ff3,\n    0x748f82ee,\n    0x78a5636f,\n    0x84c87814,\n    0x8cc70208,\n    0x90befffa,\n    0xa4506ceb,\n    0xbef9a3f7,\n    0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667,\n    0xbb67ae85,\n    0x3c6ef372,\n    0xa54ff53a,\n    0x510e527f,\n    0x9b05688c,\n    0x1f83d9ab,\n    0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA2 {\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [\n            A,\n            B,\n            C,\n            D,\n            E,\n            F,\n            G,\n            H\n        ];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for(let i = 0; i < 16; i++, offset += 4)SHA256_W[i] = view.getUint32(offset, false);\n        for(let i = 16; i < 64; i++){\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ W15 >>> 3;\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ W2 >>> 10;\n            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for(let i = 0; i < 64; i++){\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = sigma0 + Maj(A, B, C) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = D + T1 | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = T1 + T2 | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = A + this.A | 0;\n        B = B + this.B | 0;\n        C = C + this.C | 0;\n        D = D + this.D | 0;\n        E = E + this.E | 0;\n        F = F + this.F | 0;\n        G = G + this.G | 0;\n        H = H + this.H | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n    constructor(){\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor(){\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */ const sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(()=>new SHA256());\nconst sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(()=>new SHA224()); //# sourceMappingURL=sha256.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"Chi\");\n$RefreshReg$(_c1, \"Maj\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyNTYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFrQztBQUNpQjtBQUNuRCxnRUFBZ0U7QUFDaEUsMERBQTBEO0FBQzFELG9CQUFvQjtBQUNwQixNQUFNRyxNQUFNLENBQUNDLEdBQUdDLEdBQUdDLElBQU0sSUFBS0QsSUFBTSxDQUFDRCxJQUFJRTtLQUFuQ0g7QUFDTixvREFBb0Q7QUFDcEQsTUFBTUksTUFBTSxDQUFDSCxHQUFHQyxHQUFHQyxJQUFNLElBQUtELElBQU1ELElBQUlFLElBQU1ELElBQUlDO01BQTVDQztBQUNOLG1CQUFtQjtBQUNuQix5RkFBeUY7QUFDekYsa0JBQWtCO0FBQ2xCLE1BQU1DLFdBQVcsYUFBYSxHQUFHLElBQUlDLFlBQVk7SUFDN0M7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0NBQ3ZGO0FBQ0QseUdBQXlHO0FBQ3pHLGtCQUFrQjtBQUNsQixNQUFNQyxLQUFLLGFBQWEsR0FBRyxJQUFJRCxZQUFZO0lBQ3ZDO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7Q0FDdkY7QUFDRCw0REFBNEQ7QUFDNUQsbURBQW1EO0FBQ25ELE1BQU1FLFdBQVcsYUFBYSxHQUFHLElBQUlGLFlBQVk7QUFD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QUNXLENBQUMsR0FBR1gsRUFBRSxDQUFDLEVBQUUsR0FBRztJQUNyQjtBQTZESjtBQUNBLDRFQUE0RTtBQUM1RSxNQUFNK0IsZUFBZTdCO0lBQ2pCNEIsYUFBYztRQUNWLEtBQUs7UUFDTCxJQUFJLENBQUMxQixDQUFDLEdBQUcsYUFBYTtRQUN0QixJQUFJLENBQUNDLENBQUMsR0FBRyxhQUFhO1FBQ3RCLElBQUksQ0FBQ0MsQ0FBQyxHQUFHLGFBQWE7UUFDdEIsSUFBSSxDQUFDQyxDQUFDLEdBQUcsYUFBYTtRQUN0QixJQUFJLENBQUNDLENBQUMsR0FBRyxhQUFhO1FBQ3RCLElBQUksQ0FBQ0MsQ0FBQyxHQUFHLGFBQWE7UUFDdEIsSUFBSSxDQUFDQyxDQUFDLEdBQUcsYUFBYTtRQUN0QixJQUFJLENBQUNDLENBQUMsR0FBRyxhQUFhO1FBQ3RCLElBQUksQ0FBQ3FCLFNBQVMsR0FBRztJQUNyQjtBQUNKO0FBQ0E7OztDQUdDLEdBQ00sTUFBTUMsU0FBUyxhQUFhLEdBQUd6QywwREFBZUEsQ0FBQyxJQUFNLElBQUlVLFVBQVU7QUFDbkUsTUFBTWdDLFNBQVMsYUFBYSxHQUFHMUMsMERBQWVBLENBQUMsSUFBTSxJQUFJdUMsVUFBVSxDQUMxRSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTI1Ni5qcz82ZjFlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNIQTIgfSBmcm9tICcuL19zaGEyLmpzJztcbmltcG9ydCB7IHJvdHIsIHdyYXBDb25zdHJ1Y3RvciB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gU0hBMi0yNTYgbmVlZCB0byB0cnkgMl4xMjggaGFzaGVzIHRvIGV4ZWN1dGUgYmlydGhkYXkgYXR0YWNrLlxuLy8gQlRDIG5ldHdvcmsgaXMgZG9pbmcgMl42NyBoYXNoZXMvc2VjIGFzIHBlciBlYXJseSAyMDIzLlxuLy8gQ2hvaWNlOiBhID8gYiA6IGNcbmNvbnN0IENoaSA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKH5hICYgYyk7XG4vLyBNYWpvcml0eSBmdW5jdGlvbiwgdHJ1ZSBpZiBhbnkgdHdvIGlucHVzdCBpcyB0cnVlXG5jb25zdCBNYWogPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeIChhICYgYykgXiAoYiAmIGMpO1xuLy8gUm91bmQgY29uc3RhbnRzOlxuLy8gZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgNjQgcHJpbWVzIDIuLjMxMSlcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgU0hBMjU2X0sgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LCAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxuICAgIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsXG4gICAgMHhlNDliNjljMSwgMHhlZmJlNDc4NiwgMHgwZmMxOWRjNiwgMHgyNDBjYTFjYywgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSxcbiAgICAweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LCAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxuICAgIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG4gICAgMHhhMmJmZThhMSwgMHhhODFhNjY0YiwgMHhjMjRiOGI3MCwgMHhjNzZjNTFhMywgMHhkMTkyZTgxOSwgMHhkNjk5MDYyNCwgMHhmNDBlMzU4NSwgMHgxMDZhYTA3MCxcbiAgICAweDE5YTRjMTE2LCAweDFlMzc2YzA4LCAweDI3NDg3NzRjLCAweDM0YjBiY2I1LCAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxuICAgIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJcbl0pO1xuLy8gSW5pdGlhbCBzdGF0ZSAoZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgc3F1YXJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4IHByaW1lcyAyLi4xOSk6XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IElWID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg2YTA5ZTY2NywgMHhiYjY3YWU4NSwgMHgzYzZlZjM3MiwgMHhhNTRmZjUzYSwgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOVxuXSk7XG4vLyBUZW1wb3JhcnkgYnVmZmVyLCBub3QgdXNlZCB0byBzdG9yZSBhbnl0aGluZyBiZXR3ZWVuIHJ1bnNcbi8vIE5hbWVkIHRoaXMgd2F5IGJlY2F1c2UgaXQgbWF0Y2hlcyBzcGVjaWZpY2F0aW9uLlxuY29uc3QgU0hBMjU2X1cgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDY0KTtcbmNsYXNzIFNIQTI1NiBleHRlbmRzIFNIQTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcig2NCwgMzIsIDgsIGZhbHNlKTtcbiAgICAgICAgLy8gV2UgY2Fubm90IHVzZSBhcnJheSBoZXJlIHNpbmNlIGFycmF5IGFsbG93cyBpbmRleGluZyBieSB2YXJpYWJsZVxuICAgICAgICAvLyB3aGljaCBtZWFucyBvcHRpbWl6ZXIvY29tcGlsZXIgY2Fubm90IHVzZSByZWdpc3RlcnMuXG4gICAgICAgIHRoaXMuQSA9IElWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5CID0gSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLkMgPSBJVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuRCA9IElWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5FID0gSVZbNF0gfCAwO1xuICAgICAgICB0aGlzLkYgPSBJVls1XSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IElWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5IID0gSVZbN10gfCAwO1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtBLCBCLCBDLCBELCBFLCBGLCBHLCBIXTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpIHtcbiAgICAgICAgdGhpcy5BID0gQSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IEIgfCAwO1xuICAgICAgICB0aGlzLkMgPSBDIHwgMDtcbiAgICAgICAgdGhpcy5EID0gRCB8IDA7XG4gICAgICAgIHRoaXMuRSA9IEUgfCAwO1xuICAgICAgICB0aGlzLkYgPSBGIHwgMDtcbiAgICAgICAgdGhpcy5HID0gRyB8IDA7XG4gICAgICAgIHRoaXMuSCA9IEggfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IDE2IHdvcmRzIGludG8gdGhlIHJlbWFpbmluZyA0OCB3b3JkcyB3WzE2Li42M10gb2YgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgYXJyYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcbiAgICAgICAgICAgIFNIQTI1Nl9XW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IFcxNSA9IFNIQTI1Nl9XW2kgLSAxNV07XG4gICAgICAgICAgICBjb25zdCBXMiA9IFNIQTI1Nl9XW2kgLSAyXTtcbiAgICAgICAgICAgIGNvbnN0IHMwID0gcm90cihXMTUsIDcpIF4gcm90cihXMTUsIDE4KSBeIChXMTUgPj4+IDMpO1xuICAgICAgICAgICAgY29uc3QgczEgPSByb3RyKFcyLCAxNykgXiByb3RyKFcyLCAxOSkgXiAoVzIgPj4+IDEwKTtcbiAgICAgICAgICAgIFNIQTI1Nl9XW2ldID0gKHMxICsgU0hBMjU2X1dbaSAtIDddICsgczAgKyBTSEEyNTZfV1tpIC0gMTZdKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA2NCByb3VuZHNcbiAgICAgICAgbGV0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTEgPSByb3RyKEUsIDYpIF4gcm90cihFLCAxMSkgXiByb3RyKEUsIDI1KTtcbiAgICAgICAgICAgIGNvbnN0IFQxID0gKEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTAgPSByb3RyKEEsIDIpIF4gcm90cihBLCAxMykgXiByb3RyKEEsIDIyKTtcbiAgICAgICAgICAgIGNvbnN0IFQyID0gKHNpZ21hMCArIE1haihBLCBCLCBDKSkgfCAwO1xuICAgICAgICAgICAgSCA9IEc7XG4gICAgICAgICAgICBHID0gRjtcbiAgICAgICAgICAgIEYgPSBFO1xuICAgICAgICAgICAgRSA9IChEICsgVDEpIHwgMDtcbiAgICAgICAgICAgIEQgPSBDO1xuICAgICAgICAgICAgQyA9IEI7XG4gICAgICAgICAgICBCID0gQTtcbiAgICAgICAgICAgIEEgPSAoVDEgKyBUMikgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgIEEgPSAoQSArIHRoaXMuQSkgfCAwO1xuICAgICAgICBCID0gKEIgKyB0aGlzLkIpIHwgMDtcbiAgICAgICAgQyA9IChDICsgdGhpcy5DKSB8IDA7XG4gICAgICAgIEQgPSAoRCArIHRoaXMuRCkgfCAwO1xuICAgICAgICBFID0gKEUgKyB0aGlzLkUpIHwgMDtcbiAgICAgICAgRiA9IChGICsgdGhpcy5GKSB8IDA7XG4gICAgICAgIEcgPSAoRyArIHRoaXMuRykgfCAwO1xuICAgICAgICBIID0gKEggKyB0aGlzLkgpIHwgMDtcbiAgICAgICAgdGhpcy5zZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgIFNIQTI1Nl9XLmZpbGwoMCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICB0aGlzLmJ1ZmZlci5maWxsKDApO1xuICAgIH1cbn1cbi8vIENvbnN0YW50cyBmcm9tIGh0dHBzOi8vbnZscHVicy5uaXN0Lmdvdi9uaXN0cHVicy9GSVBTL05JU1QuRklQUy4xODAtNC5wZGZcbmNsYXNzIFNIQTIyNCBleHRlbmRzIFNIQTI1NiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuQSA9IDB4YzEwNTllZDggfCAwO1xuICAgICAgICB0aGlzLkIgPSAweDM2N2NkNTA3IHwgMDtcbiAgICAgICAgdGhpcy5DID0gMHgzMDcwZGQxNyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IDB4ZjcwZTU5MzkgfCAwO1xuICAgICAgICB0aGlzLkUgPSAweGZmYzAwYjMxIHwgMDtcbiAgICAgICAgdGhpcy5GID0gMHg2ODU4MTUxMSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IDB4NjRmOThmYTcgfCAwO1xuICAgICAgICB0aGlzLkggPSAweGJlZmE0ZmE0IHwgMDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSAyODtcbiAgICB9XG59XG4vKipcbiAqIFNIQTItMjU2IGhhc2ggZnVuY3Rpb25cbiAqIEBwYXJhbSBtZXNzYWdlIC0gZGF0YSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnQgY29uc3Qgc2hhMjU2ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBMjU2KCkpO1xuZXhwb3J0IGNvbnN0IHNoYTIyNCA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTIyNCgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTI1Ni5qcy5tYXAiXSwibmFtZXMiOlsiU0hBMiIsInJvdHIiLCJ3cmFwQ29uc3RydWN0b3IiLCJDaGkiLCJhIiwiYiIsImMiLCJNYWoiLCJTSEEyNTZfSyIsIlVpbnQzMkFycmF5IiwiSVYiLCJTSEEyNTZfVyIsIlNIQTI1NiIsImdldCIsIkEiLCJCIiwiQyIsIkQiLCJFIiwiRiIsIkciLCJIIiwic2V0IiwicHJvY2VzcyIsInZpZXciLCJvZmZzZXQiLCJpIiwiZ2V0VWludDMyIiwiVzE1IiwiVzIiLCJzMCIsInMxIiwic2lnbWExIiwiVDEiLCJzaWdtYTAiLCJUMiIsInJvdW5kQ2xlYW4iLCJmaWxsIiwiZGVzdHJveSIsImJ1ZmZlciIsImNvbnN0cnVjdG9yIiwiU0hBMjI0Iiwib3V0cHV0TGVuIiwic2hhMjU2Iiwic2hhMjI0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/hashes/esm/sha256.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/hashes/esm/sha3.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/sha3.js ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Keccak: function() { return /* binding */ Keccak; },\n/* harmony export */   keccakP: function() { return /* binding */ keccakP; },\n/* harmony export */   keccak_224: function() { return /* binding */ keccak_224; },\n/* harmony export */   keccak_256: function() { return /* binding */ keccak_256; },\n/* harmony export */   keccak_384: function() { return /* binding */ keccak_384; },\n/* harmony export */   keccak_512: function() { return /* binding */ keccak_512; },\n/* harmony export */   sha3_224: function() { return /* binding */ sha3_224; },\n/* harmony export */   sha3_256: function() { return /* binding */ sha3_256; },\n/* harmony export */   sha3_384: function() { return /* binding */ sha3_384; },\n/* harmony export */   sha3_512: function() { return /* binding */ sha3_512; },\n/* harmony export */   shake128: function() { return /* binding */ shake128; },\n/* harmony export */   shake256: function() { return /* binding */ shake256; }\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.\n// It's called a sponge function.\n// Various per round constants calculations\nconst [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [\n    [],\n    [],\n    []\n];\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nconst _7n = /* @__PURE__ */ BigInt(7);\nconst _256n = /* @__PURE__ */ BigInt(256);\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\nfor(let round = 0, R = _1n, x = 1, y = 0; round < 24; round++){\n    // Pi\n    [x, y] = [\n        y,\n        (2 * x + 3 * y) % 5\n    ];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);\n    // Iota\n    let t = _0n;\n    for(let j = 0; j < 7; j++){\n        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;\n        if (R & _2n) t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;\n    }\n    _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.split)(_SHA3_IOTA, true);\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s)=>s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBH)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSH)(h, l, s);\nconst rotlL = (h, l, s)=>s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBL)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSL)(h, l, s);\n// Same as keccakf1600, but allows to skip some rounds\nfunction keccakP(s) {\n    let rounds = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 24;\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for(let round = 24 - rounds; round < 24; round++){\n        // Theta \n        for(let x = 0; x < 10; x++)B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for(let x = 0; x < 10; x += 2){\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for(let y = 0; y < 50; y += 10){\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho () and Pi ()\n        let curH = s[2];\n        let curL = s[3];\n        for(let t = 0; t < 24; t++){\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi ()\n        for(let y = 0; y < 50; y += 10){\n            for(let x = 0; x < 10; x++)B[x] = s[y + x];\n            for(let x = 0; x < 10; x++)s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota ()\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    B.fill(0);\n}\nclass Keccak extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\n    keccak() {\n        keccakP(this.state32, this.rounds);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.exists)(this);\n        const { blockLen, state } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(data);\n        const len = data.length;\n        for(let pos = 0; pos < len;){\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for(let i = 0; i < take; i++)state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen) this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished) return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.exists)(this, false);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.bytes)(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for(let pos = 0, len = out.length; pos < len;){\n            if (this.posOut >= blockLen) this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF) throw new Error(\"XOF is not possible for this instance\");\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.number)(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.output)(out, this);\n        if (this.finished) throw new Error(\"digest() was already called\");\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        this.state.fill(0);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24){\n        super();\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        // Can be passed from user as dkLen\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.number)(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        if (0 >= this.blockLen || this.blockLen >= 200) throw new Error(\"Sha3 supports only keccak-f1600 function\");\n        this.state = new Uint8Array(200);\n        this.state32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(this.state);\n    }\n}\nconst gen = (suffix, blockLen, outputLen)=>(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(()=>new Keccak(blockLen, suffix, outputLen));\nconst sha3_224 = /* @__PURE__ */ gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */ const sha3_256 = /* @__PURE__ */ gen(0x06, 136, 256 / 8);\nconst sha3_384 = /* @__PURE__ */ gen(0x06, 104, 384 / 8);\nconst sha3_512 = /* @__PURE__ */ gen(0x06, 72, 512 / 8);\nconst keccak_224 = /* @__PURE__ */ gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */ const keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);\nconst keccak_384 = /* @__PURE__ */ gen(0x01, 104, 384 / 8);\nconst keccak_512 = /* @__PURE__ */ gen(0x01, 72, 512 / 8);\nconst genShake = (suffix, blockLen, outputLen)=>(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapXOFConstructorWithOpts)(function() {\n        let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        return new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true);\n    });\nconst shake128 = /* @__PURE__ */ genShake(0x1f, 168, 128 / 8);\nconst shake256 = /* @__PURE__ */ genShake(0x1f, 136, 256 / 8); //# sourceMappingURL=sha3.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE2RDtBQUNLO0FBQzRCO0FBQzlGLG9HQUFvRztBQUNwRyxpQ0FBaUM7QUFDakMsMkNBQTJDO0FBQzNDLE1BQU0sQ0FBQ2MsU0FBU0MsV0FBV0MsV0FBVyxHQUFHO0lBQUMsRUFBRTtJQUFFLEVBQUU7SUFBRSxFQUFFO0NBQUM7QUFDckQsTUFBTUMsTUFBTSxhQUFhLEdBQUdDLE9BQU87QUFDbkMsTUFBTUMsTUFBTSxhQUFhLEdBQUdELE9BQU87QUFDbkMsTUFBTUUsTUFBTSxhQUFhLEdBQUdGLE9BQU87QUFDbkMsTUFBTUcsTUFBTSxhQUFhLEdBQUdILE9BQU87QUFDbkMsTUFBTUksUUFBUSxhQUFhLEdBQUdKLE9BQU87QUFDckMsTUFBTUssU0FBUyxhQUFhLEdBQUdMLE9BQU87QUFDdEMsSUFBSyxJQUFJTSxRQUFRLEdBQUdDLElBQUlOLEtBQUtPLElBQUksR0FBR0MsSUFBSSxHQUFHSCxRQUFRLElBQUlBLFFBQVM7SUFDNUQsS0FBSztJQUNMLENBQUNFLEdBQUdDLEVBQUUsR0FBRztRQUFDQTtRQUFJLEtBQUlELElBQUksSUFBSUMsQ0FBQUEsSUFBSztLQUFFO0lBQ2pDYixRQUFRYyxJQUFJLENBQUMsSUFBSyxLQUFJRCxJQUFJRCxDQUFBQTtJQUMxQixhQUFhO0lBQ2JYLFVBQVVhLElBQUksQ0FBQyxDQUFHSixRQUFRLEtBQU1BLENBQUFBLFFBQVEsS0FBTSxJQUFLO0lBQ25ELE9BQU87SUFDUCxJQUFJSyxJQUFJWjtJQUNSLElBQUssSUFBSWEsSUFBSSxHQUFHQSxJQUFJLEdBQUdBLElBQUs7UUFDeEJMLElBQUksQ0FBQyxLQUFNTixNQUFRLENBQUNNLEtBQUtKLEdBQUUsSUFBS0UsTUFBTSxJQUFLRDtRQUMzQyxJQUFJRyxJQUFJTCxLQUNKUyxLQUFLVixPQUFRLENBQUNBLE9BQU8sYUFBYSxHQUFHRCxPQUFPWSxFQUFDLElBQUtYO0lBQzFEO0lBQ0FILFdBQVdZLElBQUksQ0FBQ0M7QUFDcEI7QUFDQSxNQUFNLENBQUNFLGFBQWFDLFlBQVksR0FBRyxhQUFhLEdBQUd4Qiw4Q0FBS0EsQ0FBQ1EsWUFBWTtBQUNyRSxvQ0FBb0M7QUFDcEMsTUFBTWlCLFFBQVEsQ0FBQ0MsR0FBR0MsR0FBR0MsSUFBT0EsSUFBSSxLQUFLaEMsK0NBQU1BLENBQUM4QixHQUFHQyxHQUFHQyxLQUFLOUIsK0NBQU1BLENBQUM0QixHQUFHQyxHQUFHQztBQUNwRSxNQUFNQyxRQUFRLENBQUNILEdBQUdDLEdBQUdDLElBQU9BLElBQUksS0FBSy9CLCtDQUFNQSxDQUFDNkIsR0FBR0MsR0FBR0MsS0FBSzdCLCtDQUFNQSxDQUFDMkIsR0FBR0MsR0FBR0M7QUFDcEUsc0RBQXNEO0FBQy9DLFNBQVNFLFFBQVFGLENBQUM7UUFBRUcsU0FBQUEsaUVBQVM7SUFDaEMsTUFBTUMsSUFBSSxJQUFJQyxZQUFZLElBQUk7SUFDOUIsOEZBQThGO0lBQzlGLElBQUssSUFBSWpCLFFBQVEsS0FBS2UsUUFBUWYsUUFBUSxJQUFJQSxRQUFTO1FBQy9DLFVBQVU7UUFDVixJQUFLLElBQUlFLElBQUksR0FBR0EsSUFBSSxJQUFJQSxJQUNwQmMsQ0FBQyxDQUFDZCxFQUFFLEdBQUdVLENBQUMsQ0FBQ1YsRUFBRSxHQUFHVSxDQUFDLENBQUNWLElBQUksR0FBRyxHQUFHVSxDQUFDLENBQUNWLElBQUksR0FBRyxHQUFHVSxDQUFDLENBQUNWLElBQUksR0FBRyxHQUFHVSxDQUFDLENBQUNWLElBQUksR0FBRztRQUMvRCxJQUFLLElBQUlBLElBQUksR0FBR0EsSUFBSSxJQUFJQSxLQUFLLEVBQUc7WUFDNUIsTUFBTWdCLE9BQU8sQ0FBQ2hCLElBQUksS0FBSztZQUN2QixNQUFNaUIsT0FBTyxDQUFDakIsSUFBSSxLQUFLO1lBQ3ZCLE1BQU1rQixLQUFLSixDQUFDLENBQUNHLEtBQUs7WUFDbEIsTUFBTUUsS0FBS0wsQ0FBQyxDQUFDRyxPQUFPLEVBQUU7WUFDdEIsTUFBTUcsS0FBS2IsTUFBTVcsSUFBSUMsSUFBSSxLQUFLTCxDQUFDLENBQUNFLEtBQUs7WUFDckMsTUFBTUssS0FBS1YsTUFBTU8sSUFBSUMsSUFBSSxLQUFLTCxDQUFDLENBQUNFLE9BQU8sRUFBRTtZQUN6QyxJQUFLLElBQUlmLElBQUksR0FBR0EsSUFBSSxJQUFJQSxLQUFLLEdBQUk7Z0JBQzdCUyxDQUFDLENBQUNWLElBQUlDLEVBQUUsSUFBSW1CO2dCQUNaVixDQUFDLENBQUNWLElBQUlDLElBQUksRUFBRSxJQUFJb0I7WUFDcEI7UUFDSjtRQUNBLHFCQUFxQjtRQUNyQixJQUFJQyxPQUFPWixDQUFDLENBQUMsRUFBRTtRQUNmLElBQUlhLE9BQU9iLENBQUMsQ0FBQyxFQUFFO1FBQ2YsSUFBSyxJQUFJUCxJQUFJLEdBQUdBLElBQUksSUFBSUEsSUFBSztZQUN6QixNQUFNcUIsUUFBUW5DLFNBQVMsQ0FBQ2MsRUFBRTtZQUMxQixNQUFNaUIsS0FBS2IsTUFBTWUsTUFBTUMsTUFBTUM7WUFDN0IsTUFBTUgsS0FBS1YsTUFBTVcsTUFBTUMsTUFBTUM7WUFDN0IsTUFBTUMsS0FBS3JDLE9BQU8sQ0FBQ2UsRUFBRTtZQUNyQm1CLE9BQU9aLENBQUMsQ0FBQ2UsR0FBRztZQUNaRixPQUFPYixDQUFDLENBQUNlLEtBQUssRUFBRTtZQUNoQmYsQ0FBQyxDQUFDZSxHQUFHLEdBQUdMO1lBQ1JWLENBQUMsQ0FBQ2UsS0FBSyxFQUFFLEdBQUdKO1FBQ2hCO1FBQ0EsVUFBVTtRQUNWLElBQUssSUFBSXBCLElBQUksR0FBR0EsSUFBSSxJQUFJQSxLQUFLLEdBQUk7WUFDN0IsSUFBSyxJQUFJRCxJQUFJLEdBQUdBLElBQUksSUFBSUEsSUFDcEJjLENBQUMsQ0FBQ2QsRUFBRSxHQUFHVSxDQUFDLENBQUNULElBQUlELEVBQUU7WUFDbkIsSUFBSyxJQUFJQSxJQUFJLEdBQUdBLElBQUksSUFBSUEsSUFDcEJVLENBQUMsQ0FBQ1QsSUFBSUQsRUFBRSxJQUFJLENBQUNjLENBQUMsQ0FBQyxDQUFDZCxJQUFJLEtBQUssR0FBRyxHQUFHYyxDQUFDLENBQUMsQ0FBQ2QsSUFBSSxLQUFLLEdBQUc7UUFDdEQ7UUFDQSxXQUFXO1FBQ1hVLENBQUMsQ0FBQyxFQUFFLElBQUlMLFdBQVcsQ0FBQ1AsTUFBTTtRQUMxQlksQ0FBQyxDQUFDLEVBQUUsSUFBSUosV0FBVyxDQUFDUixNQUFNO0lBQzlCO0lBQ0FnQixFQUFFWSxJQUFJLENBQUM7QUFDWDtBQUNPLE1BQU1DLGVBQWU1QywyQ0FBSUE7SUFxQjVCNkMsU0FBUztRQUNMaEIsUUFBUSxJQUFJLENBQUNpQixPQUFPLEVBQUUsSUFBSSxDQUFDaEIsTUFBTTtRQUNqQyxJQUFJLENBQUNpQixNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUNDLEdBQUcsR0FBRztJQUNmO0lBQ0FDLE9BQU9DLElBQUksRUFBRTtRQUNUMUQsa0RBQU1BLENBQUMsSUFBSTtRQUNYLE1BQU0sRUFBRTJELFFBQVEsRUFBRUMsS0FBSyxFQUFFLEdBQUcsSUFBSTtRQUNoQ0YsT0FBT2hELGtEQUFPQSxDQUFDZ0Q7UUFDZixNQUFNRyxNQUFNSCxLQUFLSSxNQUFNO1FBQ3ZCLElBQUssSUFBSU4sTUFBTSxHQUFHQSxNQUFNSyxLQUFNO1lBQzFCLE1BQU1FLE9BQU9DLEtBQUtDLEdBQUcsQ0FBQ04sV0FBVyxJQUFJLENBQUNILEdBQUcsRUFBRUssTUFBTUw7WUFDakQsSUFBSyxJQUFJVSxJQUFJLEdBQUdBLElBQUlILE1BQU1HLElBQ3RCTixLQUFLLENBQUMsSUFBSSxDQUFDSixHQUFHLEdBQUcsSUFBSUUsSUFBSSxDQUFDRixNQUFNO1lBQ3BDLElBQUksSUFBSSxDQUFDQSxHQUFHLEtBQUtHLFVBQ2IsSUFBSSxDQUFDTixNQUFNO1FBQ25CO1FBQ0EsT0FBTyxJQUFJO0lBQ2Y7SUFDQWMsU0FBUztRQUNMLElBQUksSUFBSSxDQUFDQyxRQUFRLEVBQ2I7UUFDSixJQUFJLENBQUNBLFFBQVEsR0FBRztRQUNoQixNQUFNLEVBQUVSLEtBQUssRUFBRVMsTUFBTSxFQUFFYixHQUFHLEVBQUVHLFFBQVEsRUFBRSxHQUFHLElBQUk7UUFDN0MsaUJBQWlCO1FBQ2pCQyxLQUFLLENBQUNKLElBQUksSUFBSWE7UUFDZCxJQUFJLENBQUNBLFNBQVMsSUFBRyxNQUFPLEtBQUtiLFFBQVFHLFdBQVcsR0FDNUMsSUFBSSxDQUFDTixNQUFNO1FBQ2ZPLEtBQUssQ0FBQ0QsV0FBVyxFQUFFLElBQUk7UUFDdkIsSUFBSSxDQUFDTixNQUFNO0lBQ2Y7SUFDQWlCLFVBQVVDLEdBQUcsRUFBRTtRQUNYdkUsa0RBQU1BLENBQUMsSUFBSSxFQUFFO1FBQ2JELGlEQUFLQSxDQUFDd0U7UUFDTixJQUFJLENBQUNKLE1BQU07UUFDWCxNQUFNSyxZQUFZLElBQUksQ0FBQ1osS0FBSztRQUM1QixNQUFNLEVBQUVELFFBQVEsRUFBRSxHQUFHLElBQUk7UUFDekIsSUFBSyxJQUFJSCxNQUFNLEdBQUdLLE1BQU1VLElBQUlULE1BQU0sRUFBRU4sTUFBTUssS0FBTTtZQUM1QyxJQUFJLElBQUksQ0FBQ04sTUFBTSxJQUFJSSxVQUNmLElBQUksQ0FBQ04sTUFBTTtZQUNmLE1BQU1VLE9BQU9DLEtBQUtDLEdBQUcsQ0FBQ04sV0FBVyxJQUFJLENBQUNKLE1BQU0sRUFBRU0sTUFBTUw7WUFDcERlLElBQUlFLEdBQUcsQ0FBQ0QsVUFBVUUsUUFBUSxDQUFDLElBQUksQ0FBQ25CLE1BQU0sRUFBRSxJQUFJLENBQUNBLE1BQU0sR0FBR1EsT0FBT1A7WUFDN0QsSUFBSSxDQUFDRCxNQUFNLElBQUlRO1lBQ2ZQLE9BQU9PO1FBQ1g7UUFDQSxPQUFPUTtJQUNYO0lBQ0FJLFFBQVFKLEdBQUcsRUFBRTtRQUNULGtGQUFrRjtRQUNsRixJQUFJLENBQUMsSUFBSSxDQUFDSyxTQUFTLEVBQ2YsTUFBTSxJQUFJQyxNQUFNO1FBQ3BCLE9BQU8sSUFBSSxDQUFDUCxTQUFTLENBQUNDO0lBQzFCO0lBQ0FPLElBQUkvRSxLQUFLLEVBQUU7UUFDUEUsa0RBQU1BLENBQUNGO1FBQ1AsT0FBTyxJQUFJLENBQUM0RSxPQUFPLENBQUMsSUFBSUksV0FBV2hGO0lBQ3ZDO0lBQ0FpRixXQUFXVCxHQUFHLEVBQUU7UUFDWnJFLGtEQUFNQSxDQUFDcUUsS0FBSyxJQUFJO1FBQ2hCLElBQUksSUFBSSxDQUFDSCxRQUFRLEVBQ2IsTUFBTSxJQUFJUyxNQUFNO1FBQ3BCLElBQUksQ0FBQ1AsU0FBUyxDQUFDQztRQUNmLElBQUksQ0FBQ1UsT0FBTztRQUNaLE9BQU9WO0lBQ1g7SUFDQVcsU0FBUztRQUNMLE9BQU8sSUFBSSxDQUFDRixVQUFVLENBQUMsSUFBSUQsV0FBVyxJQUFJLENBQUNJLFNBQVM7SUFDeEQ7SUFDQUYsVUFBVTtRQUNOLElBQUksQ0FBQ0csU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ3hCLEtBQUssQ0FBQ1QsSUFBSSxDQUFDO0lBQ3BCO0lBQ0FrQyxXQUFXQyxFQUFFLEVBQUU7UUFDWCxNQUFNLEVBQUUzQixRQUFRLEVBQUVVLE1BQU0sRUFBRWMsU0FBUyxFQUFFN0MsTUFBTSxFQUFFc0MsU0FBUyxFQUFFLEdBQUcsSUFBSTtRQUMvRFUsTUFBT0EsQ0FBQUEsS0FBSyxJQUFJbEMsT0FBT08sVUFBVVUsUUFBUWMsV0FBV1AsV0FBV3RDLE9BQU07UUFDckVnRCxHQUFHaEMsT0FBTyxDQUFDbUIsR0FBRyxDQUFDLElBQUksQ0FBQ25CLE9BQU87UUFDM0JnQyxHQUFHOUIsR0FBRyxHQUFHLElBQUksQ0FBQ0EsR0FBRztRQUNqQjhCLEdBQUcvQixNQUFNLEdBQUcsSUFBSSxDQUFDQSxNQUFNO1FBQ3ZCK0IsR0FBR2xCLFFBQVEsR0FBRyxJQUFJLENBQUNBLFFBQVE7UUFDM0JrQixHQUFHaEQsTUFBTSxHQUFHQTtRQUNaLDhCQUE4QjtRQUM5QmdELEdBQUdqQixNQUFNLEdBQUdBO1FBQ1ppQixHQUFHSCxTQUFTLEdBQUdBO1FBQ2ZHLEdBQUdWLFNBQVMsR0FBR0E7UUFDZlUsR0FBR0YsU0FBUyxHQUFHLElBQUksQ0FBQ0EsU0FBUztRQUM3QixPQUFPRTtJQUNYO0lBMUdBLDJEQUEyRDtJQUMzREMsWUFBWTVCLFFBQVEsRUFBRVUsTUFBTSxFQUFFYyxTQUFTLEVBQUVQLFlBQVksS0FBSyxFQUFFdEMsU0FBUyxFQUFFLENBQUU7UUFDckUsS0FBSztRQUNMLElBQUksQ0FBQ3FCLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDVSxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDYyxTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ1AsU0FBUyxHQUFHQTtRQUNqQixJQUFJLENBQUN0QyxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDa0IsR0FBRyxHQUFHO1FBQ1gsSUFBSSxDQUFDRCxNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUNhLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNnQixTQUFTLEdBQUc7UUFDakIsbUNBQW1DO1FBQ25DbkYsa0RBQU1BLENBQUNrRjtRQUNQLHVEQUF1RDtRQUN2RCxJQUFJLEtBQUssSUFBSSxDQUFDeEIsUUFBUSxJQUFJLElBQUksQ0FBQ0EsUUFBUSxJQUFJLEtBQ3ZDLE1BQU0sSUFBSWtCLE1BQU07UUFDcEIsSUFBSSxDQUFDakIsS0FBSyxHQUFHLElBQUltQixXQUFXO1FBQzVCLElBQUksQ0FBQ3pCLE9BQU8sR0FBRzdDLDhDQUFHQSxDQUFDLElBQUksQ0FBQ21ELEtBQUs7SUFDakM7QUF3Rko7QUFDQSxNQUFNNEIsTUFBTSxDQUFDbkIsUUFBUVYsVUFBVXdCLFlBQWN4RSwwREFBZUEsQ0FBQyxJQUFNLElBQUl5QyxPQUFPTyxVQUFVVSxRQUFRYztBQUN6RixNQUFNTSxXQUFXLGFBQWEsR0FBR0QsSUFBSSxNQUFNLEtBQUssTUFBTSxHQUFHO0FBQ2hFOzs7Q0FHQyxHQUNNLE1BQU1FLFdBQVcsYUFBYSxHQUFHRixJQUFJLE1BQU0sS0FBSyxNQUFNLEdBQUc7QUFDekQsTUFBTUcsV0FBVyxhQUFhLEdBQUdILElBQUksTUFBTSxLQUFLLE1BQU0sR0FBRztBQUN6RCxNQUFNSSxXQUFXLGFBQWEsR0FBR0osSUFBSSxNQUFNLElBQUksTUFBTSxHQUFHO0FBQ3hELE1BQU1LLGFBQWEsYUFBYSxHQUFHTCxJQUFJLE1BQU0sS0FBSyxNQUFNLEdBQUc7QUFDbEU7OztDQUdDLEdBQ00sTUFBTU0sYUFBYSxhQUFhLEdBQUdOLElBQUksTUFBTSxLQUFLLE1BQU0sR0FBRztBQUMzRCxNQUFNTyxhQUFhLGFBQWEsR0FBR1AsSUFBSSxNQUFNLEtBQUssTUFBTSxHQUFHO0FBQzNELE1BQU1RLGFBQWEsYUFBYSxHQUFHUixJQUFJLE1BQU0sSUFBSSxNQUFNLEdBQUc7QUFDakUsTUFBTVMsV0FBVyxDQUFDNUIsUUFBUVYsVUFBVXdCLFlBQWN2RSxxRUFBMEJBLENBQUM7WUFBQ3NGLHdFQUFPLENBQUM7ZUFBTSxJQUFJOUMsT0FBT08sVUFBVVUsUUFBUTZCLEtBQUtDLEtBQUssS0FBS0MsWUFBWWpCLFlBQVllLEtBQUtDLEtBQUssRUFBRTs7QUFDckssTUFBTUUsV0FBVyxhQUFhLEdBQUdKLFNBQVMsTUFBTSxLQUFLLE1BQU0sR0FBRztBQUM5RCxNQUFNSyxXQUFXLGFBQWEsR0FBR0wsU0FBUyxNQUFNLEtBQUssTUFBTSxHQUFHLENBQ3JFLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMy5qcz9iNDJlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGJ5dGVzLCBleGlzdHMsIG51bWJlciwgb3V0cHV0IH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IHJvdGxCSCwgcm90bEJMLCByb3RsU0gsIHJvdGxTTCwgc3BsaXQgfSBmcm9tICcuL191NjQuanMnO1xuaW1wb3J0IHsgSGFzaCwgdTMyLCB0b0J5dGVzLCB3cmFwQ29uc3RydWN0b3IsIHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzLCB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gU0hBMyAoa2VjY2FrKSBpcyBiYXNlZCBvbiBhIG5ldyBkZXNpZ246IGJhc2ljYWxseSwgdGhlIGludGVybmFsIHN0YXRlIGlzIGJpZ2dlciB0aGFuIG91dHB1dCBzaXplLlxuLy8gSXQncyBjYWxsZWQgYSBzcG9uZ2UgZnVuY3Rpb24uXG4vLyBWYXJpb3VzIHBlciByb3VuZCBjb25zdGFudHMgY2FsY3VsYXRpb25zXG5jb25zdCBbU0hBM19QSSwgU0hBM19ST1RMLCBfU0hBM19JT1RBXSA9IFtbXSwgW10sIFtdXTtcbmNvbnN0IF8wbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyKTtcbmNvbnN0IF83biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoNyk7XG5jb25zdCBfMjU2biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMjU2KTtcbmNvbnN0IF8weDcxbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMHg3MSk7XG5mb3IgKGxldCByb3VuZCA9IDAsIFIgPSBfMW4sIHggPSAxLCB5ID0gMDsgcm91bmQgPCAyNDsgcm91bmQrKykge1xuICAgIC8vIFBpXG4gICAgW3gsIHldID0gW3ksICgyICogeCArIDMgKiB5KSAlIDVdO1xuICAgIFNIQTNfUEkucHVzaCgyICogKDUgKiB5ICsgeCkpO1xuICAgIC8vIFJvdGF0aW9uYWxcbiAgICBTSEEzX1JPVEwucHVzaCgoKChyb3VuZCArIDEpICogKHJvdW5kICsgMikpIC8gMikgJSA2NCk7XG4gICAgLy8gSW90YVxuICAgIGxldCB0ID0gXzBuO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgNzsgaisrKSB7XG4gICAgICAgIFIgPSAoKFIgPDwgXzFuKSBeICgoUiA+PiBfN24pICogXzB4NzFuKSkgJSBfMjU2bjtcbiAgICAgICAgaWYgKFIgJiBfMm4pXG4gICAgICAgICAgICB0IF49IF8xbiA8PCAoKF8xbiA8PCAvKiBAX19QVVJFX18gKi8gQmlnSW50KGopKSAtIF8xbik7XG4gICAgfVxuICAgIF9TSEEzX0lPVEEucHVzaCh0KTtcbn1cbmNvbnN0IFtTSEEzX0lPVEFfSCwgU0hBM19JT1RBX0xdID0gLyogQF9fUFVSRV9fICovIHNwbGl0KF9TSEEzX0lPVEEsIHRydWUpO1xuLy8gTGVmdCByb3RhdGlvbiAod2l0aG91dCAwLCAzMiwgNjQpXG5jb25zdCByb3RsSCA9IChoLCBsLCBzKSA9PiAocyA+IDMyID8gcm90bEJIKGgsIGwsIHMpIDogcm90bFNIKGgsIGwsIHMpKTtcbmNvbnN0IHJvdGxMID0gKGgsIGwsIHMpID0+IChzID4gMzIgPyByb3RsQkwoaCwgbCwgcykgOiByb3RsU0woaCwgbCwgcykpO1xuLy8gU2FtZSBhcyBrZWNjYWtmMTYwMCwgYnV0IGFsbG93cyB0byBza2lwIHNvbWUgcm91bmRzXG5leHBvcnQgZnVuY3Rpb24ga2VjY2FrUChzLCByb3VuZHMgPSAyNCkge1xuICAgIGNvbnN0IEIgPSBuZXcgVWludDMyQXJyYXkoNSAqIDIpO1xuICAgIC8vIE5PVEU6IGFsbCBpbmRpY2VzIGFyZSB4MiBzaW5jZSB3ZSBzdG9yZSBzdGF0ZSBhcyB1MzIgaW5zdGVhZCBvZiB1NjQgKGJpZ2ludHMgdG8gc2xvdyBpbiBqcylcbiAgICBmb3IgKGxldCByb3VuZCA9IDI0IC0gcm91bmRzOyByb3VuZCA8IDI0OyByb3VuZCsrKSB7XG4gICAgICAgIC8vIFRoZXRhIM64XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgIEJbeF0gPSBzW3hdIF4gc1t4ICsgMTBdIF4gc1t4ICsgMjBdIF4gc1t4ICsgMzBdIF4gc1t4ICsgNDBdO1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4ICs9IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeDEgPSAoeCArIDgpICUgMTA7XG4gICAgICAgICAgICBjb25zdCBpZHgwID0gKHggKyAyKSAlIDEwO1xuICAgICAgICAgICAgY29uc3QgQjAgPSBCW2lkeDBdO1xuICAgICAgICAgICAgY29uc3QgQjEgPSBCW2lkeDAgKyAxXTtcbiAgICAgICAgICAgIGNvbnN0IFRoID0gcm90bEgoQjAsIEIxLCAxKSBeIEJbaWR4MV07XG4gICAgICAgICAgICBjb25zdCBUbCA9IHJvdGxMKEIwLCBCMSwgMSkgXiBCW2lkeDEgKyAxXTtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTA7IHkgKz0gMTApIHtcbiAgICAgICAgICAgICAgICBzW3ggKyB5XSBePSBUaDtcbiAgICAgICAgICAgICAgICBzW3ggKyB5ICsgMV0gXj0gVGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmhvICjPgSkgYW5kIFBpICjPgClcbiAgICAgICAgbGV0IGN1ckggPSBzWzJdO1xuICAgICAgICBsZXQgY3VyTCA9IHNbM107XG4gICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgMjQ7IHQrKykge1xuICAgICAgICAgICAgY29uc3Qgc2hpZnQgPSBTSEEzX1JPVExbdF07XG4gICAgICAgICAgICBjb25zdCBUaCA9IHJvdGxIKGN1ckgsIGN1ckwsIHNoaWZ0KTtcbiAgICAgICAgICAgIGNvbnN0IFRsID0gcm90bEwoY3VySCwgY3VyTCwgc2hpZnQpO1xuICAgICAgICAgICAgY29uc3QgUEkgPSBTSEEzX1BJW3RdO1xuICAgICAgICAgICAgY3VySCA9IHNbUEldO1xuICAgICAgICAgICAgY3VyTCA9IHNbUEkgKyAxXTtcbiAgICAgICAgICAgIHNbUEldID0gVGg7XG4gICAgICAgICAgICBzW1BJICsgMV0gPSBUbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGkgKM+HKVxuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDUwOyB5ICs9IDEwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICAgICAgQlt4XSA9IHNbeSArIHhdO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgICAgIHNbeSArIHhdIF49IH5CWyh4ICsgMikgJSAxMF0gJiBCWyh4ICsgNCkgJSAxMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW90YSAozrkpXG4gICAgICAgIHNbMF0gXj0gU0hBM19JT1RBX0hbcm91bmRdO1xuICAgICAgICBzWzFdIF49IFNIQTNfSU9UQV9MW3JvdW5kXTtcbiAgICB9XG4gICAgQi5maWxsKDApO1xufVxuZXhwb3J0IGNsYXNzIEtlY2NhayBleHRlbmRzIEhhc2gge1xuICAgIC8vIE5PVEU6IHdlIGFjY2VwdCBhcmd1bWVudHMgaW4gYnl0ZXMgaW5zdGVhZCBvZiBiaXRzIGhlcmUuXG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCBlbmFibGVYT0YgPSBmYWxzZSwgcm91bmRzID0gMjQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLnN1ZmZpeCA9IHN1ZmZpeDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRoaXMuZW5hYmxlWE9GID0gZW5hYmxlWE9GO1xuICAgICAgICB0aGlzLnJvdW5kcyA9IHJvdW5kcztcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLnBvc091dCA9IDA7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gQ2FuIGJlIHBhc3NlZCBmcm9tIHVzZXIgYXMgZGtMZW5cbiAgICAgICAgbnVtYmVyKG91dHB1dExlbik7XG4gICAgICAgIC8vIDE2MDAgPSA1eDUgbWF0cml4IG9mIDY0Yml0LiAgMTYwMCBiaXRzID09PSAyMDAgYnl0ZXNcbiAgICAgICAgaWYgKDAgPj0gdGhpcy5ibG9ja0xlbiB8fCB0aGlzLmJsb2NrTGVuID49IDIwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2hhMyBzdXBwb3J0cyBvbmx5IGtlY2Nhay1mMTYwMCBmdW5jdGlvbicpO1xuICAgICAgICB0aGlzLnN0YXRlID0gbmV3IFVpbnQ4QXJyYXkoMjAwKTtcbiAgICAgICAgdGhpcy5zdGF0ZTMyID0gdTMyKHRoaXMuc3RhdGUpO1xuICAgIH1cbiAgICBrZWNjYWsoKSB7XG4gICAgICAgIGtlY2Nha1AodGhpcy5zdGF0ZTMyLCB0aGlzLnJvdW5kcyk7XG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBleGlzdHModGhpcyk7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIHN0YXRlIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gdG9CeXRlcyhkYXRhKTtcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWtlOyBpKyspXG4gICAgICAgICAgICAgICAgc3RhdGVbdGhpcy5wb3MrK10gXj0gZGF0YVtwb3MrK107XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZmluaXNoZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCB7IHN0YXRlLCBzdWZmaXgsIHBvcywgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIC8vIERvIHRoZSBwYWRkaW5nXG4gICAgICAgIHN0YXRlW3Bvc10gXj0gc3VmZml4O1xuICAgICAgICBpZiAoKHN1ZmZpeCAmIDB4ODApICE9PSAwICYmIHBvcyA9PT0gYmxvY2tMZW4gLSAxKVxuICAgICAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICAgICAgc3RhdGVbYmxvY2tMZW4gLSAxXSBePSAweDgwO1xuICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgIH1cbiAgICB3cml0ZUludG8ob3V0KSB7XG4gICAgICAgIGV4aXN0cyh0aGlzLCBmYWxzZSk7XG4gICAgICAgIGJ5dGVzKG91dCk7XG4gICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlck91dCA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDAsIGxlbiA9IG91dC5sZW5ndGg7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvc091dCA+PSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3NPdXQsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICBvdXQuc2V0KGJ1ZmZlck91dC5zdWJhcnJheSh0aGlzLnBvc091dCwgdGhpcy5wb3NPdXQgKyB0YWtlKSwgcG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zT3V0ICs9IHRha2U7XG4gICAgICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICB4b2ZJbnRvKG91dCkge1xuICAgICAgICAvLyBTaGEzL0tlY2NhayB1c2FnZSB3aXRoIFhPRiBpcyBwcm9iYWJseSBtaXN0YWtlLCBvbmx5IFNIQUtFIGluc3RhbmNlcyBjYW4gZG8gWE9GXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVYT0YpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1hPRiBpcyBub3QgcG9zc2libGUgZm9yIHRoaXMgaW5zdGFuY2UnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVJbnRvKG91dCk7XG4gICAgfVxuICAgIHhvZihieXRlcykge1xuICAgICAgICBudW1iZXIoYnl0ZXMpO1xuICAgICAgICByZXR1cm4gdGhpcy54b2ZJbnRvKG5ldyBVaW50OEFycmF5KGJ5dGVzKSk7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIG91dHB1dChvdXQsIHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5maW5pc2hlZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGlnZXN0KCkgd2FzIGFscmVhZHkgY2FsbGVkJyk7XG4gICAgICAgIHRoaXMud3JpdGVJbnRvKG91dCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpZ2VzdEludG8obmV3IFVpbnQ4QXJyYXkodGhpcy5vdXRwdXRMZW4pKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnN0YXRlLmZpbGwoMCk7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIHJvdW5kcywgZW5hYmxlWE9GIH0gPSB0aGlzO1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgZW5hYmxlWE9GLCByb3VuZHMpKTtcbiAgICAgICAgdG8uc3RhdGUzMi5zZXQodGhpcy5zdGF0ZTMyKTtcbiAgICAgICAgdG8ucG9zID0gdGhpcy5wb3M7XG4gICAgICAgIHRvLnBvc091dCA9IHRoaXMucG9zT3V0O1xuICAgICAgICB0by5maW5pc2hlZCA9IHRoaXMuZmluaXNoZWQ7XG4gICAgICAgIHRvLnJvdW5kcyA9IHJvdW5kcztcbiAgICAgICAgLy8gU3VmZml4IGNhbiBjaGFuZ2UgaW4gY1NIQUtFXG4gICAgICAgIHRvLnN1ZmZpeCA9IHN1ZmZpeDtcbiAgICAgICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0by5lbmFibGVYT0YgPSBlbmFibGVYT0Y7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IHRoaXMuZGVzdHJveWVkO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxufVxuY29uc3QgZ2VuID0gKHN1ZmZpeCwgYmxvY2tMZW4sIG91dHB1dExlbikgPT4gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuKSk7XG5leHBvcnQgY29uc3Qgc2hhM18yMjQgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDYsIDE0NCwgMjI0IC8gOCk7XG4vKipcbiAqIFNIQTMtMjU2IGhhc2ggZnVuY3Rpb25cbiAqIEBwYXJhbSBtZXNzYWdlIC0gdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHNoYTNfMjU2ID0gLyogQF9fUFVSRV9fICovIGdlbigweDA2LCAxMzYsIDI1NiAvIDgpO1xuZXhwb3J0IGNvbnN0IHNoYTNfMzg0ID0gLyogQF9fUFVSRV9fICovIGdlbigweDA2LCAxMDQsIDM4NCAvIDgpO1xuZXhwb3J0IGNvbnN0IHNoYTNfNTEyID0gLyogQF9fUFVSRV9fICovIGdlbigweDA2LCA3MiwgNTEyIC8gOCk7XG5leHBvcnQgY29uc3Qga2VjY2FrXzIyNCA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwMSwgMTQ0LCAyMjQgLyA4KTtcbi8qKlxuICoga2VjY2FrLTI1NiBoYXNoIGZ1bmN0aW9uLiBEaWZmZXJlbnQgZnJvbSBTSEEzLTI1Ni5cbiAqIEBwYXJhbSBtZXNzYWdlIC0gdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0IGNvbnN0IGtlY2Nha18yNTYgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDEsIDEzNiwgMjU2IC8gOCk7XG5leHBvcnQgY29uc3Qga2VjY2FrXzM4NCA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwMSwgMTA0LCAzODQgLyA4KTtcbmV4cG9ydCBjb25zdCBrZWNjYWtfNTEyID0gLyogQF9fUFVSRV9fICovIGdlbigweDAxLCA3MiwgNTEyIC8gOCk7XG5jb25zdCBnZW5TaGFrZSA9IChzdWZmaXgsIGJsb2NrTGVuLCBvdXRwdXRMZW4pID0+IHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzKChvcHRzID0ge30pID0+IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3B0cy5ka0xlbiA9PT0gdW5kZWZpbmVkID8gb3V0cHV0TGVuIDogb3B0cy5ka0xlbiwgdHJ1ZSkpO1xuZXhwb3J0IGNvbnN0IHNoYWtlMTI4ID0gLyogQF9fUFVSRV9fICovIGdlblNoYWtlKDB4MWYsIDE2OCwgMTI4IC8gOCk7XG5leHBvcnQgY29uc3Qgc2hha2UyNTYgPSAvKiBAX19QVVJFX18gKi8gZ2VuU2hha2UoMHgxZiwgMTM2LCAyNTYgLyA4KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTMuanMubWFwIl0sIm5hbWVzIjpbImJ5dGVzIiwiZXhpc3RzIiwibnVtYmVyIiwib3V0cHV0Iiwicm90bEJIIiwicm90bEJMIiwicm90bFNIIiwicm90bFNMIiwic3BsaXQiLCJIYXNoIiwidTMyIiwidG9CeXRlcyIsIndyYXBDb25zdHJ1Y3RvciIsIndyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzIiwiU0hBM19QSSIsIlNIQTNfUk9UTCIsIl9TSEEzX0lPVEEiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJfMm4iLCJfN24iLCJfMjU2biIsIl8weDcxbiIsInJvdW5kIiwiUiIsIngiLCJ5IiwicHVzaCIsInQiLCJqIiwiU0hBM19JT1RBX0giLCJTSEEzX0lPVEFfTCIsInJvdGxIIiwiaCIsImwiLCJzIiwicm90bEwiLCJrZWNjYWtQIiwicm91bmRzIiwiQiIsIlVpbnQzMkFycmF5IiwiaWR4MSIsImlkeDAiLCJCMCIsIkIxIiwiVGgiLCJUbCIsImN1ckgiLCJjdXJMIiwic2hpZnQiLCJQSSIsImZpbGwiLCJLZWNjYWsiLCJrZWNjYWsiLCJzdGF0ZTMyIiwicG9zT3V0IiwicG9zIiwidXBkYXRlIiwiZGF0YSIsImJsb2NrTGVuIiwic3RhdGUiLCJsZW4iLCJsZW5ndGgiLCJ0YWtlIiwiTWF0aCIsIm1pbiIsImkiLCJmaW5pc2giLCJmaW5pc2hlZCIsInN1ZmZpeCIsIndyaXRlSW50byIsIm91dCIsImJ1ZmZlck91dCIsInNldCIsInN1YmFycmF5IiwieG9mSW50byIsImVuYWJsZVhPRiIsIkVycm9yIiwieG9mIiwiVWludDhBcnJheSIsImRpZ2VzdEludG8iLCJkZXN0cm95IiwiZGlnZXN0Iiwib3V0cHV0TGVuIiwiZGVzdHJveWVkIiwiX2Nsb25lSW50byIsInRvIiwiY29uc3RydWN0b3IiLCJnZW4iLCJzaGEzXzIyNCIsInNoYTNfMjU2Iiwic2hhM18zODQiLCJzaGEzXzUxMiIsImtlY2Nha18yMjQiLCJrZWNjYWtfMjU2Iiwia2VjY2FrXzM4NCIsImtlY2Nha181MTIiLCJnZW5TaGFrZSIsIm9wdHMiLCJka0xlbiIsInVuZGVmaW5lZCIsInNoYWtlMTI4Iiwic2hha2UyNTYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/hashes/esm/sha3.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/hashes/esm/sha512.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/sha512.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA512: function() { return /* binding */ SHA512; },\n/* harmony export */   sha384: function() { return /* binding */ sha384; },\n/* harmony export */   sha512: function() { return /* binding */ sha512; },\n/* harmony export */   sha512_224: function() { return /* binding */ sha512_224; },\n/* harmony export */   sha512_256: function() { return /* binding */ sha512_256; }\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_sha2.js */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (()=>_u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].split([\n        \"0x428a2f98d728ae22\",\n        \"0x7137449123ef65cd\",\n        \"0xb5c0fbcfec4d3b2f\",\n        \"0xe9b5dba58189dbbc\",\n        \"0x3956c25bf348b538\",\n        \"0x59f111f1b605d019\",\n        \"0x923f82a4af194f9b\",\n        \"0xab1c5ed5da6d8118\",\n        \"0xd807aa98a3030242\",\n        \"0x12835b0145706fbe\",\n        \"0x243185be4ee4b28c\",\n        \"0x550c7dc3d5ffb4e2\",\n        \"0x72be5d74f27b896f\",\n        \"0x80deb1fe3b1696b1\",\n        \"0x9bdc06a725c71235\",\n        \"0xc19bf174cf692694\",\n        \"0xe49b69c19ef14ad2\",\n        \"0xefbe4786384f25e3\",\n        \"0x0fc19dc68b8cd5b5\",\n        \"0x240ca1cc77ac9c65\",\n        \"0x2de92c6f592b0275\",\n        \"0x4a7484aa6ea6e483\",\n        \"0x5cb0a9dcbd41fbd4\",\n        \"0x76f988da831153b5\",\n        \"0x983e5152ee66dfab\",\n        \"0xa831c66d2db43210\",\n        \"0xb00327c898fb213f\",\n        \"0xbf597fc7beef0ee4\",\n        \"0xc6e00bf33da88fc2\",\n        \"0xd5a79147930aa725\",\n        \"0x06ca6351e003826f\",\n        \"0x142929670a0e6e70\",\n        \"0x27b70a8546d22ffc\",\n        \"0x2e1b21385c26c926\",\n        \"0x4d2c6dfc5ac42aed\",\n        \"0x53380d139d95b3df\",\n        \"0x650a73548baf63de\",\n        \"0x766a0abb3c77b2a8\",\n        \"0x81c2c92e47edaee6\",\n        \"0x92722c851482353b\",\n        \"0xa2bfe8a14cf10364\",\n        \"0xa81a664bbc423001\",\n        \"0xc24b8b70d0f89791\",\n        \"0xc76c51a30654be30\",\n        \"0xd192e819d6ef5218\",\n        \"0xd69906245565a910\",\n        \"0xf40e35855771202a\",\n        \"0x106aa07032bbd1b8\",\n        \"0x19a4c116b8d2d0c8\",\n        \"0x1e376c085141ab53\",\n        \"0x2748774cdf8eeb99\",\n        \"0x34b0bcb5e19b48a8\",\n        \"0x391c0cb3c5c95a63\",\n        \"0x4ed8aa4ae3418acb\",\n        \"0x5b9cca4f7763e373\",\n        \"0x682e6ff3d6b2b8a3\",\n        \"0x748f82ee5defb2fc\",\n        \"0x78a5636f43172f60\",\n        \"0x84c87814a1f0ab72\",\n        \"0x8cc702081a6439ec\",\n        \"0x90befffa23631e28\",\n        \"0xa4506cebde82bde9\",\n        \"0xbef9a3f7b2c67915\",\n        \"0xc67178f2e372532b\",\n        \"0xca273eceea26619c\",\n        \"0xd186b8c721c0c207\",\n        \"0xeada7dd6cde0eb1e\",\n        \"0xf57d4f7fee6ed178\",\n        \"0x06f067aa72176fba\",\n        \"0x0a637dc5a2c898a6\",\n        \"0x113f9804bef90dae\",\n        \"0x1b710b35131c471b\",\n        \"0x28db77f523047d84\",\n        \"0x32caab7b40c72493\",\n        \"0x3c9ebe0a15c9bebc\",\n        \"0x431d67c49c100d4c\",\n        \"0x4cc5d4becb3e42b6\",\n        \"0x597f299cfc657e2a\",\n        \"0x5fcb6fab3ad6faec\",\n        \"0x6c44198c4a475817\"\n    ].map((n)=>BigInt(n))))();\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nclass SHA512 extends _sha2_js__WEBPACK_IMPORTED_MODULE_1__.SHA2 {\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [\n            Ah,\n            Al,\n            Bh,\n            Bl,\n            Ch,\n            Cl,\n            Dh,\n            Dl,\n            Eh,\n            El,\n            Fh,\n            Fl,\n            Gh,\n            Gl,\n            Hh,\n            Hl\n        ];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for(let i = 0; i < 16; i++, offset += 4){\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32(offset += 4);\n        }\n        for(let i = 16; i < 80; i++){\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSH(W15h, W15l, 7);\n            const s0l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSH(W2h, W2l, 6);\n            const s1l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for(let i = 0; i < 80; i++){\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Eh, El, 41);\n            const sigma1l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = Eh & Fh ^ ~Eh & Gh;\n            const CHIl = El & Fl ^ ~El & Gl;\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Ah, Al, 39);\n            const sigma0l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Ah, Al, 39);\n            const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;\n            const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add3L(T1l, sigma0l, MAJl);\n            Ah = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        SHA512_W_H.fill(0);\n        SHA512_W_L.fill(0);\n    }\n    destroy() {\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n    constructor(){\n        super(128, 64, 16, false);\n        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n        // Also looks cleaner and easier to verify with spec.\n        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x6a09e667 | 0;\n        this.Al = 0xf3bcc908 | 0;\n        this.Bh = 0xbb67ae85 | 0;\n        this.Bl = 0x84caa73b | 0;\n        this.Ch = 0x3c6ef372 | 0;\n        this.Cl = 0xfe94f82b | 0;\n        this.Dh = 0xa54ff53a | 0;\n        this.Dl = 0x5f1d36f1 | 0;\n        this.Eh = 0x510e527f | 0;\n        this.El = 0xade682d1 | 0;\n        this.Fh = 0x9b05688c | 0;\n        this.Fl = 0x2b3e6c1f | 0;\n        this.Gh = 0x1f83d9ab | 0;\n        this.Gl = 0xfb41bd6b | 0;\n        this.Hh = 0x5be0cd19 | 0;\n        this.Hl = 0x137e2179 | 0;\n    }\n}\nclass SHA512_224 extends SHA512 {\n    constructor(){\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x8c3d37c8 | 0;\n        this.Al = 0x19544da2 | 0;\n        this.Bh = 0x73e19966 | 0;\n        this.Bl = 0x89dcd4d6 | 0;\n        this.Ch = 0x1dfab7ae | 0;\n        this.Cl = 0x32ff9c82 | 0;\n        this.Dh = 0x679dd514 | 0;\n        this.Dl = 0x582f9fcf | 0;\n        this.Eh = 0x0f6d2b69 | 0;\n        this.El = 0x7bd44da8 | 0;\n        this.Fh = 0x77e36f73 | 0;\n        this.Fl = 0x04c48942 | 0;\n        this.Gh = 0x3f9d85a8 | 0;\n        this.Gl = 0x6a1d36c8 | 0;\n        this.Hh = 0x1112e6ad | 0;\n        this.Hl = 0x91d692a1 | 0;\n        this.outputLen = 28;\n    }\n}\nclass SHA512_256 extends SHA512 {\n    constructor(){\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x22312194 | 0;\n        this.Al = 0xfc2bf72c | 0;\n        this.Bh = 0x9f555fa3 | 0;\n        this.Bl = 0xc84c64c2 | 0;\n        this.Ch = 0x2393b86b | 0;\n        this.Cl = 0x6f53b151 | 0;\n        this.Dh = 0x96387719 | 0;\n        this.Dl = 0x5940eabd | 0;\n        this.Eh = 0x96283ee2 | 0;\n        this.El = 0xa88effe3 | 0;\n        this.Fh = 0xbe5e1e25 | 0;\n        this.Fl = 0x53863992 | 0;\n        this.Gh = 0x2b0199fc | 0;\n        this.Gl = 0x2c85b8aa | 0;\n        this.Hh = 0x0eb72ddc | 0;\n        this.Hl = 0x81c52ca2 | 0;\n        this.outputLen = 32;\n    }\n}\nclass SHA384 extends SHA512 {\n    constructor(){\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0xcbbb9d5d | 0;\n        this.Al = 0xc1059ed8 | 0;\n        this.Bh = 0x629a292a | 0;\n        this.Bl = 0x367cd507 | 0;\n        this.Ch = 0x9159015a | 0;\n        this.Cl = 0x3070dd17 | 0;\n        this.Dh = 0x152fecd8 | 0;\n        this.Dl = 0xf70e5939 | 0;\n        this.Eh = 0x67332667 | 0;\n        this.El = 0xffc00b31 | 0;\n        this.Fh = 0x8eb44a87 | 0;\n        this.Fl = 0x68581511 | 0;\n        this.Gh = 0xdb0c2e0d | 0;\n        this.Gl = 0x64f98fa7 | 0;\n        this.Hh = 0x47b5481d | 0;\n        this.Hl = 0xbefa4fa4 | 0;\n        this.outputLen = 48;\n    }\n}\nconst sha512 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(()=>new SHA512());\nconst sha512_224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(()=>new SHA512_224());\nconst sha512_256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(()=>new SHA512_256());\nconst sha384 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(()=>new SHA384()); //# sourceMappingURL=sha512.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGE1MTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBa0M7QUFDTjtBQUNpQjtBQUM3QywwR0FBMEc7QUFDMUcsa0JBQWtCO0FBQ2xCLE1BQU0sQ0FBQ0csV0FBV0MsVUFBVSxHQUFtQixhQUFILEdBQUksS0FBTUgscURBQVMsQ0FBQztRQUM1RDtRQUFzQjtRQUFzQjtRQUFzQjtRQUNsRTtRQUFzQjtRQUFzQjtRQUFzQjtRQUNsRTtRQUFzQjtRQUFzQjtRQUFzQjtRQUNsRTtRQUFzQjtRQUFzQjtRQUFzQjtRQUNsRTtRQUFzQjtRQUFzQjtRQUFzQjtRQUNsRTtRQUFzQjtRQUFzQjtRQUFzQjtRQUNsRTtRQUFzQjtRQUFzQjtRQUFzQjtRQUNsRTtRQUFzQjtRQUFzQjtRQUFzQjtRQUNsRTtRQUFzQjtRQUFzQjtRQUFzQjtRQUNsRTtRQUFzQjtRQUFzQjtRQUFzQjtRQUNsRTtRQUFzQjtRQUFzQjtRQUFzQjtRQUNsRTtRQUFzQjtRQUFzQjtRQUFzQjtRQUNsRTtRQUFzQjtRQUFzQjtRQUFzQjtRQUNsRTtRQUFzQjtRQUFzQjtRQUFzQjtRQUNsRTtRQUFzQjtRQUFzQjtRQUFzQjtRQUNsRTtRQUFzQjtRQUFzQjtRQUFzQjtRQUNsRTtRQUFzQjtRQUFzQjtRQUFzQjtRQUNsRTtRQUFzQjtRQUFzQjtRQUFzQjtRQUNsRTtRQUFzQjtRQUFzQjtRQUFzQjtRQUNsRTtRQUFzQjtRQUFzQjtRQUFzQjtLQUNyRSxDQUFDSyxHQUFHLENBQUNDLENBQUFBLElBQUtDLE9BQU9ELElBQUc7QUFDckIsNERBQTREO0FBQzVELE1BQU1FLGFBQWEsYUFBYSxHQUFHLElBQUlDLFlBQVk7QUFDbkQsTUFBTUMsYUFBYSxhQUFhLEdBQUcsSUFBSUQsWUFBWTtBQUM1QyxNQUFNRSxlQUFlWiwwQ0FBSUE7SUF3QjVCLGtCQUFrQjtJQUNsQmEsTUFBTTtRQUNGLE1BQU0sRUFBRUMsRUFBRSxF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RyxhQUFhO1FBQ3ZCLElBQUksQ0FBQ0MsRUFBRSxHQUFHLGFBQWE7UUFDdkIsSUFBSSxDQUFDQyxFQUFFLEdBQUcsYUFBYTtRQUN2QixJQUFJLENBQUNDLEVBQUUsR0FBRyxhQUFhO1FBQ3ZCLElBQUksQ0FBQ0MsRUFBRSxHQUFHLGFBQWE7UUFDdkIsSUFBSSxDQUFDQyxFQUFFLEdBQUcsYUFBYTtRQUN2QixJQUFJLENBQUNDLEVBQUUsR0FBRyxhQUFhO1FBQ3ZCLElBQUksQ0FBQ0MsRUFBRSxHQUFHLGFBQWE7UUFDdkIsSUFBSSxDQUFDQyxFQUFFLEdBQUcsYUFBYTtRQUN2QixJQUFJLENBQUNDLEVBQUUsR0FBRyxhQUFhO1FBQ3ZCLElBQUksQ0FBQ0MsRUFBRSxHQUFHLGFBQWE7UUFDdkIsSUFBSSxDQUFDQyxFQUFFLEdBQUcsYUFBYTtRQUN2QixJQUFJLENBQUNDLEVBQUUsR0FBRyxhQUFhO1FBQ3ZCLElBQUksQ0FBQ0MsRUFBRSxHQUFHLGFBQWE7UUFDdkIsSUFBSSxDQUFDQyxFQUFFLEdBQUcsYUFBYTtRQUN2QixJQUFJLENBQUNrRCxTQUFTLEdBQUc7SUFDckI7QUFDSjtBQUNPLE1BQU1HLFNBQVMsYUFBYSxHQUFHaEYsMERBQWVBLENBQUMsSUFBTSxJQUFJVSxVQUFVO0FBQ25FLE1BQU11RSxhQUFhLGFBQWEsR0FBR2pGLDBEQUFlQSxDQUFDLElBQU0sSUFBSTRFLGNBQWM7QUFDM0UsTUFBTU0sYUFBYSxhQUFhLEdBQUdsRiwwREFBZUEsQ0FBQyxJQUFNLElBQUk4RSxjQUFjO0FBQzNFLE1BQU1LLFNBQVMsYUFBYSxHQUFHbkYsMERBQWVBLENBQUMsSUFBTSxJQUFJK0UsVUFBVSxDQUMxRSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTUxMi5qcz9hM2U4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNIQTIgfSBmcm9tICcuL19zaGEyLmpzJztcbmltcG9ydCB1NjQgZnJvbSAnLi9fdTY0LmpzJztcbmltcG9ydCB7IHdyYXBDb25zdHJ1Y3RvciB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gUm91bmQgY29udGFudHMgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDgwIHByaW1lcyAyLi40MDkpOlxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBbU0hBNTEyX0toLCBTSEE1MTJfS2xdID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB1NjQuc3BsaXQoW1xuICAgICcweDQyOGEyZjk4ZDcyOGFlMjInLCAnMHg3MTM3NDQ5MTIzZWY2NWNkJywgJzB4YjVjMGZiY2ZlYzRkM2IyZicsICcweGU5YjVkYmE1ODE4OWRiYmMnLFxuICAgICcweDM5NTZjMjViZjM0OGI1MzgnLCAnMHg1OWYxMTFmMWI2MDVkMDE5JywgJzB4OTIzZjgyYTRhZjE5NGY5YicsICcweGFiMWM1ZWQ1ZGE2ZDgxMTgnLFxuICAgICcweGQ4MDdhYTk4YTMwMzAyNDInLCAnMHgxMjgzNWIwMTQ1NzA2ZmJlJywgJzB4MjQzMTg1YmU0ZWU0YjI4YycsICcweDU1MGM3ZGMzZDVmZmI0ZTInLFxuICAgICcweDcyYmU1ZDc0ZjI3Yjg5NmYnLCAnMHg4MGRlYjFmZTNiMTY5NmIxJywgJzB4OWJkYzA2YTcyNWM3MTIzNScsICcweGMxOWJmMTc0Y2Y2OTI2OTQnLFxuICAgICcweGU0OWI2OWMxOWVmMTRhZDInLCAnMHhlZmJlNDc4NjM4NGYyNWUzJywgJzB4MGZjMTlkYzY4YjhjZDViNScsICcweDI0MGNhMWNjNzdhYzljNjUnLFxuICAgICcweDJkZTkyYzZmNTkyYjAyNzUnLCAnMHg0YTc0ODRhYTZlYTZlNDgzJywgJzB4NWNiMGE5ZGNiZDQxZmJkNCcsICcweDc2Zjk4OGRhODMxMTUzYjUnLFxuICAgICcweDk4M2U1MTUyZWU2NmRmYWInLCAnMHhhODMxYzY2ZDJkYjQzMjEwJywgJzB4YjAwMzI3Yzg5OGZiMjEzZicsICcweGJmNTk3ZmM3YmVlZjBlZTQnLFxuICAgICcweGM2ZTAwYmYzM2RhODhmYzInLCAnMHhkNWE3OTE0NzkzMGFhNzI1JywgJzB4MDZjYTYzNTFlMDAzODI2ZicsICcweDE0MjkyOTY3MGEwZTZlNzAnLFxuICAgICcweDI3YjcwYTg1NDZkMjJmZmMnLCAnMHgyZTFiMjEzODVjMjZjOTI2JywgJzB4NGQyYzZkZmM1YWM0MmFlZCcsICcweDUzMzgwZDEzOWQ5NWIzZGYnLFxuICAgICcweDY1MGE3MzU0OGJhZjYzZGUnLCAnMHg3NjZhMGFiYjNjNzdiMmE4JywgJzB4ODFjMmM5MmU0N2VkYWVlNicsICcweDkyNzIyYzg1MTQ4MjM1M2InLFxuICAgICcweGEyYmZlOGExNGNmMTAzNjQnLCAnMHhhODFhNjY0YmJjNDIzMDAxJywgJzB4YzI0YjhiNzBkMGY4OTc5MScsICcweGM3NmM1MWEzMDY1NGJlMzAnLFxuICAgICcweGQxOTJlODE5ZDZlZjUyMTgnLCAnMHhkNjk5MDYyNDU1NjVhOTEwJywgJzB4ZjQwZTM1ODU1NzcxMjAyYScsICcweDEwNmFhMDcwMzJiYmQxYjgnLFxuICAgICcweDE5YTRjMTE2YjhkMmQwYzgnLCAnMHgxZTM3NmMwODUxNDFhYjUzJywgJzB4Mjc0ODc3NGNkZjhlZWI5OScsICcweDM0YjBiY2I1ZTE5YjQ4YTgnLFxuICAgICcweDM5MWMwY2IzYzVjOTVhNjMnLCAnMHg0ZWQ4YWE0YWUzNDE4YWNiJywgJzB4NWI5Y2NhNGY3NzYzZTM3MycsICcweDY4MmU2ZmYzZDZiMmI4YTMnLFxuICAgICcweDc0OGY4MmVlNWRlZmIyZmMnLCAnMHg3OGE1NjM2ZjQzMTcyZjYwJywgJzB4ODRjODc4MTRhMWYwYWI3MicsICcweDhjYzcwMjA4MWE2NDM5ZWMnLFxuICAgICcweDkwYmVmZmZhMjM2MzFlMjgnLCAnMHhhNDUwNmNlYmRlODJiZGU5JywgJzB4YmVmOWEzZjdiMmM2NzkxNScsICcweGM2NzE3OGYyZTM3MjUzMmInLFxuICAgICcweGNhMjczZWNlZWEyNjYxOWMnLCAnMHhkMTg2YjhjNzIxYzBjMjA3JywgJzB4ZWFkYTdkZDZjZGUwZWIxZScsICcweGY1N2Q0ZjdmZWU2ZWQxNzgnLFxuICAgICcweDA2ZjA2N2FhNzIxNzZmYmEnLCAnMHgwYTYzN2RjNWEyYzg5OGE2JywgJzB4MTEzZjk4MDRiZWY5MGRhZScsICcweDFiNzEwYjM1MTMxYzQ3MWInLFxuICAgICcweDI4ZGI3N2Y1MjMwNDdkODQnLCAnMHgzMmNhYWI3YjQwYzcyNDkzJywgJzB4M2M5ZWJlMGExNWM5YmViYycsICcweDQzMWQ2N2M0OWMxMDBkNGMnLFxuICAgICcweDRjYzVkNGJlY2IzZTQyYjYnLCAnMHg1OTdmMjk5Y2ZjNjU3ZTJhJywgJzB4NWZjYjZmYWIzYWQ2ZmFlYycsICcweDZjNDQxOThjNGE0NzU4MTcnXG5dLm1hcChuID0+IEJpZ0ludChuKSkpKSgpO1xuLy8gVGVtcG9yYXJ5IGJ1ZmZlciwgbm90IHVzZWQgdG8gc3RvcmUgYW55dGhpbmcgYmV0d2VlbiBydW5zXG5jb25zdCBTSEE1MTJfV19IID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg4MCk7XG5jb25zdCBTSEE1MTJfV19MID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg4MCk7XG5leHBvcnQgY2xhc3MgU0hBNTEyIGV4dGVuZHMgU0hBMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDEyOCwgNjQsIDE2LCBmYWxzZSk7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGUgd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgICAgICAvLyBBbHNvIGxvb2tzIGNsZWFuZXIgYW5kIGVhc2llciB0byB2ZXJpZnkgd2l0aCBzcGVjLlxuICAgICAgICAvLyBJbml0aWFsIHN0YXRlIChmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBzcXVhcmUgcm9vdHMgb2YgdGhlIGZpcnN0IDggcHJpbWVzIDIuLjE5KTpcbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcbiAgICAgICAgdGhpcy5BaCA9IDB4NmEwOWU2NjcgfCAwO1xuICAgICAgICB0aGlzLkFsID0gMHhmM2JjYzkwOCB8IDA7XG4gICAgICAgIHRoaXMuQmggPSAweGJiNjdhZTg1IHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IDB4ODRjYWE3M2IgfCAwO1xuICAgICAgICB0aGlzLkNoID0gMHgzYzZlZjM3MiB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSAweGZlOTRmODJiIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IDB4YTU0ZmY1M2EgfCAwO1xuICAgICAgICB0aGlzLkRsID0gMHg1ZjFkMzZmMSB8IDA7XG4gICAgICAgIHRoaXMuRWggPSAweDUxMGU1MjdmIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IDB4YWRlNjgyZDEgfCAwO1xuICAgICAgICB0aGlzLkZoID0gMHg5YjA1Njg4YyB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSAweDJiM2U2YzFmIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IDB4MWY4M2Q5YWIgfCAwO1xuICAgICAgICB0aGlzLkdsID0gMHhmYjQxYmQ2YiB8IDA7XG4gICAgICAgIHRoaXMuSGggPSAweDViZTBjZDE5IHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IDB4MTM3ZTIxNzkgfCAwO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGxdO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBzZXQoQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwpIHtcbiAgICAgICAgdGhpcy5BaCA9IEFoIHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IEFsIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IEJoIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IEJsIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IENoIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IENsIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IERoIHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IERsIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IEVoIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IEVsIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IEZoIHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IEZsIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IEdoIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IEdsIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IEhoIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IEhsIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNjQgd29yZHMgd1sxNi4uNzldIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpIHtcbiAgICAgICAgICAgIFNIQTUxMl9XX0hbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgICAgICAgICAgU0hBNTEyX1dfTFtpXSA9IHZpZXcuZ2V0VWludDMyKChvZmZzZXQgKz0gNCkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDgwOyBpKyspIHtcbiAgICAgICAgICAgIC8vIHMwIDo9ICh3W2ktMTVdIHJpZ2h0cm90YXRlIDEpIHhvciAod1tpLTE1XSByaWdodHJvdGF0ZSA4KSB4b3IgKHdbaS0xNV0gcmlnaHRzaGlmdCA3KVxuICAgICAgICAgICAgY29uc3QgVzE1aCA9IFNIQTUxMl9XX0hbaSAtIDE1XSB8IDA7XG4gICAgICAgICAgICBjb25zdCBXMTVsID0gU0hBNTEyX1dfTFtpIC0gMTVdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHMwaCA9IHU2NC5yb3RyU0goVzE1aCwgVzE1bCwgMSkgXiB1NjQucm90clNIKFcxNWgsIFcxNWwsIDgpIF4gdTY0LnNoclNIKFcxNWgsIFcxNWwsIDcpO1xuICAgICAgICAgICAgY29uc3QgczBsID0gdTY0LnJvdHJTTChXMTVoLCBXMTVsLCAxKSBeIHU2NC5yb3RyU0woVzE1aCwgVzE1bCwgOCkgXiB1NjQuc2hyU0woVzE1aCwgVzE1bCwgNyk7XG4gICAgICAgICAgICAvLyBzMSA6PSAod1tpLTJdIHJpZ2h0cm90YXRlIDE5KSB4b3IgKHdbaS0yXSByaWdodHJvdGF0ZSA2MSkgeG9yICh3W2ktMl0gcmlnaHRzaGlmdCA2KVxuICAgICAgICAgICAgY29uc3QgVzJoID0gU0hBNTEyX1dfSFtpIC0gMl0gfCAwO1xuICAgICAgICAgICAgY29uc3QgVzJsID0gU0hBNTEyX1dfTFtpIC0gMl0gfCAwO1xuICAgICAgICAgICAgY29uc3QgczFoID0gdTY0LnJvdHJTSChXMmgsIFcybCwgMTkpIF4gdTY0LnJvdHJCSChXMmgsIFcybCwgNjEpIF4gdTY0LnNoclNIKFcyaCwgVzJsLCA2KTtcbiAgICAgICAgICAgIGNvbnN0IHMxbCA9IHU2NC5yb3RyU0woVzJoLCBXMmwsIDE5KSBeIHU2NC5yb3RyQkwoVzJoLCBXMmwsIDYxKSBeIHU2NC5zaHJTTChXMmgsIFcybCwgNik7XG4gICAgICAgICAgICAvLyBTSEEyNTZfV1tpXSA9IHMwICsgczEgKyBTSEEyNTZfV1tpIC0gN10gKyBTSEEyNTZfV1tpIC0gMTZdO1xuICAgICAgICAgICAgY29uc3QgU1VNbCA9IHU2NC5hZGQ0TChzMGwsIHMxbCwgU0hBNTEyX1dfTFtpIC0gN10sIFNIQTUxMl9XX0xbaSAtIDE2XSk7XG4gICAgICAgICAgICBjb25zdCBTVU1oID0gdTY0LmFkZDRIKFNVTWwsIHMwaCwgczFoLCBTSEE1MTJfV19IW2kgLSA3XSwgU0hBNTEyX1dfSFtpIC0gMTZdKTtcbiAgICAgICAgICAgIFNIQTUxMl9XX0hbaV0gPSBTVU1oIHwgMDtcbiAgICAgICAgICAgIFNIQTUxMl9XX0xbaV0gPSBTVU1sIHwgMDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCB9ID0gdGhpcztcbiAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA4MCByb3VuZHNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4MDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBTMSA6PSAoZSByaWdodHJvdGF0ZSAxNCkgeG9yIChlIHJpZ2h0cm90YXRlIDE4KSB4b3IgKGUgcmlnaHRyb3RhdGUgNDEpXG4gICAgICAgICAgICBjb25zdCBzaWdtYTFoID0gdTY0LnJvdHJTSChFaCwgRWwsIDE0KSBeIHU2NC5yb3RyU0goRWgsIEVsLCAxOCkgXiB1NjQucm90ckJIKEVoLCBFbCwgNDEpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExbCA9IHU2NC5yb3RyU0woRWgsIEVsLCAxNCkgXiB1NjQucm90clNMKEVoLCBFbCwgMTgpIF4gdTY0LnJvdHJCTChFaCwgRWwsIDQxKTtcbiAgICAgICAgICAgIC8vY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IENISWggPSAoRWggJiBGaCkgXiAofkVoICYgR2gpO1xuICAgICAgICAgICAgY29uc3QgQ0hJbCA9IChFbCAmIEZsKSBeICh+RWwgJiBHbCk7XG4gICAgICAgICAgICAvLyBUMSA9IEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEE1MTJfS1tpXSArIFNIQTUxMl9XW2ldXG4gICAgICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IFQxbGwgPSB1NjQuYWRkNUwoSGwsIHNpZ21hMWwsIENISWwsIFNIQTUxMl9LbFtpXSwgU0hBNTEyX1dfTFtpXSk7XG4gICAgICAgICAgICBjb25zdCBUMWggPSB1NjQuYWRkNUgoVDFsbCwgSGgsIHNpZ21hMWgsIENISWgsIFNIQTUxMl9LaFtpXSwgU0hBNTEyX1dfSFtpXSk7XG4gICAgICAgICAgICBjb25zdCBUMWwgPSBUMWxsIHwgMDtcbiAgICAgICAgICAgIC8vIFMwIDo9IChhIHJpZ2h0cm90YXRlIDI4KSB4b3IgKGEgcmlnaHRyb3RhdGUgMzQpIHhvciAoYSByaWdodHJvdGF0ZSAzOSlcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMGggPSB1NjQucm90clNIKEFoLCBBbCwgMjgpIF4gdTY0LnJvdHJCSChBaCwgQWwsIDM0KSBeIHU2NC5yb3RyQkgoQWgsIEFsLCAzOSk7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTBsID0gdTY0LnJvdHJTTChBaCwgQWwsIDI4KSBeIHU2NC5yb3RyQkwoQWgsIEFsLCAzNCkgXiB1NjQucm90ckJMKEFoLCBBbCwgMzkpO1xuICAgICAgICAgICAgY29uc3QgTUFKaCA9IChBaCAmIEJoKSBeIChBaCAmIENoKSBeIChCaCAmIENoKTtcbiAgICAgICAgICAgIGNvbnN0IE1BSmwgPSAoQWwgJiBCbCkgXiAoQWwgJiBDbCkgXiAoQmwgJiBDbCk7XG4gICAgICAgICAgICBIaCA9IEdoIHwgMDtcbiAgICAgICAgICAgIEhsID0gR2wgfCAwO1xuICAgICAgICAgICAgR2ggPSBGaCB8IDA7XG4gICAgICAgICAgICBHbCA9IEZsIHwgMDtcbiAgICAgICAgICAgIEZoID0gRWggfCAwO1xuICAgICAgICAgICAgRmwgPSBFbCB8IDA7XG4gICAgICAgICAgICAoeyBoOiBFaCwgbDogRWwgfSA9IHU2NC5hZGQoRGggfCAwLCBEbCB8IDAsIFQxaCB8IDAsIFQxbCB8IDApKTtcbiAgICAgICAgICAgIERoID0gQ2ggfCAwO1xuICAgICAgICAgICAgRGwgPSBDbCB8IDA7XG4gICAgICAgICAgICBDaCA9IEJoIHwgMDtcbiAgICAgICAgICAgIENsID0gQmwgfCAwO1xuICAgICAgICAgICAgQmggPSBBaCB8IDA7XG4gICAgICAgICAgICBCbCA9IEFsIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IEFsbCA9IHU2NC5hZGQzTChUMWwsIHNpZ21hMGwsIE1BSmwpO1xuICAgICAgICAgICAgQWggPSB1NjQuYWRkM0goQWxsLCBUMWgsIHNpZ21hMGgsIE1BSmgpO1xuICAgICAgICAgICAgQWwgPSBBbGwgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgICh7IGg6IEFoLCBsOiBBbCB9ID0gdTY0LmFkZCh0aGlzLkFoIHwgMCwgdGhpcy5BbCB8IDAsIEFoIHwgMCwgQWwgfCAwKSk7XG4gICAgICAgICh7IGg6IEJoLCBsOiBCbCB9ID0gdTY0LmFkZCh0aGlzLkJoIHwgMCwgdGhpcy5CbCB8IDAsIEJoIHwgMCwgQmwgfCAwKSk7XG4gICAgICAgICh7IGg6IENoLCBsOiBDbCB9ID0gdTY0LmFkZCh0aGlzLkNoIHwgMCwgdGhpcy5DbCB8IDAsIENoIHwgMCwgQ2wgfCAwKSk7XG4gICAgICAgICh7IGg6IERoLCBsOiBEbCB9ID0gdTY0LmFkZCh0aGlzLkRoIHwgMCwgdGhpcy5EbCB8IDAsIERoIHwgMCwgRGwgfCAwKSk7XG4gICAgICAgICh7IGg6IEVoLCBsOiBFbCB9ID0gdTY0LmFkZCh0aGlzLkVoIHwgMCwgdGhpcy5FbCB8IDAsIEVoIHwgMCwgRWwgfCAwKSk7XG4gICAgICAgICh7IGg6IEZoLCBsOiBGbCB9ID0gdTY0LmFkZCh0aGlzLkZoIHwgMCwgdGhpcy5GbCB8IDAsIEZoIHwgMCwgRmwgfCAwKSk7XG4gICAgICAgICh7IGg6IEdoLCBsOiBHbCB9ID0gdTY0LmFkZCh0aGlzLkdoIHwgMCwgdGhpcy5HbCB8IDAsIEdoIHwgMCwgR2wgfCAwKSk7XG4gICAgICAgICh7IGg6IEhoLCBsOiBIbCB9ID0gdTY0LmFkZCh0aGlzLkhoIHwgMCwgdGhpcy5IbCB8IDAsIEhoIHwgMCwgSGwgfCAwKSk7XG4gICAgICAgIHRoaXMuc2V0KEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgU0hBNTEyX1dfSC5maWxsKDApO1xuICAgICAgICBTSEE1MTJfV19MLmZpbGwoMCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyLmZpbGwoMCk7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgIH1cbn1cbmNsYXNzIFNIQTUxMl8yMjQgZXh0ZW5kcyBTSEE1MTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xuICAgICAgICB0aGlzLkFoID0gMHg4YzNkMzdjOCB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSAweDE5NTQ0ZGEyIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IDB4NzNlMTk5NjYgfCAwO1xuICAgICAgICB0aGlzLkJsID0gMHg4OWRjZDRkNiB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSAweDFkZmFiN2FlIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IDB4MzJmZjljODIgfCAwO1xuICAgICAgICB0aGlzLkRoID0gMHg2NzlkZDUxNCB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSAweDU4MmY5ZmNmIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IDB4MGY2ZDJiNjkgfCAwO1xuICAgICAgICB0aGlzLkVsID0gMHg3YmQ0NGRhOCB8IDA7XG4gICAgICAgIHRoaXMuRmggPSAweDc3ZTM2ZjczIHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IDB4MDRjNDg5NDIgfCAwO1xuICAgICAgICB0aGlzLkdoID0gMHgzZjlkODVhOCB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSAweDZhMWQzNmM4IHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IDB4MTExMmU2YWQgfCAwO1xuICAgICAgICB0aGlzLkhsID0gMHg5MWQ2OTJhMSB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMjg7XG4gICAgfVxufVxuY2xhc3MgU0hBNTEyXzI1NiBleHRlbmRzIFNIQTUxMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIGggLS0gaGlnaCAzMiBiaXRzLCBsIC0tIGxvdyAzMiBiaXRzXG4gICAgICAgIHRoaXMuQWggPSAweDIyMzEyMTk0IHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IDB4ZmMyYmY3MmMgfCAwO1xuICAgICAgICB0aGlzLkJoID0gMHg5ZjU1NWZhMyB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSAweGM4NGM2NGMyIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IDB4MjM5M2I4NmIgfCAwO1xuICAgICAgICB0aGlzLkNsID0gMHg2ZjUzYjE1MSB8IDA7XG4gICAgICAgIHRoaXMuRGggPSAweDk2Mzg3NzE5IHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IDB4NTk0MGVhYmQgfCAwO1xuICAgICAgICB0aGlzLkVoID0gMHg5NjI4M2VlMiB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSAweGE4OGVmZmUzIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IDB4YmU1ZTFlMjUgfCAwO1xuICAgICAgICB0aGlzLkZsID0gMHg1Mzg2Mzk5MiB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSAweDJiMDE5OWZjIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IDB4MmM4NWI4YWEgfCAwO1xuICAgICAgICB0aGlzLkhoID0gMHgwZWI3MmRkYyB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSAweDgxYzUyY2EyIHwgMDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSAzMjtcbiAgICB9XG59XG5jbGFzcyBTSEEzODQgZXh0ZW5kcyBTSEE1MTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xuICAgICAgICB0aGlzLkFoID0gMHhjYmJiOWQ1ZCB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSAweGMxMDU5ZWQ4IHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IDB4NjI5YTI5MmEgfCAwO1xuICAgICAgICB0aGlzLkJsID0gMHgzNjdjZDUwNyB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSAweDkxNTkwMTVhIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IDB4MzA3MGRkMTcgfCAwO1xuICAgICAgICB0aGlzLkRoID0gMHgxNTJmZWNkOCB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSAweGY3MGU1OTM5IHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IDB4NjczMzI2NjcgfCAwO1xuICAgICAgICB0aGlzLkVsID0gMHhmZmMwMGIzMSB8IDA7XG4gICAgICAgIHRoaXMuRmggPSAweDhlYjQ0YTg3IHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IDB4Njg1ODE1MTEgfCAwO1xuICAgICAgICB0aGlzLkdoID0gMHhkYjBjMmUwZCB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSAweDY0Zjk4ZmE3IHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IDB4NDdiNTQ4MWQgfCAwO1xuICAgICAgICB0aGlzLkhsID0gMHhiZWZhNGZhNCB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gNDg7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IHNoYTUxMiA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTUxMigpKTtcbmV4cG9ydCBjb25zdCBzaGE1MTJfMjI0ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBNTEyXzIyNCgpKTtcbmV4cG9ydCBjb25zdCBzaGE1MTJfMjU2ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBNTEyXzI1NigpKTtcbmV4cG9ydCBjb25zdCBzaGEzODQgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEEzODQoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGE1MTIuanMubWFwIl0sIm5hbWVzIjpbIlNIQTIiLCJ1NjQiLCJ3cmFwQ29uc3RydWN0b3IiLCJTSEE1MTJfS2giLCJTSEE1MTJfS2wiLCJzcGxpdCIsIm1hcCIsIm4iLCJCaWdJbnQiLCJTSEE1MTJfV19IIiwiVWludDMyQXJyYXkiLCJTSEE1MTJfV19MIiwiU0hBNTEyIiwiZ2V0IiwiQWgiLCJBbCIsIkJoIiwiQmwiLCJDaCIsIkNsIiwiRGgiLCJEbCIsIkVoIiwiRWwiLCJGaCIsIkZsIiwiR2giLCJHbCIsIkhoIiwiSGwiLCJzZXQiLCJwcm9jZXNzIiwidmlldyIsIm9mZnNldCIsImkiLCJnZXRVaW50MzIiLCJXMTVoIiwiVzE1bCIsInMwaCIsInJvdHJTSCIsInNoclNIIiwiczBsIiwicm90clNMIiwic2hyU0wiLCJXMmgiLCJXMmwiLCJzMWgiLCJyb3RyQkgiLCJzMWwiLCJyb3RyQkwiLCJTVU1sIiwiYWRkNEwiLCJTVU1oIiwiYWRkNEgiLCJzaWdtYTFoIiwic2lnbWExbCIsIkNISWgiLCJDSElsIiwiVDFsbCIsImFkZDVMIiwiVDFoIiwiYWRkNUgiLCJUMWwiLCJzaWdtYTBoIiwic2lnbWEwbCIsIk1BSmgiLCJNQUpsIiwiaCIsImwiLCJhZGQiLCJBbGwiLCJhZGQzTCIsImFkZDNIIiwicm91bmRDbGVhbiIsImZpbGwiLCJkZXN0cm95IiwiYnVmZmVyIiwiY29uc3RydWN0b3IiLCJTSEE1MTJfMjI0Iiwib3V0cHV0TGVuIiwiU0hBNTEyXzI1NiIsIlNIQTM4NCIsInNoYTUxMiIsInNoYTUxMl8yMjQiLCJzaGE1MTJfMjU2Iiwic2hhMzg0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/hashes/esm/sha512.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/hashes/esm/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/utils.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: function() { return /* binding */ Hash; },\n/* harmony export */   asyncLoop: function() { return /* binding */ asyncLoop; },\n/* harmony export */   bytesToHex: function() { return /* binding */ bytesToHex; },\n/* harmony export */   checkOpts: function() { return /* binding */ checkOpts; },\n/* harmony export */   concatBytes: function() { return /* binding */ concatBytes; },\n/* harmony export */   createView: function() { return /* binding */ createView; },\n/* harmony export */   hexToBytes: function() { return /* binding */ hexToBytes; },\n/* harmony export */   isLE: function() { return /* binding */ isLE; },\n/* harmony export */   nextTick: function() { return /* binding */ nextTick; },\n/* harmony export */   randomBytes: function() { return /* binding */ randomBytes; },\n/* harmony export */   rotr: function() { return /* binding */ rotr; },\n/* harmony export */   toBytes: function() { return /* binding */ toBytes; },\n/* harmony export */   u32: function() { return /* binding */ u32; },\n/* harmony export */   u8: function() { return /* binding */ u8; },\n/* harmony export */   utf8ToBytes: function() { return /* binding */ utf8ToBytes; },\n/* harmony export */   wrapConstructor: function() { return /* binding */ wrapConstructor; },\n/* harmony export */   wrapConstructorWithOpts: function() { return /* binding */ wrapConstructorWithOpts; },\n/* harmony export */   wrapXOFConstructorWithOpts: function() { return /* binding */ wrapXOFConstructorWithOpts; }\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/crypto.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\n\nconst u8a = (a)=>a instanceof Uint8Array;\n// Cast array to different type\nconst u8 = (arr)=>new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr)=>new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nconst createView = (arr)=>new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift)=>word << 32 - shift | word >>> shift;\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nconst isLE = new Uint8Array(new Uint32Array([\n    0x11223344\n]).buffer)[0] === 0x44;\nif (!isLE) throw new Error(\"Non little-endian hardware is not supported\");\nconst hexes = /* @__PURE__ */ Array.from({\n    length: 256\n}, (_, i)=>i.toString(16).padStart(2, \"0\"));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function bytesToHex(bytes) {\n    if (!u8a(bytes)) throw new Error(\"Uint8Array expected\");\n    // pre-caching improves the speed 6x\n    let hex = \"\";\n    for(let i = 0; i < bytes.length; i++){\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function hexToBytes(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    const len = hex.length;\n    if (len % 2) throw new Error(\"padded hex string expected, got unpadded hex of length \" + len);\n    const array = new Uint8Array(len / 2);\n    for(let i = 0; i < array.length; i++){\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0) throw new Error(\"Invalid byte sequence\");\n        array[i] = byte;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async ()=>{};\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for(let i = 0; i < iters; i++){\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick) continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ function utf8ToBytes(str) {\n    if (typeof str !== \"string\") throw new Error(\"utf8ToBytes expected string, got \".concat(typeof str));\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */ function toBytes(data) {\n    if (typeof data === \"string\") data = utf8ToBytes(data);\n    if (!u8a(data)) throw new Error(\"expected Uint8Array, got \".concat(typeof data));\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */ function concatBytes() {\n    for(var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++){\n        arrays[_key] = arguments[_key];\n    }\n    const r = new Uint8Array(arrays.reduce((sum, a)=>sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a)=>{\n        if (!u8a(a)) throw new Error(\"Uint8Array expected\");\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== \"[object Object]\") throw new Error(\"Options should be object or undefined\");\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg)=>hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = ()=>hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */ function randomBytes() {\n    let bytesLength = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 32;\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues === \"function\") {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error(\"crypto.getRandomValues must be defined\");\n} //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsb0VBQW9FLEdBQ3BFLG9GQUFvRjtBQUNwRixzRUFBc0U7QUFDdEUsa0VBQWtFO0FBQ2xFLDhEQUE4RDtBQUM5RCwrREFBK0Q7QUFDL0QsOERBQThEO0FBQ2hCO0FBQzlDLE1BQU1DLE1BQU0sQ0FBQ0MsSUFBTUEsYUFBYUM7QUFDaEMsK0JBQStCO0FBQ3hCLE1BQU1DLEtBQUssQ0FBQ0MsTUFBUSxJQUFJRixXQUFXRSxJQUFJQyxNQUFNLEVBQUVELElBQUlFLFVBQVUsRUFBRUYsSUFBSUcsVUFBVSxFQUFFO0FBQy9FLE1BQU1DLE1BQU0sQ0FBQ0osTUFBUSxJQUFJSyxZQUFZTCxJQUFJQyxNQUFNLEVBQUVELElBQUlFLFVBQVUsRUFBRUksS0FBS0MsS0FBSyxDQUFDUCxJQUFJRyxVQUFVLEdBQUcsSUFBSTtBQUN4RyxxQkFBcUI7QUFDZCxNQUFNSyxhQUFhLENBQUNSLE1BQVEsSUFBSVMsU0FBU1QsSUFBSUMsTUFBTSxFQUFFRCxJQUFJRSxVQUFVLEVBQUVGLElBQUlHLFVBQVUsRUFBRTtBQUM1RiwrREFBK0Q7QUFDeEQsTUFBTU8sT0FBTyxDQUFDQyxNQUFNQyxRQUFVLFFBQVUsS0FBS0EsUUFBV0QsU0FBU0MsTUFBTztBQUMvRSxpRkFBaUY7QUFDakYsd0RBQXdEO0FBQ2pELE1BQU1DLE9BQU8sSUFBSWYsV0FBVyxJQUFJTyxZQUFZO0lBQUM7Q0FBVyxFQUFFSixNQUFNLENBQUMsQ0FBQyxFQUFFLEtBQUssS0FBSztBQUNyRixJQUFJLENBQUNZLE1BQ0QsTUFBTSxJQUFJQyxNQUFNO0FBQ3BCLE1BQU1DLFFBQVEsYUFBYSxHQUFHQyxNQUFNQyxJQUFJLENBQUM7SUFBRUMsUUFBUTtBQUFJLEdBQUcsQ0FBQ0MsR0FBR0MsSUFBTUEsRUFBRUMsUUFBUSxDQUFDLElBQUlDLFFBQVEs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QU9RO0FBQ1g7QUFDQTs7Q0FFQyxHQUNNLFNBQVNVO1FBQVlDLGNBQUFBLGlFQUFjO0lBQ3RDLElBQUl6Rix3REFBTUEsSUFBSSxPQUFPQSx3REFBTUEsQ0FBQzBGLGVBQWUsS0FBSyxZQUFZO1FBQ3hELE9BQU8xRix3REFBTUEsQ0FBQzBGLGVBQWUsQ0FBQyxJQUFJdkYsV0FBV3NGO0lBQ2pEO0lBQ0EsTUFBTSxJQUFJdEUsTUFBTTtBQUNwQixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vdXRpbHMuanM/ZWY3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBXZSB1c2UgV2ViQ3J5cHRvIGFrYSBnbG9iYWxUaGlzLmNyeXB0bywgd2hpY2ggZXhpc3RzIGluIGJyb3dzZXJzIGFuZCBub2RlLmpzIDE2Ky5cbi8vIG5vZGUuanMgdmVyc2lvbnMgZWFybGllciB0aGFuIHYxOSBkb24ndCBkZWNsYXJlIGl0IGluIGdsb2JhbCBzY29wZS5cbi8vIEZvciBub2RlLmpzLCBwYWNrYWdlLmpzb24jZXhwb3J0cyBmaWVsZCBtYXBwaW5nIHJld3JpdGVzIGltcG9ydFxuLy8gZnJvbSBgY3J5cHRvYCB0byBgY3J5cHRvTm9kZWAsIHdoaWNoIGltcG9ydHMgbmF0aXZlIG1vZHVsZS5cbi8vIE1ha2VzIHRoZSB1dGlscyB1bi1pbXBvcnRhYmxlIGluIGJyb3dzZXJzIHdpdGhvdXQgYSBidW5kbGVyLlxuLy8gT25jZSBub2RlLmpzIDE4IGlzIGRlcHJlY2F0ZWQsIHdlIGNhbiBqdXN0IGRyb3AgdGhlIGltcG9ydC5cbmltcG9ydCB7IGNyeXB0byB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvY3J5cHRvJztcbmNvbnN0IHU4YSA9IChhKSA9PiBhIGluc3RhbmNlb2YgVWludDhBcnJheTtcbi8vIENhc3QgYXJyYXkgdG8gZGlmZmVyZW50IHR5cGVcbmV4cG9ydCBjb25zdCB1OCA9IChhcnIpID0+IG5ldyBVaW50OEFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG5leHBvcnQgY29uc3QgdTMyID0gKGFycikgPT4gbmV3IFVpbnQzMkFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBNYXRoLmZsb29yKGFyci5ieXRlTGVuZ3RoIC8gNCkpO1xuLy8gQ2FzdCBhcnJheSB0byB2aWV3XG5leHBvcnQgY29uc3QgY3JlYXRlVmlldyA9IChhcnIpID0+IG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuLy8gVGhlIHJvdGF0ZSByaWdodCAoY2lyY3VsYXIgcmlnaHQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyXG5leHBvcnQgY29uc3Qgcm90ciA9ICh3b3JkLCBzaGlmdCkgPT4gKHdvcmQgPDwgKDMyIC0gc2hpZnQpKSB8ICh3b3JkID4+PiBzaGlmdCk7XG4vLyBiaWctZW5kaWFuIGhhcmR3YXJlIGlzIHJhcmUuIEp1c3QgaW4gY2FzZSBzb21lb25lIHN0aWxsIGRlY2lkZXMgdG8gcnVuIGhhc2hlczpcbi8vIGVhcmx5LXRocm93IGFuIGVycm9yIGJlY2F1c2Ugd2UgZG9uJ3Qgc3VwcG9ydCBCRSB5ZXQuXG5leHBvcnQgY29uc3QgaXNMRSA9IG5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShbMHgxMTIyMzM0NF0pLmJ1ZmZlcilbMF0gPT09IDB4NDQ7XG5pZiAoIWlzTEUpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb24gbGl0dGxlLWVuZGlhbiBoYXJkd2FyZSBpcyBub3Qgc3VwcG9ydGVkJyk7XG5jb25zdCBoZXhlcyA9IC8qIEBfX1BVUkVfXyAqLyBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKF8sIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBAZXhhbXBsZSBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pKSAvLyAnY2FmZTAxMjMnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgaWYgKCF1OGEoYnl0ZXMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuLyoqXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIGNvbnN0IGxlbiA9IGhleC5sZW5ndGg7XG4gICAgaWYgKGxlbiAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGVkIGhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBsZW4pO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkobGVuIC8gMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBqID0gaSAqIDI7XG4gICAgICAgIGNvbnN0IGhleEJ5dGUgPSBoZXguc2xpY2UoaiwgaiArIDIpO1xuICAgICAgICBjb25zdCBieXRlID0gTnVtYmVyLnBhcnNlSW50KGhleEJ5dGUsIDE2KTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihieXRlKSB8fCBieXRlIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBieXRlIHNlcXVlbmNlJyk7XG4gICAgICAgIGFycmF5W2ldID0gYnl0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuLy8gVGhlcmUgaXMgbm8gc2V0SW1tZWRpYXRlIGluIGJyb3dzZXIgYW5kIHNldFRpbWVvdXQgaXMgc2xvdy5cbi8vIGNhbGwgb2YgYXN5bmMgZm4gd2lsbCByZXR1cm4gUHJvbWlzZSwgd2hpY2ggd2lsbCBiZSBmdWxsZmlsZWQgb25seSBvblxuLy8gbmV4dCBzY2hlZHVsZXIgcXVldWUgcHJvY2Vzc2luZyBzdGVwIGFuZCB0aGlzIGlzIGV4YWN0bHkgd2hhdCB3ZSBuZWVkLlxuZXhwb3J0IGNvbnN0IG5leHRUaWNrID0gYXN5bmMgKCkgPT4geyB9O1xuLy8gUmV0dXJucyBjb250cm9sIHRvIHRocmVhZCBlYWNoICd0aWNrJyBtcyB0byBhdm9pZCBibG9ja2luZ1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFzeW5jTG9vcChpdGVycywgdGljaywgY2IpIHtcbiAgICBsZXQgdHMgPSBEYXRlLm5vdygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcnM7IGkrKykge1xuICAgICAgICBjYihpKTtcbiAgICAgICAgLy8gRGF0ZS5ub3coKSBpcyBub3QgbW9ub3RvbmljLCBzbyBpbiBjYXNlIGlmIGNsb2NrIGdvZXMgYmFja3dhcmRzIHdlIHJldHVybiByZXR1cm4gY29udHJvbCB0b29cbiAgICAgICAgY29uc3QgZGlmZiA9IERhdGUubm93KCkgLSB0cztcbiAgICAgICAgaWYgKGRpZmYgPj0gMCAmJiBkaWZmIDwgdGljaylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBhd2FpdCBuZXh0VGljaygpO1xuICAgICAgICB0cyArPSBkaWZmO1xuICAgIH1cbn1cbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuLyoqXG4gKiBOb3JtYWxpemVzIChub24taGV4KSBzdHJpbmcgb3IgVWludDhBcnJheSB0byBVaW50OEFycmF5LlxuICogV2FybmluZzogd2hlbiBVaW50OEFycmF5IGlzIHBhc3NlZCwgaXQgd291bGQgTk9UIGdldCBjb3BpZWQuXG4gKiBLZWVwIGluIG1pbmQgZm9yIGZ1dHVyZSBtdXRhYmxlIG9wZXJhdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gICAgaWYgKCF1OGEoZGF0YSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgVWludDhBcnJheSwgZ290ICR7dHlwZW9mIGRhdGF9YCk7XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgY29uc3QgciA9IG5ldyBVaW50OEFycmF5KGFycmF5cy5yZWR1Y2UoKHN1bSwgYSkgPT4gc3VtICsgYS5sZW5ndGgsIDApKTtcbiAgICBsZXQgcGFkID0gMDsgLy8gd2FsayB0aHJvdWdoIGVhY2ggaXRlbSwgZW5zdXJlIHRoZXkgaGF2ZSBwcm9wZXIgdHlwZVxuICAgIGFycmF5cy5mb3JFYWNoKChhKSA9PiB7XG4gICAgICAgIGlmICghdThhKGEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIHIuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9KTtcbiAgICByZXR1cm4gcjtcbn1cbi8vIEZvciBydW50aW1lIGNoZWNrIGlmIGNsYXNzIGltcGxlbWVudHMgaW50ZXJmYWNlXG5leHBvcnQgY2xhc3MgSGFzaCB7XG4gICAgLy8gU2FmZSB2ZXJzaW9uIHRoYXQgY2xvbmVzIGludGVybmFsIHN0YXRlXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgICB9XG59XG5jb25zdCB0b1N0ciA9IHt9LnRvU3RyaW5nO1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrT3B0cyhkZWZhdWx0cywgb3B0cykge1xuICAgIGlmIChvcHRzICE9PSB1bmRlZmluZWQgJiYgdG9TdHIuY2FsbChvcHRzKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT3B0aW9ucyBzaG91bGQgYmUgb2JqZWN0IG9yIHVuZGVmaW5lZCcpO1xuICAgIGNvbnN0IG1lcmdlZCA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdHMsIG9wdHMpO1xuICAgIHJldHVybiBtZXJnZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnKSA9PiBoYXNoQ29ucygpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKCk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAoKSA9PiBoYXNoQ29ucygpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbi8qKlxuICogU2VjdXJlIFBSTkcuIFVzZXMgYGNyeXB0by5nZXRSYW5kb21WYWx1ZXNgLCB3aGljaCBkZWZlcnMgdG8gT1MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21CeXRlcyhieXRlc0xlbmd0aCA9IDMyKSB7XG4gICAgaWYgKGNyeXB0byAmJiB0eXBlb2YgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShieXRlc0xlbmd0aCkpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMgbXVzdCBiZSBkZWZpbmVkJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOlsiY3J5cHRvIiwidThhIiwiYSIsIlVpbnQ4QXJyYXkiLCJ1OCIsImFyciIsImJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJieXRlTGVuZ3RoIiwidTMyIiwiVWludDMyQXJyYXkiLCJNYXRoIiwiZmxvb3IiLCJjcmVhdGVWaWV3IiwiRGF0YVZpZXciLCJyb3RyIiwid29yZCIsInNoaWZ0IiwiaXNMRSIsIkVycm9yIiwiaGV4ZXMiLCJBcnJheSIsImZyb20iLCJsZW5ndGgiLCJfIiwiaSIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJieXRlc1RvSGV4IiwiYnl0ZXMiLCJoZXgiLCJoZXhUb0J5dGVzIiwibGVuIiwiYXJyYXkiLCJqIiwiaGV4Qnl0ZSIsInNsaWNlIiwiYnl0ZSIsIk51bWJlciIsInBhcnNlSW50IiwiaXNOYU4iLCJuZXh0VGljayIsImFzeW5jTG9vcCIsIml0ZXJzIiwidGljayIsImNiIiwidHMiLCJEYXRlIiwibm93IiwiZGlmZiIsInV0ZjhUb0J5dGVzIiwic3RyIiwiVGV4dEVuY29kZXIiLCJlbmNvZGUiLCJ0b0J5dGVzIiwiZGF0YSIsImNvbmNhdEJ5dGVzIiwiYXJyYXlzIiwiciIsInJlZHVjZSIsInN1bSIsInBhZCIsImZvckVhY2giLCJzZXQiLCJIYXNoIiwiY2xvbmUiLCJfY2xvbmVJbnRvIiwidG9TdHIiLCJjaGVja09wdHMiLCJkZWZhdWx0cyIsIm9wdHMiLCJ1bmRlZmluZWQiLCJjYWxsIiwibWVyZ2VkIiwiT2JqZWN0IiwiYXNzaWduIiwid3JhcENvbnN0cnVjdG9yIiwiaGFzaENvbnMiLCJoYXNoQyIsIm1zZyIsInVwZGF0ZSIsImRpZ2VzdCIsInRtcCIsIm91dHB1dExlbiIsImJsb2NrTGVuIiwiY3JlYXRlIiwid3JhcENvbnN0cnVjdG9yV2l0aE9wdHMiLCJ3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyIsInJhbmRvbUJ5dGVzIiwiYnl0ZXNMZW5ndGgiLCJnZXRSYW5kb21WYWx1ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/hashes/esm/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@swc/helpers/esm/_check_private_redeclaration.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@swc/helpers/esm/_check_private_redeclaration.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: function() { return /* binding */ _check_private_redeclaration; },\n/* harmony export */   _check_private_redeclaration: function() { return /* binding */ _check_private_redeclaration; }\n/* harmony export */ });\nfunction _check_private_redeclaration(obj, privateCollection) {\n    if (privateCollection.has(obj)) {\n        throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3djL2hlbHBlcnMvZXNtL19jaGVja19wcml2YXRlX3JlZGVjbGFyYXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTyxTQUFTQSw2QkFBNkJDLEdBQUcsRUFBRUMsaUJBQWlCO0lBQy9ELElBQUlBLGtCQUFrQkMsR0FBRyxDQUFDRixNQUFNO1FBQzVCLE1BQU0sSUFBSUcsVUFBVTtJQUN4QjtBQUNKO0FBQzZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac3djL2hlbHBlcnMvZXNtL19jaGVja19wcml2YXRlX3JlZGVjbGFyYXRpb24uanM/YzMyMSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gX2NoZWNrX3ByaXZhdGVfcmVkZWNsYXJhdGlvbihvYmosIHByaXZhdGVDb2xsZWN0aW9uKSB7XG4gICAgaWYgKHByaXZhdGVDb2xsZWN0aW9uLmhhcyhvYmopKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgaW5pdGlhbGl6ZSB0aGUgc2FtZSBwcml2YXRlIGVsZW1lbnRzIHR3aWNlIG9uIGFuIG9iamVjdFwiKTtcbiAgICB9XG59XG5leHBvcnQgeyBfY2hlY2tfcHJpdmF0ZV9yZWRlY2xhcmF0aW9uIGFzIF8gfTtcbiJdLCJuYW1lcyI6WyJfY2hlY2tfcHJpdmF0ZV9yZWRlY2xhcmF0aW9uIiwib2JqIiwicHJpdmF0ZUNvbGxlY3Rpb24iLCJoYXMiLCJUeXBlRXJyb3IiLCJfIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@swc/helpers/esm/_check_private_redeclaration.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_apply_descriptor_get.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@swc/helpers/esm/_class_apply_descriptor_get.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: function() { return /* binding */ _class_apply_descriptor_get; },\n/* harmony export */   _class_apply_descriptor_get: function() { return /* binding */ _class_apply_descriptor_get; }\n/* harmony export */ });\nfunction _class_apply_descriptor_get(receiver, descriptor) {\n    if (descriptor.get) return descriptor.get.call(receiver);\n    return descriptor.value;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3djL2hlbHBlcnMvZXNtL19jbGFzc19hcHBseV9kZXNjcmlwdG9yX2dldC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFPLFNBQVNBLDRCQUE0QkMsUUFBUSxFQUFFQyxVQUFVO0lBQzVELElBQUlBLFdBQVdDLEdBQUcsRUFBRSxPQUFPRCxXQUFXQyxHQUFHLENBQUNDLElBQUksQ0FBQ0g7SUFFL0MsT0FBT0MsV0FBV0csS0FBSztBQUMzQjtBQUM0QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL2VzbS9fY2xhc3NfYXBwbHlfZGVzY3JpcHRvcl9nZXQuanM/NTFlNiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gX2NsYXNzX2FwcGx5X2Rlc2NyaXB0b3JfZ2V0KHJlY2VpdmVyLCBkZXNjcmlwdG9yKSB7XG4gICAgaWYgKGRlc2NyaXB0b3IuZ2V0KSByZXR1cm4gZGVzY3JpcHRvci5nZXQuY2FsbChyZWNlaXZlcik7XG5cbiAgICByZXR1cm4gZGVzY3JpcHRvci52YWx1ZTtcbn1cbmV4cG9ydCB7IF9jbGFzc19hcHBseV9kZXNjcmlwdG9yX2dldCBhcyBfIH07XG4iXSwibmFtZXMiOlsiX2NsYXNzX2FwcGx5X2Rlc2NyaXB0b3JfZ2V0IiwicmVjZWl2ZXIiLCJkZXNjcmlwdG9yIiwiZ2V0IiwiY2FsbCIsInZhbHVlIiwiXyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_apply_descriptor_get.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_apply_descriptor_set.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@swc/helpers/esm/_class_apply_descriptor_set.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: function() { return /* binding */ _class_apply_descriptor_set; },\n/* harmony export */   _class_apply_descriptor_set: function() { return /* binding */ _class_apply_descriptor_set; }\n/* harmony export */ });\nfunction _class_apply_descriptor_set(receiver, descriptor, value) {\n    if (descriptor.set) descriptor.set.call(receiver, value);\n    else {\n        if (!descriptor.writable) {\n            // This should only throw in strict mode, but class bodies are\n            // always strict and private fields can only be used inside\n            // class bodies.\n            throw new TypeError(\"attempted to set read only private field\");\n        }\n        descriptor.value = value;\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3djL2hlbHBlcnMvZXNtL19jbGFzc19hcHBseV9kZXNjcmlwdG9yX3NldC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFPLFNBQVNBLDRCQUE0QkMsUUFBUSxFQUFFQyxVQUFVLEVBQUVDLEtBQUs7SUFDbkUsSUFBSUQsV0FBV0UsR0FBRyxFQUFFRixXQUFXRSxHQUFHLENBQUNDLElBQUksQ0FBQ0osVUFBVUU7U0FDN0M7UUFDRCxJQUFJLENBQUNELFdBQVdJLFFBQVEsRUFBRTtZQUN0Qiw4REFBOEQ7WUFDOUQsMkRBQTJEO1lBQzNELGdCQUFnQjtZQUNoQixNQUFNLElBQUlDLFVBQVU7UUFDeEI7UUFDQUwsV0FBV0MsS0FBSyxHQUFHQTtJQUN2QjtBQUNKO0FBQzRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac3djL2hlbHBlcnMvZXNtL19jbGFzc19hcHBseV9kZXNjcmlwdG9yX3NldC5qcz84MmQ0Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBfY2xhc3NfYXBwbHlfZGVzY3JpcHRvcl9zZXQocmVjZWl2ZXIsIGRlc2NyaXB0b3IsIHZhbHVlKSB7XG4gICAgaWYgKGRlc2NyaXB0b3Iuc2V0KSBkZXNjcmlwdG9yLnNldC5jYWxsKHJlY2VpdmVyLCB2YWx1ZSk7XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICghZGVzY3JpcHRvci53cml0YWJsZSkge1xuICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgb25seSB0aHJvdyBpbiBzdHJpY3QgbW9kZSwgYnV0IGNsYXNzIGJvZGllcyBhcmVcbiAgICAgICAgICAgIC8vIGFsd2F5cyBzdHJpY3QgYW5kIHByaXZhdGUgZmllbGRzIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlXG4gICAgICAgICAgICAvLyBjbGFzcyBib2RpZXMuXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIHNldCByZWFkIG9ubHkgcHJpdmF0ZSBmaWVsZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBkZXNjcmlwdG9yLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufVxuZXhwb3J0IHsgX2NsYXNzX2FwcGx5X2Rlc2NyaXB0b3Jfc2V0IGFzIF8gfTtcbiJdLCJuYW1lcyI6WyJfY2xhc3NfYXBwbHlfZGVzY3JpcHRvcl9zZXQiLCJyZWNlaXZlciIsImRlc2NyaXB0b3IiLCJ2YWx1ZSIsInNldCIsImNhbGwiLCJ3cml0YWJsZSIsIlR5cGVFcnJvciIsIl8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_apply_descriptor_set.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_apply_descriptor_update.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@swc/helpers/esm/_class_apply_descriptor_update.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: function() { return /* binding */ _class_apply_descriptor_update; },\n/* harmony export */   _class_apply_descriptor_update: function() { return /* binding */ _class_apply_descriptor_update; }\n/* harmony export */ });\nfunction _class_apply_descriptor_update(receiver, descriptor) {\n    if (descriptor.set) {\n        if (!descriptor.get) throw new TypeError(\"attempted to read set only private field\");\n        if (!(\"__destrWrapper\" in descriptor)) {\n            descriptor.__destrWrapper = {\n                set value (v){\n                    descriptor.set.call(receiver, v);\n                },\n                get value () {\n                    return descriptor.get.call(receiver);\n                }\n            };\n        }\n        return descriptor.__destrWrapper;\n    } else {\n        if (!descriptor.writable) {\n            // This should only throw in strict mode, but class bodies are\n            // always strict and private fields can only be used inside\n            // class bodies.\n            throw new TypeError(\"attempted to set read only private field\");\n        }\n        return descriptor;\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3djL2hlbHBlcnMvZXNtL19jbGFzc19hcHBseV9kZXNjcmlwdG9yX3VwZGF0ZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFPLFNBQVNBLCtCQUErQkMsUUFBUSxFQUFFQyxVQUFVO0lBQy9ELElBQUlBLFdBQVdDLEdBQUcsRUFBRTtRQUNoQixJQUFJLENBQUNELFdBQVdFLEdBQUcsRUFBRSxNQUFNLElBQUlDLFVBQVU7UUFFekMsSUFBSSxDQUFFLHFCQUFvQkgsVUFBUyxHQUFJO1lBQ25DQSxXQUFXSSxjQUFjLEdBQUc7Z0JBQ3hCLElBQUlDLE9BQU1DLEVBQUc7b0JBQ1ROLFdBQVdDLEdBQUcsQ0FBQ00sSUFBSSxDQUFDUixVQUFVTztnQkFDbEM7Z0JBQ0EsSUFBSUQsU0FBUTtvQkFDUixPQUFPTCxXQUFXRSxHQUFHLENBQUNLLElBQUksQ0FBQ1I7Z0JBQy9CO1lBQ0o7UUFDSjtRQUVBLE9BQU9DLFdBQVdJLGNBQWM7SUFDcEMsT0FBTztRQUNILElBQUksQ0FBQ0osV0FBV1EsUUFBUSxFQUFFO1lBQ3RCLDhEQUE4RDtZQUM5RCwyREFBMkQ7WUFDM0QsZ0JBQWdCO1lBQ2hCLE1BQU0sSUFBSUwsVUFBVTtRQUN4QjtRQUVBLE9BQU9IO0lBQ1g7QUFDSjtBQUMrQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL2VzbS9fY2xhc3NfYXBwbHlfZGVzY3JpcHRvcl91cGRhdGUuanM/ODZjYSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gX2NsYXNzX2FwcGx5X2Rlc2NyaXB0b3JfdXBkYXRlKHJlY2VpdmVyLCBkZXNjcmlwdG9yKSB7XG4gICAgaWYgKGRlc2NyaXB0b3Iuc2V0KSB7XG4gICAgICAgIGlmICghZGVzY3JpcHRvci5nZXQpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gcmVhZCBzZXQgb25seSBwcml2YXRlIGZpZWxkXCIpO1xuXG4gICAgICAgIGlmICghKFwiX19kZXN0cldyYXBwZXJcIiBpbiBkZXNjcmlwdG9yKSkge1xuICAgICAgICAgICAgZGVzY3JpcHRvci5fX2Rlc3RyV3JhcHBlciA9IHtcbiAgICAgICAgICAgICAgICBzZXQgdmFsdWUodikge1xuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLnNldC5jYWxsKHJlY2VpdmVyLCB2KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3IuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVzY3JpcHRvci5fX2Rlc3RyV3JhcHBlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWRlc2NyaXB0b3Iud3JpdGFibGUpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG9ubHkgdGhyb3cgaW4gc3RyaWN0IG1vZGUsIGJ1dCBjbGFzcyBib2RpZXMgYXJlXG4gICAgICAgICAgICAvLyBhbHdheXMgc3RyaWN0IGFuZCBwcml2YXRlIGZpZWxkcyBjYW4gb25seSBiZSB1c2VkIGluc2lkZVxuICAgICAgICAgICAgLy8gY2xhc3MgYm9kaWVzLlxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBzZXQgcmVhZCBvbmx5IHByaXZhdGUgZmllbGRcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgICB9XG59XG5leHBvcnQgeyBfY2xhc3NfYXBwbHlfZGVzY3JpcHRvcl91cGRhdGUgYXMgXyB9O1xuIl0sIm5hbWVzIjpbIl9jbGFzc19hcHBseV9kZXNjcmlwdG9yX3VwZGF0ZSIsInJlY2VpdmVyIiwiZGVzY3JpcHRvciIsInNldCIsImdldCIsIlR5cGVFcnJvciIsIl9fZGVzdHJXcmFwcGVyIiwidmFsdWUiLCJ2IiwiY2FsbCIsIndyaXRhYmxlIiwiXyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_apply_descriptor_update.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_check_private_static_access.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@swc/helpers/esm/_class_check_private_static_access.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: function() { return /* binding */ _class_check_private_static_access; },\n/* harmony export */   _class_check_private_static_access: function() { return /* binding */ _class_check_private_static_access; }\n/* harmony export */ });\nfunction _class_check_private_static_access(receiver, classConstructor) {\n    if (receiver !== classConstructor) throw new TypeError(\"Private static access of wrong provenance\");\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3djL2hlbHBlcnMvZXNtL19jbGFzc19jaGVja19wcml2YXRlX3N0YXRpY19hY2Nlc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTyxTQUFTQSxtQ0FBbUNDLFFBQVEsRUFBRUMsZ0JBQWdCO0lBQ3pFLElBQUlELGFBQWFDLGtCQUFrQixNQUFNLElBQUlDLFVBQVU7QUFDM0Q7QUFDbUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzd2MvaGVscGVycy9lc20vX2NsYXNzX2NoZWNrX3ByaXZhdGVfc3RhdGljX2FjY2Vzcy5qcz8wNTMzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBfY2xhc3NfY2hlY2tfcHJpdmF0ZV9zdGF0aWNfYWNjZXNzKHJlY2VpdmVyLCBjbGFzc0NvbnN0cnVjdG9yKSB7XG4gICAgaWYgKHJlY2VpdmVyICE9PSBjbGFzc0NvbnN0cnVjdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBzdGF0aWMgYWNjZXNzIG9mIHdyb25nIHByb3ZlbmFuY2VcIik7XG59XG5leHBvcnQgeyBfY2xhc3NfY2hlY2tfcHJpdmF0ZV9zdGF0aWNfYWNjZXNzIGFzIF8gfTtcbiJdLCJuYW1lcyI6WyJfY2xhc3NfY2hlY2tfcHJpdmF0ZV9zdGF0aWNfYWNjZXNzIiwicmVjZWl2ZXIiLCJjbGFzc0NvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiXyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_check_private_static_access.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_extract_field_descriptor.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@swc/helpers/esm/_class_extract_field_descriptor.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: function() { return /* binding */ _class_extract_field_descriptor; },\n/* harmony export */   _class_extract_field_descriptor: function() { return /* binding */ _class_extract_field_descriptor; }\n/* harmony export */ });\nfunction _class_extract_field_descriptor(receiver, privateMap, action) {\n    if (!privateMap.has(receiver)) throw new TypeError(\"attempted to \" + action + \" private field on non-instance\");\n    return privateMap.get(receiver);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3djL2hlbHBlcnMvZXNtL19jbGFzc19leHRyYWN0X2ZpZWxkX2Rlc2NyaXB0b3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTyxTQUFTQSxnQ0FBZ0NDLFFBQVEsRUFBRUMsVUFBVSxFQUFFQyxNQUFNO0lBQ3hFLElBQUksQ0FBQ0QsV0FBV0UsR0FBRyxDQUFDSCxXQUFXLE1BQU0sSUFBSUksVUFBVSxrQkFBa0JGLFNBQVM7SUFFOUUsT0FBT0QsV0FBV0ksR0FBRyxDQUFDTDtBQUMxQjtBQUNnRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL2VzbS9fY2xhc3NfZXh0cmFjdF9maWVsZF9kZXNjcmlwdG9yLmpzP2QyNTciXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIF9jbGFzc19leHRyYWN0X2ZpZWxkX2Rlc2NyaXB0b3IocmVjZWl2ZXIsIHByaXZhdGVNYXAsIGFjdGlvbikge1xuICAgIGlmICghcHJpdmF0ZU1hcC5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIFwiICsgYWN0aW9uICsgXCIgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7XG5cbiAgICByZXR1cm4gcHJpdmF0ZU1hcC5nZXQocmVjZWl2ZXIpO1xufVxuZXhwb3J0IHsgX2NsYXNzX2V4dHJhY3RfZmllbGRfZGVzY3JpcHRvciBhcyBfIH07XG4iXSwibmFtZXMiOlsiX2NsYXNzX2V4dHJhY3RfZmllbGRfZGVzY3JpcHRvciIsInJlY2VpdmVyIiwicHJpdmF0ZU1hcCIsImFjdGlvbiIsImhhcyIsIlR5cGVFcnJvciIsImdldCIsIl8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_extract_field_descriptor.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_get.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@swc/helpers/esm/_class_private_field_get.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: function() { return /* binding */ _class_private_field_get; },\n/* harmony export */   _class_private_field_get: function() { return /* binding */ _class_private_field_get; }\n/* harmony export */ });\n/* harmony import */ var _class_apply_descriptor_get_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_class_apply_descriptor_get.js */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_apply_descriptor_get.js\");\n/* harmony import */ var _class_extract_field_descriptor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_class_extract_field_descriptor.js */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_extract_field_descriptor.js\");\n\n\nfunction _class_private_field_get(receiver, privateMap) {\n    var descriptor = (0,_class_extract_field_descriptor_js__WEBPACK_IMPORTED_MODULE_0__._class_extract_field_descriptor)(receiver, privateMap, \"get\");\n    return (0,_class_apply_descriptor_get_js__WEBPACK_IMPORTED_MODULE_1__._class_apply_descriptor_get)(receiver, descriptor);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3djL2hlbHBlcnMvZXNtL19jbGFzc19wcml2YXRlX2ZpZWxkX2dldC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQStFO0FBQ1E7QUFFaEYsU0FBU0UseUJBQXlCQyxRQUFRLEVBQUVDLFVBQVU7SUFDekQsSUFBSUMsYUFBYUosbUdBQStCQSxDQUFDRSxVQUFVQyxZQUFZO0lBQ3ZFLE9BQU9KLDJGQUEyQkEsQ0FBQ0csVUFBVUU7QUFDakQ7QUFDeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzd2MvaGVscGVycy9lc20vX2NsYXNzX3ByaXZhdGVfZmllbGRfZ2V0LmpzP2Y2MzUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX2NsYXNzX2FwcGx5X2Rlc2NyaXB0b3JfZ2V0IH0gZnJvbSBcIi4vX2NsYXNzX2FwcGx5X2Rlc2NyaXB0b3JfZ2V0LmpzXCI7XG5pbXBvcnQgeyBfY2xhc3NfZXh0cmFjdF9maWVsZF9kZXNjcmlwdG9yIH0gZnJvbSBcIi4vX2NsYXNzX2V4dHJhY3RfZmllbGRfZGVzY3JpcHRvci5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gX2NsYXNzX3ByaXZhdGVfZmllbGRfZ2V0KHJlY2VpdmVyLCBwcml2YXRlTWFwKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBfY2xhc3NfZXh0cmFjdF9maWVsZF9kZXNjcmlwdG9yKHJlY2VpdmVyLCBwcml2YXRlTWFwLCBcImdldFwiKTtcbiAgICByZXR1cm4gX2NsYXNzX2FwcGx5X2Rlc2NyaXB0b3JfZ2V0KHJlY2VpdmVyLCBkZXNjcmlwdG9yKTtcbn1cbmV4cG9ydCB7IF9jbGFzc19wcml2YXRlX2ZpZWxkX2dldCBhcyBfIH07XG4iXSwibmFtZXMiOlsiX2NsYXNzX2FwcGx5X2Rlc2NyaXB0b3JfZ2V0IiwiX2NsYXNzX2V4dHJhY3RfZmllbGRfZGVzY3JpcHRvciIsIl9jbGFzc19wcml2YXRlX2ZpZWxkX2dldCIsInJlY2VpdmVyIiwicHJpdmF0ZU1hcCIsImRlc2NyaXB0b3IiLCJfIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_get.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_init.js":
/*!********************************************************************!*\
  !*** ./node_modules/@swc/helpers/esm/_class_private_field_init.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: function() { return /* binding */ _class_private_field_init; },\n/* harmony export */   _class_private_field_init: function() { return /* binding */ _class_private_field_init; }\n/* harmony export */ });\n/* harmony import */ var _check_private_redeclaration_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_check_private_redeclaration.js */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_check_private_redeclaration.js\");\n\nfunction _class_private_field_init(obj, privateMap, value) {\n    (0,_check_private_redeclaration_js__WEBPACK_IMPORTED_MODULE_0__._check_private_redeclaration)(obj, privateMap);\n    privateMap.set(obj, value);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3djL2hlbHBlcnMvZXNtL19jbGFzc19wcml2YXRlX2ZpZWxkX2luaXQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWlGO0FBRTFFLFNBQVNDLDBCQUEwQkMsR0FBRyxFQUFFQyxVQUFVLEVBQUVDLEtBQUs7SUFDNURKLDZGQUE0QkEsQ0FBQ0UsS0FBS0M7SUFDbENBLFdBQVdFLEdBQUcsQ0FBQ0gsS0FBS0U7QUFDeEI7QUFDMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzd2MvaGVscGVycy9lc20vX2NsYXNzX3ByaXZhdGVfZmllbGRfaW5pdC5qcz8zNTI3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9jaGVja19wcml2YXRlX3JlZGVjbGFyYXRpb24gfSBmcm9tIFwiLi9fY2hlY2tfcHJpdmF0ZV9yZWRlY2xhcmF0aW9uLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBfY2xhc3NfcHJpdmF0ZV9maWVsZF9pbml0KG9iaiwgcHJpdmF0ZU1hcCwgdmFsdWUpIHtcbiAgICBfY2hlY2tfcHJpdmF0ZV9yZWRlY2xhcmF0aW9uKG9iaiwgcHJpdmF0ZU1hcCk7XG4gICAgcHJpdmF0ZU1hcC5zZXQob2JqLCB2YWx1ZSk7XG59XG5leHBvcnQgeyBfY2xhc3NfcHJpdmF0ZV9maWVsZF9pbml0IGFzIF8gfTtcbiJdLCJuYW1lcyI6WyJfY2hlY2tfcHJpdmF0ZV9yZWRlY2xhcmF0aW9uIiwiX2NsYXNzX3ByaXZhdGVfZmllbGRfaW5pdCIsIm9iaiIsInByaXZhdGVNYXAiLCJ2YWx1ZSIsInNldCIsIl8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_init.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_set.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@swc/helpers/esm/_class_private_field_set.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: function() { return /* binding */ _class_private_field_set; },\n/* harmony export */   _class_private_field_set: function() { return /* binding */ _class_private_field_set; }\n/* harmony export */ });\n/* harmony import */ var _class_apply_descriptor_set_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_class_apply_descriptor_set.js */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_apply_descriptor_set.js\");\n/* harmony import */ var _class_extract_field_descriptor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_class_extract_field_descriptor.js */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_extract_field_descriptor.js\");\n\n\nfunction _class_private_field_set(receiver, privateMap, value) {\n    var descriptor = (0,_class_extract_field_descriptor_js__WEBPACK_IMPORTED_MODULE_0__._class_extract_field_descriptor)(receiver, privateMap, \"set\");\n    (0,_class_apply_descriptor_set_js__WEBPACK_IMPORTED_MODULE_1__._class_apply_descriptor_set)(receiver, descriptor, value);\n    return value;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3djL2hlbHBlcnMvZXNtL19jbGFzc19wcml2YXRlX2ZpZWxkX3NldC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQStFO0FBQ1E7QUFFaEYsU0FBU0UseUJBQXlCQyxRQUFRLEVBQUVDLFVBQVUsRUFBRUMsS0FBSztJQUNoRSxJQUFJQyxhQUFhTCxtR0FBK0JBLENBQUNFLFVBQVVDLFlBQVk7SUFDdkVKLDJGQUEyQkEsQ0FBQ0csVUFBVUcsWUFBWUQ7SUFDbEQsT0FBT0E7QUFDWDtBQUN5QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL2VzbS9fY2xhc3NfcHJpdmF0ZV9maWVsZF9zZXQuanM/ODE1NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfY2xhc3NfYXBwbHlfZGVzY3JpcHRvcl9zZXQgfSBmcm9tIFwiLi9fY2xhc3NfYXBwbHlfZGVzY3JpcHRvcl9zZXQuanNcIjtcbmltcG9ydCB7IF9jbGFzc19leHRyYWN0X2ZpZWxkX2Rlc2NyaXB0b3IgfSBmcm9tIFwiLi9fY2xhc3NfZXh0cmFjdF9maWVsZF9kZXNjcmlwdG9yLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBfY2xhc3NfcHJpdmF0ZV9maWVsZF9zZXQocmVjZWl2ZXIsIHByaXZhdGVNYXAsIHZhbHVlKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBfY2xhc3NfZXh0cmFjdF9maWVsZF9kZXNjcmlwdG9yKHJlY2VpdmVyLCBwcml2YXRlTWFwLCBcInNldFwiKTtcbiAgICBfY2xhc3NfYXBwbHlfZGVzY3JpcHRvcl9zZXQocmVjZWl2ZXIsIGRlc2NyaXB0b3IsIHZhbHVlKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnQgeyBfY2xhc3NfcHJpdmF0ZV9maWVsZF9zZXQgYXMgXyB9O1xuIl0sIm5hbWVzIjpbIl9jbGFzc19hcHBseV9kZXNjcmlwdG9yX3NldCIsIl9jbGFzc19leHRyYWN0X2ZpZWxkX2Rlc2NyaXB0b3IiLCJfY2xhc3NfcHJpdmF0ZV9maWVsZF9zZXQiLCJyZWNlaXZlciIsInByaXZhdGVNYXAiLCJ2YWx1ZSIsImRlc2NyaXB0b3IiLCJfIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_set.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_update.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@swc/helpers/esm/_class_private_field_update.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: function() { return /* binding */ _class_private_field_update; },\n/* harmony export */   _class_private_field_update: function() { return /* binding */ _class_private_field_update; }\n/* harmony export */ });\n/* harmony import */ var _class_apply_descriptor_update_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_class_apply_descriptor_update.js */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_apply_descriptor_update.js\");\n/* harmony import */ var _class_extract_field_descriptor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_class_extract_field_descriptor.js */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_extract_field_descriptor.js\");\n\n\nfunction _class_private_field_update(receiver, privateMap) {\n    var descriptor = (0,_class_extract_field_descriptor_js__WEBPACK_IMPORTED_MODULE_0__._class_extract_field_descriptor)(receiver, privateMap, \"update\");\n    return (0,_class_apply_descriptor_update_js__WEBPACK_IMPORTED_MODULE_1__._class_apply_descriptor_update)(receiver, descriptor);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3djL2hlbHBlcnMvZXNtL19jbGFzc19wcml2YXRlX2ZpZWxkX3VwZGF0ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXFGO0FBQ0U7QUFFaEYsU0FBU0UsNEJBQTRCQyxRQUFRLEVBQUVDLFVBQVU7SUFDNUQsSUFBSUMsYUFBYUosbUdBQStCQSxDQUFDRSxVQUFVQyxZQUFZO0lBQ3ZFLE9BQU9KLGlHQUE4QkEsQ0FBQ0csVUFBVUU7QUFDcEQ7QUFDNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzd2MvaGVscGVycy9lc20vX2NsYXNzX3ByaXZhdGVfZmllbGRfdXBkYXRlLmpzP2M5M2UiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX2NsYXNzX2FwcGx5X2Rlc2NyaXB0b3JfdXBkYXRlIH0gZnJvbSBcIi4vX2NsYXNzX2FwcGx5X2Rlc2NyaXB0b3JfdXBkYXRlLmpzXCI7XG5pbXBvcnQgeyBfY2xhc3NfZXh0cmFjdF9maWVsZF9kZXNjcmlwdG9yIH0gZnJvbSBcIi4vX2NsYXNzX2V4dHJhY3RfZmllbGRfZGVzY3JpcHRvci5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gX2NsYXNzX3ByaXZhdGVfZmllbGRfdXBkYXRlKHJlY2VpdmVyLCBwcml2YXRlTWFwKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBfY2xhc3NfZXh0cmFjdF9maWVsZF9kZXNjcmlwdG9yKHJlY2VpdmVyLCBwcml2YXRlTWFwLCBcInVwZGF0ZVwiKTtcbiAgICByZXR1cm4gX2NsYXNzX2FwcGx5X2Rlc2NyaXB0b3JfdXBkYXRlKHJlY2VpdmVyLCBkZXNjcmlwdG9yKTtcbn1cbmV4cG9ydCB7IF9jbGFzc19wcml2YXRlX2ZpZWxkX3VwZGF0ZSBhcyBfIH07XG4iXSwibmFtZXMiOlsiX2NsYXNzX2FwcGx5X2Rlc2NyaXB0b3JfdXBkYXRlIiwiX2NsYXNzX2V4dHJhY3RfZmllbGRfZGVzY3JpcHRvciIsIl9jbGFzc19wcml2YXRlX2ZpZWxkX3VwZGF0ZSIsInJlY2VpdmVyIiwicHJpdmF0ZU1hcCIsImRlc2NyaXB0b3IiLCJfIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_update.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_method_get.js":
/*!********************************************************************!*\
  !*** ./node_modules/@swc/helpers/esm/_class_private_method_get.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: function() { return /* binding */ _class_private_method_get; },\n/* harmony export */   _class_private_method_get: function() { return /* binding */ _class_private_method_get; }\n/* harmony export */ });\nfunction _class_private_method_get(receiver, privateSet, fn) {\n    if (!privateSet.has(receiver)) throw new TypeError(\"attempted to get private field on non-instance\");\n    return fn;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3djL2hlbHBlcnMvZXNtL19jbGFzc19wcml2YXRlX21ldGhvZF9nZXQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTyxTQUFTQSwwQkFBMEJDLFFBQVEsRUFBRUMsVUFBVSxFQUFFQyxFQUFFO0lBQzlELElBQUksQ0FBQ0QsV0FBV0UsR0FBRyxDQUFDSCxXQUFXLE1BQU0sSUFBSUksVUFBVTtJQUVuRCxPQUFPRjtBQUNYO0FBQzBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac3djL2hlbHBlcnMvZXNtL19jbGFzc19wcml2YXRlX21ldGhvZF9nZXQuanM/OWRhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gX2NsYXNzX3ByaXZhdGVfbWV0aG9kX2dldChyZWNlaXZlciwgcHJpdmF0ZVNldCwgZm4pIHtcbiAgICBpZiAoIXByaXZhdGVTZXQuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBnZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7XG5cbiAgICByZXR1cm4gZm47XG59XG5leHBvcnQgeyBfY2xhc3NfcHJpdmF0ZV9tZXRob2RfZ2V0IGFzIF8gfTtcbiJdLCJuYW1lcyI6WyJfY2xhc3NfcHJpdmF0ZV9tZXRob2RfZ2V0IiwicmVjZWl2ZXIiLCJwcml2YXRlU2V0IiwiZm4iLCJoYXMiLCJUeXBlRXJyb3IiLCJfIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_method_get.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_method_init.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@swc/helpers/esm/_class_private_method_init.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: function() { return /* binding */ _class_private_method_init; },\n/* harmony export */   _class_private_method_init: function() { return /* binding */ _class_private_method_init; }\n/* harmony export */ });\n/* harmony import */ var _check_private_redeclaration_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_check_private_redeclaration.js */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_check_private_redeclaration.js\");\n\nfunction _class_private_method_init(obj, privateSet) {\n    (0,_check_private_redeclaration_js__WEBPACK_IMPORTED_MODULE_0__._check_private_redeclaration)(obj, privateSet);\n    privateSet.add(obj);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3djL2hlbHBlcnMvZXNtL19jbGFzc19wcml2YXRlX21ldGhvZF9pbml0LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpRjtBQUUxRSxTQUFTQywyQkFBMkJDLEdBQUcsRUFBRUMsVUFBVTtJQUN0REgsNkZBQTRCQSxDQUFDRSxLQUFLQztJQUNsQ0EsV0FBV0MsR0FBRyxDQUFDRjtBQUNuQjtBQUMyQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL2VzbS9fY2xhc3NfcHJpdmF0ZV9tZXRob2RfaW5pdC5qcz80NTA5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9jaGVja19wcml2YXRlX3JlZGVjbGFyYXRpb24gfSBmcm9tIFwiLi9fY2hlY2tfcHJpdmF0ZV9yZWRlY2xhcmF0aW9uLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBfY2xhc3NfcHJpdmF0ZV9tZXRob2RfaW5pdChvYmosIHByaXZhdGVTZXQpIHtcbiAgICBfY2hlY2tfcHJpdmF0ZV9yZWRlY2xhcmF0aW9uKG9iaiwgcHJpdmF0ZVNldCk7XG4gICAgcHJpdmF0ZVNldC5hZGQob2JqKTtcbn1cbmV4cG9ydCB7IF9jbGFzc19wcml2YXRlX21ldGhvZF9pbml0IGFzIF8gfTtcbiJdLCJuYW1lcyI6WyJfY2hlY2tfcHJpdmF0ZV9yZWRlY2xhcmF0aW9uIiwiX2NsYXNzX3ByaXZhdGVfbWV0aG9kX2luaXQiLCJvYmoiLCJwcml2YXRlU2V0IiwiYWRkIiwiXyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_method_init.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_static_private_method_get.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@swc/helpers/esm/_class_static_private_method_get.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: function() { return /* binding */ _class_static_private_method_get; },\n/* harmony export */   _class_static_private_method_get: function() { return /* binding */ _class_static_private_method_get; }\n/* harmony export */ });\n/* harmony import */ var _class_check_private_static_access_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_class_check_private_static_access.js */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_check_private_static_access.js\");\n\nfunction _class_static_private_method_get(receiver, classConstructor, method) {\n    (0,_class_check_private_static_access_js__WEBPACK_IMPORTED_MODULE_0__._class_check_private_static_access)(receiver, classConstructor);\n    return method;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3djL2hlbHBlcnMvZXNtL19jbGFzc19zdGF0aWNfcHJpdmF0ZV9tZXRob2RfZ2V0LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE2RjtBQUV0RixTQUFTQyxpQ0FBaUNDLFFBQVEsRUFBRUMsZ0JBQWdCLEVBQUVDLE1BQU07SUFDL0VKLHlHQUFrQ0EsQ0FBQ0UsVUFBVUM7SUFFN0MsT0FBT0M7QUFDWDtBQUNpRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL2VzbS9fY2xhc3Nfc3RhdGljX3ByaXZhdGVfbWV0aG9kX2dldC5qcz9jNzFlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9jbGFzc19jaGVja19wcml2YXRlX3N0YXRpY19hY2Nlc3MgfSBmcm9tIFwiLi9fY2xhc3NfY2hlY2tfcHJpdmF0ZV9zdGF0aWNfYWNjZXNzLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBfY2xhc3Nfc3RhdGljX3ByaXZhdGVfbWV0aG9kX2dldChyZWNlaXZlciwgY2xhc3NDb25zdHJ1Y3RvciwgbWV0aG9kKSB7XG4gICAgX2NsYXNzX2NoZWNrX3ByaXZhdGVfc3RhdGljX2FjY2VzcyhyZWNlaXZlciwgY2xhc3NDb25zdHJ1Y3Rvcik7XG5cbiAgICByZXR1cm4gbWV0aG9kO1xufVxuZXhwb3J0IHsgX2NsYXNzX3N0YXRpY19wcml2YXRlX21ldGhvZF9nZXQgYXMgXyB9O1xuIl0sIm5hbWVzIjpbIl9jbGFzc19jaGVja19wcml2YXRlX3N0YXRpY19hY2Nlc3MiLCJfY2xhc3Nfc3RhdGljX3ByaXZhdGVfbWV0aG9kX2dldCIsInJlY2VpdmVyIiwiY2xhc3NDb25zdHJ1Y3RvciIsIm1ldGhvZCIsIl8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_static_private_method_get.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/_version.js":
/*!*************************************************!*\
  !*** ./node_modules/ethers/lib.esm/_version.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: function() { return /* binding */ version; }\n/* harmony export */ });\n/* Do NOT modify this file; see /src.ts/_admin/update-version.ts */ /**\n *  The current version of Ethers.\n */ const version = \"6.16.0\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9fdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWlFLEdBQ2pFOztDQUVDLEdBQ00sTUFBTUEsVUFBVSxTQUFTLENBQ2hDLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vX3ZlcnNpb24uanM/NmUxOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBEbyBOT1QgbW9kaWZ5IHRoaXMgZmlsZTsgc2VlIC9zcmMudHMvX2FkbWluL3VwZGF0ZS12ZXJzaW9uLnRzICovXG4vKipcbiAqICBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIEV0aGVycy5cbiAqL1xuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcIjYuMTYuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/_version.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/abi/abi-coder.js":
/*!******************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/abi-coder.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbiCoder: function() { return /* binding */ AbiCoder; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @swc/helpers/_/_class_private_method_get */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_method_get.js\");\n/* harmony import */ var _swc_helpers_class_private_method_init__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @swc/helpers/_/_class_private_method_init */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_method_init.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./coders/abstract-coder.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n/* harmony import */ var _coders_address_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./coders/address.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/address.js\");\n/* harmony import */ var _coders_array_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./coders/array.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/array.js\");\n/* harmony import */ var _coders_boolean_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./coders/boolean.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/boolean.js\");\n/* harmony import */ var _coders_bytes_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./coders/bytes.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/bytes.js\");\n/* harmony import */ var _coders_fixed_bytes_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./coders/fixed-bytes.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js\");\n/* harmony import */ var _coders_null_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./coders/null.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/null.js\");\n/* harmony import */ var _coders_number_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./coders/number.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/number.js\");\n/* harmony import */ var _coders_string_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./coders/string.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/string.js\");\n/* harmony import */ var _coders_tuple_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./coders/tuple.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/tuple.js\");\n/* harmony import */ var _fragments_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./fragments.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/fragments.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../address/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/**\n *  When sending values to or receiving values from a [[Contract]], the\n *  data is generally encoded using the [ABI standard](link-solc-abi).\n *\n *  The AbiCoder provides a utility to encode values to ABI data and\n *  decode values from ABI data.\n *\n *  Most of the time, developers should favour the [[Contract]] class,\n *  which further abstracts a lot of the finer details of ABI data.\n *\n *  @_section api/abi/abi-coder:ABI Encoding\n */ // See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// https://docs.soliditylang.org/en/v0.8.17/control-structures.html\nconst PanicReasons = new Map();\nPanicReasons.set(0x00, \"GENERIC_PANIC\");\nPanicReasons.set(0x01, \"ASSERT_FALSE\");\nPanicReasons.set(0x11, \"OVERFLOW\");\nPanicReasons.set(0x12, \"DIVIDE_BY_ZERO\");\nPanicReasons.set(0x21, \"ENUM_RANGE_ERROR\");\nPanicReasons.set(0x22, \"BAD_STORAGE_DATA\");\nPanicReasons.set(0x31, \"STACK_UNDERFLOW\");\nPanicReasons.set(0x32, \"ARRAY_RANGE_ERROR\");\nPanicReasons.set(0x41, \"OUT_OF_MEMORY\");\nPanicReasons.set(0x51, \"UNINITIALIZED_FUNCTION_CALL\");\nconst paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nconst paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\nlet defaultCoder = null;\nlet defaultMaxInflation = 1024;\nfunction getBuiltinCallException(action, tx, data, abiCoder) {\n    let message = \"missing revert data\";\n    let reason = null;\n    const invocation = null;\n    let revert = null;\n    if (data) {\n        message = \"execution reverted\";\n        const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(data);\n        data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(data);\n        if (bytes.length === 0) {\n            message += \" (no data present; likely require(false) occurred\";\n            reason = \"require(false)\";\n        } else if (bytes.length % 32 !== 4) {\n            message += \" (could not decode reason; invalid data length)\";\n        } else if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(0, 4)) === \"0x08c379a0\") {\n            // Error(string)\n            try {\n                reason = abiCoder.decode([\n                    \"string\"\n                ], bytes.slice(4))[0];\n                revert = {\n                    signature: \"Error(string)\",\n                    name: \"Error\",\n                    args: [\n                        reason\n                    ]\n                };\n                message += \": \".concat(JSON.stringify(reason));\n            } catch (error) {\n                message += \" (could not decode reason; invalid string data)\";\n            }\n        } else if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(0, 4)) === \"0x4e487b71\") {\n            // Panic(uint256)\n            try {\n                const code = Number(abiCoder.decode([\n                    \"uint256\"\n                ], bytes.slice(4))[0]);\n                revert = {\n                    signature: \"Panic(uint256)\",\n                    name: \"Panic\",\n                    args: [\n                        code\n                    ]\n                };\n                reason = \"Panic due to \".concat(PanicReasons.get(code) || \"UNKNOWN\", \"(\").concat(code, \")\");\n                message += \": \".concat(reason);\n            } catch (error) {\n                message += \" (could not decode panic code)\";\n            }\n        } else {\n            message += \" (unknown custom error)\";\n        }\n    }\n    const transaction = {\n        to: tx.to ? (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(tx.to) : null,\n        data: tx.data || \"0x\"\n    };\n    if (tx.from) {\n        transaction.from = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(tx.from);\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.makeError)(message, \"CALL_EXCEPTION\", {\n        action,\n        data,\n        reason,\n        transaction,\n        invocation,\n        revert\n    });\n}\nvar _getCoder = /*#__PURE__*/ new WeakSet();\n/**\n *  The **AbiCoder** is a low-level class responsible for encoding JavaScript\n *  values into binary data and decoding binary data into JavaScript values.\n */ class AbiCoder {\n    /**\n     *  Get the default values for the given %%types%%.\n     *\n     *  For example, a ``uint`` is by default ``0`` and ``bool``\n     *  is by default ``false``.\n     */ getDefaultValue(types) {\n        const coders = types.map((type)=>(0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _getCoder, getCoder).call(this, _fragments_js__WEBPACK_IMPORTED_MODULE_4__.ParamType.from(type)));\n        const coder = new _coders_tuple_js__WEBPACK_IMPORTED_MODULE_5__.TupleCoder(coders, \"_\");\n        return coder.defaultValue();\n    }\n    /**\n     *  Encode the %%values%% as the %%types%% into ABI data.\n     *\n     *  @returns DataHexstring\n     */ encode(types, values) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgumentCount)(values.length, types.length, \"types/values length mismatch\");\n        const coders = types.map((type)=>(0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _getCoder, getCoder).call(this, _fragments_js__WEBPACK_IMPORTED_MODULE_4__.ParamType.from(type)));\n        const coder = new _coders_tuple_js__WEBPACK_IMPORTED_MODULE_5__.TupleCoder(coders, \"_\");\n        const writer = new _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_6__.Writer();\n        coder.encode(writer, values);\n        return writer.data;\n    }\n    /**\n     *  Decode the ABI %%data%% as the %%types%% into values.\n     *\n     *  If %%loose%% decoding is enabled, then strict padding is\n     *  not enforced. Some older versions of Solidity incorrectly\n     *  padded event data emitted from ``external`` functions.\n     */ decode(types, data, loose) {\n        const coders = types.map((type)=>(0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _getCoder, getCoder).call(this, _fragments_js__WEBPACK_IMPORTED_MODULE_4__.ParamType.from(type)));\n        const coder = new _coders_tuple_js__WEBPACK_IMPORTED_MODULE_5__.TupleCoder(coders, \"_\");\n        return coder.decode(new _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_6__.Reader(data, loose, defaultMaxInflation));\n    }\n    static _setDefaultMaxInflation(value) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(typeof value === \"number\" && Number.isInteger(value), \"invalid defaultMaxInflation factor\", \"value\", value);\n        defaultMaxInflation = value;\n    }\n    /**\n     *  Returns the shared singleton instance of a default [[AbiCoder]].\n     *\n     *  On the first call, the instance is created internally.\n     */ static defaultAbiCoder() {\n        if (defaultCoder == null) {\n            defaultCoder = new AbiCoder();\n        }\n        return defaultCoder;\n    }\n    /**\n     *  Returns an ethers-compatible [[CallExceptionError]] Error for the given\n     *  result %%data%% for the [[CallExceptionAction]] %%action%% against\n     *  the Transaction %%tx%%.\n     */ static getBuiltinCallException(action, tx, data) {\n        return getBuiltinCallException(action, tx, data, AbiCoder.defaultAbiCoder());\n    }\n    constructor(){\n        (0,_swc_helpers_class_private_method_init__WEBPACK_IMPORTED_MODULE_7__._)(this, _getCoder);\n    }\n} //# sourceMappingURL=abi-coder.js.map\nfunction getCoder(param) {\n    if (param.isArray()) {\n        return new _coders_array_js__WEBPACK_IMPORTED_MODULE_8__.ArrayCoder((0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _getCoder, getCoder).call(this, param.arrayChildren), param.arrayLength, param.name);\n    }\n    if (param.isTuple()) {\n        return new _coders_tuple_js__WEBPACK_IMPORTED_MODULE_5__.TupleCoder(param.components.map((c)=>(0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _getCoder, getCoder).call(this, c)), param.name);\n    }\n    switch(param.baseType){\n        case \"address\":\n            return new _coders_address_js__WEBPACK_IMPORTED_MODULE_9__.AddressCoder(param.name);\n        case \"bool\":\n            return new _coders_boolean_js__WEBPACK_IMPORTED_MODULE_10__.BooleanCoder(param.name);\n        case \"string\":\n            return new _coders_string_js__WEBPACK_IMPORTED_MODULE_11__.StringCoder(param.name);\n        case \"bytes\":\n            return new _coders_bytes_js__WEBPACK_IMPORTED_MODULE_12__.BytesCoder(param.name);\n        case \"\":\n            return new _coders_null_js__WEBPACK_IMPORTED_MODULE_13__.NullCoder(param.name);\n    }\n    // u?int[0-9]*\n    let match = param.type.match(paramTypeNumber);\n    if (match) {\n        let size = parseInt(match[2] || \"256\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(size !== 0 && size <= 256 && size % 8 === 0, \"invalid \" + match[1] + \" bit length\", \"param\", param);\n        return new _coders_number_js__WEBPACK_IMPORTED_MODULE_14__.NumberCoder(size / 8, match[1] === \"int\", param.name);\n    }\n    // bytes[0-9]+\n    match = param.type.match(paramTypeBytes);\n    if (match) {\n        let size = parseInt(match[1]);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(size !== 0 && size <= 32, \"invalid bytes length\", \"param\", param);\n        return new _coders_fixed_bytes_js__WEBPACK_IMPORTED_MODULE_15__.FixedBytesCoder(size, param.name);\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, \"invalid type\", \"type\", param.type);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvYWJpLWNvZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7O0NBV0MsR0FDRCxtRUFBbUU7OztBQUNLO0FBQ1o7QUFDVDtBQUNKO0FBQ0k7QUFDSjtBQUNXO0FBQ2I7QUFDSTtBQUNBO0FBQ0Y7QUFDSjtBQUNNO0FBQ2dCO0FBQ2pFLG1FQUFtRTtBQUNuRSxNQUFNa0IsZUFBZSxJQUFJQztBQUN6QkQsYUFBYUUsR0FBRyxDQUFDLE1BQU07QUFDdkJGLGFBQWFFLEdBQUcsQ0FBQyxNQUFNO0FBQ3ZCRixhQUFhRSxHQUFHLENBQUMsTUFBTTtBQUN2QkYsYUFBYUUsR0FBRyxDQUFDLE1BQU07QUFDdkJGLGFBQWFFLEdBQUcsQ0FBQyxNQUFNO0FBQ3ZCRixhQUFhRSxHQUFHLENBQUMsTUFBTTtBQUN2QkYsYUFBYUUsR0FBRyxDQUFDLE1BQU07QUFDdkJGLGFBQWFFLEdBQUcsQ0FBQyxNQUFNO0FBQ3ZCRixhQUFhRSxHQUFHLENBQUMsTUFBTTtBQUN2QkYsYUFBYUUsR0FBRyxDQUFDLE1BQU07QUFDdkIsTUFBTUMsaUJBQWlCLElBQUlDLE9BQU87QUFDbEMsTUFBTUMsa0JBQWtCLElBQUlELE9BQU87QUFDbkMsSUFBSUUsZUFBZTtBQUNuQixJQUFJQyxzQkFBc0I7QUFDMUIsU0FBU0Msd0JBQXdCQyxNQUFNLEVBQUVDLEVBQUUsRUFBRUMsSUFBSSxFQUFFQyxRQUFRO0lBQ3ZELElBQUlDLFVBQVU7SUFDZCxJQUFJQyxTQUFTO0lBQ2IsTUFBTUMsYUFBYTtJQUNuQixJQUFJQyxTQUFTO0lBQ2IsSUFBSUwsTUFBTTtRQUNORSxVQUFVO1FBQ1YsTUFBTUksUUFBUXBCLHlEQUFRQSxDQUFDYztRQUN2QkEsT0FBT2Isd0RBQU9BLENBQUNhO1FBQ2YsSUFBSU0sTUFBTUMsTUFBTSxLQUFLLEdBQUc7WUFDcEJMLFdBQVc7WUFDWEMsU0FB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QixJQUFJO1FBQ3RDLEtBQUs7WUFDRCxPQUFPLElBQUlsQyw2REFBWUEsQ0FBQzhELE1BQU01QixJQUFJO1FBQ3RDLEtBQUs7WUFDRCxPQUFPLElBQUk3QiwyREFBV0EsQ0FBQ3lELE1BQU01QixJQUFJO1FBQ3JDLEtBQUs7WUFDRCxPQUFPLElBQUlqQyx5REFBVUEsQ0FBQzZELE1BQU01QixJQUFJO1FBQ3BDLEtBQUs7WUFDRCxPQUFPLElBQUkvQix1REFBU0EsQ0FBQzJELE1BQU01QixJQUFJO0lBQ3ZDO0lBQ0EsY0FBYztJQUNkLElBQUlvQyxRQUFRUixNQUFNWixJQUFJLENBQUNvQixLQUFLLENBQUNyRDtJQUM3QixJQUFJcUQsT0FBTztRQUNQLElBQUlDLE9BQU9DLFNBQVNGLEtBQUssQ0FBQyxFQUFFLElBQUk7UUFDaEMzRSwrREFBY0EsQ0FBQzRFLFNBQVMsS0FBS0EsUUFBUSxPQUFPLE9BQVEsTUFBTyxHQUFHLGFBQWFELEtBQUssQ0FBQyxFQUFFLEdBQUcsZUFBZSxTQUFTUjtRQUM5RyxPQUFPLElBQUkxRCwyREFBV0EsQ0FBQ21FLE9BQU8sR0FBSUQsS0FBSyxDQUFDLEVBQUUsS0FBSyxPQUFRUixNQUFNNUIsSUFBSTtJQUNyRTtJQUNBLGNBQWM7SUFDZG9DLFFBQVFSLE1BQU1aLElBQUksQ0FBQ29CLEtBQUssQ0FBQ3ZEO0lBQ3pCLElBQUl1RCxPQUFPO1FBQ1AsSUFBSUMsT0FBT0MsU0FBU0YsS0FBSyxDQUFDLEVBQUU7UUFDNUIzRSwrREFBY0EsQ0FBQzRFLFNBQVMsS0FBS0EsUUFBUSxJQUFJLHdCQUF3QixTQUFTVDtRQUMxRSxPQUFPLElBQUk1RCxvRUFBZUEsQ0FBQ3FFLE1BQU1ULE1BQU01QixJQUFJO0lBQy9DO0lBQ0F2QywrREFBY0EsQ0FBQyxPQUFPLGdCQUFnQixRQUFRbUUsTUFBTVosSUFBSTtBQUM1RCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2FiaS1jb2Rlci5qcz9mZDQzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIFdoZW4gc2VuZGluZyB2YWx1ZXMgdG8gb3IgcmVjZWl2aW5nIHZhbHVlcyBmcm9tIGEgW1tDb250cmFjdF1dLCB0aGVcbiAqICBkYXRhIGlzIGdlbmVyYWxseSBlbmNvZGVkIHVzaW5nIHRoZSBbQUJJIHN0YW5kYXJkXShsaW5rLXNvbGMtYWJpKS5cbiAqXG4gKiAgVGhlIEFiaUNvZGVyIHByb3ZpZGVzIGEgdXRpbGl0eSB0byBlbmNvZGUgdmFsdWVzIHRvIEFCSSBkYXRhIGFuZFxuICogIGRlY29kZSB2YWx1ZXMgZnJvbSBBQkkgZGF0YS5cbiAqXG4gKiAgTW9zdCBvZiB0aGUgdGltZSwgZGV2ZWxvcGVycyBzaG91bGQgZmF2b3VyIHRoZSBbW0NvbnRyYWN0XV0gY2xhc3MsXG4gKiAgd2hpY2ggZnVydGhlciBhYnN0cmFjdHMgYSBsb3Qgb2YgdGhlIGZpbmVyIGRldGFpbHMgb2YgQUJJIGRhdGEuXG4gKlxuICogIEBfc2VjdGlvbiBhcGkvYWJpL2FiaS1jb2RlcjpBQkkgRW5jb2RpbmdcbiAqL1xuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL0V0aGVyZXVtLUNvbnRyYWN0LUFCSVxuaW1wb3J0IHsgYXNzZXJ0QXJndW1lbnRDb3VudCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IFJlYWRlciwgV3JpdGVyIH0gZnJvbSBcIi4vY29kZXJzL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG5pbXBvcnQgeyBBZGRyZXNzQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvYWRkcmVzcy5qc1wiO1xuaW1wb3J0IHsgQXJyYXlDb2RlciB9IGZyb20gXCIuL2NvZGVycy9hcnJheS5qc1wiO1xuaW1wb3J0IHsgQm9vbGVhbkNvZGVyIH0gZnJvbSBcIi4vY29kZXJzL2Jvb2xlYW4uanNcIjtcbmltcG9ydCB7IEJ5dGVzQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvYnl0ZXMuanNcIjtcbmltcG9ydCB7IEZpeGVkQnl0ZXNDb2RlciB9IGZyb20gXCIuL2NvZGVycy9maXhlZC1ieXRlcy5qc1wiO1xuaW1wb3J0IHsgTnVsbENvZGVyIH0gZnJvbSBcIi4vY29kZXJzL251bGwuanNcIjtcbmltcG9ydCB7IE51bWJlckNvZGVyIH0gZnJvbSBcIi4vY29kZXJzL251bWJlci5qc1wiO1xuaW1wb3J0IHsgU3RyaW5nQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvc3RyaW5nLmpzXCI7XG5pbXBvcnQgeyBUdXBsZUNvZGVyIH0gZnJvbSBcIi4vY29kZXJzL3R1cGxlLmpzXCI7XG5pbXBvcnQgeyBQYXJhbVR5cGUgfSBmcm9tIFwiLi9mcmFnbWVudHMuanNcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0Qnl0ZXMsIGhleGxpZnksIG1ha2VFcnJvciB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuLy8gaHR0cHM6Ly9kb2NzLnNvbGlkaXR5bGFuZy5vcmcvZW4vdjAuOC4xNy9jb250cm9sLXN0cnVjdHVyZXMuaHRtbFxuY29uc3QgUGFuaWNSZWFzb25zID0gbmV3IE1hcCgpO1xuUGFuaWNSZWFzb25zLnNldCgweDAwLCBcIkdFTkVSSUNfUEFOSUNcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MDEsIFwiQVNTRVJUX0ZBTFNFXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDExLCBcIk9WRVJGTE9XXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDEyLCBcIkRJVklERV9CWV9aRVJPXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDIxLCBcIkVOVU1fUkFOR0VfRVJST1JcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MjIsIFwiQkFEX1NUT1JBR0VfREFUQVwiKTtcblBhbmljUmVhc29ucy5zZXQoMHgzMSwgXCJTVEFDS19VTkRFUkZMT1dcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MzIsIFwiQVJSQVlfUkFOR0VfRVJST1JcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4NDEsIFwiT1VUX09GX01FTU9SWVwiKTtcblBhbmljUmVhc29ucy5zZXQoMHg1MSwgXCJVTklOSVRJQUxJWkVEX0ZVTkNUSU9OX0NBTExcIik7XG5jb25zdCBwYXJhbVR5cGVCeXRlcyA9IG5ldyBSZWdFeHAoL15ieXRlcyhbMC05XSopJC8pO1xuY29uc3QgcGFyYW1UeXBlTnVtYmVyID0gbmV3IFJlZ0V4cCgvXih1P2ludCkoWzAtOV0qKSQvKTtcbmxldCBkZWZhdWx0Q29kZXIgPSBudWxsO1xubGV0IGRlZmF1bHRNYXhJbmZsYXRpb24gPSAxMDI0O1xuZnVuY3Rpb24gZ2V0QnVpbHRpbkNhbGxFeGNlcHRpb24oYWN0aW9uLCB0eCwgZGF0YSwgYWJpQ29kZXIpIHtcbiAgICBsZXQgbWVzc2FnZSA9IFwibWlzc2luZyByZXZlcnQgZGF0YVwiO1xuICAgIGxldCByZWFzb24gPSBudWxsO1xuICAgIGNvbnN0IGludm9jYXRpb24gPSBudWxsO1xuICAgIGxldCByZXZlcnQgPSBudWxsO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBcImV4ZWN1dGlvbiByZXZlcnRlZFwiO1xuICAgICAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKGRhdGEpO1xuICAgICAgICBkYXRhID0gaGV4bGlmeShkYXRhKTtcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAobm8gZGF0YSBwcmVzZW50OyBsaWtlbHkgcmVxdWlyZShmYWxzZSkgb2NjdXJyZWRcIjtcbiAgICAgICAgICAgIHJlYXNvbiA9IFwicmVxdWlyZShmYWxzZSlcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChieXRlcy5sZW5ndGggJSAzMiAhPT0gNCkge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAoY291bGQgbm90IGRlY29kZSByZWFzb247IGludmFsaWQgZGF0YSBsZW5ndGgpXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGV4bGlmeShieXRlcy5zbGljZSgwLCA0KSkgPT09IFwiMHgwOGMzNzlhMFwiKSB7XG4gICAgICAgICAgICAvLyBFcnJvcihzdHJpbmcpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlYXNvbiA9IGFiaUNvZGVyLmRlY29kZShbXCJzdHJpbmdcIl0sIGJ5dGVzLnNsaWNlKDQpKVswXTtcbiAgICAgICAgICAgICAgICByZXZlcnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogXCJFcnJvcihzdHJpbmcpXCIsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiRXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW3JlYXNvbl1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gYDogJHtKU09OLnN0cmluZ2lmeShyZWFzb24pfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9IFwiIChjb3VsZCBub3QgZGVjb2RlIHJlYXNvbjsgaW52YWxpZCBzdHJpbmcgZGF0YSlcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoZXhsaWZ5KGJ5dGVzLnNsaWNlKDAsIDQpKSA9PT0gXCIweDRlNDg3YjcxXCIpIHtcbiAgICAgICAgICAgIC8vIFBhbmljKHVpbnQyNTYpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBOdW1iZXIoYWJpQ29kZXIuZGVjb2RlKFtcInVpbnQyNTZcIl0sIGJ5dGVzLnNsaWNlKDQpKVswXSk7XG4gICAgICAgICAgICAgICAgcmV2ZXJ0ID0ge1xuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6IFwiUGFuaWModWludDI1NilcIixcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJQYW5pY1wiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbY29kZV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlYXNvbiA9IGBQYW5pYyBkdWUgdG8gJHtQYW5pY1JlYXNvbnMuZ2V0KGNvZGUpIHx8IFwiVU5LTk9XTlwifSgke2NvZGV9KWA7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBgOiAke3JlYXNvbn1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAoY291bGQgbm90IGRlY29kZSBwYW5pYyBjb2RlKVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAodW5rbm93biBjdXN0b20gZXJyb3IpXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSB7XG4gICAgICAgIHRvOiAodHgudG8gPyBnZXRBZGRyZXNzKHR4LnRvKSA6IG51bGwpLFxuICAgICAgICBkYXRhOiAodHguZGF0YSB8fCBcIjB4XCIpXG4gICAgfTtcbiAgICBpZiAodHguZnJvbSkge1xuICAgICAgICB0cmFuc2FjdGlvbi5mcm9tID0gZ2V0QWRkcmVzcyh0eC5mcm9tKTtcbiAgICB9XG4gICAgcmV0dXJuIG1ha2VFcnJvcihtZXNzYWdlLCBcIkNBTExfRVhDRVBUSU9OXCIsIHtcbiAgICAgICAgYWN0aW9uLCBkYXRhLCByZWFzb24sIHRyYW5zYWN0aW9uLCBpbnZvY2F0aW9uLCByZXZlcnRcbiAgICB9KTtcbn1cbi8qKlxuICogIFRoZSAqKkFiaUNvZGVyKiogaXMgYSBsb3ctbGV2ZWwgY2xhc3MgcmVzcG9uc2libGUgZm9yIGVuY29kaW5nIEphdmFTY3JpcHRcbiAqICB2YWx1ZXMgaW50byBiaW5hcnkgZGF0YSBhbmQgZGVjb2RpbmcgYmluYXJ5IGRhdGEgaW50byBKYXZhU2NyaXB0IHZhbHVlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEFiaUNvZGVyIHtcbiAgICAjZ2V0Q29kZXIocGFyYW0pIHtcbiAgICAgICAgaWYgKHBhcmFtLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheUNvZGVyKHRoaXMuI2dldENvZGVyKHBhcmFtLmFycmF5Q2hpbGRyZW4pLCBwYXJhbS5hcnJheUxlbmd0aCwgcGFyYW0ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtLmlzVHVwbGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUdXBsZUNvZGVyKHBhcmFtLmNvbXBvbmVudHMubWFwKChjKSA9PiB0aGlzLiNnZXRDb2RlcihjKSksIHBhcmFtLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAocGFyYW0uYmFzZVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJhZGRyZXNzXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzQ29kZXIocGFyYW0ubmFtZSk7XG4gICAgICAgICAgICBjYXNlIFwiYm9vbFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQm9vbGVhbkNvZGVyKHBhcmFtLm5hbWUpO1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3RyaW5nQ29kZXIocGFyYW0ubmFtZSk7XG4gICAgICAgICAgICBjYXNlIFwiYnl0ZXNcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ5dGVzQ29kZXIocGFyYW0ubmFtZSk7XG4gICAgICAgICAgICBjYXNlIFwiXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBOdWxsQ29kZXIocGFyYW0ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdT9pbnRbMC05XSpcbiAgICAgICAgbGV0IG1hdGNoID0gcGFyYW0udHlwZS5tYXRjaChwYXJhbVR5cGVOdW1iZXIpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGxldCBzaXplID0gcGFyc2VJbnQobWF0Y2hbMl0gfHwgXCIyNTZcIik7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChzaXplICE9PSAwICYmIHNpemUgPD0gMjU2ICYmIChzaXplICUgOCkgPT09IDAsIFwiaW52YWxpZCBcIiArIG1hdGNoWzFdICsgXCIgYml0IGxlbmd0aFwiLCBcInBhcmFtXCIsIHBhcmFtKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTnVtYmVyQ29kZXIoc2l6ZSAvIDgsIChtYXRjaFsxXSA9PT0gXCJpbnRcIiksIHBhcmFtLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJ5dGVzWzAtOV0rXG4gICAgICAgIG1hdGNoID0gcGFyYW0udHlwZS5tYXRjaChwYXJhbVR5cGVCeXRlcyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgbGV0IHNpemUgPSBwYXJzZUludChtYXRjaFsxXSk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChzaXplICE9PSAwICYmIHNpemUgPD0gMzIsIFwiaW52YWxpZCBieXRlcyBsZW5ndGhcIiwgXCJwYXJhbVwiLCBwYXJhbSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZpeGVkQnl0ZXNDb2RlcihzaXplLCBwYXJhbS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIHR5cGVcIiwgXCJ0eXBlXCIsIHBhcmFtLnR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSBkZWZhdWx0IHZhbHVlcyBmb3IgdGhlIGdpdmVuICUldHlwZXMlJS5cbiAgICAgKlxuICAgICAqICBGb3IgZXhhbXBsZSwgYSBgYHVpbnRgYCBpcyBieSBkZWZhdWx0IGBgMGBgIGFuZCBgYGJvb2xgYFxuICAgICAqICBpcyBieSBkZWZhdWx0IGBgZmFsc2VgYC5cbiAgICAgKi9cbiAgICBnZXREZWZhdWx0VmFsdWUodHlwZXMpIHtcbiAgICAgICAgY29uc3QgY29kZXJzID0gdHlwZXMubWFwKCh0eXBlKSA9PiB0aGlzLiNnZXRDb2RlcihQYXJhbVR5cGUuZnJvbSh0eXBlKSkpO1xuICAgICAgICBjb25zdCBjb2RlciA9IG5ldyBUdXBsZUNvZGVyKGNvZGVycywgXCJfXCIpO1xuICAgICAgICByZXR1cm4gY29kZXIuZGVmYXVsdFZhbHVlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBFbmNvZGUgdGhlICUldmFsdWVzJSUgYXMgdGhlICUldHlwZXMlJSBpbnRvIEFCSSBkYXRhLlxuICAgICAqXG4gICAgICogIEByZXR1cm5zIERhdGFIZXhzdHJpbmdcbiAgICAgKi9cbiAgICBlbmNvZGUodHlwZXMsIHZhbHVlcykge1xuICAgICAgICBhc3NlcnRBcmd1bWVudENvdW50KHZhbHVlcy5sZW5ndGgsIHR5cGVzLmxlbmd0aCwgXCJ0eXBlcy92YWx1ZXMgbGVuZ3RoIG1pc21hdGNoXCIpO1xuICAgICAgICBjb25zdCBjb2RlcnMgPSB0eXBlcy5tYXAoKHR5cGUpID0+IHRoaXMuI2dldENvZGVyKFBhcmFtVHlwZS5mcm9tKHR5cGUpKSk7XG4gICAgICAgIGNvbnN0IGNvZGVyID0gKG5ldyBUdXBsZUNvZGVyKGNvZGVycywgXCJfXCIpKTtcbiAgICAgICAgY29uc3Qgd3JpdGVyID0gbmV3IFdyaXRlcigpO1xuICAgICAgICBjb2Rlci5lbmNvZGUod3JpdGVyLCB2YWx1ZXMpO1xuICAgICAgICByZXR1cm4gd3JpdGVyLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBEZWNvZGUgdGhlIEFCSSAlJWRhdGElJSBhcyB0aGUgJSV0eXBlcyUlIGludG8gdmFsdWVzLlxuICAgICAqXG4gICAgICogIElmICUlbG9vc2UlJSBkZWNvZGluZyBpcyBlbmFibGVkLCB0aGVuIHN0cmljdCBwYWRkaW5nIGlzXG4gICAgICogIG5vdCBlbmZvcmNlZC4gU29tZSBvbGRlciB2ZXJzaW9ucyBvZiBTb2xpZGl0eSBpbmNvcnJlY3RseVxuICAgICAqICBwYWRkZWQgZXZlbnQgZGF0YSBlbWl0dGVkIGZyb20gYGBleHRlcm5hbGBgIGZ1bmN0aW9ucy5cbiAgICAgKi9cbiAgICBkZWNvZGUodHlwZXMsIGRhdGEsIGxvb3NlKSB7XG4gICAgICAgIGNvbnN0IGNvZGVycyA9IHR5cGVzLm1hcCgodHlwZSkgPT4gdGhpcy4jZ2V0Q29kZXIoUGFyYW1UeXBlLmZyb20odHlwZSkpKTtcbiAgICAgICAgY29uc3QgY29kZXIgPSBuZXcgVHVwbGVDb2Rlcihjb2RlcnMsIFwiX1wiKTtcbiAgICAgICAgcmV0dXJuIGNvZGVyLmRlY29kZShuZXcgUmVhZGVyKGRhdGEsIGxvb3NlLCBkZWZhdWx0TWF4SW5mbGF0aW9uKSk7XG4gICAgfVxuICAgIHN0YXRpYyBfc2V0RGVmYXVsdE1heEluZmxhdGlvbih2YWx1ZSkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIiAmJiBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSwgXCJpbnZhbGlkIGRlZmF1bHRNYXhJbmZsYXRpb24gZmFjdG9yXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICBkZWZhdWx0TWF4SW5mbGF0aW9uID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBzaGFyZWQgc2luZ2xldG9uIGluc3RhbmNlIG9mIGEgZGVmYXVsdCBbW0FiaUNvZGVyXV0uXG4gICAgICpcbiAgICAgKiAgT24gdGhlIGZpcnN0IGNhbGwsIHRoZSBpbnN0YW5jZSBpcyBjcmVhdGVkIGludGVybmFsbHkuXG4gICAgICovXG4gICAgc3RhdGljIGRlZmF1bHRBYmlDb2RlcigpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRDb2RlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWZhdWx0Q29kZXIgPSBuZXcgQWJpQ29kZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmYXVsdENvZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhbiBldGhlcnMtY29tcGF0aWJsZSBbW0NhbGxFeGNlcHRpb25FcnJvcl1dIEVycm9yIGZvciB0aGUgZ2l2ZW5cbiAgICAgKiAgcmVzdWx0ICUlZGF0YSUlIGZvciB0aGUgW1tDYWxsRXhjZXB0aW9uQWN0aW9uXV0gJSVhY3Rpb24lJSBhZ2FpbnN0XG4gICAgICogIHRoZSBUcmFuc2FjdGlvbiAlJXR4JSUuXG4gICAgICovXG4gICAgc3RhdGljIGdldEJ1aWx0aW5DYWxsRXhjZXB0aW9uKGFjdGlvbiwgdHgsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGdldEJ1aWx0aW5DYWxsRXhjZXB0aW9uKGFjdGlvbiwgdHgsIGRhdGEsIEFiaUNvZGVyLmRlZmF1bHRBYmlDb2RlcigpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYmktY29kZXIuanMubWFwIl0sIm5hbWVzIjpbImFzc2VydEFyZ3VtZW50Q291bnQiLCJhc3NlcnRBcmd1bWVudCIsIlJlYWRlciIsIldyaXRlciIsIkFkZHJlc3NDb2RlciIsIkFycmF5Q29kZXIiLCJCb29sZWFuQ29kZXIiLCJCeXRlc0NvZGVyIiwiRml4ZWRCeXRlc0NvZGVyIiwiTnVsbENvZGVyIiwiTnVtYmVyQ29kZXIiLCJTdHJpbmdDb2RlciIsIlR1cGxlQ29kZXIiLCJQYXJhbVR5cGUiLCJnZXRBZGRyZXNzIiwiZ2V0Qnl0ZXMiLCJoZXhsaWZ5IiwibWFrZUVycm9yIiwiUGFuaWNSZWFzb25zIiwiTWFwIiwic2V0IiwicGFyYW1UeXBlQnl0ZXMiLCJSZWdFeHAiLCJwYXJhbVR5cGVOdW1iZXIiLCJkZWZhdWx0Q29kZXIiLCJkZWZhdWx0TWF4SW5mbGF0aW9uIiwiZ2V0QnVpbHRpbkNhbGxFeGNlcHRpb24iLCJhY3Rpb24iLCJ0eCIsImRhdGEiLCJhYmlDb2RlciIsIm1lc3NhZ2UiLCJyZWFzb24iLCJpbnZvY2F0aW9uIiwicmV2ZXJ0IiwiYnl0ZXMiLCJsZW5ndGgiLCJzbGljZSIsImRlY29kZSIsInNpZ25hdHVyZSIsIm5hbWUiLCJhcmdzIiwiSlNPTiIsInN0cmluZ2lmeSIsImVycm9yIiwiY29kZSIsIk51bWJlciIsImdldCIsInRyYW5zYWN0aW9uIiwidG8iLCJmcm9tIiwiQWJpQ29kZXIiLCJnZXREZWZhdWx0VmFsdWUiLCJ0eXBlcyIsImNvZGVycyIsIm1hcCIsInR5cGUiLCJnZXRDb2RlciIsImNvZGVyIiwiZGVmYXVsdFZhbHVlIiwiZW5jb2RlIiwidmFsdWVzIiwid3JpdGVyIiwibG9vc2UiLCJfc2V0RGVmYXVsdE1heEluZmxhdGlvbiIsInZhbHVlIiwiaXNJbnRlZ2VyIiwiZGVmYXVsdEFiaUNvZGVyIiwicGFyYW0iLCJpc0FycmF5IiwiYXJyYXlDaGlsZHJlbiIsImFycmF5TGVuZ3RoIiwiaXNUdXBsZSIsImNvbXBvbmVudHMiLCJjIiwiYmFzZVR5cGUiLCJtYXRjaCIsInNpemUiLCJwYXJzZUludCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/abi/abi-coder.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js":
/*!******************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Coder: function() { return /* binding */ Coder; },\n/* harmony export */   Reader: function() { return /* binding */ Reader; },\n/* harmony export */   Result: function() { return /* binding */ Result; },\n/* harmony export */   WordSize: function() { return /* binding */ WordSize; },\n/* harmony export */   Writer: function() { return /* binding */ Writer; },\n/* harmony export */   checkResultErrors: function() { return /* binding */ checkResultErrors; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_get */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_get.js\");\n/* harmony import */ var _swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_init */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_init.js\");\n/* harmony import */ var _swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_set */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_set.js\");\n/* harmony import */ var _swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @swc/helpers/_/_class_private_method_get */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_method_get.js\");\n/* harmony import */ var _swc_helpers_class_private_method_init__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @swc/helpers/_/_class_private_method_init */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_method_init.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/properties.js\");\n\n\n\n\n\n\n/**\n * @_ignore:\n */ const WordSize = 32;\nconst Padding = new Uint8Array(WordSize);\n// Properties used to immediate pass through to the underlying object\n// - `then` is used to detect if an object is a Promise for await\nconst passProperties = [\n    \"then\"\n];\nconst _guard = {};\nconst resultNames = new WeakMap();\nfunction getNames(result) {\n    return resultNames.get(result);\n}\nfunction setNames(result, names) {\n    resultNames.set(result, names);\n}\nfunction throwError(name, error) {\n    const wrapped = new Error(\"deferred error during ABI decoding triggered accessing \".concat(name));\n    wrapped.error = error;\n    throw wrapped;\n}\nfunction toObject(names, items, deep) {\n    if (names.indexOf(null) >= 0) {\n        return items.map((item, index)=>{\n            if (item instanceof Result) {\n                return toObject(getNames(item), item, deep);\n            }\n            return item;\n        });\n    }\n    return names.reduce((accum, name, index)=>{\n        let item = items.getValue(name);\n        if (!(name in accum)) {\n            if (deep && item instanceof Result) {\n                item = toObject(getNames(item), item, deep);\n            }\n            accum[name] = item;\n        }\n        return accum;\n    }, {});\n}\nvar // No longer used; but cannot be removed as it will remove the\n// #private field from the .d.ts which may break backwards\n// compatibility\n_names = /*#__PURE__*/ new WeakMap();\n/**\n *  A [[Result]] is a sub-class of Array, which allows accessing any\n *  of its values either positionally by its index or, if keys are\n *  provided by its name.\n *\n *  @_docloc: api/abi\n */ class Result extends Array {\n    /**\n     *  Returns the Result as a normal Array. If %%deep%%, any children\n     *  which are Result objects are also converted to a normal Array.\n     *\n     *  This will throw if there are any outstanding deferred\n     *  errors.\n     */ toArray(deep) {\n        const result = [];\n        this.forEach((item, index)=>{\n            if (item instanceof Error) {\n                throwError(\"index \".concat(index), item);\n            }\n            if (deep && item instanceof Result) {\n                item = item.toArray(deep);\n            }\n            result.push(item);\n        });\n        return result;\n    }\n    /**\n     *  Returns the Result as an Object with each name-value pair. If\n     *  %%deep%%, any children which are Result objects are also\n     *  converted to an Object.\n     *\n     *  This will throw if any value is unnamed, or if there are\n     *  any outstanding deferred errors.\n     */ toObject(deep) {\n        const names = getNames(this);\n        return names.reduce((accum, name, index)=>{\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(name != null, \"value at index \".concat(index, \" unnamed\"), \"UNSUPPORTED_OPERATION\", {\n                operation: \"toObject()\"\n            });\n            return toObject(names, this, deep);\n        }, {});\n    }\n    /**\n     *  @_ignore\n     */ slice(start, end) {\n        if (start == null) {\n            start = 0;\n        }\n        if (start < 0) {\n            start += this.length;\n            if (start < 0) {\n                start = 0;\n            }\n        }\n        if (end == null) {\n            end = this.length;\n        }\n        if (end < 0) {\n            end += this.length;\n            if (end < 0) {\n                end = 0;\n            }\n        }\n        if (end > this.length) {\n            end = this.length;\n        }\n        const _names = getNames(this);\n        const result = [], names = [];\n        for(let i = start; i < end; i++){\n            result.push(this[i]);\n            names.push(_names[i]);\n        }\n        return new Result(_guard, result, names);\n    }\n    /**\n     *  @_ignore\n     */ filter(callback, thisArg) {\n        const _names = getNames(this);\n        const result = [], names = [];\n        for(let i = 0; i < this.length; i++){\n            const item = this[i];\n            if (item instanceof Error) {\n                throwError(\"index \".concat(i), item);\n            }\n            if (callback.call(thisArg, item, i, this)) {\n                result.push(item);\n                names.push(_names[i]);\n            }\n        }\n        return new Result(_guard, result, names);\n    }\n    /**\n     *  @_ignore\n     */ map(callback, thisArg) {\n        const result = [];\n        for(let i = 0; i < this.length; i++){\n            const item = this[i];\n            if (item instanceof Error) {\n                throwError(\"index \".concat(i), item);\n            }\n            result.push(callback.call(thisArg, item, i, this));\n        }\n        return result;\n    }\n    /**\n     *  Returns the value for %%name%%.\n     *\n     *  Since it is possible to have a key whose name conflicts with\n     *  a method on a [[Result]] or its superclass Array, or any\n     *  JavaScript keyword, this ensures all named values are still\n     *  accessible by name.\n     */ getValue(name) {\n        const index = getNames(this).indexOf(name);\n        if (index === -1) {\n            return undefined;\n        }\n        const value = this[index];\n        if (value instanceof Error) {\n            throwError(\"property \".concat(JSON.stringify(name)), value.error);\n        }\n        return value;\n    }\n    /**\n     *  Creates a new [[Result]] for %%items%% with each entry\n     *  also accessible by its corresponding name in %%keys%%.\n     */ static fromItems(items, keys) {\n        return new Result(_guard, items, keys);\n    }\n    /**\n     *  @private\n     */ constructor(...args){\n        // To properly sub-class Array so the other built-in\n        // functions work, the constructor has to behave fairly\n        // well. So, in the event we are created via fromItems()\n        // we build the read-only Result object we want, but on\n        // any other input, we use the default constructor\n        // constructor(guard: any, items: Array<any>, keys?: Array<null | string>);\n        const guard = args[0];\n        let items = args[1];\n        let names = (args[2] || []).slice();\n        let wrap = true;\n        if (guard !== _guard) {\n            items = args;\n            names = [];\n            wrap = false;\n        }\n        // Can't just pass in ...items since an array of length 1\n        // is a special case in the super.\n        super(items.length);\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_1__._)(this, _names, {\n            writable: true,\n            value: void 0\n        });\n        items.forEach((item, index)=>{\n            this[index] = item;\n        });\n        // Find all unique keys\n        const nameCounts = names.reduce((accum, name)=>{\n            if (typeof name === \"string\") {\n                accum.set(name, (accum.get(name) || 0) + 1);\n            }\n            return accum;\n        }, new Map());\n        // Remove any key thats not unique\n        setNames(this, Object.freeze(items.map((item, index)=>{\n            const name = names[index];\n            if (name != null && nameCounts.get(name) === 1) {\n                return name;\n            }\n            return null;\n        })));\n        // Dummy operations to prevent TypeScript from complaining\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_2__._)(this, _names, []);\n        if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _names) == null) {\n            void (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _names);\n        }\n        if (!wrap) {\n            return;\n        }\n        // A wrapped Result is immutable\n        Object.freeze(this);\n        // Proxy indices and names so we can trap deferred errors\n        const proxy = new Proxy(this, {\n            get: (target, prop, receiver)=>{\n                if (typeof prop === \"string\") {\n                    // Index accessor\n                    if (prop.match(/^[0-9]+$/)) {\n                        const index = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.getNumber)(prop, \"%index\");\n                        if (index < 0 || index >= this.length) {\n                            throw new RangeError(\"out of result range\");\n                        }\n                        const item = target[index];\n                        if (item instanceof Error) {\n                            throwError(\"index \".concat(index), item);\n                        }\n                        return item;\n                    }\n                    // Pass important checks (like `then` for Promise) through\n                    if (passProperties.indexOf(prop) >= 0) {\n                        return Reflect.get(target, prop, receiver);\n                    }\n                    const value = target[prop];\n                    if (value instanceof Function) {\n                        // Make sure functions work with private variables\n                        // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#no_private_property_forwarding\n                        return function() {\n                            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                                args[_key] = arguments[_key];\n                            }\n                            return value.apply(this === receiver ? target : this, args);\n                        };\n                    } else if (!(prop in target)) {\n                        // Possible name accessor\n                        return target.getValue.apply(this === receiver ? target : this, [\n                            prop\n                        ]);\n                    }\n                }\n                return Reflect.get(target, prop, receiver);\n            }\n        });\n        setNames(proxy, getNames(this));\n        return proxy;\n    }\n}\n/**\n *  Returns all errors found in a [[Result]].\n *\n *  Since certain errors encountered when creating a [[Result]] do\n *  not impact the ability to continue parsing data, they are\n *  deferred until they are actually accessed. Hence a faulty string\n *  in an Event that is never used does not impact the program flow.\n *\n *  However, sometimes it may be useful to access, identify or\n *  validate correctness of a [[Result]].\n *\n *  @_docloc api/abi\n */ function checkResultErrors(result) {\n    // Find the first error (if any)\n    const errors = [];\n    const checkErrors = function(path, object) {\n        if (!Array.isArray(object)) {\n            return;\n        }\n        for(let key in object){\n            const childPath = path.slice();\n            childPath.push(key);\n            try {\n                checkErrors(childPath, object[key]);\n            } catch (error) {\n                errors.push({\n                    path: childPath,\n                    error: error\n                });\n            }\n        }\n    };\n    checkErrors([], result);\n    return errors;\n}\nfunction getValue(value) {\n    let bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.toBeArray)(value);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(bytes.length <= WordSize, \"value out-of-bounds\", \"BUFFER_OVERRUN\", {\n        buffer: bytes,\n        length: WordSize,\n        offset: bytes.length\n    });\n    if (bytes.length !== WordSize) {\n        bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.getBytesCopy)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.concat)([\n            Padding.slice(bytes.length % WordSize),\n            bytes\n        ]));\n    }\n    return bytes;\n}\n/**\n *  @_ignore\n */ class Coder {\n    _throwError(message, value) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, message, this.localName, value);\n    }\n    constructor(name, type, localName, dynamic){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.defineProperties)(this, {\n            name,\n            type,\n            localName,\n            dynamic\n        }, {\n            name: \"string\",\n            type: \"string\",\n            localName: \"string\",\n            dynamic: \"boolean\"\n        });\n    }\n}\nvar // An array of WordSize lengthed objects to concatenation\n_data = /*#__PURE__*/ new WeakMap(), _dataLength = /*#__PURE__*/ new WeakMap(), _writeData = /*#__PURE__*/ new WeakSet();\n/**\n *  @_ignore\n */ class Writer {\n    get data() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.concat)((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _data));\n    }\n    get length() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _dataLength);\n    }\n    appendWriter(writer) {\n        return (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_7__._)(this, _writeData, writeData).call(this, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.getBytesCopy)(writer.data));\n    }\n    // Arrayish item; pad on the right to *nearest* WordSize\n    writeBytes(value) {\n        let bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.getBytesCopy)(value);\n        const paddingOffset = bytes.length % WordSize;\n        if (paddingOffset) {\n            bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.getBytesCopy)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.concat)([\n                bytes,\n                Padding.slice(paddingOffset)\n            ]));\n        }\n        return (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_7__._)(this, _writeData, writeData).call(this, bytes);\n    }\n    // Numeric item; pad on the left *to* WordSize\n    writeValue(value) {\n        return (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_7__._)(this, _writeData, writeData).call(this, getValue(value));\n    }\n    // Inserts a numeric place-holder, returning a callback that can\n    // be used to asjust the value later\n    writeUpdatableValue() {\n        const offset = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _data).length;\n        (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _data).push(Padding);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_2__._)(this, _dataLength, (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _dataLength) + WordSize);\n        return (value)=>{\n            (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _data)[offset] = getValue(value);\n        };\n    }\n    constructor(){\n        (0,_swc_helpers_class_private_method_init__WEBPACK_IMPORTED_MODULE_8__._)(this, _writeData);\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_1__._)(this, _data, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_1__._)(this, _dataLength, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_2__._)(this, _data, []);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_2__._)(this, _dataLength, 0);\n    }\n}\nfunction writeData(data) {\n    (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _data).push(data);\n    (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_2__._)(this, _dataLength, (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _dataLength) + data.length);\n    return data.length;\n}\nvar _data1 = /*#__PURE__*/ new WeakMap(), _offset = /*#__PURE__*/ new WeakMap(), _bytesRead = /*#__PURE__*/ new WeakMap(), _parent = /*#__PURE__*/ new WeakMap(), _maxInflation = /*#__PURE__*/ new WeakMap(), _incrementBytesRead = /*#__PURE__*/ new WeakSet(), _peekBytes = /*#__PURE__*/ new WeakSet();\n/**\n *  @_ignore\n */ class Reader {\n    get data() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _data1));\n    }\n    get dataLength() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _data1).length;\n    }\n    get consumed() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _offset);\n    }\n    get bytes() {\n        return new Uint8Array((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _data1));\n    }\n    // Create a sub-reader with the same underlying data, but offset\n    subReader(offset) {\n        const reader = new Reader((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _data1).slice((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _offset) + offset), this.allowLoose, (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _maxInflation));\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_2__._)(reader, _parent, this);\n        return reader;\n    }\n    // Read bytes\n    readBytes(length, loose) {\n        let bytes = (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_7__._)(this, _peekBytes, peekBytes).call(this, 0, length, !!loose);\n        (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_7__._)(this, _incrementBytesRead, incrementBytesRead).call(this, length);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_2__._)(this, _offset, (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _offset) + bytes.length);\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n    // Read a numeric values\n    readValue() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.toBigInt)(this.readBytes(WordSize));\n    }\n    readIndex() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.toNumber)(this.readBytes(WordSize));\n    }\n    constructor(data, allowLoose, maxInflation){\n        (0,_swc_helpers_class_private_method_init__WEBPACK_IMPORTED_MODULE_8__._)(this, _incrementBytesRead);\n        (0,_swc_helpers_class_private_method_init__WEBPACK_IMPORTED_MODULE_8__._)(this, _peekBytes);\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_1__._)(this, _data1, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_1__._)(this, _offset, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_1__._)(this, _bytesRead, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_1__._)(this, _parent, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_1__._)(this, _maxInflation, {\n            writable: true,\n            value: void 0\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.defineProperties)(this, {\n            allowLoose: !!allowLoose\n        });\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_2__._)(this, _data1, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.getBytesCopy)(data));\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_2__._)(this, _bytesRead, 0);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_2__._)(this, _parent, null);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_2__._)(this, _maxInflation, maxInflation != null ? maxInflation : 1024);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_2__._)(this, _offset, 0);\n    }\n} //# sourceMappingURL=abstract-coder.js.map\nfunction incrementBytesRead(count) {\n    var _class_private_field_get1;\n    if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _parent)) {\n        return (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_7__._)(_class_private_field_get1 = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _parent), _incrementBytesRead, incrementBytesRead).call(_class_private_field_get1, count);\n    }\n    (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_2__._)(this, _bytesRead, (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _bytesRead) + count);\n    // Check for excessive inflation (see: #4537)\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _maxInflation) < 1 || (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _bytesRead) <= (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _maxInflation) * this.dataLength, \"compressed ABI data exceeds inflation ratio of \".concat((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _maxInflation), \" ( see: https://github.com/ethers-io/ethers.js/issues/4537 )\"), \"BUFFER_OVERRUN\", {\n        buffer: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.getBytesCopy)((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _data1)),\n        offset: (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _offset),\n        length: count,\n        info: {\n            bytesRead: (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _bytesRead),\n            dataLength: this.dataLength\n        }\n    });\n}\nfunction peekBytes(offset, length, loose) {\n    let alignedLength = Math.ceil(length / WordSize) * WordSize;\n    if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _offset) + alignedLength > (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _data1).length) {\n        if (this.allowLoose && loose && (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _offset) + length <= (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _data1).length) {\n            alignedLength = length;\n        } else {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"data out-of-bounds\", \"BUFFER_OVERRUN\", {\n                buffer: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.getBytesCopy)((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _data1)),\n                length: (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _data1).length,\n                offset: (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _offset) + alignedLength\n            });\n        }\n    }\n    return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _data1).slice((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _offset), (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _offset) + alignedLength);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2Fic3RyYWN0LWNvZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRStCO0FBQy9COztDQUVDLEdBQ00sTUFBTVUsV0FBVyxHQUFHO0FBQzNCLE1BQU1DLFVBQVUsSUFBSUMsV0FBV0Y7QUFDL0IscUVBQXFFO0FBQ3JFLGlFQUFpRTtBQUNqRSxNQUFNRyxpQkFBaUI7SUFBQztDQUFPO0FBQy9CLE1BQU1DLFNBQVMsQ0FBQztBQUNoQixNQUFNQyxjQUFjLElBQUlDO0FBQ3hCLFNBQVNDLFNBQVNDLE1BQU07SUFDcEIsT0FBT0gsWUFBWUksR0FBRyxDQUFDRDtBQUMzQjtBQUNBLFNBQVNFLFNBQVNGLE1BQU0sRUFBRUcsS0FBSztJQUMzQk4sWUFBWU8sR0FBRyxDQUFDSixRQUFRRztBQUM1QjtBQUNBLFNBQVNFLFdBQVdDLElBQUksRUFBRUMsS0FBSztJQUMzQixNQUFNQyxVQUFVLElBQUlDLE1BQU0sMERBQStELE9BQUxIO0lBQ3BGRSxRQUFRRCxLQUFLLEdBQUdBO0lBQ2hCLE1BQU1DO0FBQ1Y7QUFDQSxTQUFTRSxTQUFTUCxLQUFLLEVBQUVRLEtBQUssRUFBRUMsSUFBSTtJQUNoQyxJQUFJVCxNQUFNVSxPQUFPLENBQUMsU0FBUyxHQUFHO1FBQzFCLE9BQU9GLE1BQU1HLEdBQUcsQ0FBQyxDQUFDQyxNQUFNQztZQUNwQixJQUFJRCxnQkFBZ0JFLFFBQVE7Z0JBQ3hCLE9BQU9QLFNBQVNYLFNBQVNnQixPQUFPQSxNQUFNSDtZQUMxQztZQUNBLE9BQU9HO1FBQ1g7SUFDSjtJQUNBLE9BQU9aLE1BQU1lLE1BQU0sQ0FBQyxDQUFDQyxPQUFPYixNQUFNVTtRQUM5QixJQUFJRCxPQUFPSixNQUFNUyxRQUFRLENBQUNkO1FBQzFCLElBQUksQ0FBRUEsQ0FBQUEsUUFBUWEsS0FBSSxHQUFJO1lBQ2xCLElBQUlQLFFBQVFHLGdCQUFnQkUsUUFBUTtnQkFDaENGLE9BQU9MLFNBQVNYLFNBQVNnQixPQUFPQSxNQUFNSDtZQUMxQztZQUNBTyxLQUFLLENBQUNiLEtBQUssR0FBR1M7UUFDbEI7UUFDQSxPQUFPSTtJQUNYLEdBQUcsQ0FBQztBQUNSO0lBU0ksOERBQThEO0FBQzlELDBEQUEwRDtBQUMxRCxnQkFBZ0I7QUFDaEI7QUFYSjs7Ozs7O0NBTUMsR0FDTSxNQUFNRixlQUFlSTtJQTRGeEI7Ozs7OztLQU1DLEdBQ0RDLFFBQVFWLElBQUksRUFBRTtRQUNWLE1BQU1aLFNBQVMsRUFBRTtRQUNqQixJQUFJLENBQUN1QixPQUFPLENBQUMsQ0FBQ1IsTUFBTUM7WUFDaEIsSUFBSUQsZ0JBQWdCTixPQUFPO2dCQUN2QkosV0FBVyxTQUFlLE9BQU5XLFFBQVNEO1lBQ2pDO1lBQ0EsSUFBSUgsUUFBUUcsZ0JBQWdCRSxRQUFRO2dCQUNoQ0YsT0FBT0EsS0FBS08sT0FBTyxDQUFDVjtZQUN4QjtZQUNBWixPQUFPd0IsSUFBSSxDQUFDVDtRQUNoQjtRQUNBLE9BQU9mO0lBQ1g7SUFDQTs7Ozs7OztLQU9DLEdBQ0RVLFNBQVNFLElBQUksRUFBRTtRQUNYLE1BQU1ULFFBQVFKLFNBQVMsSUFBSTtRQUMzQixPQUFPSSxNQUFNZSxNQUFNLENBQUMsQ0FBQ0MsT0FBT2IsTUFBTVU7WUFDOUIxQix1REFBTUEsQ0FBQ2dCLFFBQVEsTUFBTSxrQkFBd0IsT0FBTlUsT0FBTSxhQUFXLHlCQUF5QjtnQkFDN0VTLFdBQVc7WUFDZjtZQUNBLE9BQU9mLFNBQVNQLE9BQU8sSUFBSSxFQUFFUztRQUNqQyxHQUFHLENBQUM7SUFDUjtJQUNBOztLQUVDLEdBQ0RjLE1BQU1DLEtBQUssRUFBRUMsR0FBRyxFQUFFO1FBQ2QsSUFBSUQsU0FBUyxNQUFNO1lBQ2ZBLFFBQVE7UUFDWjtRQUNBLElBQUlBLFFBQVEsR0FBRztZQUNYQSxTQUFTLElBQUksQ0FBQ0UsTUFBTTtZQUNwQixJQUFJRixRQUFRLEdBQUc7Z0JBQ1hBLFFBQVE7WUFDWjtRQUNKO1FBQ0EsSUFBSUMsT0FBTyxNQUFNO1lBQ2JBLE1BQU0sSUFBSSxDQUFDQyxNQUFNO1FBQ3JCO1FBQ0EsSUFBSUQsTUFBTSxHQUFHO1lBQ1RBLE9BQU8sSUFBSSxDQUFDQyxNQUFNO1lBQ2xCLElBQUlELE1BQU0sR0FBRztnQkFDVEEsTUFBTTtZQUNWO1FBQ0o7UUFDQSxJQUFJQSxNQUFNLElBQUksQ0FBQ0MsTUFBTSxFQUFFO1lBQ25CRCxNQUFNLElBQUksQ0FBQ0MsTUFBTTtRQUNyQjtRQUNBLE1BQU1DLFNBQVMvQixTQUFTLElBQUk7UUFDNUIsTUFBTUMsU0FBUyxFQUFFLEVBQUVHLFFBQVEsRUFBRTtRQUM3QixJQUFLLElBQUk0QixJQUFJSixPQUFPSSxJQUFJSCxLQUFLRyxJQUFLO1lBQzlCL0IsT0FBT3dCLElBQUksQ0FBQyxJQUFJLENBQUNPLEVBQUU7WUFDbkI1QixNQUFNcUIsSUFBSSxDQUFDTSxNQUFNLENBQUNDLEVBQUU7UUFDeEI7UUFDQSxPQUFPLElBQUlkLE9BQU9yQixRQUFRSSxRQUFRRztJQUN0QztJQUNBOztLQUVDLEdBQ0Q2QixPQUFPQyxRQUFRLEVBQUVDLE9BQU8sRUFBRTtRQUN0QixNQUFNSixTQUFTL0IsU0FBUyxJQUFJO1FBQzVCLE1BQU1DLFNBQVMsRUFBRSxFQUFFRyxRQUFRLEVBQUU7UUFDN0IsSUFBSyxJQUFJNEIsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ0YsTUFBTSxFQUFFRSxJQUFLO1lBQ2xDLE1BQU1oQixPQUFPLElBQUksQ0FBQ2dCLEVBQUU7WUFDcEIsSUFBSWhCLGdCQUFnQk4sT0FBTztnQkFDdkJKLFdBQVcsU0FBVyxPQUFGMEIsSUFBS2hCO1lBQzdCO1lBQ0EsSUFBSWtCLFNBQVNFLElBQUksQ0FBQ0QsU0FBU25CLE1BQU1nQixHQUFHLElBQUksR0FBRztnQkFDdkMvQixPQUFPd0IsSUFBSSxDQUFDVDtnQkFDWlosTUFBTXFCLElBQUksQ0FBQ00sTUFBTSxDQUFDQyxFQUFFO1lBQ3hCO1FBQ0o7UUFDQSxPQUFPLElBQUlkLE9BQU9yQixRQUFRSSxRQUFRRztJQUN0QztJQUNBOztLQUVDLEdBQ0RXLElBQUltQixRQUFRLEVBQUVDLE9BQU8sRUFBRTtRQUNuQixNQUFNbEMsU0FBUyxFQUFFO1FBQ2pCLElBQUssSUFBSStCLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNGLE1BQU0sRUFBRUUsSUFBSztZQUNsQyxNQUFNaEIsT0FBTyxJQUFJLENBQUNnQixFQUFFO1lBQ3BCLElBQUloQixnQkFBZ0JOLE9BQU87Z0JBQ3ZCSixXQUFXLFNBQVcsT0FBRjBCLElBQUtoQjtZQUM3QjtZQUNBZixPQUFPd0IsSUFBSSxDQUFDUyxTQUFTRSxJQUFJLENBQUNELFNBQVNuQixNQUFNZ0IsR0FBRyxJQUFJO1FBQ3BEO1FBQ0EsT0FBTy9CO0lBQ1g7SUFDQTs7Ozs7OztLQU9DLEdBQ0RvQixTQUFTZCxJQUFJLEVBQUU7UUFDWCxNQUFNVSxRQUFRakIsU0FBUyxJQUFJLEVBQUVjLE9BQU8sQ0FBQ1A7UUFDckMsSUFBSVUsVUFBVSxDQUFDLEdBQUc7WUFDZCxPQUFPb0I7UUFDWDtRQUNBLE1BQU1DLFFBQVEsSUFBSSxDQUFDckIsTUFBTTtRQUN6QixJQUFJcUIsaUJBQWlCNUIsT0FBTztZQUN4QkosV0FBVyxZQUFpQyxPQUFyQmlDLEtBQUtDLFNBQVMsQ0FBQ2pDLFFBQVMrQixNQUFNOUIsS0FBSztRQUM5RDtRQUNBLE9BQU84QjtJQUNYO0lBQ0E7OztLQUdDLEdBQ0QsT0FBT0csVUFBVTdCLEtBQUssRUFBRThCLElBQUksRUFBRTtRQUMxQixPQUFPLElBQUl4QixPQUFPckIsUUFBUWUsT0FBTzhCO0lBQ3JDO0lBdE5BOztLQUVDLEdBQ0RDLFlBQVksR0FBR0MsSUFBSSxDQUFFO1FBQ2pCLG9EQUFvRDtRQUNwRCx1REFBdUQ7UUFDdkQsd0RBQXdEO1FBQ3hELHVEQUF1RDtRQUN2RCxrREFBa0Q7UUFDbEQsMkVBQTJFO1FBQzNFLE1BQU1DLFFBQVFELElBQUksQ0FBQyxFQUFFO1FBQ3JCLElBQUloQyxRQUFRZ0MsSUFBSSxDQUFDLEVBQUU7UUFDbkIsSUFBSXhDLFFBQVEsQ0FBQ3dDLElBQUksQ0FBQyxFQUFFLElBQUksRUFBRSxFQUFFakIsS0FBSztRQUNqQyxJQUFJbUIsT0FBTztRQUNYLElBQUlELFVBQVVoRCxRQUFRO1lBQ2xCZSxRQUFRZ0M7WUFDUnhDLFFBQVEsRUFBRTtZQUNWMEMsT0FBTztRQUNYO1FBQ0EseURBQXlEO1FBQ3pELGtDQUFrQztRQUNsQyxLQUFLLENBQUNsQyxNQUFNa0IsTUFBTTtRQXRCdEI7O21CQUFBOztRQXVCSWxCLE1BQU1ZLE9BQU8sQ0FBQyxDQUFDUixNQUFNQztZQUFZLElBQUksQ0FBQ0EsTUFBTSxHQUFHRDtRQUFNO1FBQ3JELHVCQUF1QjtRQUN2QixNQUFNK0IsYUFBYTNDLE1BQU1lLE1BQU0sQ0FBQyxDQUFDQyxPQUFPYjtZQUNwQyxJQUFJLE9BQVFBLFNBQVUsVUFBVTtnQkFDNUJhLE1BQU1mLEdBQUcsQ0FBQ0UsTUFBTSxDQUFDYSxNQUFNbEIsR0FBRyxDQUFDSyxTQUFTLEtBQUs7WUFDN0M7WUFDQSxPQUFPYTtRQUNYLEdBQUksSUFBSTRCO1FBQ1Isa0NBQWtDO1FBQ2xDN0MsU0FBUyxJQUFJLEVBQUU4QyxPQUFPQyxNQUFNLENBQUN0QyxNQUFNRyxHQUFHLENBQUMsQ0FBQ0MsTUFBTUM7WUFDMUMsTUFBTVYsT0FBT0gsS0FBSyxDQUFDYSxNQUFNO1lBQ3pCLElBQUlWLFFBQVEsUUFBUXdDLFdBQVc3QyxHQUFHLENBQUNLLFVBQVUsR0FBRztnQkFDNUMsT0FBT0E7WUFDWDtZQUNBLE9BQU87UUFDWDtRQUNBLDBEQUEwRDtzRkFDcERILFFBQVEsRUFBRTtRQUNoQixJQUFJLDRFQUFJLEVBQUVBLFdBQVMsTUFBTTtZQUNyQixLQUFLLHdFQUFDLElBQUksRUFBRUE7UUFDaEI7UUFDQSxJQUFJLENBQUMwQyxNQUFNO1lBQ1A7UUFDSjtRQUNBLGdDQUFnQztRQUNoQ0csT0FBT0MsTUFBTSxDQUFDLElBQUk7UUFDbEIseURBQXlEO1FBQ3pELE1BQU1DLFFBQVEsSUFBSUMsTUFBTSxJQUFJLEVBQUU7WUFDMUJsRCxLQUFLLENBQUNtRCxRQUFRQyxNQUFNQztnQkFDaEIsSUFBSSxPQUFRRCxTQUFVLFVBQVU7b0JBQzVCLGlCQUFpQjtvQkFDakIsSUFBSUEsS0FBS0UsS0FBSyxDQUFDLGFBQWE7d0JBQ3hCLE1BQU12QyxRQUFRL0IsMERBQVNBLENBQUNvRSxNQUFNO3dCQUM5QixJQUFJckMsUUFBUSxLQUFLQSxTQUFTLElBQUksQ0FBQ2EsTUFBTSxFQUFFOzRCQUNuQyxNQUFNLElBQUkyQixXQUFXO3dCQUN6Qjt3QkFDQSxNQUFNekMsT0FBT3FDLE1BQU0sQ0FBQ3BDLE1BQU07d0JBQzFCLElBQUlELGdCQUFnQk4sT0FBTzs0QkFDdkJKLFdBQVcsU0FBZSxPQUFOVyxRQUFTRDt3QkFDakM7d0JBQ0EsT0FBT0E7b0JBQ1g7b0JBQ0EsMERBQTBEO29CQUMxRCxJQUFJcEIsZUFBZWtCLE9BQU8sQ0FBQ3dDLFNBQVMsR0FBRzt3QkFDbkMsT0FBT0ksUUFBUXhELEdBQUcsQ0FBQ21ELFFBQVFDLE1BQU1DO29CQUNyQztvQkFDQSxNQUFNakIsUUFBUWUsTUFBTSxDQUFDQyxLQUFLO29CQUMxQixJQUFJaEIsaUJBQWlCcUIsVUFBVTt3QkFDM0Isa0RBQWtEO3dCQUNsRCw2SEFBNkg7d0JBQzdILE9BQU87NEJBQVU7Z0NBQUdmLEtBQUgsdUJBQU87OzRCQUNwQixPQUFPTixNQUFNc0IsS0FBSyxDQUFDLElBQUssS0FBS0wsV0FBWUYsU0FBUyxJQUFJLEVBQUVUO3dCQUM1RDtvQkFDSixPQUNLLElBQUksQ0FBRVUsQ0FBQUEsUUFBUUQsTUFBSyxHQUFJO3dCQUN4Qix5QkFBeUI7d0JBQ3pCLE9BQU9BLE9BQU9oQyxRQUFRLENBQUN1QyxLQUFLLENBQUMsSUFBSyxLQUFLTCxXQUFZRixTQUFTLElBQUksRUFBRTs0QkFBQ0M7eUJBQUs7b0JBQzVFO2dCQUNKO2dCQUNBLE9BQU9JLFFBQVF4RCxHQUFHLENBQUNtRCxRQUFRQyxNQUFNQztZQUNyQztRQUNKO1FBQ0FwRCxTQUFTZ0QsT0FBT25ELFNBQVMsSUFBSTtRQUM3QixPQUFPbUQ7SUFDWDtBQWlJSjtBQUNBOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNNLFNBQVNVLGtCQUFrQjVELE1BQU07SUFDcEMsZ0NBQWdDO0lBQ2hDLE1BQU02RCxTQUFTLEVBQUU7SUFDakIsTUFBTUMsY0FBYyxTQUFVQyxJQUFJLEVBQUVDLE1BQU07UUFDdEMsSUFBSSxDQUFDM0MsTUFBTTRDLE9BQU8sQ0FBQ0QsU0FBUztZQUN4QjtRQUNKO1FBQ0EsSUFBSyxJQUFJRSxPQUFPRixPQUFRO1lBQ3BCLE1BQU1HLFlBQVlKLEtBQUtyQyxLQUFLO1lBQzVCeUMsVUFBVTNDLElBQUksQ0FBQzBDO1lBQ2YsSUFBSTtnQkFDQUosWUFBWUssV0FBV0gsTUFBTSxDQUFDRSxJQUFJO1lBQ3RDLEVBQ0EsT0FBTzNELE9BQU87Z0JBQ1ZzRCxPQUFPckMsSUFBSSxDQUFDO29CQUFFdUMsTUFBTUk7b0JBQVc1RCxPQUFPQTtnQkFBTTtZQUNoRDtRQUNKO0lBQ0o7SUFDQXVELFlBQVksRUFBRSxFQUFFOUQ7SUFDaEIsT0FBTzZEO0FBQ1g7QUFDQSxTQUFTekMsU0FBU2lCLEtBQUs7SUFDbkIsSUFBSStCLFFBQVFqRiwwREFBU0EsQ0FBQ2tEO0lBQ3RCL0MsdURBQU1BLENBQUM4RSxNQUFNdkMsTUFBTSxJQUFJckMsVUFBVSx1QkFBdUIsa0JBQWtCO1FBQUU2RSxRQUFRRDtRQUFPdkMsUUFBUXJDO1FBQVU4RSxRQUFRRixNQUFNdkMsTUFBTTtJQUFDO0lBQ2xJLElBQUl1QyxNQUFNdkMsTUFBTSxLQUFLckMsVUFBVTtRQUMzQjRFLFFBQVFwRiw2REFBWUEsQ0FBQ0QsdURBQU1BLENBQUM7WUFBQ1UsUUFBUWlDLEtBQUssQ0FBQzBDLE1BQU12QyxNQUFNLEdBQUdyQztZQUFXNEU7U0FBTTtJQUMvRTtJQUNBLE9BQU9BO0FBQ1g7QUFDQTs7Q0FFQyxHQUNNLE1BQU1HO0lBbUJUQyxZQUFZQyxPQUFPLEVBQUVwQyxLQUFLLEVBQUU7UUFDeEI5QywrREFBY0EsQ0FBQyxPQUFPa0YsU0FBUyxJQUFJLENBQUNDLFNBQVMsRUFBRXJDO0lBQ25EO0lBUEFLLFlBQVlwQyxJQUFJLEVBQUVxRSxJQUFJLEVBQUVELFNBQVMsRUFBRUUsT0FBTyxDQUFFO1FBQ3hDOUYsaUVBQWdCQSxDQUFDLElBQUksRUFBRTtZQUFFd0I7WUFBTXFFO1lBQU1EO1lBQVdFO1FBQVEsR0FBRztZQUN2RHRFLE1BQU07WUFBVXFFLE1BQU07WUFBVUQsV0FBVztZQUFVRSxTQUFTO1FBQ2xFO0lBQ0o7QUFJSjtJQUtJLHlEQUF5RDtBQUN6RCxxQ0FDQSwyQ0FTQTtBQWZKOztDQUVDLEdBQ00sTUFBTUM7SUFRVCxJQUFJQyxPQUFPO1FBQ1AsT0FBTy9GLHVEQUFNQSxDQUFDQSx1RUFBQUEsQ0FBQSxJQUFJLEVBQUUrRjtJQUN4QjtJQUNBLElBQUlqRCxTQUFTO1FBQUUsT0FBTyw0RUFBSSxFQUFFa0Q7SUFBWTtJQU14Q0MsYUFBYUMsTUFBTSxFQUFFO1FBQ2pCLE9BQU8sNkVBQUksRUFBRUMsWUFBQUEsZ0JBQU4sSUFBSSxFQUFZbEcsNkRBQVlBLENBQUNpRyxPQUFPSCxJQUFJO0lBQ25EO0lBQ0Esd0RBQXdEO0lBQ3hESyxXQUFXOUMsS0FBSyxFQUFFO1FBQ2QsSUFBSStCLFFBQVFwRiw2REFBWUEsQ0FBQ3FEO1FBQ3pCLE1BQU0rQyxnQkFBZ0JoQixNQUFNdkMsTUFBTSxHQUFHckM7UUFDckMsSUFBSTRGLGVBQWU7WUFDZmhCLFFBQVFwRiw2REFBWUEsQ0FBQ0QsdURBQU1BLENBQUM7Z0JBQUNxRjtnQkFBTzNFLFFBQVFpQyxLQUFLLENBQUMwRDthQUFlO1FBQ3JFO1FBQ0EsT0FBTyw2RUFBSSxFQUFFRixZQUFBQSxnQkFBTixJQUFJLEVBQVlkO0lBQzNCO0lBQ0EsOENBQThDO0lBQzlDaUIsV0FBV2hELEtBQUssRUFBRTtRQUNkLE9BQU8sNkVBQUksRUFBRTZDLFlBQUFBLGdCQUFOLElBQUksRUFBWTlELFNBQVNpQjtJQUNwQztJQUNBLGdFQUFnRTtJQUNoRSxvQ0FBb0M7SUFDcENpRCxzQkFBc0I7UUFDbEIsTUFBTWhCLFNBQVMsNEVBQUksRUFBRVEsT0FBS2pELE1BQU07UUFDaEMsNEVBQUksRUFBRWlELE9BQUt0RCxJQUFJLENBQUMvQjtzRkFDVnNGLGFBQUFBLHVFQUFBQSxDQUFOLElBQUksRUFBRUEsZUFBY3ZGO1FBQ3BCLE9BQU8sQ0FBQzZDO1lBQ0osNEVBQUksRUFBRXlDLE1BQUksQ0FBQ1IsT0FBTyxHQUFHbEQsU0FBU2lCO1FBQ2xDO0lBQ0o7SUF0Q0FLLGFBQWM7UUFRZDtRQVZBOzttQkFBQTs7UUFDQTs7bUJBQUE7O3NGQUVVb0MsT0FBTyxFQUFFO3NGQUNUQyxhQUFhO0lBQ3ZCO0FBb0NKO0FBL0JJLG1CQUFXRCxJQUFJO0lBQ1gsNEVBQUksRUFBRUEsT0FBS3RELElBQUksQ0FBQ3NEO2tGQUNWQyxhQUFBQSx1RUFBQUEsQ0FBTixJQUFJLEVBQUVBLGVBQWNELEtBQUtqRCxNQUFNO0lBQy9CLE9BQU9pRCxLQUFLakQsTUFBTTtBQUN0QjtJQXFDQSxzQ0FDQSx1Q0FDQSwwQ0FDQSx1Q0FDQSw2Q0FhQSxtREFjQTtBQXhDSjs7Q0FFQyxHQUNNLE1BQU0wRDtJQW1CVCxJQUFJVCxPQUFPO1FBQUUsT0FBTzVGLHdEQUFPQSxDQUFDQSx1RUFBQUEsQ0FBQSxJQUFJLEVBQUU0RjtJQUFPO0lBQ3pDLElBQUlDLGFBQWE7UUFBRSxPQUFPLDRFQUFJLEVBQUVELFFBQUtqRCxNQUFNO0lBQUU7SUFDN0MsSUFBSTJELFdBQVc7UUFBRSxPQUFPLDRFQUFJLEVBQUVsQjtJQUFRO0lBQ3RDLElBQUlGLFFBQVE7UUFBRSxPQUFPLElBQUkxRSxXQUFXQSx1RUFBQUEsQ0FBQSxJQUFJLEVBQUVvRjtJQUFPO0lBK0JqRCxnRUFBZ0U7SUFDaEVXLFVBQVVuQixNQUFNLEVBQUU7UUFDZCxNQUFNb0IsU0FBUyxJQUFJSCxPQUFPLDRFQUFJLEVBQUVULFFBQUtwRCxLQUFLLENBQUMsNEVBQUksRUFBRTRDLFdBQVNBLFNBQVMsSUFBSSxDQUFDcUIsVUFBVSxFQUFFLDRFQUFJLEVBQUVDO2dGQUMxRkYsUUFBUUcsU0FBUyxJQUFJO1FBQ3JCLE9BQU9IO0lBQ1g7SUFDQSxhQUFhO0lBQ2JJLFVBQVVqRSxNQUFNLEVBQUVrRSxLQUFLLEVBQUU7UUFDckIsSUFBSTNCLFFBQVEsNkVBQUksRUFBRTRCLFlBQUFBLGdCQUFOLElBQUksRUFBWSxHQUFHbkUsUUFBUSxDQUFDLENBQUNrRTtRQUN6Qyw2RUFBSSxFQUFFRSxxQkFBQUEseUJBQU4sSUFBSSxFQUFxQnBFO3NGQUNuQnlDLFNBQUFBLHVFQUFBQSxDQUFOLElBQUksRUFBRUEsV0FBVUYsTUFBTXZDLE1BQU07UUFDNUIsb0RBQW9EO1FBQ3BELE9BQU91QyxNQUFNMUMsS0FBSyxDQUFDLEdBQUdHO0lBQzFCO0lBQ0Esd0JBQXdCO0lBQ3hCcUUsWUFBWTtRQUNSLE9BQU85Ryx5REFBUUEsQ0FBQyxJQUFJLENBQUMwRyxTQUFTLENBQUN0RztJQUNuQztJQUNBMkcsWUFBWTtRQUNSLE9BQU85Ryx5REFBUUEsQ0FBQyxJQUFJLENBQUN5RyxTQUFTLENBQUN0RztJQUNuQztJQTlEQWtELFlBQVlvQyxJQUFJLEVBQUVhLFVBQVUsRUFBRUMsWUFBWSxDQUFFO1FBWTVDO1FBY0E7UUEvQkE7O21CQUFBOztRQUNBOzttQkFBQTs7UUFDQTs7bUJBQUE7O1FBQ0E7O21CQUFBOztRQUNBOzttQkFBQTs7UUFFSTlHLGlFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFBRTZHLFlBQVksQ0FBQyxDQUFDQTtRQUFXO3NGQUM1Q2IsUUFBTzlGLDZEQUFZQSxDQUFDOEY7c0ZBQ3BCc0IsWUFBWTtzRkFDWlAsU0FBUztzRkFDVEQsZUFBZSxnQkFBaUIsT0FBUUEsZUFBZTtzRkFDdkR0QixTQUFTO0lBQ25CO0FBd0RKLEVBQ0EsMENBQTBDO0FBcER0Qyw0QkFBb0IrQixLQUFLOztJQUNyQixJQUFJLDRFQUFJLEVBQUVSLFVBQVE7UUFDZCxPQUFPLGlMQUFJLEVBQUVBLFVBQVFJLHFCQUFBQSxvREFBbUJJO0lBQzVDO2tGQUNNRCxZQUFBQSx1RUFBQUEsQ0FBTixJQUFJLEVBQUVBLGNBQWFDO0lBQ25CLDZDQUE2QztJQUM3Qy9HLHVEQUFNQSxDQUFDLDRFQUFJLEVBQUVzRyxpQkFBZSxLQUFLLDRFQUFJLEVBQUVRLGVBQWEsNEVBQUksRUFBRVIsaUJBQWUsSUFBSSxDQUFDYixVQUFVLEVBQUUsa0RBQXFFLCtFQUFuQixJQUFJLEVBQUVhLGdCQUFhLGlFQUFnRSxrQkFBa0I7UUFDN092QixRQUFRckYsNkRBQVlBLENBQUNBLHVFQUFBQSxDQUFBLElBQUksRUFBRThGO1FBQU9SLE1BQU0sRUFBRSw0RUFBSSxFQUFFQTtRQUNoRHpDLFFBQVF3RTtRQUFPQyxNQUFNO1lBQ2pCRixTQUFTLEVBQUUsNEVBQUksRUFBRUE7WUFDakJyQixZQUFZLElBQUksQ0FBQ0EsVUFBVTtRQUMvQjtJQUNKO0FBQ0o7QUFDQSxtQkFBV1QsTUFBTSxFQUFFekMsTUFBTSxFQUFFa0UsS0FBSztJQUM1QixJQUFJUSxnQkFBZ0JDLEtBQUtDLElBQUksQ0FBQzVFLFNBQVNyQyxZQUFZQTtJQUNuRCxJQUFJLDRFQUFJLEVBQUU4RSxXQUFTaUMsZ0JBQWdCLDRFQUFJLEVBQUV6QixRQUFLakQsTUFBTSxFQUFFO1FBQ2xELElBQUksSUFBSSxDQUFDOEQsVUFBVSxJQUFJSSxTQUFTLDRFQUFJLEVBQUV6QixXQUFTekMsVUFBVSw0RUFBSSxFQUFFaUQsUUFBS2pELE1BQU0sRUFBRTtZQUN4RTBFLGdCQUFnQjFFO1FBQ3BCLE9BQ0s7WUFDRHZDLHVEQUFNQSxDQUFDLE9BQU8sc0JBQXNCLGtCQUFrQjtnQkFDbEQrRSxRQUFRckYsNkRBQVlBLENBQUNBLHVFQUFBQSxDQUFBLElBQUksRUFBRThGO2dCQUMzQmpELFFBQVEsNEVBQUksRUFBRWlELFFBQUtqRCxNQUFNO2dCQUN6QnlDLFFBQVEsNEVBQUksRUFBRUEsV0FBU2lDO1lBQzNCO1FBQ0o7SUFDSjtJQUNBLE9BQU8sNEVBQUksRUFBRXpCLFFBQUtwRCxLQUFLLENBQUMsNEVBQUksRUFBRTRDLFVBQVEsNEVBQUksRUFBRUEsV0FBU2lDO0FBQ3pEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2Fic3RyYWN0LWNvZGVyLmpzP2NlZjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgY29uY2F0LCBnZXRCeXRlc0NvcHksIGdldE51bWJlciwgaGV4bGlmeSwgdG9CZUFycmF5LCB0b0JpZ0ludCwgdG9OdW1iZXIsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnRcbi8qLCBpc0Vycm9yKi9cbiB9IGZyb20gXCIuLi8uLi91dGlscy9pbmRleC5qc1wiO1xuLyoqXG4gKiBAX2lnbm9yZTpcbiAqL1xuZXhwb3J0IGNvbnN0IFdvcmRTaXplID0gMzI7XG5jb25zdCBQYWRkaW5nID0gbmV3IFVpbnQ4QXJyYXkoV29yZFNpemUpO1xuLy8gUHJvcGVydGllcyB1c2VkIHRvIGltbWVkaWF0ZSBwYXNzIHRocm91Z2ggdG8gdGhlIHVuZGVybHlpbmcgb2JqZWN0XG4vLyAtIGB0aGVuYCBpcyB1c2VkIHRvIGRldGVjdCBpZiBhbiBvYmplY3QgaXMgYSBQcm9taXNlIGZvciBhd2FpdFxuY29uc3QgcGFzc1Byb3BlcnRpZXMgPSBbXCJ0aGVuXCJdO1xuY29uc3QgX2d1YXJkID0ge307XG5jb25zdCByZXN1bHROYW1lcyA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBnZXROYW1lcyhyZXN1bHQpIHtcbiAgICByZXR1cm4gcmVzdWx0TmFtZXMuZ2V0KHJlc3VsdCk7XG59XG5mdW5jdGlvbiBzZXROYW1lcyhyZXN1bHQsIG5hbWVzKSB7XG4gICAgcmVzdWx0TmFtZXMuc2V0KHJlc3VsdCwgbmFtZXMpO1xufVxuZnVuY3Rpb24gdGhyb3dFcnJvcihuYW1lLCBlcnJvcikge1xuICAgIGNvbnN0IHdyYXBwZWQgPSBuZXcgRXJyb3IoYGRlZmVycmVkIGVycm9yIGR1cmluZyBBQkkgZGVjb2RpbmcgdHJpZ2dlcmVkIGFjY2Vzc2luZyAke25hbWV9YCk7XG4gICAgd3JhcHBlZC5lcnJvciA9IGVycm9yO1xuICAgIHRocm93IHdyYXBwZWQ7XG59XG5mdW5jdGlvbiB0b09iamVjdChuYW1lcywgaXRlbXMsIGRlZXApIHtcbiAgICBpZiAobmFtZXMuaW5kZXhPZihudWxsKSA+PSAwKSB7XG4gICAgICAgIHJldHVybiBpdGVtcy5tYXAoKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b09iamVjdChnZXROYW1lcyhpdGVtKSwgaXRlbSwgZGVlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lcy5yZWR1Y2UoKGFjY3VtLCBuYW1lLCBpbmRleCkgPT4ge1xuICAgICAgICBsZXQgaXRlbSA9IGl0ZW1zLmdldFZhbHVlKG5hbWUpO1xuICAgICAgICBpZiAoIShuYW1lIGluIGFjY3VtKSkge1xuICAgICAgICAgICAgaWYgKGRlZXAgJiYgaXRlbSBpbnN0YW5jZW9mIFJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSB0b09iamVjdChnZXROYW1lcyhpdGVtKSwgaXRlbSwgZGVlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY2N1bVtuYW1lXSA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgIH0sIHt9KTtcbn1cbi8qKlxuICogIEEgW1tSZXN1bHRdXSBpcyBhIHN1Yi1jbGFzcyBvZiBBcnJheSwgd2hpY2ggYWxsb3dzIGFjY2Vzc2luZyBhbnlcbiAqICBvZiBpdHMgdmFsdWVzIGVpdGhlciBwb3NpdGlvbmFsbHkgYnkgaXRzIGluZGV4IG9yLCBpZiBrZXlzIGFyZVxuICogIHByb3ZpZGVkIGJ5IGl0cyBuYW1lLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL2FiaVxuICovXG5leHBvcnQgY2xhc3MgUmVzdWx0IGV4dGVuZHMgQXJyYXkge1xuICAgIC8vIE5vIGxvbmdlciB1c2VkOyBidXQgY2Fubm90IGJlIHJlbW92ZWQgYXMgaXQgd2lsbCByZW1vdmUgdGhlXG4gICAgLy8gI3ByaXZhdGUgZmllbGQgZnJvbSB0aGUgLmQudHMgd2hpY2ggbWF5IGJyZWFrIGJhY2t3YXJkc1xuICAgIC8vIGNvbXBhdGliaWxpdHlcbiAgICAjbmFtZXM7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICAvLyBUbyBwcm9wZXJseSBzdWItY2xhc3MgQXJyYXkgc28gdGhlIG90aGVyIGJ1aWx0LWluXG4gICAgICAgIC8vIGZ1bmN0aW9ucyB3b3JrLCB0aGUgY29uc3RydWN0b3IgaGFzIHRvIGJlaGF2ZSBmYWlybHlcbiAgICAgICAgLy8gd2VsbC4gU28sIGluIHRoZSBldmVudCB3ZSBhcmUgY3JlYXRlZCB2aWEgZnJvbUl0ZW1zKClcbiAgICAgICAgLy8gd2UgYnVpbGQgdGhlIHJlYWQtb25seSBSZXN1bHQgb2JqZWN0IHdlIHdhbnQsIGJ1dCBvblxuICAgICAgICAvLyBhbnkgb3RoZXIgaW5wdXQsIHdlIHVzZSB0aGUgZGVmYXVsdCBjb25zdHJ1Y3RvclxuICAgICAgICAvLyBjb25zdHJ1Y3RvcihndWFyZDogYW55LCBpdGVtczogQXJyYXk8YW55Piwga2V5cz86IEFycmF5PG51bGwgfCBzdHJpbmc+KTtcbiAgICAgICAgY29uc3QgZ3VhcmQgPSBhcmdzWzBdO1xuICAgICAgICBsZXQgaXRlbXMgPSBhcmdzWzFdO1xuICAgICAgICBsZXQgbmFtZXMgPSAoYXJnc1syXSB8fCBbXSkuc2xpY2UoKTtcbiAgICAgICAgbGV0IHdyYXAgPSB0cnVlO1xuICAgICAgICBpZiAoZ3VhcmQgIT09IF9ndWFyZCkge1xuICAgICAgICAgICAgaXRlbXMgPSBhcmdzO1xuICAgICAgICAgICAgbmFtZXMgPSBbXTtcbiAgICAgICAgICAgIHdyYXAgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYW4ndCBqdXN0IHBhc3MgaW4gLi4uaXRlbXMgc2luY2UgYW4gYXJyYXkgb2YgbGVuZ3RoIDFcbiAgICAgICAgLy8gaXMgYSBzcGVjaWFsIGNhc2UgaW4gdGhlIHN1cGVyLlxuICAgICAgICBzdXBlcihpdGVtcy5sZW5ndGgpO1xuICAgICAgICBpdGVtcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4geyB0aGlzW2luZGV4XSA9IGl0ZW07IH0pO1xuICAgICAgICAvLyBGaW5kIGFsbCB1bmlxdWUga2V5c1xuICAgICAgICBjb25zdCBuYW1lQ291bnRzID0gbmFtZXMucmVkdWNlKChhY2N1bSwgbmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAobmFtZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBhY2N1bS5zZXQobmFtZSwgKGFjY3VtLmdldChuYW1lKSB8fCAwKSArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICB9LCAobmV3IE1hcCgpKSk7XG4gICAgICAgIC8vIFJlbW92ZSBhbnkga2V5IHRoYXRzIG5vdCB1bmlxdWVcbiAgICAgICAgc2V0TmFtZXModGhpcywgT2JqZWN0LmZyZWV6ZShpdGVtcy5tYXAoKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gbmFtZXNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKG5hbWUgIT0gbnVsbCAmJiBuYW1lQ291bnRzLmdldChuYW1lKSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pKSk7XG4gICAgICAgIC8vIER1bW15IG9wZXJhdGlvbnMgdG8gcHJldmVudCBUeXBlU2NyaXB0IGZyb20gY29tcGxhaW5pbmdcbiAgICAgICAgdGhpcy4jbmFtZXMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuI25hbWVzID09IG51bGwpIHtcbiAgICAgICAgICAgIHZvaWQgKHRoaXMuI25hbWVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXdyYXApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBBIHdyYXBwZWQgUmVzdWx0IGlzIGltbXV0YWJsZVxuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgICAgICAvLyBQcm94eSBpbmRpY2VzIGFuZCBuYW1lcyBzbyB3ZSBjYW4gdHJhcCBkZWZlcnJlZCBlcnJvcnNcbiAgICAgICAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkodGhpcywge1xuICAgICAgICAgICAgZ2V0OiAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHByb3ApID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluZGV4IGFjY2Vzc29yXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wLm1hdGNoKC9eWzAtOV0rJC8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGdldE51bWJlcihwcm9wLCBcIiVpbmRleFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm91dCBvZiByZXN1bHQgcmFuZ2VcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gdGFyZ2V0W2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBpbmRleCAke2luZGV4fWAsIGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUGFzcyBpbXBvcnRhbnQgY2hlY2tzIChsaWtlIGB0aGVuYCBmb3IgUHJvbWlzZSkgdGhyb3VnaFxuICAgICAgICAgICAgICAgICAgICBpZiAocGFzc1Byb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0YXJnZXRbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgZnVuY3Rpb25zIHdvcmsgd2l0aCBwcml2YXRlIHZhcmlhYmxlc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9Qcm94eSNub19wcml2YXRlX3Byb3BlcnR5X2ZvcndhcmRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5hcHBseSgodGhpcyA9PT0gcmVjZWl2ZXIpID8gdGFyZ2V0IDogdGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCEocHJvcCBpbiB0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3NzaWJsZSBuYW1lIGFjY2Vzc29yXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmdldFZhbHVlLmFwcGx5KCh0aGlzID09PSByZWNlaXZlcikgPyB0YXJnZXQgOiB0aGlzLCBbcHJvcF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHNldE5hbWVzKHByb3h5LCBnZXROYW1lcyh0aGlzKSk7XG4gICAgICAgIHJldHVybiBwcm94eTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIFJlc3VsdCBhcyBhIG5vcm1hbCBBcnJheS4gSWYgJSVkZWVwJSUsIGFueSBjaGlsZHJlblxuICAgICAqICB3aGljaCBhcmUgUmVzdWx0IG9iamVjdHMgYXJlIGFsc28gY29udmVydGVkIHRvIGEgbm9ybWFsIEFycmF5LlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCB0aHJvdyBpZiB0aGVyZSBhcmUgYW55IG91dHN0YW5kaW5nIGRlZmVycmVkXG4gICAgICogIGVycm9ycy5cbiAgICAgKi9cbiAgICB0b0FycmF5KGRlZXApIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIHRoaXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBpbmRleCAke2luZGV4fWAsIGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlZXAgJiYgaXRlbSBpbnN0YW5jZW9mIFJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSBpdGVtLnRvQXJyYXkoZGVlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBSZXN1bHQgYXMgYW4gT2JqZWN0IHdpdGggZWFjaCBuYW1lLXZhbHVlIHBhaXIuIElmXG4gICAgICogICUlZGVlcCUlLCBhbnkgY2hpbGRyZW4gd2hpY2ggYXJlIFJlc3VsdCBvYmplY3RzIGFyZSBhbHNvXG4gICAgICogIGNvbnZlcnRlZCB0byBhbiBPYmplY3QuXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIHRocm93IGlmIGFueSB2YWx1ZSBpcyB1bm5hbWVkLCBvciBpZiB0aGVyZSBhcmVcbiAgICAgKiAgYW55IG91dHN0YW5kaW5nIGRlZmVycmVkIGVycm9ycy5cbiAgICAgKi9cbiAgICB0b09iamVjdChkZWVwKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gZ2V0TmFtZXModGhpcyk7XG4gICAgICAgIHJldHVybiBuYW1lcy5yZWR1Y2UoKGFjY3VtLCBuYW1lLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgYXNzZXJ0KG5hbWUgIT0gbnVsbCwgYHZhbHVlIGF0IGluZGV4ICR7aW5kZXh9IHVubmFtZWRgLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInRvT2JqZWN0KClcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdG9PYmplY3QobmFtZXMsIHRoaXMsIGRlZXApO1xuICAgICAgICB9LCB7fSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZVxuICAgICAqL1xuICAgIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICBzdGFydCArPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgICAgICAgZW5kICs9IHRoaXMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgICAgICAgICBlbmQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgX25hbWVzID0gZ2V0TmFtZXModGhpcyk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdLCBuYW1lcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpc1tpXSk7XG4gICAgICAgICAgICBuYW1lcy5wdXNoKF9uYW1lc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHQoX2d1YXJkLCByZXN1bHQsIG5hbWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlXG4gICAgICovXG4gICAgZmlsdGVyKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAgIGNvbnN0IF9uYW1lcyA9IGdldE5hbWVzKHRoaXMpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXSwgbmFtZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpc1tpXTtcbiAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBpbmRleCAke2l9YCwgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2suY2FsbCh0aGlzQXJnLCBpdGVtLCBpLCB0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIG5hbWVzLnB1c2goX25hbWVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlc3VsdChfZ3VhcmQsIHJlc3VsdCwgbmFtZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmVcbiAgICAgKi9cbiAgICBtYXAoY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXNbaV07XG4gICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgaW5kZXggJHtpfWAsIGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goY2FsbGJhY2suY2FsbCh0aGlzQXJnLCBpdGVtLCBpLCB0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHZhbHVlIGZvciAlJW5hbWUlJS5cbiAgICAgKlxuICAgICAqICBTaW5jZSBpdCBpcyBwb3NzaWJsZSB0byBoYXZlIGEga2V5IHdob3NlIG5hbWUgY29uZmxpY3RzIHdpdGhcbiAgICAgKiAgYSBtZXRob2Qgb24gYSBbW1Jlc3VsdF1dIG9yIGl0cyBzdXBlcmNsYXNzIEFycmF5LCBvciBhbnlcbiAgICAgKiAgSmF2YVNjcmlwdCBrZXl3b3JkLCB0aGlzIGVuc3VyZXMgYWxsIG5hbWVkIHZhbHVlcyBhcmUgc3RpbGxcbiAgICAgKiAgYWNjZXNzaWJsZSBieSBuYW1lLlxuICAgICAqL1xuICAgIGdldFZhbHVlKG5hbWUpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBnZXROYW1lcyh0aGlzKS5pbmRleE9mKG5hbWUpO1xuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpc1tpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBwcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KG5hbWUpfWAsIHZhbHVlLmVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IFtbUmVzdWx0XV0gZm9yICUlaXRlbXMlJSB3aXRoIGVhY2ggZW50cnlcbiAgICAgKiAgYWxzbyBhY2Nlc3NpYmxlIGJ5IGl0cyBjb3JyZXNwb25kaW5nIG5hbWUgaW4gJSVrZXlzJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21JdGVtcyhpdGVtcywga2V5cykge1xuICAgICAgICByZXR1cm4gbmV3IFJlc3VsdChfZ3VhcmQsIGl0ZW1zLCBrZXlzKTtcbiAgICB9XG59XG4vKipcbiAqICBSZXR1cm5zIGFsbCBlcnJvcnMgZm91bmQgaW4gYSBbW1Jlc3VsdF1dLlxuICpcbiAqICBTaW5jZSBjZXJ0YWluIGVycm9ycyBlbmNvdW50ZXJlZCB3aGVuIGNyZWF0aW5nIGEgW1tSZXN1bHRdXSBkb1xuICogIG5vdCBpbXBhY3QgdGhlIGFiaWxpdHkgdG8gY29udGludWUgcGFyc2luZyBkYXRhLCB0aGV5IGFyZVxuICogIGRlZmVycmVkIHVudGlsIHRoZXkgYXJlIGFjdHVhbGx5IGFjY2Vzc2VkLiBIZW5jZSBhIGZhdWx0eSBzdHJpbmdcbiAqICBpbiBhbiBFdmVudCB0aGF0IGlzIG5ldmVyIHVzZWQgZG9lcyBub3QgaW1wYWN0IHRoZSBwcm9ncmFtIGZsb3cuXG4gKlxuICogIEhvd2V2ZXIsIHNvbWV0aW1lcyBpdCBtYXkgYmUgdXNlZnVsIHRvIGFjY2VzcywgaWRlbnRpZnkgb3JcbiAqICB2YWxpZGF0ZSBjb3JyZWN0bmVzcyBvZiBhIFtbUmVzdWx0XV0uXG4gKlxuICogIEBfZG9jbG9jIGFwaS9hYmlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrUmVzdWx0RXJyb3JzKHJlc3VsdCkge1xuICAgIC8vIEZpbmQgdGhlIGZpcnN0IGVycm9yIChpZiBhbnkpXG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgY29uc3QgY2hlY2tFcnJvcnMgPSBmdW5jdGlvbiAocGF0aCwgb2JqZWN0KSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRQYXRoID0gcGF0aC5zbGljZSgpO1xuICAgICAgICAgICAgY2hpbGRQYXRoLnB1c2goa2V5KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2hlY2tFcnJvcnMoY2hpbGRQYXRoLCBvYmplY3Rba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7IHBhdGg6IGNoaWxkUGF0aCwgZXJyb3I6IGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjaGVja0Vycm9ycyhbXSwgcmVzdWx0KTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZnVuY3Rpb24gZ2V0VmFsdWUodmFsdWUpIHtcbiAgICBsZXQgYnl0ZXMgPSB0b0JlQXJyYXkodmFsdWUpO1xuICAgIGFzc2VydChieXRlcy5sZW5ndGggPD0gV29yZFNpemUsIFwidmFsdWUgb3V0LW9mLWJvdW5kc1wiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHsgYnVmZmVyOiBieXRlcywgbGVuZ3RoOiBXb3JkU2l6ZSwgb2Zmc2V0OiBieXRlcy5sZW5ndGggfSk7XG4gICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gV29yZFNpemUpIHtcbiAgICAgICAgYnl0ZXMgPSBnZXRCeXRlc0NvcHkoY29uY2F0KFtQYWRkaW5nLnNsaWNlKGJ5dGVzLmxlbmd0aCAlIFdvcmRTaXplKSwgYnl0ZXNdKSk7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn1cbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBDb2RlciB7XG4gICAgLy8gVGhlIGNvZGVyIG5hbWU6XG4gICAgLy8gICAtIGFkZHJlc3MsIHVpbnQyNTYsIHR1cGxlLCBhcnJheSwgZXRjLlxuICAgIG5hbWU7XG4gICAgLy8gVGhlIGZ1bGx5IGV4cGFuZGVkIHR5cGUsIGluY2x1ZGluZyBjb21wb3NpdGUgdHlwZXM6XG4gICAgLy8gICAtIGFkZHJlc3MsIHVpbnQyNTYsIHR1cGxlKGFkZHJlc3MsYnl0ZXMpLCB1aW50MjU2WzNdWzRdW10sICBldGMuXG4gICAgdHlwZTtcbiAgICAvLyBUaGUgbG9jYWxOYW1lIGJvdW5kIGluIHRoZSBzaWduYXR1cmUsIGluIHRoaXMgZXhhbXBsZSBpdCBpcyBcImJhelwiOlxuICAgIC8vICAgLSB0dXBsZShhZGRyZXNzIGZvbywgdWludCBiYXIpIGJhelxuICAgIGxvY2FsTmFtZTtcbiAgICAvLyBXaGV0aGVyIHRoaXMgdHlwZSBpcyBkeW5hbWljOlxuICAgIC8vICAtIER5bmFtaWM6IGJ5dGVzLCBzdHJpbmcsIGFkZHJlc3NbXSwgdHVwbGUoYm9vbGVhbltdKSwgZXRjLlxuICAgIC8vICAtIE5vdCBEeW5hbWljOiBhZGRyZXNzLCB1aW50MjU2LCBib29sZWFuWzNdLCB0dXBsZShhZGRyZXNzLCB1aW50OClcbiAgICBkeW5hbWljO1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHR5cGUsIGxvY2FsTmFtZSwgZHluYW1pYykge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgbmFtZSwgdHlwZSwgbG9jYWxOYW1lLCBkeW5hbWljIH0sIHtcbiAgICAgICAgICAgIG5hbWU6IFwic3RyaW5nXCIsIHR5cGU6IFwic3RyaW5nXCIsIGxvY2FsTmFtZTogXCJzdHJpbmdcIiwgZHluYW1pYzogXCJib29sZWFuXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF90aHJvd0Vycm9yKG1lc3NhZ2UsIHZhbHVlKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBtZXNzYWdlLCB0aGlzLmxvY2FsTmFtZSwgdmFsdWUpO1xuICAgIH1cbn1cbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBXcml0ZXIge1xuICAgIC8vIEFuIGFycmF5IG9mIFdvcmRTaXplIGxlbmd0aGVkIG9iamVjdHMgdG8gY29uY2F0ZW5hdGlvblxuICAgICNkYXRhO1xuICAgICNkYXRhTGVuZ3RoO1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLiNkYXRhID0gW107XG4gICAgICAgIHRoaXMuI2RhdGFMZW5ndGggPSAwO1xuICAgIH1cbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIGNvbmNhdCh0aGlzLiNkYXRhKTtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuI2RhdGFMZW5ndGg7IH1cbiAgICAjd3JpdGVEYXRhKGRhdGEpIHtcbiAgICAgICAgdGhpcy4jZGF0YS5wdXNoKGRhdGEpO1xuICAgICAgICB0aGlzLiNkYXRhTGVuZ3RoICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICByZXR1cm4gZGF0YS5sZW5ndGg7XG4gICAgfVxuICAgIGFwcGVuZFdyaXRlcih3cml0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3dyaXRlRGF0YShnZXRCeXRlc0NvcHkod3JpdGVyLmRhdGEpKTtcbiAgICB9XG4gICAgLy8gQXJyYXlpc2ggaXRlbTsgcGFkIG9uIHRoZSByaWdodCB0byAqbmVhcmVzdCogV29yZFNpemVcbiAgICB3cml0ZUJ5dGVzKHZhbHVlKSB7XG4gICAgICAgIGxldCBieXRlcyA9IGdldEJ5dGVzQ29weSh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHBhZGRpbmdPZmZzZXQgPSBieXRlcy5sZW5ndGggJSBXb3JkU2l6ZTtcbiAgICAgICAgaWYgKHBhZGRpbmdPZmZzZXQpIHtcbiAgICAgICAgICAgIGJ5dGVzID0gZ2V0Qnl0ZXNDb3B5KGNvbmNhdChbYnl0ZXMsIFBhZGRpbmcuc2xpY2UocGFkZGluZ09mZnNldCldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuI3dyaXRlRGF0YShieXRlcyk7XG4gICAgfVxuICAgIC8vIE51bWVyaWMgaXRlbTsgcGFkIG9uIHRoZSBsZWZ0ICp0byogV29yZFNpemVcbiAgICB3cml0ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiN3cml0ZURhdGEoZ2V0VmFsdWUodmFsdWUpKTtcbiAgICB9XG4gICAgLy8gSW5zZXJ0cyBhIG51bWVyaWMgcGxhY2UtaG9sZGVyLCByZXR1cm5pbmcgYSBjYWxsYmFjayB0aGF0IGNhblxuICAgIC8vIGJlIHVzZWQgdG8gYXNqdXN0IHRoZSB2YWx1ZSBsYXRlclxuICAgIHdyaXRlVXBkYXRhYmxlVmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuI2RhdGEubGVuZ3RoO1xuICAgICAgICB0aGlzLiNkYXRhLnB1c2goUGFkZGluZyk7XG4gICAgICAgIHRoaXMuI2RhdGFMZW5ndGggKz0gV29yZFNpemU7XG4gICAgICAgIHJldHVybiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuI2RhdGFbb2Zmc2V0XSA9IGdldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgUmVhZGVyIHtcbiAgICAvLyBBbGxvd3MgaW5jb21wbGV0ZSB1bnBhZGRlZCBkYXRhIHRvIGJlIHJlYWQ7IG90aGVyd2lzZSBhbiBlcnJvclxuICAgIC8vIGlzIHJhaXNlZCBpZiBhdHRlbXB0aW5nIHRvIG92ZXJydW4gdGhlIGJ1ZmZlci4gVGhpcyBpcyByZXF1aXJlZFxuICAgIC8vIHRvIGRlYWwgd2l0aCBhbiBvbGQgU29saWRpdHkgYnVnLCBpbiB3aGljaCBldmVudCBkYXRhIGZvclxuICAgIC8vIGV4dGVybmFsIChub3QgcHVibGljIHRob2d1aCkgd2FzIHRpZ2h0bHkgcGFja2VkLlxuICAgIGFsbG93TG9vc2U7XG4gICAgI2RhdGE7XG4gICAgI29mZnNldDtcbiAgICAjYnl0ZXNSZWFkO1xuICAgICNwYXJlbnQ7XG4gICAgI21heEluZmxhdGlvbjtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBhbGxvd0xvb3NlLCBtYXhJbmZsYXRpb24pIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGFsbG93TG9vc2U6ICEhYWxsb3dMb29zZSB9KTtcbiAgICAgICAgdGhpcy4jZGF0YSA9IGdldEJ5dGVzQ29weShkYXRhKTtcbiAgICAgICAgdGhpcy4jYnl0ZXNSZWFkID0gMDtcbiAgICAgICAgdGhpcy4jcGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy4jbWF4SW5mbGF0aW9uID0gKG1heEluZmxhdGlvbiAhPSBudWxsKSA/IG1heEluZmxhdGlvbiA6IDEwMjQ7XG4gICAgICAgIHRoaXMuI29mZnNldCA9IDA7XG4gICAgfVxuICAgIGdldCBkYXRhKCkgeyByZXR1cm4gaGV4bGlmeSh0aGlzLiNkYXRhKTsgfVxuICAgIGdldCBkYXRhTGVuZ3RoKCkgeyByZXR1cm4gdGhpcy4jZGF0YS5sZW5ndGg7IH1cbiAgICBnZXQgY29uc3VtZWQoKSB7IHJldHVybiB0aGlzLiNvZmZzZXQ7IH1cbiAgICBnZXQgYnl0ZXMoKSB7IHJldHVybiBuZXcgVWludDhBcnJheSh0aGlzLiNkYXRhKTsgfVxuICAgICNpbmNyZW1lbnRCeXRlc1JlYWQoY291bnQpIHtcbiAgICAgICAgaWYgKHRoaXMuI3BhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3BhcmVudC4jaW5jcmVtZW50Qnl0ZXNSZWFkKGNvdW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNieXRlc1JlYWQgKz0gY291bnQ7XG4gICAgICAgIC8vIENoZWNrIGZvciBleGNlc3NpdmUgaW5mbGF0aW9uIChzZWU6ICM0NTM3KVxuICAgICAgICBhc3NlcnQodGhpcy4jbWF4SW5mbGF0aW9uIDwgMSB8fCB0aGlzLiNieXRlc1JlYWQgPD0gdGhpcy4jbWF4SW5mbGF0aW9uICogdGhpcy5kYXRhTGVuZ3RoLCBgY29tcHJlc3NlZCBBQkkgZGF0YSBleGNlZWRzIGluZmxhdGlvbiByYXRpbyBvZiAke3RoaXMuI21heEluZmxhdGlvbn0gKCBzZWU6IGh0dHBzOi9cXC9naXRodWIuY29tL2V0aGVycy1pby9ldGhlcnMuanMvaXNzdWVzLzQ1MzcgKWAsIFwiQlVGRkVSX09WRVJSVU5cIiwge1xuICAgICAgICAgICAgYnVmZmVyOiBnZXRCeXRlc0NvcHkodGhpcy4jZGF0YSksIG9mZnNldDogdGhpcy4jb2Zmc2V0LFxuICAgICAgICAgICAgbGVuZ3RoOiBjb3VudCwgaW5mbzoge1xuICAgICAgICAgICAgICAgIGJ5dGVzUmVhZDogdGhpcy4jYnl0ZXNSZWFkLFxuICAgICAgICAgICAgICAgIGRhdGFMZW5ndGg6IHRoaXMuZGF0YUxlbmd0aFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgI3BlZWtCeXRlcyhvZmZzZXQsIGxlbmd0aCwgbG9vc2UpIHtcbiAgICAgICAgbGV0IGFsaWduZWRMZW5ndGggPSBNYXRoLmNlaWwobGVuZ3RoIC8gV29yZFNpemUpICogV29yZFNpemU7XG4gICAgICAgIGlmICh0aGlzLiNvZmZzZXQgKyBhbGlnbmVkTGVuZ3RoID4gdGhpcy4jZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFsbG93TG9vc2UgJiYgbG9vc2UgJiYgdGhpcy4jb2Zmc2V0ICsgbGVuZ3RoIDw9IHRoaXMuI2RhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYWxpZ25lZExlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJkYXRhIG91dC1vZi1ib3VuZHNcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcjogZ2V0Qnl0ZXNDb3B5KHRoaXMuI2RhdGEpLFxuICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IHRoaXMuI2RhdGEubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMuI29mZnNldCArIGFsaWduZWRMZW5ndGhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jZGF0YS5zbGljZSh0aGlzLiNvZmZzZXQsIHRoaXMuI29mZnNldCArIGFsaWduZWRMZW5ndGgpO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgYSBzdWItcmVhZGVyIHdpdGggdGhlIHNhbWUgdW5kZXJseWluZyBkYXRhLCBidXQgb2Zmc2V0XG4gICAgc3ViUmVhZGVyKG9mZnNldCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgUmVhZGVyKHRoaXMuI2RhdGEuc2xpY2UodGhpcy4jb2Zmc2V0ICsgb2Zmc2V0KSwgdGhpcy5hbGxvd0xvb3NlLCB0aGlzLiNtYXhJbmZsYXRpb24pO1xuICAgICAgICByZWFkZXIuI3BhcmVudCA9IHRoaXM7XG4gICAgICAgIHJldHVybiByZWFkZXI7XG4gICAgfVxuICAgIC8vIFJlYWQgYnl0ZXNcbiAgICByZWFkQnl0ZXMobGVuZ3RoLCBsb29zZSkge1xuICAgICAgICBsZXQgYnl0ZXMgPSB0aGlzLiNwZWVrQnl0ZXMoMCwgbGVuZ3RoLCAhIWxvb3NlKTtcbiAgICAgICAgdGhpcy4jaW5jcmVtZW50Qnl0ZXNSZWFkKGxlbmd0aCk7XG4gICAgICAgIHRoaXMuI29mZnNldCArPSBieXRlcy5sZW5ndGg7XG4gICAgICAgIC8vIEBUT0RPOiBNYWtlIHN1cmUgdGhlIGxlbmd0aC4uZW5kIGJ5dGVzIGFyZSBhbGwgMD9cbiAgICAgICAgcmV0dXJuIGJ5dGVzLnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgfVxuICAgIC8vIFJlYWQgYSBudW1lcmljIHZhbHVlc1xuICAgIHJlYWRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRvQmlnSW50KHRoaXMucmVhZEJ5dGVzKFdvcmRTaXplKSk7XG4gICAgfVxuICAgIHJlYWRJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRvTnVtYmVyKHRoaXMucmVhZEJ5dGVzKFdvcmRTaXplKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWJzdHJhY3QtY29kZXIuanMubWFwIl0sIm5hbWVzIjpbImRlZmluZVByb3BlcnRpZXMiLCJjb25jYXQiLCJnZXRCeXRlc0NvcHkiLCJnZXROdW1iZXIiLCJoZXhsaWZ5IiwidG9CZUFycmF5IiwidG9CaWdJbnQiLCJ0b051bWJlciIsImFzc2VydCIsImFzc2VydEFyZ3VtZW50IiwiV29yZFNpemUiLCJQYWRkaW5nIiwiVWludDhBcnJheSIsInBhc3NQcm9wZXJ0aWVzIiwiX2d1YXJkIiwicmVzdWx0TmFtZXMiLCJXZWFrTWFwIiwiZ2V0TmFtZXMiLCJyZXN1bHQiLCJnZXQiLCJzZXROYW1lcyIsIm5hbWVzIiwic2V0IiwidGhyb3dFcnJvciIsIm5hbWUiLCJlcnJvciIsIndyYXBwZWQiLCJFcnJvciIsInRvT2JqZWN0IiwiaXRlbXMiLCJkZWVwIiwiaW5kZXhPZiIsIm1hcCIsIml0ZW0iLCJpbmRleCIsIlJlc3VsdCIsInJlZHVjZSIsImFjY3VtIiwiZ2V0VmFsdWUiLCJBcnJheSIsInRvQXJyYXkiLCJmb3JFYWNoIiwicHVzaCIsIm9wZXJhdGlvbiIsInNsaWNlIiwic3RhcnQiLCJlbmQiLCJsZW5ndGgiLCJfbmFtZXMiLCJpIiwiZmlsdGVyIiwiY2FsbGJhY2siLCJ0aGlzQXJnIiwiY2FsbCIsInVuZGVmaW5lZCIsInZhbHVlIiwiSlNPTiIsInN0cmluZ2lmeSIsImZyb21JdGVtcyIsImtleXMiLCJjb25zdHJ1Y3RvciIsImFyZ3MiLCJndWFyZCIsIndyYXAiLCJuYW1lQ291bnRzIiwiTWFwIiwiT2JqZWN0IiwiZnJlZXplIiwicHJveHkiLCJQcm94eSIsInRhcmdldCIsInByb3AiLCJyZWNlaXZlciIsIm1hdGNoIiwiUmFuZ2VFcnJvciIsIlJlZmxlY3QiLCJGdW5jdGlvbiIsImFwcGx5IiwiY2hlY2tSZXN1bHRFcnJvcnMiLCJlcnJvcnMiLCJjaGVja0Vycm9ycyIsInBhdGgiLCJvYmplY3QiLCJpc0FycmF5Iiwia2V5IiwiY2hpbGRQYXRoIiwiYnl0ZXMiLCJidWZmZXIiLCJvZmZzZXQiLCJDb2RlciIsIl90aHJvd0Vycm9yIiwibWVzc2FnZSIsImxvY2FsTmFtZSIsInR5cGUiLCJkeW5hbWljIiwiV3JpdGVyIiwiZGF0YSIsImRhdGFMZW5ndGgiLCJhcHBlbmRXcml0ZXIiLCJ3cml0ZXIiLCJ3cml0ZURhdGEiLCJ3cml0ZUJ5dGVzIiwicGFkZGluZ09mZnNldCIsIndyaXRlVmFsdWUiLCJ3cml0ZVVwZGF0YWJsZVZhbHVlIiwiUmVhZGVyIiwiY29uc3VtZWQiLCJzdWJSZWFkZXIiLCJyZWFkZXIiLCJhbGxvd0xvb3NlIiwibWF4SW5mbGF0aW9uIiwicGFyZW50IiwicmVhZEJ5dGVzIiwibG9vc2UiLCJwZWVrQnl0ZXMiLCJpbmNyZW1lbnRCeXRlc1JlYWQiLCJyZWFkVmFsdWUiLCJyZWFkSW5kZXgiLCJieXRlc1JlYWQiLCJjb3VudCIsImluZm8iLCJhbGlnbmVkTGVuZ3RoIiwiTWF0aCIsImNlaWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/address.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/address.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressCoder: function() { return /* binding */ AddressCoder; }\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../address/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _utils_maths_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/maths.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../typed.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n\n\n\n/**\n *  @_ignore\n */ class AddressCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    defaultValue() {\n        return \"0x0000000000000000000000000000000000000000\";\n    }\n    encode(writer, _value) {\n        let value = _typed_js__WEBPACK_IMPORTED_MODULE_1__.Typed.dereference(_value, \"string\");\n        try {\n            value = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress)(value);\n        } catch (error) {\n            return this._throwError(error.message, _value);\n        }\n        return writer.writeValue(value);\n    }\n    decode(reader) {\n        return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress)((0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_3__.toBeHex)(reader.readValue(), 20));\n    }\n    constructor(localName){\n        super(\"address\", \"address\", localName, false);\n    }\n} //# sourceMappingURL=address.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2FkZHJlc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBb0Q7QUFDTDtBQUNYO0FBQ1E7QUFDNUM7O0NBRUMsR0FDTSxNQUFNSSxxQkFBcUJELHFEQUFLQTtJQUluQ0UsZUFBZTtRQUNYLE9BQU87SUFDWDtJQUNBQyxPQUFPQyxNQUFNLEVBQUVDLE1BQU0sRUFBRTtRQUNuQixJQUFJQyxRQUFRUCw0Q0FBS0EsQ0FBQ1EsV0FBVyxDQUFDRixRQUFRO1FBQ3RDLElBQUk7WUFDQUMsUUFBUVQsNkRBQVVBLENBQUNTO1FBQ3ZCLEVBQ0EsT0FBT0UsT0FBTztZQUNWLE9BQU8sSUFBSSxDQUFDQyxXQUFXLENBQUNELE1BQU1FLE9BQU8sRUFBRUw7UUFDM0M7UUFDQSxPQUFPRCxPQUFPTyxVQUFVLENBQUNMO0lBQzdCO0lBQ0FNLE9BQU9DLE1BQU0sRUFBRTtRQUNYLE9BQU9oQiw2REFBVUEsQ0FBQ0Msd0RBQU9BLENBQUNlLE9BQU9DLFNBQVMsSUFBSTtJQUNsRDtJQWxCQUMsWUFBWUMsU0FBUyxDQUFFO1FBQ25CLEtBQUssQ0FBQyxXQUFXLFdBQVdBLFdBQVc7SUFDM0M7QUFpQkosRUFDQSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvYWRkcmVzcy5qcz9jYTg2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi4vLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgdG9CZUhleCB9IGZyb20gXCIuLi8uLi91dGlscy9tYXRocy5qc1wiO1xuaW1wb3J0IHsgVHlwZWQgfSBmcm9tIFwiLi4vdHlwZWQuanNcIjtcbmltcG9ydCB7IENvZGVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXIuanNcIjtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBBZGRyZXNzQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29uc3RydWN0b3IobG9jYWxOYW1lKSB7XG4gICAgICAgIHN1cGVyKFwiYWRkcmVzc1wiLCBcImFkZHJlc3NcIiwgbG9jYWxOYW1lLCBmYWxzZSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIF92YWx1ZSkge1xuICAgICAgICBsZXQgdmFsdWUgPSBUeXBlZC5kZXJlZmVyZW5jZShfdmFsdWUsIFwic3RyaW5nXCIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFsdWUgPSBnZXRBZGRyZXNzKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90aHJvd0Vycm9yKGVycm9yLm1lc3NhZ2UsIF92YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZVZhbHVlKHZhbHVlKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gZ2V0QWRkcmVzcyh0b0JlSGV4KHJlYWRlci5yZWFkVmFsdWUoKSwgMjApKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRyZXNzLmpzLm1hcCJdLCJuYW1lcyI6WyJnZXRBZGRyZXNzIiwidG9CZUhleCIsIlR5cGVkIiwiQ29kZXIiLCJBZGRyZXNzQ29kZXIiLCJkZWZhdWx0VmFsdWUiLCJlbmNvZGUiLCJ3cml0ZXIiLCJfdmFsdWUiLCJ2YWx1ZSIsImRlcmVmZXJlbmNlIiwiZXJyb3IiLCJfdGhyb3dFcnJvciIsIm1lc3NhZ2UiLCJ3cml0ZVZhbHVlIiwiZGVjb2RlIiwicmVhZGVyIiwicmVhZFZhbHVlIiwiY29uc3RydWN0b3IiLCJsb2NhbE5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/address.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/anonymous.js":
/*!*************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/anonymous.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnonymousCoder: function() { return /* binding */ AnonymousCoder; }\n/* harmony export */ });\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n/**\n *  Clones the functionality of an existing Coder, but without a localName\n *\n *  @_ignore\n */ class AnonymousCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    defaultValue() {\n        return this.coder.defaultValue();\n    }\n    encode(writer, value) {\n        return this.coder.encode(writer, value);\n    }\n    decode(reader) {\n        return this.coder.decode(reader);\n    }\n    constructor(coder){\n        super(coder.name, coder.type, \"_\", coder.dynamic);\n        this.coder = coder;\n    }\n} //# sourceMappingURL=anonymous.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2Fub255bW91cy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE0QztBQUM1Qzs7OztDQUlDLEdBQ00sTUFBTUMsdUJBQXVCRCxxREFBS0E7SUFNckNFLGVBQWU7UUFDWCxPQUFPLElBQUksQ0FBQ0MsS0FBSyxDQUFDRCxZQUFZO0lBQ2xDO0lBQ0FFLE9BQU9DLE1BQU0sRUFBRUMsS0FBSyxFQUFFO1FBQ2xCLE9BQU8sSUFBSSxDQUFDSCxLQUFLLENBQUNDLE1BQU0sQ0FBQ0MsUUFBUUM7SUFDckM7SUFDQUMsT0FBT0MsTUFBTSxFQUFFO1FBQ1gsT0FBTyxJQUFJLENBQUNMLEtBQUssQ0FBQ0ksTUFBTSxDQUFDQztJQUM3QjtJQVpBQyxZQUFZTixLQUFLLENBQUU7UUFDZixLQUFLLENBQUNBLE1BQU1PLElBQUksRUFBRVAsTUFBTVEsSUFBSSxFQUFFLEtBQUtSLE1BQU1TLE9BQU87UUFDaEQsSUFBSSxDQUFDVCxLQUFLLEdBQUdBO0lBQ2pCO0FBVUosRUFDQSxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvYW5vbnltb3VzLmpzP2Q0YjkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuLyoqXG4gKiAgQ2xvbmVzIHRoZSBmdW5jdGlvbmFsaXR5IG9mIGFuIGV4aXN0aW5nIENvZGVyLCBidXQgd2l0aG91dCBhIGxvY2FsTmFtZVxuICpcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgQW5vbnltb3VzQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29kZXI7XG4gICAgY29uc3RydWN0b3IoY29kZXIpIHtcbiAgICAgICAgc3VwZXIoY29kZXIubmFtZSwgY29kZXIudHlwZSwgXCJfXCIsIGNvZGVyLmR5bmFtaWMpO1xuICAgICAgICB0aGlzLmNvZGVyID0gY29kZXI7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZXIuZGVmYXVsdFZhbHVlKCk7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZGVyLmVuY29kZSh3cml0ZXIsIHZhbHVlKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2Rlci5kZWNvZGUocmVhZGVyKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbm9ueW1vdXMuanMubWFwIl0sIm5hbWVzIjpbIkNvZGVyIiwiQW5vbnltb3VzQ29kZXIiLCJkZWZhdWx0VmFsdWUiLCJjb2RlciIsImVuY29kZSIsIndyaXRlciIsInZhbHVlIiwiZGVjb2RlIiwicmVhZGVyIiwiY29uc3RydWN0b3IiLCJuYW1lIiwidHlwZSIsImR5bmFtaWMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/anonymous.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/array.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/array.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArrayCoder: function() { return /* binding */ ArrayCoder; },\n/* harmony export */   pack: function() { return /* binding */ pack; },\n/* harmony export */   unpack: function() { return /* binding */ unpack; }\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../typed.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./abstract-coder.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n/* harmony import */ var _anonymous_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./anonymous.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/anonymous.js\");\n\n\n\n\n/**\n *  @_ignore\n */ function pack(writer, coders, values) {\n    let arrayValues = [];\n    if (Array.isArray(values)) {\n        arrayValues = values;\n    } else if (values && typeof values === \"object\") {\n        let unique = {};\n        arrayValues = coders.map((coder)=>{\n            const name = coder.localName;\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(name, \"cannot encode object for signature with missing names\", \"INVALID_ARGUMENT\", {\n                argument: \"values\",\n                info: {\n                    coder\n                },\n                value: values\n            });\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!unique[name], \"cannot encode object for signature with duplicate names\", \"INVALID_ARGUMENT\", {\n                argument: \"values\",\n                info: {\n                    coder\n                },\n                value: values\n            });\n            unique[name] = true;\n            return values[name];\n        });\n    } else {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid tuple value\", \"tuple\", values);\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(coders.length === arrayValues.length, \"types/value length mismatch\", \"tuple\", values);\n    let staticWriter = new _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.Writer();\n    let dynamicWriter = new _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.Writer();\n    let updateFuncs = [];\n    coders.forEach((coder, index)=>{\n        let value = arrayValues[index];\n        if (coder.dynamic) {\n            // Get current dynamic offset (for the future pointer)\n            let dynamicOffset = dynamicWriter.length;\n            // Encode the dynamic value into the dynamicWriter\n            coder.encode(dynamicWriter, value);\n            // Prepare to populate the correct offset once we are done\n            let updateFunc = staticWriter.writeUpdatableValue();\n            updateFuncs.push((baseOffset)=>{\n                updateFunc(baseOffset + dynamicOffset);\n            });\n        } else {\n            coder.encode(staticWriter, value);\n        }\n    });\n    // Backfill all the dynamic offsets, now that we know the static length\n    updateFuncs.forEach((func)=>{\n        func(staticWriter.length);\n    });\n    let length = writer.appendWriter(staticWriter);\n    length += writer.appendWriter(dynamicWriter);\n    return length;\n}\n/**\n *  @_ignore\n */ function unpack(reader, coders) {\n    let values = [];\n    let keys = [];\n    // A reader anchored to this base\n    let baseReader = reader.subReader(0);\n    coders.forEach((coder)=>{\n        let value = null;\n        if (coder.dynamic) {\n            let offset = reader.readIndex();\n            let offsetReader = baseReader.subReader(offset);\n            try {\n                value = coder.decode(offsetReader);\n            } catch (error) {\n                // Cannot recover from this\n                if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"BUFFER_OVERRUN\")) {\n                    throw error;\n                }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        } else {\n            try {\n                value = coder.decode(reader);\n            } catch (error) {\n                // Cannot recover from this\n                if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"BUFFER_OVERRUN\")) {\n                    throw error;\n                }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        }\n        if (value == undefined) {\n            throw new Error(\"investigate\");\n        }\n        values.push(value);\n        keys.push(coder.localName || null);\n    });\n    return _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.Result.fromItems(values, keys);\n}\n/**\n *  @_ignore\n */ class ArrayCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.Coder {\n    defaultValue() {\n        // Verifies the child coder is valid (even if the array is dynamic or 0-length)\n        const defaultChild = this.coder.defaultValue();\n        const result = [];\n        for(let i = 0; i < this.length; i++){\n            result.push(defaultChild);\n        }\n        return result;\n    }\n    encode(writer, _value) {\n        const value = _typed_js__WEBPACK_IMPORTED_MODULE_2__.Typed.dereference(_value, \"array\");\n        if (!Array.isArray(value)) {\n            this._throwError(\"expected array value\", value);\n        }\n        let count = this.length;\n        if (count === -1) {\n            count = value.length;\n            writer.writeValue(value.length);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgumentCount)(value.length, count, \"coder array\" + (this.localName ? \" \" + this.localName : \"\"));\n        let coders = [];\n        for(let i = 0; i < value.length; i++){\n            coders.push(this.coder);\n        }\n        return pack(writer, coders, value);\n    }\n    decode(reader) {\n        let count = this.length;\n        if (count === -1) {\n            count = reader.readIndex();\n            // Check that there is *roughly* enough data to ensure\n            // stray random data is not being read as a length. Each\n            // slot requires at least 32 bytes for their value (or 32\n            // bytes as a link to the data). This could use a much\n            // tighter bound, but we are erroring on the side of safety.\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(count * _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.WordSize <= reader.dataLength, \"insufficient data length\", \"BUFFER_OVERRUN\", {\n                buffer: reader.bytes,\n                offset: count * _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.WordSize,\n                length: reader.dataLength\n            });\n        }\n        let coders = [];\n        for(let i = 0; i < count; i++){\n            coders.push(new _anonymous_js__WEBPACK_IMPORTED_MODULE_3__.AnonymousCoder(this.coder));\n        }\n        return unpack(reader, coders);\n    }\n    constructor(coder, length, localName){\n        const type = coder.type + \"[\" + (length >= 0 ? length : \"\") + \"]\";\n        const dynamic = length === -1 || coder.dynamic;\n        super(\"array\", type, localName, dynamic);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.defineProperties)(this, {\n            coder,\n            length\n        });\n    }\n} //# sourceMappingURL=array.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2FycmF5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQThHO0FBQzFFO0FBQ2tDO0FBQ3RCO0FBQ2hEOztDQUVDLEdBQ00sU0FBU1csS0FBS0MsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLE1BQU07SUFDdkMsSUFBSUMsY0FBYyxFQUFFO0lBQ3BCLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ0gsU0FBUztRQUN2QkMsY0FBY0Q7SUFDbEIsT0FDSyxJQUFJQSxVQUFVLE9BQVFBLFdBQVksVUFBVTtRQUM3QyxJQUFJSSxTQUFTLENBQUM7UUFDZEgsY0FBY0YsT0FBT00sR0FBRyxDQUFDLENBQUNDO1lBQ3RCLE1BQU1DLE9BQU9ELE1BQU1FLFNBQVM7WUFDNUJwQix1REFBTUEsQ0FBQ21CLE1BQU0seURBQXlELG9CQUFvQjtnQkFBRUUsVUFBVTtnQkFBVUMsTUFBTTtvQkFBRUo7Z0JBQU07Z0JBQUdLLE9BQU9YO1lBQU87WUFDL0laLHVEQUFNQSxDQUFDLENBQUNnQixNQUFNLENBQUNHLEtBQUssRUFBRSwyREFBMkQsb0JBQW9CO2dCQUFFRSxVQUFVO2dCQUFVQyxNQUFNO29CQUFFSjtnQkFBTTtnQkFBR0ssT0FBT1g7WUFBTztZQUMxSkksTUFBTSxDQUFDRyxLQUFLLEdBQUc7WUFDZixPQUFPUCxNQUFNLENBQUNPLEtBQUs7UUFDdkI7SUFDSixPQUNLO1FBQ0RsQiwrREFBY0EsQ0FBQyxPQUFPLHVCQUF1QixTQUFTVztJQUMxRDtJQUNBWCwrREFBY0EsQ0FBQ1UsT0FBT2EsTUFBTSxLQUFLWCxZQUFZVyxNQUFNLEVBQUUsK0JBQStCLFNBQVNaO0lBQzdGLElBQUlhLGVBQWUsSUFBSWxCLHNEQUFNQTtJQUM3QixJQUFJbUIsZ0JBQWdCLElBQUluQixzREFBTUE7SUFDOUIsSUFBSW9CLGNBQWMsRUFBRTtJQUNwQmhCLE9BQU9pQixPQUFPLENBQUMsQ0FBQ1YsT0FB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Qix5REFBY0EsQ0FBQyxJQUFJLENBQUNVLEtBQUs7UUFDN0M7UUFDQSxPQUFPcUIsT0FBT0MsUUFBUTdCO0lBQzFCO0lBaERBd0QsWUFBWWpELEtBQUssRUFBRU0sTUFBTSxFQUFFSixTQUFTLENBQUU7UUFDbEMsTUFBTThCLE9BQVFoQyxNQUFNZ0MsSUFBSSxHQUFHLE1BQU8xQixDQUFBQSxVQUFVLElBQUlBLFNBQVMsRUFBQyxJQUFLO1FBQy9ELE1BQU1NLFVBQVdOLFdBQVcsQ0FBQyxLQUFLTixNQUFNWSxPQUFPO1FBQy9DLEtBQUssQ0FBQyxTQUFTb0IsTUFBTTlCLFdBQVdVO1FBQ2hDaEMsaUVBQWdCQSxDQUFDLElBQUksRUFBRTtZQUFFb0I7WUFBT007UUFBTztJQUMzQztBQTRDSixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9hcnJheS5qcz9hOGJhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGlzRXJyb3IsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQsIGFzc2VydEFyZ3VtZW50Q291bnQgfSBmcm9tIFwiLi4vLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IFR5cGVkIH0gZnJvbSBcIi4uL3R5cGVkLmpzXCI7XG5pbXBvcnQgeyBDb2RlciwgUmVzdWx0LCBXb3JkU2l6ZSwgV3JpdGVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXIuanNcIjtcbmltcG9ydCB7IEFub255bW91c0NvZGVyIH0gZnJvbSBcIi4vYW5vbnltb3VzLmpzXCI7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFjayh3cml0ZXIsIGNvZGVycywgdmFsdWVzKSB7XG4gICAgbGV0IGFycmF5VmFsdWVzID0gW107XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICBhcnJheVZhbHVlcyA9IHZhbHVlcztcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWVzICYmIHR5cGVvZiAodmFsdWVzKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBsZXQgdW5pcXVlID0ge307XG4gICAgICAgIGFycmF5VmFsdWVzID0gY29kZXJzLm1hcCgoY29kZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG4gICAgICAgICAgICBhc3NlcnQobmFtZSwgXCJjYW5ub3QgZW5jb2RlIG9iamVjdCBmb3Igc2lnbmF0dXJlIHdpdGggbWlzc2luZyBuYW1lc1wiLCBcIklOVkFMSURfQVJHVU1FTlRcIiwgeyBhcmd1bWVudDogXCJ2YWx1ZXNcIiwgaW5mbzogeyBjb2RlciB9LCB2YWx1ZTogdmFsdWVzIH0pO1xuICAgICAgICAgICAgYXNzZXJ0KCF1bmlxdWVbbmFtZV0sIFwiY2Fubm90IGVuY29kZSBvYmplY3QgZm9yIHNpZ25hdHVyZSB3aXRoIGR1cGxpY2F0ZSBuYW1lc1wiLCBcIklOVkFMSURfQVJHVU1FTlRcIiwgeyBhcmd1bWVudDogXCJ2YWx1ZXNcIiwgaW5mbzogeyBjb2RlciB9LCB2YWx1ZTogdmFsdWVzIH0pO1xuICAgICAgICAgICAgdW5pcXVlW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXNbbmFtZV07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCB0dXBsZSB2YWx1ZVwiLCBcInR1cGxlXCIsIHZhbHVlcyk7XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KGNvZGVycy5sZW5ndGggPT09IGFycmF5VmFsdWVzLmxlbmd0aCwgXCJ0eXBlcy92YWx1ZSBsZW5ndGggbWlzbWF0Y2hcIiwgXCJ0dXBsZVwiLCB2YWx1ZXMpO1xuICAgIGxldCBzdGF0aWNXcml0ZXIgPSBuZXcgV3JpdGVyKCk7XG4gICAgbGV0IGR5bmFtaWNXcml0ZXIgPSBuZXcgV3JpdGVyKCk7XG4gICAgbGV0IHVwZGF0ZUZ1bmNzID0gW107XG4gICAgY29kZXJzLmZvckVhY2goKGNvZGVyLCBpbmRleCkgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSBhcnJheVZhbHVlc1tpbmRleF07XG4gICAgICAgIGlmIChjb2Rlci5keW5hbWljKSB7XG4gICAgICAgICAgICAvLyBHZXQgY3VycmVudCBkeW5hbWljIG9mZnNldCAoZm9yIHRoZSBmdXR1cmUgcG9pbnRlcilcbiAgICAgICAgICAgIGxldCBkeW5hbWljT2Zmc2V0ID0gZHluYW1pY1dyaXRlci5sZW5ndGg7XG4gICAgICAgICAgICAvLyBFbmNvZGUgdGhlIGR5bmFtaWMgdmFsdWUgaW50byB0aGUgZHluYW1pY1dyaXRlclxuICAgICAgICAgICAgY29kZXIuZW5jb2RlKGR5bmFtaWNXcml0ZXIsIHZhbHVlKTtcbiAgICAgICAgICAgIC8vIFByZXBhcmUgdG8gcG9wdWxhdGUgdGhlIGNvcnJlY3Qgb2Zmc2V0IG9uY2Ugd2UgYXJlIGRvbmVcbiAgICAgICAgICAgIGxldCB1cGRhdGVGdW5jID0gc3RhdGljV3JpdGVyLndyaXRlVXBkYXRhYmxlVmFsdWUoKTtcbiAgICAgICAgICAgIHVwZGF0ZUZ1bmNzLnB1c2goKGJhc2VPZmZzZXQpID0+IHtcbiAgICAgICAgICAgICAgICB1cGRhdGVGdW5jKGJhc2VPZmZzZXQgKyBkeW5hbWljT2Zmc2V0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29kZXIuZW5jb2RlKHN0YXRpY1dyaXRlciwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gQmFja2ZpbGwgYWxsIHRoZSBkeW5hbWljIG9mZnNldHMsIG5vdyB0aGF0IHdlIGtub3cgdGhlIHN0YXRpYyBsZW5ndGhcbiAgICB1cGRhdGVGdW5jcy5mb3JFYWNoKChmdW5jKSA9PiB7IGZ1bmMoc3RhdGljV3JpdGVyLmxlbmd0aCk7IH0pO1xuICAgIGxldCBsZW5ndGggPSB3cml0ZXIuYXBwZW5kV3JpdGVyKHN0YXRpY1dyaXRlcik7XG4gICAgbGVuZ3RoICs9IHdyaXRlci5hcHBlbmRXcml0ZXIoZHluYW1pY1dyaXRlcik7XG4gICAgcmV0dXJuIGxlbmd0aDtcbn1cbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bnBhY2socmVhZGVyLCBjb2RlcnMpIHtcbiAgICBsZXQgdmFsdWVzID0gW107XG4gICAgbGV0IGtleXMgPSBbXTtcbiAgICAvLyBBIHJlYWRlciBhbmNob3JlZCB0byB0aGlzIGJhc2VcbiAgICBsZXQgYmFzZVJlYWRlciA9IHJlYWRlci5zdWJSZWFkZXIoMCk7XG4gICAgY29kZXJzLmZvckVhY2goKGNvZGVyKSA9PiB7XG4gICAgICAgIGxldCB2YWx1ZSA9IG51bGw7XG4gICAgICAgIGlmIChjb2Rlci5keW5hbWljKSB7XG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gcmVhZGVyLnJlYWRJbmRleCgpO1xuICAgICAgICAgICAgbGV0IG9mZnNldFJlYWRlciA9IGJhc2VSZWFkZXIuc3ViUmVhZGVyKG9mZnNldCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gY29kZXIuZGVjb2RlKG9mZnNldFJlYWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBDYW5ub3QgcmVjb3ZlciBmcm9tIHRoaXNcbiAgICAgICAgICAgICAgICBpZiAoaXNFcnJvcihlcnJvciwgXCJCVUZGRVJfT1ZFUlJVTlwiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICB2YWx1ZS5iYXNlVHlwZSA9IGNvZGVyLm5hbWU7XG4gICAgICAgICAgICAgICAgdmFsdWUubmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcbiAgICAgICAgICAgICAgICB2YWx1ZS50eXBlID0gY29kZXIudHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjb2Rlci5kZWNvZGUocmVhZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIENhbm5vdCByZWNvdmVyIGZyb20gdGhpc1xuICAgICAgICAgICAgICAgIGlmIChpc0Vycm9yKGVycm9yLCBcIkJVRkZFUl9PVkVSUlVOXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGVycm9yO1xuICAgICAgICAgICAgICAgIHZhbHVlLmJhc2VUeXBlID0gY29kZXIubmFtZTtcbiAgICAgICAgICAgICAgICB2YWx1ZS5uYW1lID0gY29kZXIubG9jYWxOYW1lO1xuICAgICAgICAgICAgICAgIHZhbHVlLnR5cGUgPSBjb2Rlci50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmVzdGlnYXRlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAga2V5cy5wdXNoKGNvZGVyLmxvY2FsTmFtZSB8fCBudWxsKTtcbiAgICB9KTtcbiAgICByZXR1cm4gUmVzdWx0LmZyb21JdGVtcyh2YWx1ZXMsIGtleXMpO1xufVxuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIEFycmF5Q29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29kZXI7XG4gICAgbGVuZ3RoO1xuICAgIGNvbnN0cnVjdG9yKGNvZGVyLCBsZW5ndGgsIGxvY2FsTmFtZSkge1xuICAgICAgICBjb25zdCB0eXBlID0gKGNvZGVyLnR5cGUgKyBcIltcIiArIChsZW5ndGggPj0gMCA/IGxlbmd0aCA6IFwiXCIpICsgXCJdXCIpO1xuICAgICAgICBjb25zdCBkeW5hbWljID0gKGxlbmd0aCA9PT0gLTEgfHwgY29kZXIuZHluYW1pYyk7XG4gICAgICAgIHN1cGVyKFwiYXJyYXlcIiwgdHlwZSwgbG9jYWxOYW1lLCBkeW5hbWljKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGNvZGVyLCBsZW5ndGggfSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgLy8gVmVyaWZpZXMgdGhlIGNoaWxkIGNvZGVyIGlzIHZhbGlkIChldmVuIGlmIHRoZSBhcnJheSBpcyBkeW5hbWljIG9yIDAtbGVuZ3RoKVxuICAgICAgICBjb25zdCBkZWZhdWx0Q2hpbGQgPSB0aGlzLmNvZGVyLmRlZmF1bHRWYWx1ZSgpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChkZWZhdWx0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIF92YWx1ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IFR5cGVkLmRlcmVmZXJlbmNlKF92YWx1ZSwgXCJhcnJheVwiKTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcImV4cGVjdGVkIGFycmF5IHZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY291bnQgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgaWYgKGNvdW50ID09PSAtMSkge1xuICAgICAgICAgICAgY291bnQgPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50Q291bnQodmFsdWUubGVuZ3RoLCBjb3VudCwgXCJjb2RlciBhcnJheVwiICsgKHRoaXMubG9jYWxOYW1lID8gKFwiIFwiICsgdGhpcy5sb2NhbE5hbWUpIDogXCJcIikpO1xuICAgICAgICBsZXQgY29kZXJzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvZGVycy5wdXNoKHRoaXMuY29kZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYWNrKHdyaXRlciwgY29kZXJzLCB2YWx1ZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgbGV0IGNvdW50ID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIGlmIChjb3VudCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvdW50ID0gcmVhZGVyLnJlYWRJbmRleCgpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGVyZSBpcyAqcm91Z2hseSogZW5vdWdoIGRhdGEgdG8gZW5zdXJlXG4gICAgICAgICAgICAvLyBzdHJheSByYW5kb20gZGF0YSBpcyBub3QgYmVpbmcgcmVhZCBhcyBhIGxlbmd0aC4gRWFjaFxuICAgICAgICAgICAgLy8gc2xvdCByZXF1aXJlcyBhdCBsZWFzdCAzMiBieXRlcyBmb3IgdGhlaXIgdmFsdWUgKG9yIDMyXG4gICAgICAgICAgICAvLyBieXRlcyBhcyBhIGxpbmsgdG8gdGhlIGRhdGEpLiBUaGlzIGNvdWxkIHVzZSBhIG11Y2hcbiAgICAgICAgICAgIC8vIHRpZ2h0ZXIgYm91bmQsIGJ1dCB3ZSBhcmUgZXJyb3Jpbmcgb24gdGhlIHNpZGUgb2Ygc2FmZXR5LlxuICAgICAgICAgICAgYXNzZXJ0KGNvdW50ICogV29yZFNpemUgPD0gcmVhZGVyLmRhdGFMZW5ndGgsIFwiaW5zdWZmaWNpZW50IGRhdGEgbGVuZ3RoXCIsIFwiQlVGRkVSX09WRVJSVU5cIiwgeyBidWZmZXI6IHJlYWRlci5ieXRlcywgb2Zmc2V0OiBjb3VudCAqIFdvcmRTaXplLCBsZW5ndGg6IHJlYWRlci5kYXRhTGVuZ3RoIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb2RlcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb2RlcnMucHVzaChuZXcgQW5vbnltb3VzQ29kZXIodGhpcy5jb2RlcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bnBhY2socmVhZGVyLCBjb2RlcnMpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFycmF5LmpzLm1hcCJdLCJuYW1lcyI6WyJkZWZpbmVQcm9wZXJ0aWVzIiwiaXNFcnJvciIsImFzc2VydCIsImFzc2VydEFyZ3VtZW50IiwiYXNzZXJ0QXJndW1lbnRDb3VudCIsIlR5cGVkIiwiQ29kZXIiLCJSZXN1bHQiLCJXb3JkU2l6ZSIsIldyaXRlciIsIkFub255bW91c0NvZGVyIiwicGFjayIsIndyaXRlciIsImNvZGVycyIsInZhbHVlcyIsImFycmF5VmFsdWVzIiwiQXJyYXkiLCJpc0FycmF5IiwidW5pcXVlIiwibWFwIiwiY29kZXIiLCJuYW1lIiwibG9jYWxOYW1lIiwiYXJndW1lbnQiLCJpbmZvIiwidmFsdWUiLCJsZW5ndGgiLCJzdGF0aWNXcml0ZXIiLCJkeW5hbWljV3JpdGVyIiwidXBkYXRlRnVuY3MiLCJmb3JFYWNoIiwiaW5kZXgiLCJkeW5hbWljIiwiZHluYW1pY09mZnNldCIsImVuY29kZSIsInVwZGF0ZUZ1bmMiLCJ3cml0ZVVwZGF0YWJsZVZhbHVlIiwicHVzaCIsImJhc2VPZmZzZXQiLCJmdW5jIiwiYXBwZW5kV3JpdGVyIiwidW5wYWNrIiwicmVhZGVyIiwia2V5cyIsImJhc2VSZWFkZXIiLCJzdWJSZWFkZXIiLCJvZmZzZXQiLCJyZWFkSW5kZXgiLCJvZmZzZXRSZWFkZXIiLCJkZWNvZGUiLCJlcnJvciIsImJhc2VUeXBlIiwidHlwZSIsInVuZGVmaW5lZCIsIkVycm9yIiwiZnJvbUl0ZW1zIiwiQXJyYXlDb2RlciIsImRlZmF1bHRWYWx1ZSIsImRlZmF1bHRDaGlsZCIsInJlc3VsdCIsImkiLCJfdmFsdWUiLCJkZXJlZmVyZW5jZSIsIl90aHJvd0Vycm9yIiwiY291bnQiLCJ3cml0ZVZhbHVlIiwiZGF0YUxlbmd0aCIsImJ1ZmZlciIsImJ5dGVzIiwiY29uc3RydWN0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/array.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/boolean.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/boolean.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BooleanCoder: function() { return /* binding */ BooleanCoder; }\n/* harmony export */ });\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../typed.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n\n/**\n *  @_ignore\n */ class BooleanCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    defaultValue() {\n        return false;\n    }\n    encode(writer, _value) {\n        const value = _typed_js__WEBPACK_IMPORTED_MODULE_1__.Typed.dereference(_value, \"bool\");\n        return writer.writeValue(value ? 1 : 0);\n    }\n    decode(reader) {\n        return !!reader.readValue();\n    }\n    constructor(localName){\n        super(\"bool\", \"bool\", localName, false);\n    }\n} //# sourceMappingURL=boolean.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2Jvb2xlYW4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQW9DO0FBQ1E7QUFDNUM7O0NBRUMsR0FDTSxNQUFNRSxxQkFBcUJELHFEQUFLQTtJQUluQ0UsZUFBZTtRQUNYLE9BQU87SUFDWDtJQUNBQyxPQUFPQyxNQUFNLEVBQUVDLE1BQU0sRUFBRTtRQUNuQixNQUFNQyxRQUFRUCw0Q0FBS0EsQ0FBQ1EsV0FBVyxDQUFDRixRQUFRO1FBQ3hDLE9BQU9ELE9BQU9JLFVBQVUsQ0FBQ0YsUUFBUSxJQUFJO0lBQ3pDO0lBQ0FHLE9BQU9DLE1BQU0sRUFBRTtRQUNYLE9BQU8sQ0FBQyxDQUFDQSxPQUFPQyxTQUFTO0lBQzdCO0lBWkFDLFlBQVlDLFNBQVMsQ0FBRTtRQUNuQixLQUFLLENBQUMsUUFBUSxRQUFRQSxXQUFXO0lBQ3JDO0FBV0osRUFDQSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvYm9vbGVhbi5qcz84NmMzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFR5cGVkIH0gZnJvbSBcIi4uL3R5cGVkLmpzXCI7XG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgQm9vbGVhbkNvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcImJvb2xcIiwgXCJib29sXCIsIGxvY2FsTmFtZSwgZmFsc2UpO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gVHlwZWQuZGVyZWZlcmVuY2UoX3ZhbHVlLCBcImJvb2xcIik7XG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZSA/IDEgOiAwKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gISFyZWFkZXIucmVhZFZhbHVlKCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ym9vbGVhbi5qcy5tYXAiXSwibmFtZXMiOlsiVHlwZWQiLCJDb2RlciIsIkJvb2xlYW5Db2RlciIsImRlZmF1bHRWYWx1ZSIsImVuY29kZSIsIndyaXRlciIsIl92YWx1ZSIsInZhbHVlIiwiZGVyZWZlcmVuY2UiLCJ3cml0ZVZhbHVlIiwiZGVjb2RlIiwicmVhZGVyIiwicmVhZFZhbHVlIiwiY29uc3RydWN0b3IiLCJsb2NhbE5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/boolean.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/bytes.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/bytes.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BytesCoder: function() { return /* binding */ BytesCoder; },\n/* harmony export */   DynamicBytesCoder: function() { return /* binding */ DynamicBytesCoder; }\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n\n/**\n *  @_ignore\n */ class DynamicBytesCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    defaultValue() {\n        return \"0x\";\n    }\n    encode(writer, value) {\n        value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytesCopy)(value);\n        let length = writer.writeValue(value.length);\n        length += writer.writeBytes(value);\n        return length;\n    }\n    decode(reader) {\n        return reader.readBytes(reader.readIndex(), true);\n    }\n    constructor(type, localName){\n        super(type, type, localName, true);\n    }\n}\n/**\n *  @_ignore\n */ class BytesCoder extends DynamicBytesCoder {\n    decode(reader) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(super.decode(reader));\n    }\n    constructor(localName){\n        super(\"bytes\", localName);\n    }\n} //# sourceMappingURL=bytes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2J5dGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBNkQ7QUFDakI7QUFDNUM7O0NBRUMsR0FDTSxNQUFNRywwQkFBMEJELHFEQUFLQTtJQUl4Q0UsZUFBZTtRQUNYLE9BQU87SUFDWDtJQUNBQyxPQUFPQyxNQUFNLEVBQUVDLEtBQUssRUFBRTtRQUNsQkEsUUFBUVAsNkRBQVlBLENBQUNPO1FBQ3JCLElBQUlDLFNBQVNGLE9BQU9HLFVBQVUsQ0FBQ0YsTUFBTUMsTUFBTTtRQUMzQ0EsVUFBVUYsT0FBT0ksVUFBVSxDQUFDSDtRQUM1QixPQUFPQztJQUNYO0lBQ0FHLE9BQU9DLE1BQU0sRUFBRTtRQUNYLE9BQU9BLE9BQU9DLFNBQVMsQ0FBQ0QsT0FBT0UsU0FBUyxJQUFJO0lBQ2hEO0lBZEFDLFlBQVlDLElBQUksRUFBRUMsU0FBUyxDQUFFO1FBQ3pCLEtBQUssQ0FBQ0QsTUFBTUEsTUFBTUMsV0FBVztJQUNqQztBQWFKO0FBQ0E7O0NBRUMsR0FDTSxNQUFNQyxtQkFBbUJmO0lBSTVCUSxPQUFPQyxNQUFNLEVBQUU7UUFDWCxPQUFPWCx3REFBT0EsQ0FBQyxLQUFLLENBQUNVLE9BQU9DO0lBQ2hDO0lBTEFHLFlBQVlFLFNBQVMsQ0FBRTtRQUNuQixLQUFLLENBQUMsU0FBU0E7SUFDbkI7QUFJSixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9ieXRlcy5qcz9mMzQ0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEJ5dGVzQ29weSwgaGV4bGlmeSB9IGZyb20gXCIuLi8uLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIER5bmFtaWNCeXRlc0NvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcih0eXBlLCB0eXBlLCBsb2NhbE5hbWUsIHRydWUpO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBcIjB4XCI7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gZ2V0Qnl0ZXNDb3B5KHZhbHVlKTtcbiAgICAgICAgbGV0IGxlbmd0aCA9IHdyaXRlci53cml0ZVZhbHVlKHZhbHVlLmxlbmd0aCk7XG4gICAgICAgIGxlbmd0aCArPSB3cml0ZXIud3JpdGVCeXRlcyh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkQnl0ZXMocmVhZGVyLnJlYWRJbmRleCgpLCB0cnVlKTtcbiAgICB9XG59XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgQnl0ZXNDb2RlciBleHRlbmRzIER5bmFtaWNCeXRlc0NvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIoXCJieXRlc1wiLCBsb2NhbE5hbWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KHN1cGVyLmRlY29kZShyZWFkZXIpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ieXRlcy5qcy5tYXAiXSwibmFtZXMiOlsiZ2V0Qnl0ZXNDb3B5IiwiaGV4bGlmeSIsIkNvZGVyIiwiRHluYW1pY0J5dGVzQ29kZXIiLCJkZWZhdWx0VmFsdWUiLCJlbmNvZGUiLCJ3cml0ZXIiLCJ2YWx1ZSIsImxlbmd0aCIsIndyaXRlVmFsdWUiLCJ3cml0ZUJ5dGVzIiwiZGVjb2RlIiwicmVhZGVyIiwicmVhZEJ5dGVzIiwicmVhZEluZGV4IiwiY29uc3RydWN0b3IiLCJ0eXBlIiwibG9jYWxOYW1lIiwiQnl0ZXNDb2RlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/bytes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FixedBytesCoder: function() { return /* binding */ FixedBytesCoder; }\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../typed.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n\n\n/**\n *  @_ignore\n */ class FixedBytesCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    defaultValue() {\n        return \"0x0000000000000000000000000000000000000000000000000000000000000000\".substring(0, 2 + this.size * 2);\n    }\n    encode(writer, _value) {\n        let data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytesCopy)(_typed_js__WEBPACK_IMPORTED_MODULE_2__.Typed.dereference(_value, this.type));\n        if (data.length !== this.size) {\n            this._throwError(\"incorrect data length\", _value);\n        }\n        return writer.writeBytes(data);\n    }\n    decode(reader) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(reader.readBytes(this.size));\n    }\n    constructor(size, localName){\n        let name = \"bytes\" + String(size);\n        super(name, name, localName, false);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.defineProperties)(this, {\n            size\n        }, {\n            size: \"number\"\n        });\n    }\n} //# sourceMappingURL=fixed-bytes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2ZpeGVkLWJ5dGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQStFO0FBQzNDO0FBQ1E7QUFDNUM7O0NBRUMsR0FDTSxNQUFNSyx3QkFBd0JELHFEQUFLQTtJQU90Q0UsZUFBZTtRQUNYLE9BQU8scUVBQXVFQyxTQUFTLENBQUMsR0FBRyxJQUFJLElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQy9HO0lBQ0FDLE9BQU9DLE1BQU0sRUFBRUMsTUFBTSxFQUFFO1FBQ25CLElBQUlDLE9BQU9YLDZEQUFZQSxDQUFDRSw0Q0FBS0EsQ0FBQ1UsV0FBVyxDQUFDRixRQUFRLElBQUksQ0FBQ0csSUFBSTtRQUMzRCxJQUFJRixLQUFLRyxNQUFNLEtBQUssSUFBSSxDQUFDUCxJQUFJLEVBQUU7WUFDM0IsSUFBSSxDQUFDUSxXQUFXLENBQUMseUJBQXlCTDtRQUM5QztRQUNBLE9BQU9ELE9BQU9PLFVBQVUsQ0FBQ0w7SUFDN0I7SUFDQU0sT0FBT0MsTUFBTSxFQUFFO1FBQ1gsT0FBT2pCLHdEQUFPQSxDQUFDaUIsT0FBT0MsU0FBUyxDQUFDLElBQUksQ0FBQ1osSUFBSTtJQUM3QztJQWpCQWEsWUFBWWIsSUFBSSxFQUFFYyxTQUFTLENBQUU7UUFDekIsSUFBSUMsT0FBTyxVQUFVQyxPQUFPaEI7UUFDNUIsS0FBSyxDQUFDZSxNQUFNQSxNQUFNRCxXQUFXO1FBQzdCdEIsaUVBQWdCQSxDQUFDLElBQUksRUFBRTtZQUFFUTtRQUFLLEdBQUc7WUFBRUEsTUFBTTtRQUFTO0lBQ3REO0FBY0osRUFDQSx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvZml4ZWQtYnl0ZXMuanM/NmVlZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBnZXRCeXRlc0NvcHksIGhleGxpZnkgfSBmcm9tIFwiLi4vLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IFR5cGVkIH0gZnJvbSBcIi4uL3R5cGVkLmpzXCI7XG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgRml4ZWRCeXRlc0NvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIHNpemU7XG4gICAgY29uc3RydWN0b3Ioc2l6ZSwgbG9jYWxOYW1lKSB7XG4gICAgICAgIGxldCBuYW1lID0gXCJieXRlc1wiICsgU3RyaW5nKHNpemUpO1xuICAgICAgICBzdXBlcihuYW1lLCBuYW1lLCBsb2NhbE5hbWUsIGZhbHNlKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHNpemUgfSwgeyBzaXplOiBcIm51bWJlclwiIH0pO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiAoXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIikuc3Vic3RyaW5nKDAsIDIgKyB0aGlzLnNpemUgKiAyKTtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XG4gICAgICAgIGxldCBkYXRhID0gZ2V0Qnl0ZXNDb3B5KFR5cGVkLmRlcmVmZXJlbmNlKF92YWx1ZSwgdGhpcy50eXBlKSk7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gdGhpcy5zaXplKSB7XG4gICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwiaW5jb3JyZWN0IGRhdGEgbGVuZ3RoXCIsIF92YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZUJ5dGVzKGRhdGEpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KHJlYWRlci5yZWFkQnl0ZXModGhpcy5zaXplKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zml4ZWQtYnl0ZXMuanMubWFwIl0sIm5hbWVzIjpbImRlZmluZVByb3BlcnRpZXMiLCJnZXRCeXRlc0NvcHkiLCJoZXhsaWZ5IiwiVHlwZWQiLCJDb2RlciIsIkZpeGVkQnl0ZXNDb2RlciIsImRlZmF1bHRWYWx1ZSIsInN1YnN0cmluZyIsInNpemUiLCJlbmNvZGUiLCJ3cml0ZXIiLCJfdmFsdWUiLCJkYXRhIiwiZGVyZWZlcmVuY2UiLCJ0eXBlIiwibGVuZ3RoIiwiX3Rocm93RXJyb3IiLCJ3cml0ZUJ5dGVzIiwiZGVjb2RlIiwicmVhZGVyIiwicmVhZEJ5dGVzIiwiY29uc3RydWN0b3IiLCJsb2NhbE5hbWUiLCJuYW1lIiwiU3RyaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/null.js":
/*!********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/null.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NullCoder: function() { return /* binding */ NullCoder; }\n/* harmony export */ });\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\nconst Empty = new Uint8Array([]);\n/**\n *  @_ignore\n */ class NullCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    defaultValue() {\n        return null;\n    }\n    encode(writer, value) {\n        if (value != null) {\n            this._throwError(\"not null\", value);\n        }\n        return writer.writeBytes(Empty);\n    }\n    decode(reader) {\n        reader.readBytes(0);\n        return null;\n    }\n    constructor(localName){\n        super(\"null\", \"\", localName, false);\n    }\n} //# sourceMappingURL=null.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL251bGwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNEM7QUFDNUMsTUFBTUMsUUFBUSxJQUFJQyxXQUFXLEVBQUU7QUFDL0I7O0NBRUMsR0FDTSxNQUFNQyxrQkFBa0JILHFEQUFLQTtJQUloQ0ksZUFBZTtRQUNYLE9BQU87SUFDWDtJQUNBQyxPQUFPQyxNQUFNLEVBQUVDLEtBQUssRUFBRTtRQUNsQixJQUFJQSxTQUFTLE1BQU07WUFDZixJQUFJLENBQUNDLFdBQVcsQ0FBQyxZQUFZRDtRQUNqQztRQUNBLE9BQU9ELE9BQU9HLFVBQVUsQ0FBQ1I7SUFDN0I7SUFDQVMsT0FBT0MsTUFBTSxFQUFFO1FBQ1hBLE9BQU9DLFNBQVMsQ0FBQztRQUNqQixPQUFPO0lBQ1g7SUFmQUMsWUFBWUMsU0FBUyxDQUFFO1FBQ25CLEtBQUssQ0FBQyxRQUFRLElBQUlBLFdBQVc7SUFDakM7QUFjSixFQUNBLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9udWxsLmpzP2IyMTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuY29uc3QgRW1wdHkgPSBuZXcgVWludDhBcnJheShbXSk7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgTnVsbENvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcIm51bGxcIiwgXCJcIiwgbG9jYWxOYW1lLCBmYWxzZSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwibm90IG51bGxcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVCeXRlcyhFbXB0eSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmVhZGVyLnJlYWRCeXRlcygwKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bnVsbC5qcy5tYXAiXSwibmFtZXMiOlsiQ29kZXIiLCJFbXB0eSIsIlVpbnQ4QXJyYXkiLCJOdWxsQ29kZXIiLCJkZWZhdWx0VmFsdWUiLCJlbmNvZGUiLCJ3cml0ZXIiLCJ2YWx1ZSIsIl90aHJvd0Vycm9yIiwid3JpdGVCeXRlcyIsImRlY29kZSIsInJlYWRlciIsInJlYWRCeXRlcyIsImNvbnN0cnVjdG9yIiwibG9jYWxOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/null.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/number.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/number.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NumberCoder: function() { return /* binding */ NumberCoder; }\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../typed.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n\n\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_MAX_UINT256 = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n/**\n *  @_ignore\n */ class NumberCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    defaultValue() {\n        return 0;\n    }\n    encode(writer, _value) {\n        let value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(_typed_js__WEBPACK_IMPORTED_MODULE_2__.Typed.dereference(_value, this.type));\n        // Check bounds are safe for encoding\n        let maxUintValue = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.mask)(BN_MAX_UINT256, _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.WordSize * 8);\n        if (this.signed) {\n            let bounds = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.mask)(maxUintValue, this.size * 8 - 1);\n            if (value > bounds || value < -(bounds + BN_1)) {\n                this._throwError(\"value out-of-bounds\", _value);\n            }\n            value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toTwos)(value, 8 * _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.WordSize);\n        } else if (value < BN_0 || value > (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.mask)(maxUintValue, this.size * 8)) {\n            this._throwError(\"value out-of-bounds\", _value);\n        }\n        return writer.writeValue(value);\n    }\n    decode(reader) {\n        let value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.mask)(reader.readValue(), this.size * 8);\n        if (this.signed) {\n            value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.fromTwos)(value, this.size * 8);\n        }\n        return value;\n    }\n    constructor(size, signed, localName){\n        const name = (signed ? \"int\" : \"uint\") + size * 8;\n        super(name, name, localName, false);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.defineProperties)(this, {\n            size,\n            signed\n        }, {\n            size: \"number\",\n            signed: \"boolean\"\n        });\n    }\n} //# sourceMappingURL=number.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL251bWJlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEyRjtBQUN2RDtBQUNrQjtBQUN0RCxNQUFNUSxPQUFPQyxPQUFPO0FBQ3BCLE1BQU1DLE9BQU9ELE9BQU87QUFDcEIsTUFBTUUsaUJBQWlCRixPQUFPO0FBQzlCOztDQUVDLEdBQ00sTUFBTUcsb0JBQW9CTixxREFBS0E7SUFRbENPLGVBQWU7UUFDWCxPQUFPO0lBQ1g7SUFDQUMsT0FBT0MsTUFBTSxFQUFFQyxNQUFNLEVBQUU7UUFDbkIsSUFBSUMsUUFBUWYsMERBQVNBLENBQUNHLDRDQUFLQSxDQUFDYSxXQUFXLENBQUNGLFFBQVEsSUFBSSxDQUFDRyxJQUFJO1FBQ3pELHFDQUFxQztRQUNyQyxJQUFJQyxlQUFlakIscURBQUlBLENBQUNRLGdCQUFnQkosd0RBQVFBLEdBQUc7UUFDbkQsSUFBSSxJQUFJLENBQUNjLE1BQU0sRUFBRTtZQUNiLElBQUlDLFNBQVNuQixxREFBSUEsQ0FBQ2lCLGNBQWMsSUFBSyxDQUFDRyxJQUFJLEdBQUcsSUFBSztZQUNsRCxJQUFJTixRQUFRSyxVQUFVTCxRQUFRLENBQUVLLENBQUFBLFNBQVNaLElBQUcsR0FBSTtnQkFDNUMsSUFBSSxDQUFDYyxXQUFXLENBQUMsdUJBQXVCUjtZQUM1QztZQUNBQyxRQUFRYix1REFBTUEsQ0FBQ2EsT0FBTyxJQUFJVix3REFBUUE7UUFDdEMsT0FDSyxJQUFJVSxRQUFRVCxRQUFRUyxRQUFRZCxxREFBSUEsQ0FBQ2lCLGNBQWMsSUFBSSxDQUFDRyxJQUFJLEdBQUcsSUFBSTtZQUNoRSxJQUFJLENBQUNDLFdBQVcsQ0FBQyx1QkFBdUJSO1FBQzVDO1FBQ0EsT0FBT0QsT0FBT1UsVUFBVSxDQUFDUjtJQUM3QjtJQUNBUyxPQUFPQyxNQUFNLEVBQUU7UUFDWCxJQUFJVixRQUFRZCxxREFBSUEsQ0FBQ3dCLE9BQU9DLFNBQVMsSUFBSSxJQUFJLENBQUNMLElBQUksR0FBRztRQUNqRCxJQUFJLElBQUksQ0FBQ0YsTUFBTSxFQUFFO1lBQ2JKLFFBQVFoQix5REFBUUEsQ0FBQ2dCLE9BQU8sSUFBSSxDQUFDTSxJQUFJLEdBQUc7UUFDeEM7UUFDQSxPQUFPTjtJQUNYO0lBOUJBWSxZQUFZTixJQUFJLEVBQUVGLE1BQU0sRUFBRVMsU0FBUyxDQUFFO1FBQ2pDLE1BQU1DLE9BQVEsQ0FBQ1YsU0FBUyxRQUFRLE1BQUssSUFBTUUsT0FBTztRQUNsRCxLQUFLLENBQUNRLE1BQU1BLE1BQU1ELFdBQVc7UUFDN0I5QixpRUFBZ0JBLENBQUMsSUFBSSxFQUFFO1lBQUV1QjtZQUFNRjtRQUFPLEdBQUc7WUFBRUUsTUFBTTtZQUFVRixRQUFRO1FBQVU7SUFDakY7QUEyQkosRUFDQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvbnVtYmVyLmpzPzcxNTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgZnJvbVR3b3MsIGdldEJpZ0ludCwgbWFzaywgdG9Ud29zIH0gZnJvbSBcIi4uLy4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBUeXBlZCB9IGZyb20gXCIuLi90eXBlZC5qc1wiO1xuaW1wb3J0IHsgQ29kZXIsIFdvcmRTaXplIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXIuanNcIjtcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5jb25zdCBCTl8xID0gQmlnSW50KDEpO1xuY29uc3QgQk5fTUFYX1VJTlQyNTYgPSBCaWdJbnQoXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIik7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgTnVtYmVyQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgc2l6ZTtcbiAgICBzaWduZWQ7XG4gICAgY29uc3RydWN0b3Ioc2l6ZSwgc2lnbmVkLCBsb2NhbE5hbWUpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9ICgoc2lnbmVkID8gXCJpbnRcIiA6IFwidWludFwiKSArIChzaXplICogOCkpO1xuICAgICAgICBzdXBlcihuYW1lLCBuYW1lLCBsb2NhbE5hbWUsIGZhbHNlKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHNpemUsIHNpZ25lZCB9LCB7IHNpemU6IFwibnVtYmVyXCIsIHNpZ25lZDogXCJib29sZWFuXCIgfSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIF92YWx1ZSkge1xuICAgICAgICBsZXQgdmFsdWUgPSBnZXRCaWdJbnQoVHlwZWQuZGVyZWZlcmVuY2UoX3ZhbHVlLCB0aGlzLnR5cGUpKTtcbiAgICAgICAgLy8gQ2hlY2sgYm91bmRzIGFyZSBzYWZlIGZvciBlbmNvZGluZ1xuICAgICAgICBsZXQgbWF4VWludFZhbHVlID0gbWFzayhCTl9NQVhfVUlOVDI1NiwgV29yZFNpemUgKiA4KTtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmVkKSB7XG4gICAgICAgICAgICBsZXQgYm91bmRzID0gbWFzayhtYXhVaW50VmFsdWUsICh0aGlzLnNpemUgKiA4KSAtIDEpO1xuICAgICAgICAgICAgaWYgKHZhbHVlID4gYm91bmRzIHx8IHZhbHVlIDwgLShib3VuZHMgKyBCTl8xKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJ2YWx1ZSBvdXQtb2YtYm91bmRzXCIsIF92YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IHRvVHdvcyh2YWx1ZSwgOCAqIFdvcmRTaXplKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA8IEJOXzAgfHwgdmFsdWUgPiBtYXNrKG1heFVpbnRWYWx1ZSwgdGhpcy5zaXplICogOCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJ2YWx1ZSBvdXQtb2YtYm91bmRzXCIsIF92YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZVZhbHVlKHZhbHVlKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICBsZXQgdmFsdWUgPSBtYXNrKHJlYWRlci5yZWFkVmFsdWUoKSwgdGhpcy5zaXplICogOCk7XG4gICAgICAgIGlmICh0aGlzLnNpZ25lZCkge1xuICAgICAgICAgICAgdmFsdWUgPSBmcm9tVHdvcyh2YWx1ZSwgdGhpcy5zaXplICogOCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW51bWJlci5qcy5tYXAiXSwibmFtZXMiOlsiZGVmaW5lUHJvcGVydGllcyIsImZyb21Ud29zIiwiZ2V0QmlnSW50IiwibWFzayIsInRvVHdvcyIsIlR5cGVkIiwiQ29kZXIiLCJXb3JkU2l6ZSIsIkJOXzAiLCJCaWdJbnQiLCJCTl8xIiwiQk5fTUFYX1VJTlQyNTYiLCJOdW1iZXJDb2RlciIsImRlZmF1bHRWYWx1ZSIsImVuY29kZSIsIndyaXRlciIsIl92YWx1ZSIsInZhbHVlIiwiZGVyZWZlcmVuY2UiLCJ0eXBlIiwibWF4VWludFZhbHVlIiwic2lnbmVkIiwiYm91bmRzIiwic2l6ZSIsIl90aHJvd0Vycm9yIiwid3JpdGVWYWx1ZSIsImRlY29kZSIsInJlYWRlciIsInJlYWRWYWx1ZSIsImNvbnN0cnVjdG9yIiwibG9jYWxOYW1lIiwibmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/number.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/string.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/string.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StringCoder: function() { return /* binding */ StringCoder; }\n/* harmony export */ });\n/* harmony import */ var _utils_utf8_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/utf8.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../typed.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bytes.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/bytes.js\");\n\n\n\n/**\n *  @_ignore\n */ class StringCoder extends _bytes_js__WEBPACK_IMPORTED_MODULE_0__.DynamicBytesCoder {\n    defaultValue() {\n        return \"\";\n    }\n    encode(writer, _value) {\n        return super.encode(writer, (0,_utils_utf8_js__WEBPACK_IMPORTED_MODULE_1__.toUtf8Bytes)(_typed_js__WEBPACK_IMPORTED_MODULE_2__.Typed.dereference(_value, \"string\")));\n    }\n    decode(reader) {\n        return (0,_utils_utf8_js__WEBPACK_IMPORTED_MODULE_1__.toUtf8String)(super.decode(reader));\n    }\n    constructor(localName){\n        super(\"string\", localName);\n    }\n} //# sourceMappingURL=string.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL3N0cmluZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWdFO0FBQzVCO0FBQ1c7QUFDL0M7O0NBRUMsR0FDTSxNQUFNSSxvQkFBb0JELHdEQUFpQkE7SUFJOUNFLGVBQWU7UUFDWCxPQUFPO0lBQ1g7SUFDQUMsT0FBT0MsTUFBTSxFQUFFQyxNQUFNLEVBQUU7UUFDbkIsT0FBTyxLQUFLLENBQUNGLE9BQU9DLFFBQVFQLDJEQUFXQSxDQUFDRSw0Q0FBS0EsQ0FBQ08sV0FBVyxDQUFDRCxRQUFRO0lBQ3RFO0lBQ0FFLE9BQU9DLE1BQU0sRUFBRTtRQUNYLE9BQU9WLDREQUFZQSxDQUFDLEtBQUssQ0FBQ1MsT0FBT0M7SUFDckM7SUFYQUMsWUFBWUMsU0FBUyxDQUFFO1FBQ25CLEtBQUssQ0FBQyxVQUFVQTtJQUNwQjtBQVVKLEVBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL3N0cmluZy5qcz9mYjZjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHRvVXRmOEJ5dGVzLCB0b1V0ZjhTdHJpbmcgfSBmcm9tIFwiLi4vLi4vdXRpbHMvdXRmOC5qc1wiO1xuaW1wb3J0IHsgVHlwZWQgfSBmcm9tIFwiLi4vdHlwZWQuanNcIjtcbmltcG9ydCB7IER5bmFtaWNCeXRlc0NvZGVyIH0gZnJvbSBcIi4vYnl0ZXMuanNcIjtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHJpbmdDb2RlciBleHRlbmRzIER5bmFtaWNCeXRlc0NvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIoXCJzdHJpbmdcIiwgbG9jYWxOYW1lKTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5lbmNvZGUod3JpdGVyLCB0b1V0ZjhCeXRlcyhUeXBlZC5kZXJlZmVyZW5jZShfdmFsdWUsIFwic3RyaW5nXCIpKSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHRvVXRmOFN0cmluZyhzdXBlci5kZWNvZGUocmVhZGVyKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyaW5nLmpzLm1hcCJdLCJuYW1lcyI6WyJ0b1V0ZjhCeXRlcyIsInRvVXRmOFN0cmluZyIsIlR5cGVkIiwiRHluYW1pY0J5dGVzQ29kZXIiLCJTdHJpbmdDb2RlciIsImRlZmF1bHRWYWx1ZSIsImVuY29kZSIsIndyaXRlciIsIl92YWx1ZSIsImRlcmVmZXJlbmNlIiwiZGVjb2RlIiwicmVhZGVyIiwiY29uc3RydWN0b3IiLCJsb2NhbE5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/string.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/tuple.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/tuple.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TupleCoder: function() { return /* binding */ TupleCoder; }\n/* harmony export */ });\n/* harmony import */ var _utils_properties_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/properties.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../typed.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./array.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/array.js\");\n\n\n\n\n/**\n *  @_ignore\n */ class TupleCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    defaultValue() {\n        const values = [];\n        this.coders.forEach((coder)=>{\n            values.push(coder.defaultValue());\n        });\n        // We only output named properties for uniquely named coders\n        const uniqueNames = this.coders.reduce((accum, coder)=>{\n            const name = coder.localName;\n            if (name) {\n                if (!accum[name]) {\n                    accum[name] = 0;\n                }\n                accum[name]++;\n            }\n            return accum;\n        }, {});\n        // Add named values\n        this.coders.forEach((coder, index)=>{\n            let name = coder.localName;\n            if (!name || uniqueNames[name] !== 1) {\n                return;\n            }\n            if (name === \"length\") {\n                name = \"_length\";\n            }\n            if (values[name] != null) {\n                return;\n            }\n            values[name] = values[index];\n        });\n        return Object.freeze(values);\n    }\n    encode(writer, _value) {\n        const value = _typed_js__WEBPACK_IMPORTED_MODULE_1__.Typed.dereference(_value, \"tuple\");\n        return (0,_array_js__WEBPACK_IMPORTED_MODULE_2__.pack)(writer, this.coders, value);\n    }\n    decode(reader) {\n        return (0,_array_js__WEBPACK_IMPORTED_MODULE_2__.unpack)(reader, this.coders);\n    }\n    constructor(coders, localName){\n        let dynamic = false;\n        const types = [];\n        coders.forEach((coder)=>{\n            if (coder.dynamic) {\n                dynamic = true;\n            }\n            types.push(coder.type);\n        });\n        const type = \"tuple(\" + types.join(\",\") + \")\";\n        super(\"tuple\", type, localName, dynamic);\n        (0,_utils_properties_js__WEBPACK_IMPORTED_MODULE_3__.defineProperties)(this, {\n            coders: Object.freeze(coders.slice())\n        });\n    }\n} //# sourceMappingURL=tuple.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL3R1cGxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTZEO0FBQ3pCO0FBQ1E7QUFDRjtBQUMxQzs7Q0FFQyxHQUNNLE1BQU1LLG1CQUFtQkgscURBQUtBO0lBZWpDSSxlQUFlO1FBQ1gsTUFBTUMsU0FBUyxFQUFFO1FBQ2pCLElBQUksQ0FBQ0MsTUFBTSxDQUFDQyxPQUFPLENBQUMsQ0FBQ0M7WUFDakJILE9BQU9JLElBQUksQ0FBQ0QsTUFBTUosWUFBWTtRQUNsQztRQUNBLDREQUE0RDtRQUM1RCxNQUFNTSxjQUFjLElBQUksQ0FBQ0osTUFBTSxDQUFDSyxNQUFNLENBQUMsQ0FBQ0MsT0FBT0o7WUFDM0MsTUFBTUssT0FBT0wsTUFBTU0sU0FBUztZQUM1QixJQUFJRCxNQUFNO2dCQUNOLElBQUksQ0FBQ0QsS0FBSyxDQUFDQyxLQUFLLEVBQUU7b0JBQ2RELEtBQUssQ0FBQ0MsS0FBSyxHQUFHO2dCQUNsQjtnQkFDQUQsS0FBSyxDQUFDQyxLQUFLO1lBQ2Y7WUFDQSxPQUFPRDtRQUNYLEdBQUcsQ0FBQztRQUNKLG1CQUFtQjtRQUNuQixJQUFJLENBQUNOLE1BQU0sQ0FBQ0MsT0FBTyxDQUFDLENBQUNDLE9BQU9PO1lBQ3hCLElBQUlGLE9BQU9MLE1BQU1NLFNBQVM7WUFDMUIsSUFBSSxDQUFDRCxRQUFRSCxXQUFXLENBQUNHLEtBQUssS0FBSyxHQUFHO2dCQUNsQztZQUNKO1lBQ0EsSUFBSUEsU0FBUyxVQUFVO2dCQUNuQkEsT0FBTztZQUNYO1lBQ0EsSUFBSVIsTUFBTSxDQUFDUSxLQUFLLElBQUksTUFBTTtnQkFDdEI7WUFDSjtZQUNBUixNQUFNLENBQUNRLEtBQUssR0FBR1IsTUFBTSxDQUFDVSxNQUFNO1FBQ2hDO1FBQ0EsT0FBT0MsT0FBT0MsTUFBTSxDQUFDWjtJQUN6QjtJQUNBYSxPQUFPQyxNQUFNLEVBQUVDLE1BQU0sRUFBRTtRQUNuQixNQUFNQyxRQUFRdEIsNENBQUtBLENBQUN1QixXQUFXLENBQUNGLFFBQVE7UUFDeEMsT0FBT25CLCtDQUFJQSxDQUFDa0IsUUFBUSxJQUFJLENBQUNiLE1BQU0sRUFBRWU7SUFDckM7SUFDQUUsT0FBT0MsTUFBTSxFQUFFO1FBQ1gsT0FBT3RCLGlEQUFNQSxDQUFDc0IsUUFBUSxJQUFJLENBQUNsQixNQUFNO0lBQ3JDO0lBbkRBbUIsWUFBWW5CLE1BQU0sRUFBRVEsU0FBUyxDQUFFO1FBQzNCLElBQUlZLFVBQVU7UUFDZCxNQUFNQyxRQUFRLEVBQUU7UUFDaEJyQixPQUFPQyxPQUFPLENBQUMsQ0FBQ0M7WUFDWixJQUFJQSxNQUFNa0IsT0FBTyxFQUFFO2dCQUNmQSxVQUFVO1lBQ2Q7WUFDQUMsTUFBTWxCLElBQUksQ0FBQ0QsTUFBTW9CLElBQUk7UUFDekI7UUFDQSxNQUFNQSxPQUFRLFdBQVdELE1BQU1FLElBQUksQ0FBQyxPQUFPO1FBQzNDLEtBQUssQ0FBQyxTQUFTRCxNQUFNZCxXQUFXWTtRQUNoQzVCLHNFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFBRVEsUUFBUVUsT0FBT0MsTUFBTSxDQUFDWCxPQUFPd0IsS0FBSztRQUFJO0lBQ25FO0FBd0NKLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL3R1cGxlLmpzPzNhNGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcyB9IGZyb20gXCIuLi8uLi91dGlscy9wcm9wZXJ0aWVzLmpzXCI7XG5pbXBvcnQgeyBUeXBlZCB9IGZyb20gXCIuLi90eXBlZC5qc1wiO1xuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuaW1wb3J0IHsgcGFjaywgdW5wYWNrIH0gZnJvbSBcIi4vYXJyYXkuanNcIjtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBUdXBsZUNvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvZGVycztcbiAgICBjb25zdHJ1Y3Rvcihjb2RlcnMsIGxvY2FsTmFtZSkge1xuICAgICAgICBsZXQgZHluYW1pYyA9IGZhbHNlO1xuICAgICAgICBjb25zdCB0eXBlcyA9IFtdO1xuICAgICAgICBjb2RlcnMuZm9yRWFjaCgoY29kZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChjb2Rlci5keW5hbWljKSB7XG4gICAgICAgICAgICAgICAgZHluYW1pYyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0eXBlcy5wdXNoKGNvZGVyLnR5cGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdHlwZSA9IChcInR1cGxlKFwiICsgdHlwZXMuam9pbihcIixcIikgKyBcIilcIik7XG4gICAgICAgIHN1cGVyKFwidHVwbGVcIiwgdHlwZSwgbG9jYWxOYW1lLCBkeW5hbWljKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGNvZGVyczogT2JqZWN0LmZyZWV6ZShjb2RlcnMuc2xpY2UoKSkgfSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgICAgIHRoaXMuY29kZXJzLmZvckVhY2goKGNvZGVyKSA9PiB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaChjb2Rlci5kZWZhdWx0VmFsdWUoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBXZSBvbmx5IG91dHB1dCBuYW1lZCBwcm9wZXJ0aWVzIGZvciB1bmlxdWVseSBuYW1lZCBjb2RlcnNcbiAgICAgICAgY29uc3QgdW5pcXVlTmFtZXMgPSB0aGlzLmNvZGVycy5yZWR1Y2UoKGFjY3VtLCBjb2RlcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcbiAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhY2N1bVtuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBhY2N1bVtuYW1lXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFjY3VtW25hbWVdKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgLy8gQWRkIG5hbWVkIHZhbHVlc1xuICAgICAgICB0aGlzLmNvZGVycy5mb3JFYWNoKChjb2RlciwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGxldCBuYW1lID0gY29kZXIubG9jYWxOYW1lO1xuICAgICAgICAgICAgaWYgKCFuYW1lIHx8IHVuaXF1ZU5hbWVzW25hbWVdICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hbWUgPT09IFwibGVuZ3RoXCIpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gXCJfbGVuZ3RoXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZXNbbmFtZV0gPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUodmFsdWVzKTtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gVHlwZWQuZGVyZWZlcmVuY2UoX3ZhbHVlLCBcInR1cGxlXCIpO1xuICAgICAgICByZXR1cm4gcGFjayh3cml0ZXIsIHRoaXMuY29kZXJzLCB2YWx1ZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHVucGFjayhyZWFkZXIsIHRoaXMuY29kZXJzKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10dXBsZS5qcy5tYXAiXSwibmFtZXMiOlsiZGVmaW5lUHJvcGVydGllcyIsIlR5cGVkIiwiQ29kZXIiLCJwYWNrIiwidW5wYWNrIiwiVHVwbGVDb2RlciIsImRlZmF1bHRWYWx1ZSIsInZhbHVlcyIsImNvZGVycyIsImZvckVhY2giLCJjb2RlciIsInB1c2giLCJ1bmlxdWVOYW1lcyIsInJlZHVjZSIsImFjY3VtIiwibmFtZSIsImxvY2FsTmFtZSIsImluZGV4IiwiT2JqZWN0IiwiZnJlZXplIiwiZW5jb2RlIiwid3JpdGVyIiwiX3ZhbHVlIiwidmFsdWUiLCJkZXJlZmVyZW5jZSIsImRlY29kZSIsInJlYWRlciIsImNvbnN0cnVjdG9yIiwiZHluYW1pYyIsInR5cGVzIiwidHlwZSIsImpvaW4iLCJzbGljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/tuple.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/abi/fragments.js":
/*!******************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/fragments.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConstructorFragment: function() { return /* binding */ ConstructorFragment; },\n/* harmony export */   ErrorFragment: function() { return /* binding */ ErrorFragment; },\n/* harmony export */   EventFragment: function() { return /* binding */ EventFragment; },\n/* harmony export */   FallbackFragment: function() { return /* binding */ FallbackFragment; },\n/* harmony export */   Fragment: function() { return /* binding */ Fragment; },\n/* harmony export */   FunctionFragment: function() { return /* binding */ FunctionFragment; },\n/* harmony export */   NamedFragment: function() { return /* binding */ NamedFragment; },\n/* harmony export */   ParamType: function() { return /* binding */ ParamType; },\n/* harmony export */   StructFragment: function() { return /* binding */ StructFragment; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_get */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_get.js\");\n/* harmony import */ var _swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_init */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_init.js\");\n/* harmony import */ var _swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_set */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_set.js\");\n/* harmony import */ var _swc_helpers_class_private_field_update__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_update */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_update.js\");\n/* harmony import */ var _swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @swc/helpers/_/_class_private_method_get */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_method_get.js\");\n/* harmony import */ var _swc_helpers_class_private_method_init__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @swc/helpers/_/_class_private_method_init */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_method_init.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../hash/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/hash/id.js\");\n/**\n *  A fragment is a single item from an ABI, which may represent any of:\n *\n *  - [Functions](FunctionFragment)\n *  - [Events](EventFragment)\n *  - [Constructors](ConstructorFragment)\n *  - Custom [Errors](ErrorFragment)\n *  - [Fallback or Receive](FallbackFragment) functions\n *\n *  @_subsection api/abi/abi-coder:Fragments  [about-fragments]\n */ \n\n\n\n\n\n\n\n;\n// [ \"a\", \"b\" ] => { \"a\": 1, \"b\": 1 }\nfunction setify(items) {\n    const result = new Set();\n    items.forEach((k)=>result.add(k));\n    return Object.freeze(result);\n}\nconst _kwVisibDeploy = \"external public payable override\";\nconst KwVisibDeploy = setify(_kwVisibDeploy.split(\" \"));\n// Visibility Keywords\nconst _kwVisib = \"constant external internal payable private public pure view override\";\nconst KwVisib = setify(_kwVisib.split(\" \"));\nconst _kwTypes = \"constructor error event fallback function receive struct\";\nconst KwTypes = setify(_kwTypes.split(\" \"));\nconst _kwModifiers = \"calldata memory storage payable indexed\";\nconst KwModifiers = setify(_kwModifiers.split(\" \"));\nconst _kwOther = \"tuple returns\";\n// All Keywords\nconst _keywords = [\n    _kwTypes,\n    _kwModifiers,\n    _kwOther,\n    _kwVisib\n].join(\" \");\nconst Keywords = setify(_keywords.split(\" \"));\n// Single character tokens\nconst SimpleTokens = {\n    \"(\": \"OPEN_PAREN\",\n    \")\": \"CLOSE_PAREN\",\n    \"[\": \"OPEN_BRACKET\",\n    \"]\": \"CLOSE_BRACKET\",\n    \",\": \"COMMA\",\n    \"@\": \"AT\"\n};\n// Parser regexes to consume the next token\nconst regexWhitespacePrefix = new RegExp(\"^(\\\\s*)\");\nconst regexNumberPrefix = new RegExp(\"^([0-9]+)\");\nconst regexIdPrefix = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)\");\n// Parser regexs to check validity\nconst regexId = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)$\");\nconst regexType = new RegExp(\"^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$\");\nvar _offset = /*#__PURE__*/ new WeakMap(), _tokens = /*#__PURE__*/ new WeakMap(), _subTokenString = /*#__PURE__*/ new WeakSet();\nclass TokenString {\n    get offset() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _offset);\n    }\n    get length() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _tokens).length - (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _offset);\n    }\n    clone() {\n        return new TokenString((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _tokens));\n    }\n    reset() {\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_1__._)(this, _offset, 0);\n    }\n    // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens\n    popKeyword(allowed) {\n        const top = this.peek();\n        if (top.type !== \"KEYWORD\" || !allowed.has(top.text)) {\n            throw new Error(\"expected keyword \".concat(top.text));\n        }\n        return this.pop().text;\n    }\n    // Pops and returns the value of the next token if it is `type`; throws if out of tokens\n    popType(type) {\n        if (this.peek().type !== type) {\n            const top = this.peek();\n            throw new Error(\"expected \".concat(type, \"; got \").concat(top.type, \" \").concat(JSON.stringify(top.text)));\n        }\n        return this.pop().text;\n    }\n    // Pops and returns a \"(\" TOKENS \")\"\n    popParen() {\n        const top = this.peek();\n        if (top.type !== \"OPEN_PAREN\") {\n            throw new Error(\"bad start\");\n        }\n        const result = (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _subTokenString, subTokenString).call(this, (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _offset) + 1, top.match + 1);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_1__._)(this, _offset, top.match + 1);\n        return result;\n    }\n    // Pops and returns the items within \"(\" ITEM1 \",\" ITEM2 \",\" ... \")\"\n    popParams() {\n        const top = this.peek();\n        if (top.type !== \"OPEN_PAREN\") {\n            throw new Error(\"bad start\");\n        }\n        const result = [];\n        while((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _offset) < top.match - 1){\n            const link = this.peek().linkNext;\n            result.push((0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _subTokenString, subTokenString).call(this, (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _offset) + 1, link));\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_1__._)(this, _offset, link);\n        }\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_1__._)(this, _offset, top.match + 1);\n        return result;\n    }\n    // Returns the top Token, throwing if out of tokens\n    peek() {\n        if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _offset) >= (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _tokens).length) {\n            throw new Error(\"out-of-bounds\");\n        }\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _tokens)[(0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _offset)];\n    }\n    // Returns the next value, if it is a keyword in `allowed`\n    peekKeyword(allowed) {\n        const top = this.peekType(\"KEYWORD\");\n        return top != null && allowed.has(top) ? top : null;\n    }\n    // Returns the value of the next token if it is `type`\n    peekType(type) {\n        if (this.length === 0) {\n            return null;\n        }\n        const top = this.peek();\n        return top.type === type ? top.text : null;\n    }\n    // Returns the next token; throws if out of tokens\n    pop() {\n        const result = this.peek();\n        (0,_swc_helpers_class_private_field_update__WEBPACK_IMPORTED_MODULE_3__._)(this, _offset).value++;\n        return result;\n    }\n    toString() {\n        const tokens = [];\n        for(let i = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _offset); i < (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _tokens).length; i++){\n            const token = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _tokens)[i];\n            tokens.push(\"\".concat(token.type, \":\").concat(token.text));\n        }\n        return \"<TokenString \".concat(tokens.join(\" \"), \">\");\n    }\n    constructor(tokens){\n        (0,_swc_helpers_class_private_method_init__WEBPACK_IMPORTED_MODULE_4__._)(this, _subTokenString);\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_5__._)(this, _offset, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_5__._)(this, _tokens, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_1__._)(this, _offset, 0);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_1__._)(this, _tokens, tokens.slice());\n    }\n}\nfunction subTokenString() {\n    let from = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, to = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n    return new TokenString((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _tokens).slice(from, to).map((t)=>{\n        return Object.freeze(Object.assign({}, t, {\n            match: t.match - from,\n            linkBack: t.linkBack - from,\n            linkNext: t.linkNext - from\n        }));\n    }));\n}\nfunction lex(text) {\n    const tokens = [];\n    const throwError = (message)=>{\n        const token = offset < text.length ? JSON.stringify(text[offset]) : \"$EOI\";\n        throw new Error(\"invalid token \".concat(token, \" at \").concat(offset, \": \").concat(message));\n    };\n    let brackets = [];\n    let commas = [];\n    let offset = 0;\n    while(offset < text.length){\n        // Strip off any leading whitespace\n        let cur = text.substring(offset);\n        let match = cur.match(regexWhitespacePrefix);\n        if (match) {\n            offset += match[1].length;\n            cur = text.substring(offset);\n        }\n        const token = {\n            depth: brackets.length,\n            linkBack: -1,\n            linkNext: -1,\n            match: -1,\n            type: \"\",\n            text: \"\",\n            offset,\n            value: -1\n        };\n        tokens.push(token);\n        let type = SimpleTokens[cur[0]] || \"\";\n        if (type) {\n            token.type = type;\n            token.text = cur[0];\n            offset++;\n            if (type === \"OPEN_PAREN\") {\n                brackets.push(tokens.length - 1);\n                commas.push(tokens.length - 1);\n            } else if (type == \"CLOSE_PAREN\") {\n                if (brackets.length === 0) {\n                    throwError(\"no matching open bracket\");\n                }\n                token.match = brackets.pop();\n                tokens[token.match].match = tokens.length - 1;\n                token.depth--;\n                token.linkBack = commas.pop();\n                tokens[token.linkBack].linkNext = tokens.length - 1;\n            } else if (type === \"COMMA\") {\n                token.linkBack = commas.pop();\n                tokens[token.linkBack].linkNext = tokens.length - 1;\n                commas.push(tokens.length - 1);\n            } else if (type === \"OPEN_BRACKET\") {\n                token.type = \"BRACKET\";\n            } else if (type === \"CLOSE_BRACKET\") {\n                // Remove the CLOSE_BRACKET\n                let suffix = tokens.pop().text;\n                if (tokens.length > 0 && tokens[tokens.length - 1].type === \"NUMBER\") {\n                    const value = tokens.pop().text;\n                    suffix = value + suffix;\n                    tokens[tokens.length - 1].value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getNumber)(value);\n                }\n                if (tokens.length === 0 || tokens[tokens.length - 1].type !== \"BRACKET\") {\n                    throw new Error(\"missing opening bracket\");\n                }\n                tokens[tokens.length - 1].text += suffix;\n            }\n            continue;\n        }\n        match = cur.match(regexIdPrefix);\n        if (match) {\n            token.text = match[1];\n            offset += token.text.length;\n            if (Keywords.has(token.text)) {\n                token.type = \"KEYWORD\";\n                continue;\n            }\n            if (token.text.match(regexType)) {\n                token.type = \"TYPE\";\n                continue;\n            }\n            token.type = \"ID\";\n            continue;\n        }\n        match = cur.match(regexNumberPrefix);\n        if (match) {\n            token.text = match[1];\n            token.type = \"NUMBER\";\n            offset += token.text.length;\n            continue;\n        }\n        throw new Error(\"unexpected token \".concat(JSON.stringify(cur[0]), \" at position \").concat(offset));\n    }\n    return new TokenString(tokens.map((t)=>Object.freeze(t)));\n}\n// Check only one of `allowed` is in `set`\nfunction allowSingle(set, allowed) {\n    let included = [];\n    for(const key in allowed.keys()){\n        if (set.has(key)) {\n            included.push(key);\n        }\n    }\n    if (included.length > 1) {\n        throw new Error(\"conflicting types: \".concat(included.join(\", \")));\n    }\n}\n// Functions to process a Solidity Signature TokenString from left-to-right for...\n// ...the name with an optional type, returning the name\nfunction consumeName(type, tokens) {\n    if (tokens.peekKeyword(KwTypes)) {\n        const keyword = tokens.pop().text;\n        if (keyword !== type) {\n            throw new Error(\"expected \".concat(type, \", got \").concat(keyword));\n        }\n    }\n    return tokens.popType(\"ID\");\n}\n// ...all keywords matching allowed, returning the keywords\nfunction consumeKeywords(tokens, allowed) {\n    const keywords = new Set();\n    while(true){\n        const keyword = tokens.peekType(\"KEYWORD\");\n        if (keyword == null || allowed && !allowed.has(keyword)) {\n            break;\n        }\n        tokens.pop();\n        if (keywords.has(keyword)) {\n            throw new Error(\"duplicate keywords: \".concat(JSON.stringify(keyword)));\n        }\n        keywords.add(keyword);\n    }\n    return Object.freeze(keywords);\n}\n// ...all visibility keywords, returning the coalesced mutability\nfunction consumeMutability(tokens) {\n    let modifiers = consumeKeywords(tokens, KwVisib);\n    // Detect conflicting modifiers\n    allowSingle(modifiers, setify(\"constant payable nonpayable\".split(\" \")));\n    allowSingle(modifiers, setify(\"pure view payable nonpayable\".split(\" \")));\n    // Process mutability states\n    if (modifiers.has(\"view\")) {\n        return \"view\";\n    }\n    if (modifiers.has(\"pure\")) {\n        return \"pure\";\n    }\n    if (modifiers.has(\"payable\")) {\n        return \"payable\";\n    }\n    if (modifiers.has(\"nonpayable\")) {\n        return \"nonpayable\";\n    }\n    // Process legacy `constant` last\n    if (modifiers.has(\"constant\")) {\n        return \"view\";\n    }\n    return \"nonpayable\";\n}\n// ...a parameter list, returning the ParamType list\nfunction consumeParams(tokens, allowIndexed) {\n    return tokens.popParams().map((t)=>ParamType.from(t, allowIndexed));\n}\n// ...a gas limit, returning a BigNumber or null if none\nfunction consumeGas(tokens) {\n    if (tokens.peekType(\"AT\")) {\n        tokens.pop();\n        if (tokens.peekType(\"NUMBER\")) {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBigInt)(tokens.pop().text);\n        }\n        throw new Error(\"invalid gas\");\n    }\n    return null;\n}\nfunction consumeEoi(tokens) {\n    if (tokens.length) {\n        throw new Error(\"unexpected tokens at offset \".concat(tokens.offset, \": \").concat(tokens.toString()));\n    }\n}\nconst regexArrayType = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\nfunction verifyBasicType(type) {\n    const match = type.match(regexType);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.assertArgument)(match, \"invalid type\", \"type\", type);\n    if (type === \"uint\") {\n        return \"uint256\";\n    }\n    if (type === \"int\") {\n        return \"int256\";\n    }\n    if (match[2]) {\n        // bytesXX\n        const length = parseInt(match[2]);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.assertArgument)(length !== 0 && length <= 32, \"invalid bytes length\", \"type\", type);\n    } else if (match[3]) {\n        // intXX or uintXX\n        const size = parseInt(match[3]);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.assertArgument)(size !== 0 && size <= 256 && size % 8 === 0, \"invalid numeric width\", \"type\", type);\n    }\n    return type;\n}\n// Make the Fragment constructors effectively private\nconst _guard = {};\nconst internal = Symbol.for(\"_ethers_internal\");\nconst ParamTypeInternal = \"_ParamTypeInternal\";\nconst ErrorFragmentInternal = \"_ErrorInternal\";\nconst EventFragmentInternal = \"_EventInternal\";\nconst ConstructorFragmentInternal = \"_ConstructorInternal\";\nconst FallbackFragmentInternal = \"_FallbackInternal\";\nconst FunctionFragmentInternal = \"_FunctionInternal\";\nconst StructFragmentInternal = \"_StructInternal\";\nvar _walkAsync = /*#__PURE__*/ new WeakSet();\n/**\n *  Each input and output of a [[Fragment]] is an Array of **ParamType**.\n */ class ParamType {\n    /**\n     *  Return a string representation of this type.\n     *\n     *  For example,\n     *\n     *  ``sighash\" => \"(uint256,address)\"``\n     *\n     *  ``\"minimal\" => \"tuple(uint256,address) indexed\"``\n     *\n     *  ``\"full\" => \"tuple(uint256 foo, address bar) indexed baz\"``\n     */ format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            const name = this.name || \"\";\n            if (this.isArray()) {\n                const result = JSON.parse(this.arrayChildren.format(\"json\"));\n                result.name = name;\n                result.type += \"[\".concat(this.arrayLength < 0 ? \"\" : String(this.arrayLength), \"]\");\n                return JSON.stringify(result);\n            }\n            const result = {\n                type: this.baseType === \"tuple\" ? \"tuple\" : this.type,\n                name\n            };\n            if (typeof this.indexed === \"boolean\") {\n                result.indexed = this.indexed;\n            }\n            if (this.isTuple()) {\n                result.components = this.components.map((c)=>JSON.parse(c.format(format)));\n            }\n            return JSON.stringify(result);\n        }\n        let result = \"\";\n        // Array\n        if (this.isArray()) {\n            result += this.arrayChildren.format(format);\n            result += \"[\".concat(this.arrayLength < 0 ? \"\" : String(this.arrayLength), \"]\");\n        } else {\n            if (this.isTuple()) {\n                result += \"(\" + this.components.map((comp)=>comp.format(format)).join(format === \"full\" ? \", \" : \",\") + \")\";\n            } else {\n                result += this.type;\n            }\n        }\n        if (format !== \"sighash\") {\n            if (this.indexed === true) {\n                result += \" indexed\";\n            }\n            if (format === \"full\" && this.name) {\n                result += \" \" + this.name;\n            }\n        }\n        return result;\n    }\n    /**\n     *  Returns true if %%this%% is an Array type.\n     *\n     *  This provides a type gaurd ensuring that [[arrayChildren]]\n     *  and [[arrayLength]] are non-null.\n     */ isArray() {\n        return this.baseType === \"array\";\n    }\n    /**\n     *  Returns true if %%this%% is a Tuple type.\n     *\n     *  This provides a type gaurd ensuring that [[components]]\n     *  is non-null.\n     */ isTuple() {\n        return this.baseType === \"tuple\";\n    }\n    /**\n     *  Returns true if %%this%% is an Indexable type.\n     *\n     *  This provides a type gaurd ensuring that [[indexed]]\n     *  is non-null.\n     */ isIndexable() {\n        return this.indexed != null;\n    }\n    /**\n     *  Walks the **ParamType** with %%value%%, calling %%process%%\n     *  on each type, destructing the %%value%% recursively.\n     */ walk(value, process) {\n        if (this.isArray()) {\n            if (!Array.isArray(value)) {\n                throw new Error(\"invalid array value\");\n            }\n            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\n                throw new Error(\"array is wrong length\");\n            }\n            const _this = this;\n            return value.map((v)=>_this.arrayChildren.walk(v, process));\n        }\n        if (this.isTuple()) {\n            if (!Array.isArray(value)) {\n                throw new Error(\"invalid tuple value\");\n            }\n            if (value.length !== this.components.length) {\n                throw new Error(\"array is wrong length\");\n            }\n            const _this = this;\n            return value.map((v, i)=>_this.components[i].walk(v, process));\n        }\n        return process(this.type, value);\n    }\n    /**\n     *  Walks the **ParamType** with %%value%%, asynchronously calling\n     *  %%process%% on each type, destructing the %%value%% recursively.\n     *\n     *  This can be used to resolve ENS names by walking and resolving each\n     *  ``\"address\"`` type.\n     */ async walkAsync(value, process) {\n        const promises = [];\n        const result = [\n            value\n        ];\n        (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _walkAsync, walkAsync).call(this, promises, value, process, (value)=>{\n            result[0] = value;\n        });\n        if (promises.length) {\n            await Promise.all(promises);\n        }\n        return result[0];\n    }\n    /**\n     *  Creates a new **ParamType** for %%obj%%.\n     *\n     *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,\n     *  otherwise the ``indexed`` keyword will throw an error.\n     */ static from(obj, allowIndexed) {\n        if (ParamType.isParamType(obj)) {\n            return obj;\n        }\n        if (typeof obj === \"string\") {\n            try {\n                return ParamType.from(lex(obj), allowIndexed);\n            } catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.assertArgument)(false, \"invalid param type\", \"obj\", obj);\n            }\n        } else if (obj instanceof TokenString) {\n            let type = \"\", baseType = \"\";\n            let comps = null;\n            if (consumeKeywords(obj, setify([\n                \"tuple\"\n            ])).has(\"tuple\") || obj.peekType(\"OPEN_PAREN\")) {\n                // Tuple\n                baseType = \"tuple\";\n                comps = obj.popParams().map((t)=>ParamType.from(t));\n                type = \"tuple(\".concat(comps.map((c)=>c.format()).join(\",\"), \")\");\n            } else {\n                // Normal\n                type = verifyBasicType(obj.popType(\"TYPE\"));\n                baseType = type;\n            }\n            // Check for Array\n            let arrayChildren = null;\n            let arrayLength = null;\n            while(obj.length && obj.peekType(\"BRACKET\")){\n                const bracket = obj.pop(); //arrays[i];\n                arrayChildren = new ParamType(_guard, \"\", type, baseType, null, comps, arrayLength, arrayChildren);\n                arrayLength = bracket.value;\n                type += bracket.text;\n                baseType = \"array\";\n                comps = null;\n            }\n            let indexed = null;\n            const keywords = consumeKeywords(obj, KwModifiers);\n            if (keywords.has(\"indexed\")) {\n                if (!allowIndexed) {\n                    throw new Error(\"\");\n                }\n                indexed = true;\n            }\n            const name = obj.peekType(\"ID\") ? obj.pop().text : \"\";\n            if (obj.length) {\n                throw new Error(\"leftover tokens\");\n            }\n            return new ParamType(_guard, name, type, baseType, indexed, comps, arrayLength, arrayChildren);\n        }\n        const name = obj.name;\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.assertArgument)(!name || typeof name === \"string\" && name.match(regexId), \"invalid name\", \"obj.name\", name);\n        let indexed = obj.indexed;\n        if (indexed != null) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.assertArgument)(allowIndexed, \"parameter cannot be indexed\", \"obj.indexed\", obj.indexed);\n            indexed = !!indexed;\n        }\n        let type = obj.type;\n        let arrayMatch = type.match(regexArrayType);\n        if (arrayMatch) {\n            const arrayLength = parseInt(arrayMatch[2] || \"-1\");\n            const arrayChildren = ParamType.from({\n                type: arrayMatch[1],\n                components: obj.components\n            });\n            return new ParamType(_guard, name || \"\", type, \"array\", indexed, null, arrayLength, arrayChildren);\n        }\n        if (type === \"tuple\" || type.startsWith(\"tuple(\" /* fix: ) */ ) || type.startsWith(\"(\" /* fix: ) */ )) {\n            const comps = obj.components != null ? obj.components.map((c)=>ParamType.from(c)) : null;\n            const tuple = new ParamType(_guard, name || \"\", type, \"tuple\", indexed, comps, null, null);\n            // @TODO: use lexer to validate and normalize type\n            return tuple;\n        }\n        type = verifyBasicType(obj.type);\n        return new ParamType(_guard, name || \"\", type, type, indexed, null, null, null);\n    }\n    /**\n     *  Returns true if %%value%% is a **ParamType**.\n     */ static isParamType(value) {\n        return value && value[internal] === ParamTypeInternal;\n    }\n    /**\n     *  @private\n     */ constructor(guard, name, type, baseType, indexed, components, arrayLength, arrayChildren){\n        (0,_swc_helpers_class_private_method_init__WEBPACK_IMPORTED_MODULE_4__._)(this, _walkAsync);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.assertPrivate)(guard, _guard, \"ParamType\");\n        Object.defineProperty(this, internal, {\n            value: ParamTypeInternal\n        });\n        if (components) {\n            components = Object.freeze(components.slice());\n        }\n        if (baseType === \"array\") {\n            if (arrayLength == null || arrayChildren == null) {\n                throw new Error(\"\");\n            }\n        } else if (arrayLength != null || arrayChildren != null) {\n            throw new Error(\"\");\n        }\n        if (baseType === \"tuple\") {\n            if (components == null) {\n                throw new Error(\"\");\n            }\n        } else if (components != null) {\n            throw new Error(\"\");\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.defineProperties)(this, {\n            name,\n            type,\n            baseType,\n            indexed,\n            components,\n            arrayLength,\n            arrayChildren\n        });\n    }\n}\nfunction walkAsync(promises, value, process, setValue) {\n    var _components_index;\n    if (this.isArray()) {\n        if (!Array.isArray(value)) {\n            throw new Error(\"invalid array value\");\n        }\n        if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\n            throw new Error(\"array is wrong length\");\n        }\n        const childType = this.arrayChildren;\n        const result = value.slice();\n        result.forEach((value, index)=>{\n            (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_2__._)(childType, _walkAsync, walkAsync).call(childType, promises, value, process, (value)=>{\n                result[index] = value;\n            });\n        });\n        setValue(result);\n        return;\n    }\n    if (this.isTuple()) {\n        const components = this.components;\n        // Convert the object into an array\n        let result;\n        if (Array.isArray(value)) {\n            result = value.slice();\n        } else {\n            if (value == null || typeof value !== \"object\") {\n                throw new Error(\"invalid tuple value\");\n            }\n            result = components.map((param)=>{\n                if (!param.name) {\n                    throw new Error(\"cannot use object value with unnamed components\");\n                }\n                if (!(param.name in value)) {\n                    throw new Error(\"missing value for component \".concat(param.name));\n                }\n                return value[param.name];\n            });\n        }\n        if (result.length !== this.components.length) {\n            throw new Error(\"array is wrong length\");\n        }\n        result.forEach((value, index)=>{\n            (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_2__._)(_components_index = components[index], _walkAsync, walkAsync).call(_components_index, promises, value, process, (value)=>{\n                result[index] = value;\n            });\n        });\n        setValue(result);\n        return;\n    }\n    const result = process(this.type, value);\n    if (result.then) {\n        promises.push(async function() {\n            setValue(await result);\n        }());\n    } else {\n        setValue(result);\n    }\n}\n/**\n *  An abstract class to represent An individual fragment from a parse ABI.\n */ class Fragment {\n    /**\n     *  Creates a new **Fragment** for %%obj%%, wich can be any supported\n     *  ABI frgament type.\n     */ static from(obj) {\n        if (typeof obj === \"string\") {\n            // Try parsing JSON...\n            try {\n                Fragment.from(JSON.parse(obj));\n            } catch (e) {}\n            // ...otherwise, use the human-readable lexer\n            return Fragment.from(lex(obj));\n        }\n        if (obj instanceof TokenString) {\n            // Human-readable ABI (already lexed)\n            const type = obj.peekKeyword(KwTypes);\n            switch(type){\n                case \"constructor\":\n                    return ConstructorFragment.from(obj);\n                case \"error\":\n                    return ErrorFragment.from(obj);\n                case \"event\":\n                    return EventFragment.from(obj);\n                case \"fallback\":\n                case \"receive\":\n                    return FallbackFragment.from(obj);\n                case \"function\":\n                    return FunctionFragment.from(obj);\n                case \"struct\":\n                    return StructFragment.from(obj);\n            }\n        } else if (typeof obj === \"object\") {\n            // JSON ABI\n            switch(obj.type){\n                case \"constructor\":\n                    return ConstructorFragment.from(obj);\n                case \"error\":\n                    return ErrorFragment.from(obj);\n                case \"event\":\n                    return EventFragment.from(obj);\n                case \"fallback\":\n                case \"receive\":\n                    return FallbackFragment.from(obj);\n                case \"function\":\n                    return FunctionFragment.from(obj);\n                case \"struct\":\n                    return StructFragment.from(obj);\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.assert)(false, \"unsupported type: \".concat(obj.type), \"UNSUPPORTED_OPERATION\", {\n                operation: \"Fragment.from\"\n            });\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.assertArgument)(false, \"unsupported frgament object\", \"obj\", obj);\n    }\n    /**\n     *  Returns true if %%value%% is a [[ConstructorFragment]].\n     */ static isConstructor(value) {\n        return ConstructorFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is an [[ErrorFragment]].\n     */ static isError(value) {\n        return ErrorFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is an [[EventFragment]].\n     */ static isEvent(value) {\n        return EventFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is a [[FunctionFragment]].\n     */ static isFunction(value) {\n        return FunctionFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is a [[StructFragment]].\n     */ static isStruct(value) {\n        return StructFragment.isFragment(value);\n    }\n    /**\n     *  @private\n     */ constructor(guard, type, inputs){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.assertPrivate)(guard, _guard, \"Fragment\");\n        inputs = Object.freeze(inputs.slice());\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.defineProperties)(this, {\n            type,\n            inputs\n        });\n    }\n}\n/**\n *  An abstract class to represent An individual fragment\n *  which has a name from a parse ABI.\n */ class NamedFragment extends Fragment {\n    /**\n     *  @private\n     */ constructor(guard, type, name, inputs){\n        super(guard, type, inputs);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.assertArgument)(typeof name === \"string\" && name.match(regexId), \"invalid identifier\", \"name\", name);\n        inputs = Object.freeze(inputs.slice());\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.defineProperties)(this, {\n            name\n        });\n    }\n}\nfunction joinParams(format, params) {\n    return \"(\" + params.map((p)=>p.format(format)).join(format === \"full\" ? \", \" : \",\") + \")\";\n}\n/**\n *  A Fragment which represents a //Custom Error//.\n */ class ErrorFragment extends NamedFragment {\n    /**\n     *  The Custom Error selector.\n     */ get selector() {\n        return (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_9__.id)(this.format(\"sighash\")).substring(0, 10);\n    }\n    /**\n     *  Returns a string representation of this fragment as %%format%%.\n     */ format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"error\",\n                name: this.name,\n                inputs: this.inputs.map((input)=>JSON.parse(input.format(format)))\n            });\n        }\n        const result = [];\n        if (format !== \"sighash\") {\n            result.push(\"error\");\n        }\n        result.push(this.name + joinParams(format, this.inputs));\n        return result.join(\" \");\n    }\n    /**\n     *  Returns a new **ErrorFragment** for %%obj%%.\n     */ static from(obj) {\n        if (ErrorFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof obj === \"string\") {\n            return ErrorFragment.from(lex(obj));\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"error\", obj);\n            const inputs = consumeParams(obj);\n            consumeEoi(obj);\n            return new ErrorFragment(_guard, name, inputs);\n        }\n        return new ErrorFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is an\n     *  **ErrorFragment**.\n     */ static isFragment(value) {\n        return value && value[internal] === ErrorFragmentInternal;\n    }\n    /**\n     *  @private\n     */ constructor(guard, name, inputs){\n        super(guard, \"error\", name, inputs);\n        Object.defineProperty(this, internal, {\n            value: ErrorFragmentInternal\n        });\n    }\n}\n/**\n *  A Fragment which represents an Event.\n */ class EventFragment extends NamedFragment {\n    /**\n     *  The Event topic hash.\n     */ get topicHash() {\n        return (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_9__.id)(this.format(\"sighash\"));\n    }\n    /**\n     *  Returns a string representation of this event as %%format%%.\n     */ format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"event\",\n                anonymous: this.anonymous,\n                name: this.name,\n                inputs: this.inputs.map((i)=>JSON.parse(i.format(format)))\n            });\n        }\n        const result = [];\n        if (format !== \"sighash\") {\n            result.push(\"event\");\n        }\n        result.push(this.name + joinParams(format, this.inputs));\n        if (format !== \"sighash\" && this.anonymous) {\n            result.push(\"anonymous\");\n        }\n        return result.join(\" \");\n    }\n    /**\n     *  Return the topic hash for an event with %%name%% and %%params%%.\n     */ static getTopicHash(name, params) {\n        params = (params || []).map((p)=>ParamType.from(p));\n        const fragment = new EventFragment(_guard, name, params, false);\n        return fragment.topicHash;\n    }\n    /**\n     *  Returns a new **EventFragment** for %%obj%%.\n     */ static from(obj) {\n        if (EventFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof obj === \"string\") {\n            try {\n                return EventFragment.from(lex(obj));\n            } catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.assertArgument)(false, \"invalid event fragment\", \"obj\", obj);\n            }\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"event\", obj);\n            const inputs = consumeParams(obj, true);\n            const anonymous = !!consumeKeywords(obj, setify([\n                \"anonymous\"\n            ])).has(\"anonymous\");\n            consumeEoi(obj);\n            return new EventFragment(_guard, name, inputs, anonymous);\n        }\n        return new EventFragment(_guard, obj.name, obj.inputs ? obj.inputs.map((p)=>ParamType.from(p, true)) : [], !!obj.anonymous);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is an\n     *  **EventFragment**.\n     */ static isFragment(value) {\n        return value && value[internal] === EventFragmentInternal;\n    }\n    /**\n     *  @private\n     */ constructor(guard, name, inputs, anonymous){\n        super(guard, \"event\", name, inputs);\n        Object.defineProperty(this, internal, {\n            value: EventFragmentInternal\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.defineProperties)(this, {\n            anonymous\n        });\n    }\n}\n/**\n *  A Fragment which represents a constructor.\n */ class ConstructorFragment extends Fragment {\n    /**\n     *  Returns a string representation of this constructor as %%format%%.\n     */ format(format) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.assert)(format != null && format !== \"sighash\", \"cannot format a constructor for sighash\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"format(sighash)\"\n        });\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"constructor\",\n                stateMutability: this.payable ? \"payable\" : \"undefined\",\n                payable: this.payable,\n                gas: this.gas != null ? this.gas : undefined,\n                inputs: this.inputs.map((i)=>JSON.parse(i.format(format)))\n            });\n        }\n        const result = [\n            \"constructor\".concat(joinParams(format, this.inputs))\n        ];\n        if (this.payable) {\n            result.push(\"payable\");\n        }\n        if (this.gas != null) {\n            result.push(\"@\".concat(this.gas.toString()));\n        }\n        return result.join(\" \");\n    }\n    /**\n     *  Returns a new **ConstructorFragment** for %%obj%%.\n     */ static from(obj) {\n        if (ConstructorFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof obj === \"string\") {\n            try {\n                return ConstructorFragment.from(lex(obj));\n            } catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.assertArgument)(false, \"invalid constuctor fragment\", \"obj\", obj);\n            }\n        } else if (obj instanceof TokenString) {\n            consumeKeywords(obj, setify([\n                \"constructor\"\n            ]));\n            const inputs = consumeParams(obj);\n            const payable = !!consumeKeywords(obj, KwVisibDeploy).has(\"payable\");\n            const gas = consumeGas(obj);\n            consumeEoi(obj);\n            return new ConstructorFragment(_guard, \"constructor\", inputs, payable, gas);\n        }\n        return new ConstructorFragment(_guard, \"constructor\", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, obj.gas != null ? obj.gas : null);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **ConstructorFragment**.\n     */ static isFragment(value) {\n        return value && value[internal] === ConstructorFragmentInternal;\n    }\n    /**\n     *  @private\n     */ constructor(guard, type, inputs, payable, gas){\n        super(guard, type, inputs);\n        Object.defineProperty(this, internal, {\n            value: ConstructorFragmentInternal\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.defineProperties)(this, {\n            payable,\n            gas\n        });\n    }\n}\n/**\n *  A Fragment which represents a method.\n */ class FallbackFragment extends Fragment {\n    /**\n     *  Returns a string representation of this fallback as %%format%%.\n     */ format(format) {\n        const type = this.inputs.length === 0 ? \"receive\" : \"fallback\";\n        if (format === \"json\") {\n            const stateMutability = this.payable ? \"payable\" : \"nonpayable\";\n            return JSON.stringify({\n                type,\n                stateMutability\n            });\n        }\n        return \"\".concat(type, \"()\").concat(this.payable ? \" payable\" : \"\");\n    }\n    /**\n     *  Returns a new **FallbackFragment** for %%obj%%.\n     */ static from(obj) {\n        if (FallbackFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof obj === \"string\") {\n            try {\n                return FallbackFragment.from(lex(obj));\n            } catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.assertArgument)(false, \"invalid fallback fragment\", \"obj\", obj);\n            }\n        } else if (obj instanceof TokenString) {\n            const errorObj = obj.toString();\n            const topIsValid = obj.peekKeyword(setify([\n                \"fallback\",\n                \"receive\"\n            ]));\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.assertArgument)(topIsValid, \"type must be fallback or receive\", \"obj\", errorObj);\n            const type = obj.popKeyword(setify([\n                \"fallback\",\n                \"receive\"\n            ]));\n            // receive()\n            if (type === \"receive\") {\n                const inputs = consumeParams(obj);\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.assertArgument)(inputs.length === 0, \"receive cannot have arguments\", \"obj.inputs\", inputs);\n                consumeKeywords(obj, setify([\n                    \"payable\"\n                ]));\n                consumeEoi(obj);\n                return new FallbackFragment(_guard, [], true);\n            }\n            // fallback() [payable]\n            // fallback(bytes) [payable] returns (bytes)\n            let inputs = consumeParams(obj);\n            if (inputs.length) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.assertArgument)(inputs.length === 1 && inputs[0].type === \"bytes\", \"invalid fallback inputs\", \"obj.inputs\", inputs.map((i)=>i.format(\"minimal\")).join(\", \"));\n            } else {\n                inputs = [\n                    ParamType.from(\"bytes\")\n                ];\n            }\n            const mutability = consumeMutability(obj);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.assertArgument)(mutability === \"nonpayable\" || mutability === \"payable\", \"fallback cannot be constants\", \"obj.stateMutability\", mutability);\n            if (consumeKeywords(obj, setify([\n                \"returns\"\n            ])).has(\"returns\")) {\n                const outputs = consumeParams(obj);\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.assertArgument)(outputs.length === 1 && outputs[0].type === \"bytes\", \"invalid fallback outputs\", \"obj.outputs\", outputs.map((i)=>i.format(\"minimal\")).join(\", \"));\n            }\n            consumeEoi(obj);\n            return new FallbackFragment(_guard, inputs, mutability === \"payable\");\n        }\n        if (obj.type === \"receive\") {\n            return new FallbackFragment(_guard, [], true);\n        }\n        if (obj.type === \"fallback\") {\n            const inputs = [\n                ParamType.from(\"bytes\")\n            ];\n            const payable = obj.stateMutability === \"payable\";\n            return new FallbackFragment(_guard, inputs, payable);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.assertArgument)(false, \"invalid fallback description\", \"obj\", obj);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **FallbackFragment**.\n     */ static isFragment(value) {\n        return value && value[internal] === FallbackFragmentInternal;\n    }\n    constructor(guard, inputs, payable){\n        super(guard, \"fallback\", inputs);\n        Object.defineProperty(this, internal, {\n            value: FallbackFragmentInternal\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.defineProperties)(this, {\n            payable\n        });\n    }\n}\n/**\n *  A Fragment which represents a method.\n */ class FunctionFragment extends NamedFragment {\n    /**\n     *  The Function selector.\n     */ get selector() {\n        return (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_9__.id)(this.format(\"sighash\")).substring(0, 10);\n    }\n    /**\n     *  Returns a string representation of this function as %%format%%.\n     */ format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"function\",\n                name: this.name,\n                constant: this.constant,\n                stateMutability: this.stateMutability !== \"nonpayable\" ? this.stateMutability : undefined,\n                payable: this.payable,\n                gas: this.gas != null ? this.gas : undefined,\n                inputs: this.inputs.map((i)=>JSON.parse(i.format(format))),\n                outputs: this.outputs.map((o)=>JSON.parse(o.format(format)))\n            });\n        }\n        const result = [];\n        if (format !== \"sighash\") {\n            result.push(\"function\");\n        }\n        result.push(this.name + joinParams(format, this.inputs));\n        if (format !== \"sighash\") {\n            if (this.stateMutability !== \"nonpayable\") {\n                result.push(this.stateMutability);\n            }\n            if (this.outputs && this.outputs.length) {\n                result.push(\"returns\");\n                result.push(joinParams(format, this.outputs));\n            }\n            if (this.gas != null) {\n                result.push(\"@\".concat(this.gas.toString()));\n            }\n        }\n        return result.join(\" \");\n    }\n    /**\n     *  Return the selector for a function with %%name%% and %%params%%.\n     */ static getSelector(name, params) {\n        params = (params || []).map((p)=>ParamType.from(p));\n        const fragment = new FunctionFragment(_guard, name, \"view\", params, [], null);\n        return fragment.selector;\n    }\n    /**\n     *  Returns a new **FunctionFragment** for %%obj%%.\n     */ static from(obj) {\n        if (FunctionFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof obj === \"string\") {\n            try {\n                return FunctionFragment.from(lex(obj));\n            } catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.assertArgument)(false, \"invalid function fragment\", \"obj\", obj);\n            }\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"function\", obj);\n            const inputs = consumeParams(obj);\n            const mutability = consumeMutability(obj);\n            let outputs = [];\n            if (consumeKeywords(obj, setify([\n                \"returns\"\n            ])).has(\"returns\")) {\n                outputs = consumeParams(obj);\n            }\n            const gas = consumeGas(obj);\n            consumeEoi(obj);\n            return new FunctionFragment(_guard, name, mutability, inputs, outputs, gas);\n        }\n        let stateMutability = obj.stateMutability;\n        // Use legacy Solidity ABI logic if stateMutability is missing\n        if (stateMutability == null) {\n            stateMutability = \"payable\";\n            if (typeof obj.constant === \"boolean\") {\n                stateMutability = \"view\";\n                if (!obj.constant) {\n                    stateMutability = \"payable\";\n                    if (typeof obj.payable === \"boolean\" && !obj.payable) {\n                        stateMutability = \"nonpayable\";\n                    }\n                }\n            } else if (typeof obj.payable === \"boolean\" && !obj.payable) {\n                stateMutability = \"nonpayable\";\n            }\n        }\n        // @TODO: verifyState for stateMutability (e.g. throw if\n        //        payable: false but stateMutability is \"nonpayable\")\n        return new FunctionFragment(_guard, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], obj.gas != null ? obj.gas : null);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **FunctionFragment**.\n     */ static isFragment(value) {\n        return value && value[internal] === FunctionFragmentInternal;\n    }\n    /**\n     *  @private\n     */ constructor(guard, name, stateMutability, inputs, outputs, gas){\n        super(guard, \"function\", name, inputs);\n        Object.defineProperty(this, internal, {\n            value: FunctionFragmentInternal\n        });\n        outputs = Object.freeze(outputs.slice());\n        const constant = stateMutability === \"view\" || stateMutability === \"pure\";\n        const payable = stateMutability === \"payable\";\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.defineProperties)(this, {\n            constant,\n            gas,\n            outputs,\n            payable,\n            stateMutability\n        });\n    }\n}\n/**\n *  A Fragment which represents a structure.\n */ class StructFragment extends NamedFragment {\n    /**\n     *  Returns a string representation of this struct as %%format%%.\n     */ format() {\n        throw new Error(\"@TODO\");\n    }\n    /**\n     *  Returns a new **StructFragment** for %%obj%%.\n     */ static from(obj) {\n        if (typeof obj === \"string\") {\n            try {\n                return StructFragment.from(lex(obj));\n            } catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.assertArgument)(false, \"invalid struct fragment\", \"obj\", obj);\n            }\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"struct\", obj);\n            const inputs = consumeParams(obj);\n            consumeEoi(obj);\n            return new StructFragment(_guard, name, inputs);\n        }\n        return new StructFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);\n    }\n    // @TODO: fix this return type\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **StructFragment**.\n     */ static isFragment(value) {\n        return value && value[internal] === StructFragmentInternal;\n    }\n    /**\n     *  @private\n     */ constructor(guard, name, inputs){\n        super(guard, \"struct\", name, inputs);\n        Object.defineProperty(this, internal, {\n            value: StructFragmentInternal\n        });\n    }\n} //# sourceMappingURL=fragments.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvZnJhZ21lbnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7OztDQVVDOzs7Ozs7QUFDaUg7QUFDNUU7O0FBRXRDLHFDQUFxQztBQUNyQyxTQUFTTyxPQUFPQyxLQUFLO0lBQ2pCLE1BQU1DLFNBQVMsSUFBSUM7SUFDbkJGLE1BQU1HLE9BQU8sQ0FBQyxDQUFDQyxJQUFNSCxPQUFPSSxHQUFHLENBQUNEO0lBQ2hDLE9BQU9FLE9BQU9DLE1BQU0sQ0FBQ047QUFDekI7QUFDQSxNQUFNTyxpQkFBaUI7QUFDdkIsTUFBTUMsZ0JBQWdCVixPQUFPUyxlQUFlRSxLQUFLLENBQUM7QUFDbEQsc0JBQXNCO0FBQ3RCLE1BQU1DLFdBQVc7QUFDakIsTUFBTUMsVUFBVWIsT0FBT1ksU0FBU0QsS0FBSyxDQUFDO0FBQ3RDLE1BQU1HLFdBQVc7QUFDakIsTUFBTUMsVUFBVWYsT0FBT2MsU0FBU0gsS0FBSyxDQUFDO0FBQ3RDLE1BQU1LLGVBQWU7QUFDckIsTUFBTUMsY0FBY2pCLE9BQU9nQixhQUFhTCxLQUFLLENBQUM7QUFDOUMsTUFBTU8sV0FBVztBQUNqQixlQUFlO0FBQ2YsTUFBTUMsWUFBWTtJQUFDTDtJQUFVRTtJQUFjRTtJQUFVTjtDQUFTLENBQUNRLElBQUksQ0FBQztBQUNwRSxNQUFNQyxXQUFXckIsT0FBT21CLFVBQVVSLEtBQUssQ0FBQztBQUN4QywwQkFBMEI7QUFDMUIsTUFBTVcsZUFBZTtJQUNqQixLQUFLO0lBQWMsS0FBSztJQUN4QixLQUFLO0lBQWdCLEtBQUs7SUFDMUIsS0FBSztJQUFTLEtBQUs7QUFDdkI7QUFDQSwyQ0FBMkM7QUFDM0MsTUFBTUMsd0JBQXdCLElBQUlDLE9BQU87QUFDekMsTUFBTUMsb0JBQW9CLElBQUlELE9BQU87QUFDckMsTUFBTUUsZ0JBQWdCLElBQUlGLE9BQU87QUFDakMsa0NBQWtDO0FB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T0FBTywyQkFBMkIsT0FBT3FJO1lBQzVEO1FBQ0osT0FDSyxJQUFJQSxlQUFldEcsYUFBYTtZQUNqQyxNQUFNZ0YsT0FBTzNCLFlBQVksVUFBVWlEO1lBQ25DLE1BQU04QixTQUFTekUsY0FBYzJDO1lBQzdCdkMsV0FBV3VDO1lBQ1gsT0FBTyxJQUFJc0IsZUFBZXhELFFBQVFZLE1BQU1vRDtRQUM1QztRQUNBLE9BQU8sSUFBSVIsZUFBZXhELFFBQVFrQyxJQUFJdEIsSUFBSSxFQUFFc0IsSUFBSThCLE1BQU0sR0FBRzlCLElBQUk4QixNQUFNLENBQUNsRyxHQUFHLENBQUMyQixVQUFVN0IsSUFBSSxJQUFJLEVBQUU7SUFDaEc7SUFDQSw4QkFBOEI7SUFDOUI7OztLQUdDLEdBQ0QsT0FBTytGLFdBQVdqRixLQUFLLEVBQUU7UUFDckIsT0FBUUEsU0FBU0EsS0FBSyxDQUFDdUIsU0FBUyxLQUFLUztJQUN6QztJQXhDQTs7S0FFQyxHQUNEaEQsWUFBWWdGLEtBQUssRUFBRTlCLElBQUksRUFBRW9ELE1BQU0sQ0FBRTtRQUM3QixLQUFLLENBQUN0QixPQUFPLFVBQVU5QixNQUFNb0Q7UUFDN0IxSixPQUFPcUksY0FBYyxDQUFDLElBQUksRUFBRTFDLFVBQVU7WUFBRXZCLE9BQU9nQztRQUF1QjtJQUMxRTtBQW1DSixFQUNBLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2ZyYWdtZW50cy5qcz83MWIwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIEEgZnJhZ21lbnQgaXMgYSBzaW5nbGUgaXRlbSBmcm9tIGFuIEFCSSwgd2hpY2ggbWF5IHJlcHJlc2VudCBhbnkgb2Y6XG4gKlxuICogIC0gW0Z1bmN0aW9uc10oRnVuY3Rpb25GcmFnbWVudClcbiAqICAtIFtFdmVudHNdKEV2ZW50RnJhZ21lbnQpXG4gKiAgLSBbQ29uc3RydWN0b3JzXShDb25zdHJ1Y3RvckZyYWdtZW50KVxuICogIC0gQ3VzdG9tIFtFcnJvcnNdKEVycm9yRnJhZ21lbnQpXG4gKiAgLSBbRmFsbGJhY2sgb3IgUmVjZWl2ZV0oRmFsbGJhY2tGcmFnbWVudCkgZnVuY3Rpb25zXG4gKlxuICogIEBfc3Vic2VjdGlvbiBhcGkvYWJpL2FiaS1jb2RlcjpGcmFnbWVudHMgIFthYm91dC1mcmFnbWVudHNdXG4gKi9cbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGdldEJpZ0ludCwgZ2V0TnVtYmVyLCBhc3NlcnQsIGFzc2VydFByaXZhdGUsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBpZCB9IGZyb20gXCIuLi9oYXNoL2luZGV4LmpzXCI7XG47XG4vLyBbIFwiYVwiLCBcImJcIiBdID0+IHsgXCJhXCI6IDEsIFwiYlwiOiAxIH1cbmZ1bmN0aW9uIHNldGlmeShpdGVtcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTZXQoKTtcbiAgICBpdGVtcy5mb3JFYWNoKChrKSA9PiByZXN1bHQuYWRkKGspKTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShyZXN1bHQpO1xufVxuY29uc3QgX2t3VmlzaWJEZXBsb3kgPSBcImV4dGVybmFsIHB1YmxpYyBwYXlhYmxlIG92ZXJyaWRlXCI7XG5jb25zdCBLd1Zpc2liRGVwbG95ID0gc2V0aWZ5KF9rd1Zpc2liRGVwbG95LnNwbGl0KFwiIFwiKSk7XG4vLyBWaXNpYmlsaXR5IEtleXdvcmRzXG5jb25zdCBfa3dWaXNpYiA9IFwiY29uc3RhbnQgZXh0ZXJuYWwgaW50ZXJuYWwgcGF5YWJsZSBwcml2YXRlIHB1YmxpYyBwdXJlIHZpZXcgb3ZlcnJpZGVcIjtcbmNvbnN0IEt3VmlzaWIgPSBzZXRpZnkoX2t3VmlzaWIuc3BsaXQoXCIgXCIpKTtcbmNvbnN0IF9rd1R5cGVzID0gXCJjb25zdHJ1Y3RvciBlcnJvciBldmVudCBmYWxsYmFjayBmdW5jdGlvbiByZWNlaXZlIHN0cnVjdFwiO1xuY29uc3QgS3dUeXBlcyA9IHNldGlmeShfa3dUeXBlcy5zcGxpdChcIiBcIikpO1xuY29uc3QgX2t3TW9kaWZpZXJzID0gXCJjYWxsZGF0YSBtZW1vcnkgc3RvcmFnZSBwYXlhYmxlIGluZGV4ZWRcIjtcbmNvbnN0IEt3TW9kaWZpZXJzID0gc2V0aWZ5KF9rd01vZGlmaWVycy5zcGxpdChcIiBcIikpO1xuY29uc3QgX2t3T3RoZXIgPSBcInR1cGxlIHJldHVybnNcIjtcbi8vIEFsbCBLZXl3b3Jkc1xuY29uc3QgX2tleXdvcmRzID0gW19rd1R5cGVzLCBfa3dNb2RpZmllcnMsIF9rd090aGVyLCBfa3dWaXNpYl0uam9pbihcIiBcIik7XG5jb25zdCBLZXl3b3JkcyA9IHNldGlmeShfa2V5d29yZHMuc3BsaXQoXCIgXCIpKTtcbi8vIFNpbmdsZSBjaGFyYWN0ZXIgdG9rZW5zXG5jb25zdCBTaW1wbGVUb2tlbnMgPSB7XG4gICAgXCIoXCI6IFwiT1BFTl9QQVJFTlwiLCBcIilcIjogXCJDTE9TRV9QQVJFTlwiLFxuICAgIFwiW1wiOiBcIk9QRU5fQlJBQ0tFVFwiLCBcIl1cIjogXCJDTE9TRV9CUkFDS0VUXCIsXG4gICAgXCIsXCI6IFwiQ09NTUFcIiwgXCJAXCI6IFwiQVRcIlxufTtcbi8vIFBhcnNlciByZWdleGVzIHRvIGNvbnN1bWUgdGhlIG5leHQgdG9rZW5cbmNvbnN0IHJlZ2V4V2hpdGVzcGFjZVByZWZpeCA9IG5ldyBSZWdFeHAoXCJeKFxcXFxzKilcIik7XG5jb25zdCByZWdleE51bWJlclByZWZpeCA9IG5ldyBSZWdFeHAoXCJeKFswLTldKylcIik7XG5jb25zdCByZWdleElkUHJlZml4ID0gbmV3IFJlZ0V4cChcIl4oW2EtekEtWiRfXVthLXpBLVowLTkkX10qKVwiKTtcbi8vIFBhcnNlciByZWdleHMgdG8gY2hlY2sgdmFsaWRpdHlcbmNvbnN0IHJlZ2V4SWQgPSBuZXcgUmVnRXhwKFwiXihbYS16QS1aJF9dW2EtekEtWjAtOSRfXSopJFwiKTtcbmNvbnN0IHJlZ2V4VHlwZSA9IG5ldyBSZWdFeHAoXCJeKGFkZHJlc3N8Ym9vbHxieXRlcyhbMC05XSopfHN0cmluZ3x1P2ludChbMC05XSopKSRcIik7XG5jbGFzcyBUb2tlblN0cmluZyB7XG4gICAgI29mZnNldDtcbiAgICAjdG9rZW5zO1xuICAgIGdldCBvZmZzZXQoKSB7IHJldHVybiB0aGlzLiNvZmZzZXQ7IH1cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy4jdG9rZW5zLmxlbmd0aCAtIHRoaXMuI29mZnNldDsgfVxuICAgIGNvbnN0cnVjdG9yKHRva2Vucykge1xuICAgICAgICB0aGlzLiNvZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLiN0b2tlbnMgPSB0b2tlbnMuc2xpY2UoKTtcbiAgICB9XG4gICAgY2xvbmUoKSB7IHJldHVybiBuZXcgVG9rZW5TdHJpbmcodGhpcy4jdG9rZW5zKTsgfVxuICAgIHJlc2V0KCkgeyB0aGlzLiNvZmZzZXQgPSAwOyB9XG4gICAgI3N1YlRva2VuU3RyaW5nKGZyb20gPSAwLCB0byA9IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUb2tlblN0cmluZyh0aGlzLiN0b2tlbnMuc2xpY2UoZnJvbSwgdG8pLm1hcCgodCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUoT2JqZWN0LmFzc2lnbih7fSwgdCwge1xuICAgICAgICAgICAgICAgIG1hdGNoOiAodC5tYXRjaCAtIGZyb20pLFxuICAgICAgICAgICAgICAgIGxpbmtCYWNrOiAodC5saW5rQmFjayAtIGZyb20pLFxuICAgICAgICAgICAgICAgIGxpbmtOZXh0OiAodC5saW5rTmV4dCAtIGZyb20pLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIC8vIFBvcHMgYW5kIHJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBuZXh0IHRva2VuLCBpZiBpdCBpcyBhIGtleXdvcmQgaW4gYWxsb3dlZDsgdGhyb3dzIGlmIG91dCBvZiB0b2tlbnNcbiAgICBwb3BLZXl3b3JkKGFsbG93ZWQpIHtcbiAgICAgICAgY29uc3QgdG9wID0gdGhpcy5wZWVrKCk7XG4gICAgICAgIGlmICh0b3AudHlwZSAhPT0gXCJLRVlXT1JEXCIgfHwgIWFsbG93ZWQuaGFzKHRvcC50ZXh0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCBrZXl3b3JkICR7dG9wLnRleHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucG9wKCkudGV4dDtcbiAgICB9XG4gICAgLy8gUG9wcyBhbmQgcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIG5leHQgdG9rZW4gaWYgaXQgaXMgYHR5cGVgOyB0aHJvd3MgaWYgb3V0IG9mIHRva2Vuc1xuICAgIHBvcFR5cGUodHlwZSkge1xuICAgICAgICBpZiAodGhpcy5wZWVrKCkudHlwZSAhPT0gdHlwZSkge1xuICAgICAgICAgICAgY29uc3QgdG9wID0gdGhpcy5wZWVrKCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkICR7dHlwZX07IGdvdCAke3RvcC50eXBlfSAke0pTT04uc3RyaW5naWZ5KHRvcC50ZXh0KX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wb3AoKS50ZXh0O1xuICAgIH1cbiAgICAvLyBQb3BzIGFuZCByZXR1cm5zIGEgXCIoXCIgVE9LRU5TIFwiKVwiXG4gICAgcG9wUGFyZW4oKSB7XG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVlaygpO1xuICAgICAgICBpZiAodG9wLnR5cGUgIT09IFwiT1BFTl9QQVJFTlwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgc3RhcnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy4jc3ViVG9rZW5TdHJpbmcodGhpcy4jb2Zmc2V0ICsgMSwgdG9wLm1hdGNoICsgMSk7XG4gICAgICAgIHRoaXMuI29mZnNldCA9IHRvcC5tYXRjaCArIDE7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIFBvcHMgYW5kIHJldHVybnMgdGhlIGl0ZW1zIHdpdGhpbiBcIihcIiBJVEVNMSBcIixcIiBJVEVNMiBcIixcIiAuLi4gXCIpXCJcbiAgICBwb3BQYXJhbXMoKSB7XG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVlaygpO1xuICAgICAgICBpZiAodG9wLnR5cGUgIT09IFwiT1BFTl9QQVJFTlwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgc3RhcnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLiNvZmZzZXQgPCB0b3AubWF0Y2ggLSAxKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5rID0gdGhpcy5wZWVrKCkubGlua05leHQ7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLiNzdWJUb2tlblN0cmluZyh0aGlzLiNvZmZzZXQgKyAxLCBsaW5rKSk7XG4gICAgICAgICAgICB0aGlzLiNvZmZzZXQgPSBsaW5rO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI29mZnNldCA9IHRvcC5tYXRjaCArIDE7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIHRvcCBUb2tlbiwgdGhyb3dpbmcgaWYgb3V0IG9mIHRva2Vuc1xuICAgIHBlZWsoKSB7XG4gICAgICAgIGlmICh0aGlzLiNvZmZzZXQgPj0gdGhpcy4jdG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib3V0LW9mLWJvdW5kc1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jdG9rZW5zW3RoaXMuI29mZnNldF07XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIG5leHQgdmFsdWUsIGlmIGl0IGlzIGEga2V5d29yZCBpbiBgYWxsb3dlZGBcbiAgICBwZWVrS2V5d29yZChhbGxvd2VkKSB7XG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVla1R5cGUoXCJLRVlXT1JEXCIpO1xuICAgICAgICByZXR1cm4gKHRvcCAhPSBudWxsICYmIGFsbG93ZWQuaGFzKHRvcCkpID8gdG9wIDogbnVsbDtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIG5leHQgdG9rZW4gaWYgaXQgaXMgYHR5cGVgXG4gICAgcGVla1R5cGUodHlwZSkge1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVlaygpO1xuICAgICAgICByZXR1cm4gKHRvcC50eXBlID09PSB0eXBlKSA/IHRvcC50ZXh0IDogbnVsbDtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgbmV4dCB0b2tlbjsgdGhyb3dzIGlmIG91dCBvZiB0b2tlbnNcbiAgICBwb3AoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucGVlaygpO1xuICAgICAgICB0aGlzLiNvZmZzZXQrKztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy4jb2Zmc2V0OyBpIDwgdGhpcy4jdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMuI3Rva2Vuc1tpXTtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKGAke3Rva2VuLnR5cGV9OiR7dG9rZW4udGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYDxUb2tlblN0cmluZyAke3Rva2Vucy5qb2luKFwiIFwiKX0+YDtcbiAgICB9XG59XG5mdW5jdGlvbiBsZXgodGV4dCkge1xuICAgIGNvbnN0IHRva2VucyA9IFtdO1xuICAgIGNvbnN0IHRocm93RXJyb3IgPSAobWVzc2FnZSkgPT4ge1xuICAgICAgICBjb25zdCB0b2tlbiA9IChvZmZzZXQgPCB0ZXh0Lmxlbmd0aCkgPyBKU09OLnN0cmluZ2lmeSh0ZXh0W29mZnNldF0pIDogXCIkRU9JXCI7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB0b2tlbiAke3Rva2VufSBhdCAke29mZnNldH06ICR7bWVzc2FnZX1gKTtcbiAgICB9O1xuICAgIGxldCBicmFja2V0cyA9IFtdO1xuICAgIGxldCBjb21tYXMgPSBbXTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICB3aGlsZSAob2Zmc2V0IDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgLy8gU3RyaXAgb2ZmIGFueSBsZWFkaW5nIHdoaXRlc3BhY2VcbiAgICAgICAgbGV0IGN1ciA9IHRleHQuc3Vic3RyaW5nKG9mZnNldCk7XG4gICAgICAgIGxldCBtYXRjaCA9IGN1ci5tYXRjaChyZWdleFdoaXRlc3BhY2VQcmVmaXgpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIG9mZnNldCArPSBtYXRjaFsxXS5sZW5ndGg7XG4gICAgICAgICAgICBjdXIgPSB0ZXh0LnN1YnN0cmluZyhvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRva2VuID0geyBkZXB0aDogYnJhY2tldHMubGVuZ3RoLCBsaW5rQmFjazogLTEsIGxpbmtOZXh0OiAtMSwgbWF0Y2g6IC0xLCB0eXBlOiBcIlwiLCB0ZXh0OiBcIlwiLCBvZmZzZXQsIHZhbHVlOiAtMSB9O1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGxldCB0eXBlID0gKFNpbXBsZVRva2Vuc1tjdXJbMF1dIHx8IFwiXCIpO1xuICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgdG9rZW4udHlwZSA9IHR5cGU7XG4gICAgICAgICAgICB0b2tlbi50ZXh0ID0gY3VyWzBdO1xuICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJPUEVOX1BBUkVOXCIpIHtcbiAgICAgICAgICAgICAgICBicmFja2V0cy5wdXNoKHRva2Vucy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICBjb21tYXMucHVzaCh0b2tlbnMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IFwiQ0xPU0VfUEFSRU5cIikge1xuICAgICAgICAgICAgICAgIGlmIChicmFja2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihcIm5vIG1hdGNoaW5nIG9wZW4gYnJhY2tldFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9rZW4ubWF0Y2ggPSBicmFja2V0cy5wb3AoKTtcbiAgICAgICAgICAgICAgICAodG9rZW5zW3Rva2VuLm1hdGNoXSkubWF0Y2ggPSB0b2tlbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICB0b2tlbi5kZXB0aC0tO1xuICAgICAgICAgICAgICAgIHRva2VuLmxpbmtCYWNrID0gY29tbWFzLnBvcCgpO1xuICAgICAgICAgICAgICAgICh0b2tlbnNbdG9rZW4ubGlua0JhY2tdKS5saW5rTmV4dCA9IHRva2Vucy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gXCJDT01NQVwiKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4ubGlua0JhY2sgPSBjb21tYXMucG9wKCk7XG4gICAgICAgICAgICAgICAgKHRva2Vuc1t0b2tlbi5saW5rQmFja10pLmxpbmtOZXh0ID0gdG9rZW5zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgY29tbWFzLnB1c2godG9rZW5zLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gXCJPUEVOX0JSQUNLRVRcIikge1xuICAgICAgICAgICAgICAgIHRva2VuLnR5cGUgPSBcIkJSQUNLRVRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiQ0xPU0VfQlJBQ0tFVFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBDTE9TRV9CUkFDS0VUXG4gICAgICAgICAgICAgICAgbGV0IHN1ZmZpeCA9IHRva2Vucy5wb3AoKS50ZXh0O1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gMCAmJiB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLnR5cGUgPT09IFwiTlVNQkVSXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0b2tlbnMucG9wKCkudGV4dDtcbiAgICAgICAgICAgICAgICAgICAgc3VmZml4ID0gdmFsdWUgKyBzdWZmaXg7XG4gICAgICAgICAgICAgICAgICAgICh0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdKS52YWx1ZSA9IGdldE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAwIHx8IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0udHlwZSAhPT0gXCJCUkFDS0VUXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBvcGVuaW5nIGJyYWNrZXRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICh0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdKS50ZXh0ICs9IHN1ZmZpeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG1hdGNoID0gY3VyLm1hdGNoKHJlZ2V4SWRQcmVmaXgpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHRva2VuLnRleHQgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIG9mZnNldCArPSB0b2tlbi50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChLZXl3b3Jkcy5oYXModG9rZW4udGV4dCkpIHtcbiAgICAgICAgICAgICAgICB0b2tlbi50eXBlID0gXCJLRVlXT1JEXCI7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9rZW4udGV4dC5tYXRjaChyZWdleFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4udHlwZSA9IFwiVFlQRVwiO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9rZW4udHlwZSA9IFwiSURcIjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG1hdGNoID0gY3VyLm1hdGNoKHJlZ2V4TnVtYmVyUHJlZml4KTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICB0b2tlbi50ZXh0ID0gbWF0Y2hbMV07XG4gICAgICAgICAgICB0b2tlbi50eXBlID0gXCJOVU1CRVJcIjtcbiAgICAgICAgICAgIG9mZnNldCArPSB0b2tlbi50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5leHBlY3RlZCB0b2tlbiAke0pTT04uc3RyaW5naWZ5KGN1clswXSl9IGF0IHBvc2l0aW9uICR7b2Zmc2V0fWApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRva2VuU3RyaW5nKHRva2Vucy5tYXAoKHQpID0+IE9iamVjdC5mcmVlemUodCkpKTtcbn1cbi8vIENoZWNrIG9ubHkgb25lIG9mIGBhbGxvd2VkYCBpcyBpbiBgc2V0YFxuZnVuY3Rpb24gYWxsb3dTaW5nbGUoc2V0LCBhbGxvd2VkKSB7XG4gICAgbGV0IGluY2x1ZGVkID0gW107XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYWxsb3dlZC5rZXlzKCkpIHtcbiAgICAgICAgaWYgKHNldC5oYXMoa2V5KSkge1xuICAgICAgICAgICAgaW5jbHVkZWQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpbmNsdWRlZC5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29uZmxpY3RpbmcgdHlwZXM6ICR7aW5jbHVkZWQuam9pbihcIiwgXCIpfWApO1xuICAgIH1cbn1cbi8vIEZ1bmN0aW9ucyB0byBwcm9jZXNzIGEgU29saWRpdHkgU2lnbmF0dXJlIFRva2VuU3RyaW5nIGZyb20gbGVmdC10by1yaWdodCBmb3IuLi5cbi8vIC4uLnRoZSBuYW1lIHdpdGggYW4gb3B0aW9uYWwgdHlwZSwgcmV0dXJuaW5nIHRoZSBuYW1lXG5mdW5jdGlvbiBjb25zdW1lTmFtZSh0eXBlLCB0b2tlbnMpIHtcbiAgICBpZiAodG9rZW5zLnBlZWtLZXl3b3JkKEt3VHlwZXMpKSB7XG4gICAgICAgIGNvbnN0IGtleXdvcmQgPSB0b2tlbnMucG9wKCkudGV4dDtcbiAgICAgICAgaWYgKGtleXdvcmQgIT09IHR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgJHt0eXBlfSwgZ290ICR7a2V5d29yZH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG9rZW5zLnBvcFR5cGUoXCJJRFwiKTtcbn1cbi8vIC4uLmFsbCBrZXl3b3JkcyBtYXRjaGluZyBhbGxvd2VkLCByZXR1cm5pbmcgdGhlIGtleXdvcmRzXG5mdW5jdGlvbiBjb25zdW1lS2V5d29yZHModG9rZW5zLCBhbGxvd2VkKSB7XG4gICAgY29uc3Qga2V5d29yZHMgPSBuZXcgU2V0KCk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3Qga2V5d29yZCA9IHRva2Vucy5wZWVrVHlwZShcIktFWVdPUkRcIik7XG4gICAgICAgIGlmIChrZXl3b3JkID09IG51bGwgfHwgKGFsbG93ZWQgJiYgIWFsbG93ZWQuaGFzKGtleXdvcmQpKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW5zLnBvcCgpO1xuICAgICAgICBpZiAoa2V5d29yZHMuaGFzKGtleXdvcmQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZSBrZXl3b3JkczogJHtKU09OLnN0cmluZ2lmeShrZXl3b3JkKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBrZXl3b3Jkcy5hZGQoa2V5d29yZCk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKGtleXdvcmRzKTtcbn1cbi8vIC4uLmFsbCB2aXNpYmlsaXR5IGtleXdvcmRzLCByZXR1cm5pbmcgdGhlIGNvYWxlc2NlZCBtdXRhYmlsaXR5XG5mdW5jdGlvbiBjb25zdW1lTXV0YWJpbGl0eSh0b2tlbnMpIHtcbiAgICBsZXQgbW9kaWZpZXJzID0gY29uc3VtZUtleXdvcmRzKHRva2VucywgS3dWaXNpYik7XG4gICAgLy8gRGV0ZWN0IGNvbmZsaWN0aW5nIG1vZGlmaWVyc1xuICAgIGFsbG93U2luZ2xlKG1vZGlmaWVycywgc2V0aWZ5KFwiY29uc3RhbnQgcGF5YWJsZSBub25wYXlhYmxlXCIuc3BsaXQoXCIgXCIpKSk7XG4gICAgYWxsb3dTaW5nbGUobW9kaWZpZXJzLCBzZXRpZnkoXCJwdXJlIHZpZXcgcGF5YWJsZSBub25wYXlhYmxlXCIuc3BsaXQoXCIgXCIpKSk7XG4gICAgLy8gUHJvY2VzcyBtdXRhYmlsaXR5IHN0YXRlc1xuICAgIGlmIChtb2RpZmllcnMuaGFzKFwidmlld1wiKSkge1xuICAgICAgICByZXR1cm4gXCJ2aWV3XCI7XG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMuaGFzKFwicHVyZVwiKSkge1xuICAgICAgICByZXR1cm4gXCJwdXJlXCI7XG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMuaGFzKFwicGF5YWJsZVwiKSkge1xuICAgICAgICByZXR1cm4gXCJwYXlhYmxlXCI7XG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMuaGFzKFwibm9ucGF5YWJsZVwiKSkge1xuICAgICAgICByZXR1cm4gXCJub25wYXlhYmxlXCI7XG4gICAgfVxuICAgIC8vIFByb2Nlc3MgbGVnYWN5IGBjb25zdGFudGAgbGFzdFxuICAgIGlmIChtb2RpZmllcnMuaGFzKFwiY29uc3RhbnRcIikpIHtcbiAgICAgICAgcmV0dXJuIFwidmlld1wiO1xuICAgIH1cbiAgICByZXR1cm4gXCJub25wYXlhYmxlXCI7XG59XG4vLyAuLi5hIHBhcmFtZXRlciBsaXN0LCByZXR1cm5pbmcgdGhlIFBhcmFtVHlwZSBsaXN0XG5mdW5jdGlvbiBjb25zdW1lUGFyYW1zKHRva2VucywgYWxsb3dJbmRleGVkKSB7XG4gICAgcmV0dXJuIHRva2Vucy5wb3BQYXJhbXMoKS5tYXAoKHQpID0+IFBhcmFtVHlwZS5mcm9tKHQsIGFsbG93SW5kZXhlZCkpO1xufVxuLy8gLi4uYSBnYXMgbGltaXQsIHJldHVybmluZyBhIEJpZ051bWJlciBvciBudWxsIGlmIG5vbmVcbmZ1bmN0aW9uIGNvbnN1bWVHYXModG9rZW5zKSB7XG4gICAgaWYgKHRva2Vucy5wZWVrVHlwZShcIkFUXCIpKSB7XG4gICAgICAgIHRva2Vucy5wb3AoKTtcbiAgICAgICAgaWYgKHRva2Vucy5wZWVrVHlwZShcIk5VTUJFUlwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEJpZ0ludCh0b2tlbnMucG9wKCkudGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBnYXNcIik7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY29uc3VtZUVvaSh0b2tlbnMpIHtcbiAgICBpZiAodG9rZW5zLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuZXhwZWN0ZWQgdG9rZW5zIGF0IG9mZnNldCAke3Rva2Vucy5vZmZzZXR9OiAke3Rva2Vucy50b1N0cmluZygpfWApO1xuICAgIH1cbn1cbmNvbnN0IHJlZ2V4QXJyYXlUeXBlID0gbmV3IFJlZ0V4cCgvXiguKilcXFsoWzAtOV0qKVxcXSQvKTtcbmZ1bmN0aW9uIHZlcmlmeUJhc2ljVHlwZSh0eXBlKSB7XG4gICAgY29uc3QgbWF0Y2ggPSB0eXBlLm1hdGNoKHJlZ2V4VHlwZSk7XG4gICAgYXNzZXJ0QXJndW1lbnQobWF0Y2gsIFwiaW52YWxpZCB0eXBlXCIsIFwidHlwZVwiLCB0eXBlKTtcbiAgICBpZiAodHlwZSA9PT0gXCJ1aW50XCIpIHtcbiAgICAgICAgcmV0dXJuIFwidWludDI1NlwiO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJpbnRcIikge1xuICAgICAgICByZXR1cm4gXCJpbnQyNTZcIjtcbiAgICB9XG4gICAgaWYgKG1hdGNoWzJdKSB7XG4gICAgICAgIC8vIGJ5dGVzWFhcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQobWF0Y2hbMl0pO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChsZW5ndGggIT09IDAgJiYgbGVuZ3RoIDw9IDMyLCBcImludmFsaWQgYnl0ZXMgbGVuZ3RoXCIsIFwidHlwZVwiLCB0eXBlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobWF0Y2hbM10pIHtcbiAgICAgICAgLy8gaW50WFggb3IgdWludFhYXG4gICAgICAgIGNvbnN0IHNpemUgPSBwYXJzZUludChtYXRjaFszXSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHNpemUgIT09IDAgJiYgc2l6ZSA8PSAyNTYgJiYgKHNpemUgJSA4KSA9PT0gMCwgXCJpbnZhbGlkIG51bWVyaWMgd2lkdGhcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbn1cbi8vIE1ha2UgdGhlIEZyYWdtZW50IGNvbnN0cnVjdG9ycyBlZmZlY3RpdmVseSBwcml2YXRlXG5jb25zdCBfZ3VhcmQgPSB7fTtcbmNvbnN0IGludGVybmFsID0gU3ltYm9sLmZvcihcIl9ldGhlcnNfaW50ZXJuYWxcIik7XG5jb25zdCBQYXJhbVR5cGVJbnRlcm5hbCA9IFwiX1BhcmFtVHlwZUludGVybmFsXCI7XG5jb25zdCBFcnJvckZyYWdtZW50SW50ZXJuYWwgPSBcIl9FcnJvckludGVybmFsXCI7XG5jb25zdCBFdmVudEZyYWdtZW50SW50ZXJuYWwgPSBcIl9FdmVudEludGVybmFsXCI7XG5jb25zdCBDb25zdHJ1Y3RvckZyYWdtZW50SW50ZXJuYWwgPSBcIl9Db25zdHJ1Y3RvckludGVybmFsXCI7XG5jb25zdCBGYWxsYmFja0ZyYWdtZW50SW50ZXJuYWwgPSBcIl9GYWxsYmFja0ludGVybmFsXCI7XG5jb25zdCBGdW5jdGlvbkZyYWdtZW50SW50ZXJuYWwgPSBcIl9GdW5jdGlvbkludGVybmFsXCI7XG5jb25zdCBTdHJ1Y3RGcmFnbWVudEludGVybmFsID0gXCJfU3RydWN0SW50ZXJuYWxcIjtcbi8qKlxuICogIEVhY2ggaW5wdXQgYW5kIG91dHB1dCBvZiBhIFtbRnJhZ21lbnRdXSBpcyBhbiBBcnJheSBvZiAqKlBhcmFtVHlwZSoqLlxuICovXG5leHBvcnQgY2xhc3MgUGFyYW1UeXBlIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGxvY2FsIG5hbWUgb2YgdGhlIHBhcmFtZXRlciAob3IgYGBcIlwiYGAgaWYgdW5ib3VuZClcbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8qKlxuICAgICAqICBUaGUgZnVsbHkgcXVhbGlmaWVkIHR5cGUgKGUuZy4gYGBcImFkZHJlc3NcImBgLCBgYFwidHVwbGUoYWRkcmVzcylcImBgLFxuICAgICAqICBgYFwidWludDI1NlszXVtdXCJgYClcbiAgICAgKi9cbiAgICB0eXBlO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmFzZSB0eXBlIChlLmcuIGBgXCJhZGRyZXNzXCJgYCwgYGBcInR1cGxlXCJgYCwgYGBcImFycmF5XCJgYClcbiAgICAgKi9cbiAgICBiYXNlVHlwZTtcbiAgICAvKipcbiAgICAgKiAgVHJ1ZSBpZiB0aGUgcGFyYW1ldGVycyBpcyBpbmRleGVkLlxuICAgICAqXG4gICAgICogIEZvciBub24taW5kZXhhYmxlIHR5cGVzIHRoaXMgaXMgYGBudWxsYGAuXG4gICAgICovXG4gICAgaW5kZXhlZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGNvbXBvbmVudHMgZm9yIHRoZSB0dXBsZS5cbiAgICAgKlxuICAgICAqICBGb3Igbm9uLXR1cGxlIHR5cGVzIHRoaXMgaXMgYGBudWxsYGAuXG4gICAgICovXG4gICAgY29tcG9uZW50cztcbiAgICAvKipcbiAgICAgKiAgVGhlIGFycmF5IGxlbmd0aCwgb3IgYGAtMWBgIGZvciBkeW5hbWljLWxlbmd0aGVkIGFycmF5cy5cbiAgICAgKlxuICAgICAqICBGb3Igbm9uLWFycmF5IHR5cGVzIHRoaXMgaXMgYGBudWxsYGAuXG4gICAgICovXG4gICAgYXJyYXlMZW5ndGg7XG4gICAgLyoqXG4gICAgICogIFRoZSB0eXBlIG9mIGVhY2ggY2hpbGQgaW4gdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogIEZvciBub24tYXJyYXkgdHlwZXMgdGhpcyBpcyBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBhcnJheUNoaWxkcmVuO1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBuYW1lLCB0eXBlLCBiYXNlVHlwZSwgaW5kZXhlZCwgY29tcG9uZW50cywgYXJyYXlMZW5ndGgsIGFycmF5Q2hpbGRyZW4pIHtcbiAgICAgICAgYXNzZXJ0UHJpdmF0ZShndWFyZCwgX2d1YXJkLCBcIlBhcmFtVHlwZVwiKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiBQYXJhbVR5cGVJbnRlcm5hbCB9KTtcbiAgICAgICAgaWYgKGNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMgPSBPYmplY3QuZnJlZXplKGNvbXBvbmVudHMuc2xpY2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhc2VUeXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgICAgIGlmIChhcnJheUxlbmd0aCA9PSBudWxsIHx8IGFycmF5Q2hpbGRyZW4gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcnJheUxlbmd0aCAhPSBudWxsIHx8IGFycmF5Q2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKSB7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50cyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbXBvbmVudHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgbmFtZSwgdHlwZSwgYmFzZVR5cGUsIGluZGV4ZWQsIGNvbXBvbmVudHMsIGFycmF5TGVuZ3RoLCBhcnJheUNoaWxkcmVuXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdHlwZS5cbiAgICAgKlxuICAgICAqICBGb3IgZXhhbXBsZSxcbiAgICAgKlxuICAgICAqICBgYHNpZ2hhc2hcIiA9PiBcIih1aW50MjU2LGFkZHJlc3MpXCJgYFxuICAgICAqXG4gICAgICogIGBgXCJtaW5pbWFsXCIgPT4gXCJ0dXBsZSh1aW50MjU2LGFkZHJlc3MpIGluZGV4ZWRcImBgXG4gICAgICpcbiAgICAgKiAgYGBcImZ1bGxcIiA9PiBcInR1cGxlKHVpbnQyNTYgZm9vLCBhZGRyZXNzIGJhcikgaW5kZXhlZCBiYXpcImBgXG4gICAgICovXG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwic2lnaGFzaFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwianNvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5uYW1lIHx8IFwiXCI7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKHRoaXMuYXJyYXlDaGlsZHJlbi5mb3JtYXQoXCJqc29uXCIpKTtcbiAgICAgICAgICAgICAgICByZXN1bHQubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnR5cGUgKz0gYFskeyh0aGlzLmFycmF5TGVuZ3RoIDwgMCA/IFwiXCIgOiBTdHJpbmcodGhpcy5hcnJheUxlbmd0aCkpfV1gO1xuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICgodGhpcy5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKSA/IFwidHVwbGVcIiA6IHRoaXMudHlwZSksXG4gICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHRoaXMuaW5kZXhlZCkgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmluZGV4ZWQgPSB0aGlzLmluZGV4ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pc1R1cGxlKCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuY29tcG9uZW50cyA9IHRoaXMuY29tcG9uZW50cy5tYXAoKGMpID0+IEpTT04ucGFyc2UoYy5mb3JtYXQoZm9ybWF0KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIC8vIEFycmF5XG4gICAgICAgIGlmICh0aGlzLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuYXJyYXlDaGlsZHJlbi5mb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBgWyR7KHRoaXMuYXJyYXlMZW5ndGggPCAwID8gXCJcIiA6IFN0cmluZyh0aGlzLmFycmF5TGVuZ3RoKSl9XWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1R1cGxlKCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIoXCIgKyB0aGlzLmNvbXBvbmVudHMubWFwKChjb21wKSA9PiBjb21wLmZvcm1hdChmb3JtYXQpKS5qb2luKChmb3JtYXQgPT09IFwiZnVsbFwiKSA/IFwiLCBcIiA6IFwiLFwiKSArIFwiKVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMudHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ICE9PSBcInNpZ2hhc2hcIikge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXhlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiBpbmRleGVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSBcImZ1bGxcIiAmJiB0aGlzLm5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIgXCIgKyB0aGlzLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXRoaXMlJSBpcyBhbiBBcnJheSB0eXBlLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSB0eXBlIGdhdXJkIGVuc3VyaW5nIHRoYXQgW1thcnJheUNoaWxkcmVuXV1cbiAgICAgKiAgYW5kIFtbYXJyYXlMZW5ndGhdXSBhcmUgbm9uLW51bGwuXG4gICAgICovXG4gICAgaXNBcnJheSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmJhc2VUeXBlID09PSBcImFycmF5XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldGhpcyUlIGlzIGEgVHVwbGUgdHlwZS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgdHlwZSBnYXVyZCBlbnN1cmluZyB0aGF0IFtbY29tcG9uZW50c11dXG4gICAgICogIGlzIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGlzVHVwbGUoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXRoaXMlJSBpcyBhbiBJbmRleGFibGUgdHlwZS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgdHlwZSBnYXVyZCBlbnN1cmluZyB0aGF0IFtbaW5kZXhlZF1dXG4gICAgICogIGlzIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGlzSW5kZXhhYmxlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaW5kZXhlZCAhPSBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFdhbGtzIHRoZSAqKlBhcmFtVHlwZSoqIHdpdGggJSV2YWx1ZSUlLCBjYWxsaW5nICUlcHJvY2VzcyUlXG4gICAgICogIG9uIGVhY2ggdHlwZSwgZGVzdHJ1Y3RpbmcgdGhlICUldmFsdWUlJSByZWN1cnNpdmVseS5cbiAgICAgKi9cbiAgICB3YWxrKHZhbHVlLCBwcm9jZXNzKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYXJyYXkgdmFsdWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5hcnJheUxlbmd0aCAhPT0gLTEgJiYgdmFsdWUubGVuZ3RoICE9PSB0aGlzLmFycmF5TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgaXMgd3JvbmcgbGVuZ3RoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgodikgPT4gKF90aGlzLmFycmF5Q2hpbGRyZW4ud2Fsayh2LCBwcm9jZXNzKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzVHVwbGUoKSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdHVwbGUgdmFsdWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoICE9PSB0aGlzLmNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgaXMgd3JvbmcgbGVuZ3RoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgodiwgaSkgPT4gKF90aGlzLmNvbXBvbmVudHNbaV0ud2Fsayh2LCBwcm9jZXNzKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9jZXNzKHRoaXMudHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgICAjd2Fsa0FzeW5jKHByb21pc2VzLCB2YWx1ZSwgcHJvY2Vzcywgc2V0VmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBcnJheSgpKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBhcnJheSB2YWx1ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmFycmF5TGVuZ3RoICE9PSAtMSAmJiB2YWx1ZS5sZW5ndGggIT09IHRoaXMuYXJyYXlMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhcnJheSBpcyB3cm9uZyBsZW5ndGhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjaGlsZFR5cGUgPSB0aGlzLmFycmF5Q2hpbGRyZW47XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB2YWx1ZS5zbGljZSgpO1xuICAgICAgICAgICAgcmVzdWx0LmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNoaWxkVHlwZS4jd2Fsa0FzeW5jKHByb21pc2VzLCB2YWx1ZSwgcHJvY2VzcywgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2V0VmFsdWUocmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1R1cGxlKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSB0aGlzLmNvbXBvbmVudHM7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBvYmplY3QgaW50byBhbiBhcnJheVxuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlLnNsaWNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgKHZhbHVlKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHR1cGxlIHZhbHVlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjb21wb25lbnRzLm1hcCgocGFyYW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJhbS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgdXNlIG9iamVjdCB2YWx1ZSB3aXRoIHVubmFtZWQgY29tcG9uZW50c1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIShwYXJhbS5uYW1lIGluIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIHZhbHVlIGZvciBjb21wb25lbnQgJHtwYXJhbS5uYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVtwYXJhbS5uYW1lXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoICE9PSB0aGlzLmNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgaXMgd3JvbmcgbGVuZ3RoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHNbaW5kZXhdLiN3YWxrQXN5bmMocHJvbWlzZXMsIHZhbHVlLCBwcm9jZXNzLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXRWYWx1ZShyZXN1bHQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHByb2Nlc3ModGhpcy50eXBlLCB2YWx1ZSk7XG4gICAgICAgIGlmIChyZXN1bHQudGhlbikge1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgoYXN5bmMgZnVuY3Rpb24gKCkgeyBzZXRWYWx1ZShhd2FpdCByZXN1bHQpOyB9KSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFZhbHVlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFdhbGtzIHRoZSAqKlBhcmFtVHlwZSoqIHdpdGggJSV2YWx1ZSUlLCBhc3luY2hyb25vdXNseSBjYWxsaW5nXG4gICAgICogICUlcHJvY2VzcyUlIG9uIGVhY2ggdHlwZSwgZGVzdHJ1Y3RpbmcgdGhlICUldmFsdWUlJSByZWN1cnNpdmVseS5cbiAgICAgKlxuICAgICAqICBUaGlzIGNhbiBiZSB1c2VkIHRvIHJlc29sdmUgRU5TIG5hbWVzIGJ5IHdhbGtpbmcgYW5kIHJlc29sdmluZyBlYWNoXG4gICAgICogIGBgXCJhZGRyZXNzXCJgYCB0eXBlLlxuICAgICAqL1xuICAgIGFzeW5jIHdhbGtBc3luYyh2YWx1ZSwgcHJvY2Vzcykge1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbdmFsdWVdO1xuICAgICAgICB0aGlzLiN3YWxrQXN5bmMocHJvbWlzZXMsIHZhbHVlLCBwcm9jZXNzLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHJlc3VsdFswXSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByb21pc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRbMF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqUGFyYW1UeXBlKiogZm9yICUlb2JqJSUuXG4gICAgICpcbiAgICAgKiAgSWYgJSVhbGxvd0luZGV4ZWQlJSB0aGVuIHRoZSBgYGluZGV4ZWRgYCBrZXl3b3JkIGlzIHBlcm1pdHRlZCxcbiAgICAgKiAgb3RoZXJ3aXNlIHRoZSBgYGluZGV4ZWRgYCBrZXl3b3JkIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqLCBhbGxvd0luZGV4ZWQpIHtcbiAgICAgICAgaWYgKFBhcmFtVHlwZS5pc1BhcmFtVHlwZShvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBhcmFtVHlwZS5mcm9tKGxleChvYmopLCBhbGxvd0luZGV4ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBwYXJhbSB0eXBlXCIsIFwib2JqXCIsIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcbiAgICAgICAgICAgIGxldCB0eXBlID0gXCJcIiwgYmFzZVR5cGUgPSBcIlwiO1xuICAgICAgICAgICAgbGV0IGNvbXBzID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1widHVwbGVcIl0pKS5oYXMoXCJ0dXBsZVwiKSB8fCBvYmoucGVla1R5cGUoXCJPUEVOX1BBUkVOXCIpKSB7XG4gICAgICAgICAgICAgICAgLy8gVHVwbGVcbiAgICAgICAgICAgICAgICBiYXNlVHlwZSA9IFwidHVwbGVcIjtcbiAgICAgICAgICAgICAgICBjb21wcyA9IG9iai5wb3BQYXJhbXMoKS5tYXAoKHQpID0+IFBhcmFtVHlwZS5mcm9tKHQpKTtcbiAgICAgICAgICAgICAgICB0eXBlID0gYHR1cGxlKCR7Y29tcHMubWFwKChjKSA9PiBjLmZvcm1hdCgpKS5qb2luKFwiLFwiKX0pYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE5vcm1hbFxuICAgICAgICAgICAgICAgIHR5cGUgPSB2ZXJpZnlCYXNpY1R5cGUob2JqLnBvcFR5cGUoXCJUWVBFXCIpKTtcbiAgICAgICAgICAgICAgICBiYXNlVHlwZSA9IHR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgQXJyYXlcbiAgICAgICAgICAgIGxldCBhcnJheUNoaWxkcmVuID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBhcnJheUxlbmd0aCA9IG51bGw7XG4gICAgICAgICAgICB3aGlsZSAob2JqLmxlbmd0aCAmJiBvYmoucGVla1R5cGUoXCJCUkFDS0VUXCIpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnJhY2tldCA9IG9iai5wb3AoKTsgLy9hcnJheXNbaV07XG4gICAgICAgICAgICAgICAgYXJyYXlDaGlsZHJlbiA9IG5ldyBQYXJhbVR5cGUoX2d1YXJkLCBcIlwiLCB0eXBlLCBiYXNlVHlwZSwgbnVsbCwgY29tcHMsIGFycmF5TGVuZ3RoLCBhcnJheUNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICBhcnJheUxlbmd0aCA9IGJyYWNrZXQudmFsdWU7XG4gICAgICAgICAgICAgICAgdHlwZSArPSBicmFja2V0LnRleHQ7XG4gICAgICAgICAgICAgICAgYmFzZVR5cGUgPSBcImFycmF5XCI7XG4gICAgICAgICAgICAgICAgY29tcHMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGluZGV4ZWQgPSBudWxsO1xuICAgICAgICAgICAgY29uc3Qga2V5d29yZHMgPSBjb25zdW1lS2V5d29yZHMob2JqLCBLd01vZGlmaWVycyk7XG4gICAgICAgICAgICBpZiAoa2V5d29yZHMuaGFzKFwiaW5kZXhlZFwiKSkge1xuICAgICAgICAgICAgICAgIGlmICghYWxsb3dJbmRleGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5kZXhlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gKG9iai5wZWVrVHlwZShcIklEXCIpID8gb2JqLnBvcCgpLnRleHQgOiBcIlwiKTtcbiAgICAgICAgICAgIGlmIChvYmoubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibGVmdG92ZXIgdG9rZW5zXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXJhbVR5cGUoX2d1YXJkLCBuYW1lLCB0eXBlLCBiYXNlVHlwZSwgaW5kZXhlZCwgY29tcHMsIGFycmF5TGVuZ3RoLCBhcnJheUNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lID0gb2JqLm5hbWU7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KCFuYW1lIHx8ICh0eXBlb2YgKG5hbWUpID09PSBcInN0cmluZ1wiICYmIG5hbWUubWF0Y2gocmVnZXhJZCkpLCBcImludmFsaWQgbmFtZVwiLCBcIm9iai5uYW1lXCIsIG5hbWUpO1xuICAgICAgICBsZXQgaW5kZXhlZCA9IG9iai5pbmRleGVkO1xuICAgICAgICBpZiAoaW5kZXhlZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChhbGxvd0luZGV4ZWQsIFwicGFyYW1ldGVyIGNhbm5vdCBiZSBpbmRleGVkXCIsIFwib2JqLmluZGV4ZWRcIiwgb2JqLmluZGV4ZWQpO1xuICAgICAgICAgICAgaW5kZXhlZCA9ICEhaW5kZXhlZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdHlwZSA9IG9iai50eXBlO1xuICAgICAgICBsZXQgYXJyYXlNYXRjaCA9IHR5cGUubWF0Y2gocmVnZXhBcnJheVR5cGUpO1xuICAgICAgICBpZiAoYXJyYXlNYXRjaCkge1xuICAgICAgICAgICAgY29uc3QgYXJyYXlMZW5ndGggPSBwYXJzZUludChhcnJheU1hdGNoWzJdIHx8IFwiLTFcIik7XG4gICAgICAgICAgICBjb25zdCBhcnJheUNoaWxkcmVuID0gUGFyYW1UeXBlLmZyb20oe1xuICAgICAgICAgICAgICAgIHR5cGU6IGFycmF5TWF0Y2hbMV0sXG4gICAgICAgICAgICAgICAgY29tcG9uZW50czogb2JqLmNvbXBvbmVudHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXJhbVR5cGUoX2d1YXJkLCBuYW1lIHx8IFwiXCIsIHR5cGUsIFwiYXJyYXlcIiwgaW5kZXhlZCwgbnVsbCwgYXJyYXlMZW5ndGgsIGFycmF5Q2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSBcInR1cGxlXCIgfHwgdHlwZS5zdGFydHNXaXRoKFwidHVwbGUoXCIgLyogZml4OiApICovKSB8fCB0eXBlLnN0YXJ0c1dpdGgoXCIoXCIgLyogZml4OiApICovKSkge1xuICAgICAgICAgICAgY29uc3QgY29tcHMgPSAob2JqLmNvbXBvbmVudHMgIT0gbnVsbCkgPyBvYmouY29tcG9uZW50cy5tYXAoKGMpID0+IFBhcmFtVHlwZS5mcm9tKGMpKSA6IG51bGw7XG4gICAgICAgICAgICBjb25zdCB0dXBsZSA9IG5ldyBQYXJhbVR5cGUoX2d1YXJkLCBuYW1lIHx8IFwiXCIsIHR5cGUsIFwidHVwbGVcIiwgaW5kZXhlZCwgY29tcHMsIG51bGwsIG51bGwpO1xuICAgICAgICAgICAgLy8gQFRPRE86IHVzZSBsZXhlciB0byB2YWxpZGF0ZSBhbmQgbm9ybWFsaXplIHR5cGVcbiAgICAgICAgICAgIHJldHVybiB0dXBsZTtcbiAgICAgICAgfVxuICAgICAgICB0eXBlID0gdmVyaWZ5QmFzaWNUeXBlKG9iai50eXBlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJhbVR5cGUoX2d1YXJkLCBuYW1lIHx8IFwiXCIsIHR5cGUsIHR5cGUsIGluZGV4ZWQsIG51bGwsIG51bGwsIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhICoqUGFyYW1UeXBlKiouXG4gICAgICovXG4gICAgc3RhdGljIGlzUGFyYW1UeXBlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWVbaW50ZXJuYWxdID09PSBQYXJhbVR5cGVJbnRlcm5hbCk7XG4gICAgfVxufVxuLyoqXG4gKiAgQW4gYWJzdHJhY3QgY2xhc3MgdG8gcmVwcmVzZW50IEFuIGluZGl2aWR1YWwgZnJhZ21lbnQgZnJvbSBhIHBhcnNlIEFCSS5cbiAqL1xuZXhwb3J0IGNsYXNzIEZyYWdtZW50IHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHR5cGUgb2YgdGhlIGZyYWdtZW50LlxuICAgICAqL1xuICAgIHR5cGU7XG4gICAgLyoqXG4gICAgICogIFRoZSBpbnB1dHMgZm9yIHRoZSBmcmFnbWVudC5cbiAgICAgKi9cbiAgICBpbnB1dHM7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIHR5cGUsIGlucHV0cykge1xuICAgICAgICBhc3NlcnRQcml2YXRlKGd1YXJkLCBfZ3VhcmQsIFwiRnJhZ21lbnRcIik7XG4gICAgICAgIGlucHV0cyA9IE9iamVjdC5mcmVlemUoaW5wdXRzLnNsaWNlKCkpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgdHlwZSwgaW5wdXRzIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkZyYWdtZW50KiogZm9yICUlb2JqJSUsIHdpY2ggY2FuIGJlIGFueSBzdXBwb3J0ZWRcbiAgICAgKiAgQUJJIGZyZ2FtZW50IHR5cGUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIFRyeSBwYXJzaW5nIEpTT04uLi5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgRnJhZ21lbnQuZnJvbShKU09OLnBhcnNlKG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgLy8gLi4ub3RoZXJ3aXNlLCB1c2UgdGhlIGh1bWFuLXJlYWRhYmxlIGxleGVyXG4gICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZnJvbShsZXgob2JqKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICAvLyBIdW1hbi1yZWFkYWJsZSBBQkkgKGFscmVhZHkgbGV4ZWQpXG4gICAgICAgICAgICBjb25zdCB0eXBlID0gb2JqLnBlZWtLZXl3b3JkKEt3VHlwZXMpO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNvbnN0cnVjdG9yXCI6IHJldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjogcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJldmVudFwiOiByZXR1cm4gRXZlbnRGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZhbGxiYWNrXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlY2VpdmVcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZhbGxiYWNrRnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOiByZXR1cm4gRnVuY3Rpb25GcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcInN0cnVjdFwiOiByZXR1cm4gU3RydWN0RnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgLy8gSlNPTiBBQklcbiAgICAgICAgICAgIHN3aXRjaCAob2JqLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29uc3RydWN0b3JcIjogcmV0dXJuIENvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOiByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImV2ZW50XCI6IHJldHVybiBFdmVudEZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmFsbGJhY2tcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVjZWl2ZVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmFsbGJhY2tGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6IHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwic3RydWN0XCI6IHJldHVybiBTdHJ1Y3RGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UsIGB1bnN1cHBvcnRlZCB0eXBlOiAke29iai50eXBlfWAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiRnJhZ21lbnQuZnJvbVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bnN1cHBvcnRlZCBmcmdhbWVudCBvYmplY3RcIiwgXCJvYmpcIiwgb2JqKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYSBbW0NvbnN0cnVjdG9yRnJhZ21lbnRdXS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNDb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5pc0ZyYWdtZW50KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYW4gW1tFcnJvckZyYWdtZW50XV0uXG4gICAgICovXG4gICAgc3RhdGljIGlzRXJyb3IodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEVycm9yRnJhZ21lbnQuaXNGcmFnbWVudCh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGFuIFtbRXZlbnRGcmFnbWVudF1dLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0V2ZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBFdmVudEZyYWdtZW50LmlzRnJhZ21lbnQodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhIFtbRnVuY3Rpb25GcmFnbWVudF1dLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmlzRnJhZ21lbnQodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhIFtbU3RydWN0RnJhZ21lbnRdXS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNTdHJ1Y3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFN0cnVjdEZyYWdtZW50LmlzRnJhZ21lbnQodmFsdWUpO1xuICAgIH1cbn1cbi8qKlxuICogIEFuIGFic3RyYWN0IGNsYXNzIHRvIHJlcHJlc2VudCBBbiBpbmRpdmlkdWFsIGZyYWdtZW50XG4gKiAgd2hpY2ggaGFzIGEgbmFtZSBmcm9tIGEgcGFyc2UgQUJJLlxuICovXG5leHBvcnQgY2xhc3MgTmFtZWRGcmFnbWVudCBleHRlbmRzIEZyYWdtZW50IHtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUgb2YgdGhlIGZyYWdtZW50LlxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIHR5cGUsIG5hbWUsIGlucHV0cykge1xuICAgICAgICBzdXBlcihndWFyZCwgdHlwZSwgaW5wdXRzKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChuYW1lKSA9PT0gXCJzdHJpbmdcIiAmJiBuYW1lLm1hdGNoKHJlZ2V4SWQpLCBcImludmFsaWQgaWRlbnRpZmllclwiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgIGlucHV0cyA9IE9iamVjdC5mcmVlemUoaW5wdXRzLnNsaWNlKCkpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgbmFtZSB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBqb2luUGFyYW1zKGZvcm1hdCwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIFwiKFwiICsgcGFyYW1zLm1hcCgocCkgPT4gcC5mb3JtYXQoZm9ybWF0KSkuam9pbigoZm9ybWF0ID09PSBcImZ1bGxcIikgPyBcIiwgXCIgOiBcIixcIikgKyBcIilcIjtcbn1cbi8qKlxuICogIEEgRnJhZ21lbnQgd2hpY2ggcmVwcmVzZW50cyBhIC8vQ3VzdG9tIEVycm9yLy8uXG4gKi9cbmV4cG9ydCBjbGFzcyBFcnJvckZyYWdtZW50IGV4dGVuZHMgTmFtZWRGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIG5hbWUsIGlucHV0cykge1xuICAgICAgICBzdXBlcihndWFyZCwgXCJlcnJvclwiLCBuYW1lLCBpbnB1dHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IEVycm9yRnJhZ21lbnRJbnRlcm5hbCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBDdXN0b20gRXJyb3Igc2VsZWN0b3IuXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdG9yKCkge1xuICAgICAgICByZXR1cm4gaWQodGhpcy5mb3JtYXQoXCJzaWdoYXNoXCIpKS5zdWJzdHJpbmcoMCwgMTApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGZyYWdtZW50IGFzICUlZm9ybWF0JSUuXG4gICAgICovXG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwic2lnaGFzaFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwianNvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiB0aGlzLmlucHV0cy5tYXAoKGlucHV0KSA9PiBKU09OLnBhcnNlKGlucHV0LmZvcm1hdChmb3JtYXQpKSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gXCJzaWdoYXNoXCIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFwiZXJyb3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5uYW1lICsgam9pblBhcmFtcyhmb3JtYXQsIHRoaXMuaW5wdXRzKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIiBcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3ICoqRXJyb3JGcmFnbWVudCoqIGZvciAlJW9iaiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG9iaikge1xuICAgICAgICBpZiAoRXJyb3JGcmFnbWVudC5pc0ZyYWdtZW50KG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbShsZXgob2JqKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBjb25zdW1lTmFtZShcImVycm9yXCIsIG9iaik7XG4gICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XG4gICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yRnJhZ21lbnQoX2d1YXJkLCBuYW1lLCBpbnB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3JGcmFnbWVudChfZ3VhcmQsIG9iai5uYW1lLCBvYmouaW5wdXRzID8gb2JqLmlucHV0cy5tYXAoUGFyYW1UeXBlLmZyb20pIDogW10pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlmICUldmFsdWUlJSBpcyBhblxuICAgICAqICAqKkVycm9yRnJhZ21lbnQqKi5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNGcmFnbWVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlW2ludGVybmFsXSA9PT0gRXJyb3JGcmFnbWVudEludGVybmFsKTtcbiAgICB9XG59XG4vKipcbiAqICBBIEZyYWdtZW50IHdoaWNoIHJlcHJlc2VudHMgYW4gRXZlbnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBFdmVudEZyYWdtZW50IGV4dGVuZHMgTmFtZWRGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgICogIFdoZXRoZXIgdGhpcyBldmVudCBpcyBhbm9ueW1vdXMuXG4gICAgICovXG4gICAgYW5vbnltb3VzO1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBuYW1lLCBpbnB1dHMsIGFub255bW91cykge1xuICAgICAgICBzdXBlcihndWFyZCwgXCJldmVudFwiLCBuYW1lLCBpbnB1dHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IEV2ZW50RnJhZ21lbnRJbnRlcm5hbCB9KTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGFub255bW91cyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBFdmVudCB0b3BpYyBoYXNoLlxuICAgICAqL1xuICAgIGdldCB0b3BpY0hhc2goKSB7XG4gICAgICAgIHJldHVybiBpZCh0aGlzLmZvcm1hdChcInNpZ2hhc2hcIikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGV2ZW50IGFzICUlZm9ybWF0JSUuXG4gICAgICovXG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwic2lnaGFzaFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwianNvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZXZlbnRcIixcbiAgICAgICAgICAgICAgICBhbm9ueW1vdXM6IHRoaXMuYW5vbnltb3VzLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLm1hcCgoaSkgPT4gSlNPTi5wYXJzZShpLmZvcm1hdChmb3JtYXQpKSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAoZm9ybWF0ICE9PSBcInNpZ2hhc2hcIikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJldmVudFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaCh0aGlzLm5hbWUgKyBqb2luUGFyYW1zKGZvcm1hdCwgdGhpcy5pbnB1dHMpKTtcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gXCJzaWdoYXNoXCIgJiYgdGhpcy5hbm9ueW1vdXMpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFwiYW5vbnltb3VzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIiBcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHRvcGljIGhhc2ggZm9yIGFuIGV2ZW50IHdpdGggJSVuYW1lJSUgYW5kICUlcGFyYW1zJSUuXG4gICAgICovXG4gICAgc3RhdGljIGdldFRvcGljSGFzaChuYW1lLCBwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zID0gKHBhcmFtcyB8fCBbXSkubWFwKChwKSA9PiBQYXJhbVR5cGUuZnJvbShwKSk7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gbmV3IEV2ZW50RnJhZ21lbnQoX2d1YXJkLCBuYW1lLCBwYXJhbXMsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50LnRvcGljSGFzaDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgKipFdmVudEZyYWdtZW50KiogZm9yICUlb2JqJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XG4gICAgICAgIGlmIChFdmVudEZyYWdtZW50LmlzRnJhZ21lbnQob2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvYmopID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBFdmVudEZyYWdtZW50LmZyb20obGV4KG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBldmVudCBmcmFnbWVudFwiLCBcIm9ialwiLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gY29uc3VtZU5hbWUoXCJldmVudFwiLCBvYmopO1xuICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gY29uc3VtZVBhcmFtcyhvYmosIHRydWUpO1xuICAgICAgICAgICAgY29uc3QgYW5vbnltb3VzID0gISFjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1wiYW5vbnltb3VzXCJdKSkuaGFzKFwiYW5vbnltb3VzXCIpO1xuICAgICAgICAgICAgY29uc3VtZUVvaShvYmopO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudEZyYWdtZW50KF9ndWFyZCwgbmFtZSwgaW5wdXRzLCBhbm9ueW1vdXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRXZlbnRGcmFnbWVudChfZ3VhcmQsIG9iai5uYW1lLCBvYmouaW5wdXRzID8gb2JqLmlucHV0cy5tYXAoKHApID0+IFBhcmFtVHlwZS5mcm9tKHAsIHRydWUpKSA6IFtdLCAhIW9iai5hbm9ueW1vdXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlmICUldmFsdWUlJSBpcyBhblxuICAgICAqICAqKkV2ZW50RnJhZ21lbnQqKi5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNGcmFnbWVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlW2ludGVybmFsXSA9PT0gRXZlbnRGcmFnbWVudEludGVybmFsKTtcbiAgICB9XG59XG4vKipcbiAqICBBIEZyYWdtZW50IHdoaWNoIHJlcHJlc2VudHMgYSBjb25zdHJ1Y3Rvci5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbnN0cnVjdG9yRnJhZ21lbnQgZXh0ZW5kcyBGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgICogIFdoZXRoZXIgdGhlIGNvbnN0cnVjdG9yIGNhbiByZWNlaXZlIGFuIGVuZG93bWVudC5cbiAgICAgKi9cbiAgICBwYXlhYmxlO1xuICAgIC8qKlxuICAgICAqICBUaGUgcmVjb21tZW5kZWQgZ2FzIGxpbWl0IGZvciBkZXBsb3ltZW50IG9yIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdhcztcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgdHlwZSwgaW5wdXRzLCBwYXlhYmxlLCBnYXMpIHtcbiAgICAgICAgc3VwZXIoZ3VhcmQsIHR5cGUsIGlucHV0cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZTogQ29uc3RydWN0b3JGcmFnbWVudEludGVybmFsIH0pO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgcGF5YWJsZSwgZ2FzIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbnN0cnVjdG9yIGFzICUlZm9ybWF0JSUuXG4gICAgICovXG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBhc3NlcnQoZm9ybWF0ICE9IG51bGwgJiYgZm9ybWF0ICE9PSBcInNpZ2hhc2hcIiwgXCJjYW5ub3QgZm9ybWF0IGEgY29uc3RydWN0b3IgZm9yIHNpZ2hhc2hcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZm9ybWF0KHNpZ2hhc2gpXCIgfSk7XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwianNvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29uc3RydWN0b3JcIixcbiAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICh0aGlzLnBheWFibGUgPyBcInBheWFibGVcIiA6IFwidW5kZWZpbmVkXCIpLFxuICAgICAgICAgICAgICAgIHBheWFibGU6IHRoaXMucGF5YWJsZSxcbiAgICAgICAgICAgICAgICBnYXM6ICgodGhpcy5nYXMgIT0gbnVsbCkgPyB0aGlzLmdhcyA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgaW5wdXRzOiB0aGlzLmlucHV0cy5tYXAoKGkpID0+IEpTT04ucGFyc2UoaS5mb3JtYXQoZm9ybWF0KSkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbYGNvbnN0cnVjdG9yJHtqb2luUGFyYW1zKGZvcm1hdCwgdGhpcy5pbnB1dHMpfWBdO1xuICAgICAgICBpZiAodGhpcy5wYXlhYmxlKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcInBheWFibGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZ2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGBAJHt0aGlzLmdhcy50b1N0cmluZygpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIiBcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3ICoqQ29uc3RydWN0b3JGcmFnbWVudCoqIGZvciAlJW9iaiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG9iaikge1xuICAgICAgICBpZiAoQ29uc3RydWN0b3JGcmFnbWVudC5pc0ZyYWdtZW50KG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tKGxleChvYmopKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgY29uc3R1Y3RvciBmcmFnbWVudFwiLCBcIm9ialwiLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1wiY29uc3RydWN0b3JcIl0pKTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgIGNvbnN0IHBheWFibGUgPSAhIWNvbnN1bWVLZXl3b3JkcyhvYmosIEt3VmlzaWJEZXBsb3kpLmhhcyhcInBheWFibGVcIik7XG4gICAgICAgICAgICBjb25zdCBnYXMgPSBjb25zdW1lR2FzKG9iaik7XG4gICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yRnJhZ21lbnQoX2d1YXJkLCBcImNvbnN0cnVjdG9yXCIsIGlucHV0cywgcGF5YWJsZSwgZ2FzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yRnJhZ21lbnQoX2d1YXJkLCBcImNvbnN0cnVjdG9yXCIsIG9iai5pbnB1dHMgPyBvYmouaW5wdXRzLm1hcChQYXJhbVR5cGUuZnJvbSkgOiBbXSwgISFvYmoucGF5YWJsZSwgKG9iai5nYXMgIT0gbnVsbCkgPyBvYmouZ2FzIDogbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaWYgJSV2YWx1ZSUlIGlzIGFcbiAgICAgKiAgKipDb25zdHJ1Y3RvckZyYWdtZW50KiouXG4gICAgICovXG4gICAgc3RhdGljIGlzRnJhZ21lbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZVtpbnRlcm5hbF0gPT09IENvbnN0cnVjdG9yRnJhZ21lbnRJbnRlcm5hbCk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSBGcmFnbWVudCB3aGljaCByZXByZXNlbnRzIGEgbWV0aG9kLlxuICovXG5leHBvcnQgY2xhc3MgRmFsbGJhY2tGcmFnbWVudCBleHRlbmRzIEZyYWdtZW50IHtcbiAgICAvKipcbiAgICAgKiAgSWYgdGhlIGZ1bmN0aW9uIGNhbiBiZSBzZW50IHZhbHVlIGR1cmluZyBpbnZvY2F0aW9uLlxuICAgICAqL1xuICAgIHBheWFibGU7XG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIGlucHV0cywgcGF5YWJsZSkge1xuICAgICAgICBzdXBlcihndWFyZCwgXCJmYWxsYmFja1wiLCBpbnB1dHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IEZhbGxiYWNrRnJhZ21lbnRJbnRlcm5hbCB9KTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHBheWFibGUgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZmFsbGJhY2sgYXMgJSVmb3JtYXQlJS5cbiAgICAgKi9cbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSAoKHRoaXMuaW5wdXRzLmxlbmd0aCA9PT0gMCkgPyBcInJlY2VpdmVcIiA6IFwiZmFsbGJhY2tcIik7XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwianNvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZU11dGFiaWxpdHkgPSAodGhpcy5wYXlhYmxlID8gXCJwYXlhYmxlXCIgOiBcIm5vbnBheWFibGVcIik7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoeyB0eXBlLCBzdGF0ZU11dGFiaWxpdHkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke3R5cGV9KCkke3RoaXMucGF5YWJsZSA/IFwiIHBheWFibGVcIiA6IFwiXCJ9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgKipGYWxsYmFja0ZyYWdtZW50KiogZm9yICUlb2JqJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XG4gICAgICAgIGlmIChGYWxsYmFja0ZyYWdtZW50LmlzRnJhZ21lbnQob2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvYmopID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBGYWxsYmFja0ZyYWdtZW50LmZyb20obGV4KG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBmYWxsYmFjayBmcmFnbWVudFwiLCBcIm9ialwiLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvck9iaiA9IG9iai50b1N0cmluZygpO1xuICAgICAgICAgICAgY29uc3QgdG9wSXNWYWxpZCA9IG9iai5wZWVrS2V5d29yZChzZXRpZnkoW1wiZmFsbGJhY2tcIiwgXCJyZWNlaXZlXCJdKSk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh0b3BJc1ZhbGlkLCBcInR5cGUgbXVzdCBiZSBmYWxsYmFjayBvciByZWNlaXZlXCIsIFwib2JqXCIsIGVycm9yT2JqKTtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBvYmoucG9wS2V5d29yZChzZXRpZnkoW1wiZmFsbGJhY2tcIiwgXCJyZWNlaXZlXCJdKSk7XG4gICAgICAgICAgICAvLyByZWNlaXZlKClcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcInJlY2VpdmVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChpbnB1dHMubGVuZ3RoID09PSAwLCBgcmVjZWl2ZSBjYW5ub3QgaGF2ZSBhcmd1bWVudHNgLCBcIm9iai5pbnB1dHNcIiwgaW5wdXRzKTtcbiAgICAgICAgICAgICAgICBjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1wicGF5YWJsZVwiXSkpO1xuICAgICAgICAgICAgICAgIGNvbnN1bWVFb2kob2JqKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZhbGxiYWNrRnJhZ21lbnQoX2d1YXJkLCBbXSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmYWxsYmFjaygpIFtwYXlhYmxlXVxuICAgICAgICAgICAgLy8gZmFsbGJhY2soYnl0ZXMpIFtwYXlhYmxlXSByZXR1cm5zIChieXRlcylcbiAgICAgICAgICAgIGxldCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XG4gICAgICAgICAgICBpZiAoaW5wdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGlucHV0cy5sZW5ndGggPT09IDEgJiYgaW5wdXRzWzBdLnR5cGUgPT09IFwiYnl0ZXNcIiwgXCJpbnZhbGlkIGZhbGxiYWNrIGlucHV0c1wiLCBcIm9iai5pbnB1dHNcIiwgaW5wdXRzLm1hcCgoaSkgPT4gaS5mb3JtYXQoXCJtaW5pbWFsXCIpKS5qb2luKFwiLCBcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5wdXRzID0gW1BhcmFtVHlwZS5mcm9tKFwiYnl0ZXNcIildO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbXV0YWJpbGl0eSA9IGNvbnN1bWVNdXRhYmlsaXR5KG9iaik7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChtdXRhYmlsaXR5ID09PSBcIm5vbnBheWFibGVcIiB8fCBtdXRhYmlsaXR5ID09PSBcInBheWFibGVcIiwgXCJmYWxsYmFjayBjYW5ub3QgYmUgY29uc3RhbnRzXCIsIFwib2JqLnN0YXRlTXV0YWJpbGl0eVwiLCBtdXRhYmlsaXR5KTtcbiAgICAgICAgICAgIGlmIChjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1wicmV0dXJuc1wiXSkpLmhhcyhcInJldHVybnNcIikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXRzID0gY29uc3VtZVBhcmFtcyhvYmopO1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KG91dHB1dHMubGVuZ3RoID09PSAxICYmIG91dHB1dHNbMF0udHlwZSA9PT0gXCJieXRlc1wiLCBcImludmFsaWQgZmFsbGJhY2sgb3V0cHV0c1wiLCBcIm9iai5vdXRwdXRzXCIsIG91dHB1dHMubWFwKChpKSA9PiBpLmZvcm1hdChcIm1pbmltYWxcIikpLmpvaW4oXCIsIFwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZhbGxiYWNrRnJhZ21lbnQoX2d1YXJkLCBpbnB1dHMsIG11dGFiaWxpdHkgPT09IFwicGF5YWJsZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqLnR5cGUgPT09IFwicmVjZWl2ZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZhbGxiYWNrRnJhZ21lbnQoX2d1YXJkLCBbXSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iai50eXBlID09PSBcImZhbGxiYWNrXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IFtQYXJhbVR5cGUuZnJvbShcImJ5dGVzXCIpXTtcbiAgICAgICAgICAgIGNvbnN0IHBheWFibGUgPSAob2JqLnN0YXRlTXV0YWJpbGl0eSA9PT0gXCJwYXlhYmxlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGYWxsYmFja0ZyYWdtZW50KF9ndWFyZCwgaW5wdXRzLCBwYXlhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIGZhbGxiYWNrIGRlc2NyaXB0aW9uXCIsIFwib2JqXCIsIG9iaik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaWYgJSV2YWx1ZSUlIGlzIGFcbiAgICAgKiAgKipGYWxsYmFja0ZyYWdtZW50KiouXG4gICAgICovXG4gICAgc3RhdGljIGlzRnJhZ21lbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZVtpbnRlcm5hbF0gPT09IEZhbGxiYWNrRnJhZ21lbnRJbnRlcm5hbCk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSBGcmFnbWVudCB3aGljaCByZXByZXNlbnRzIGEgbWV0aG9kLlxuICovXG5leHBvcnQgY2xhc3MgRnVuY3Rpb25GcmFnbWVudCBleHRlbmRzIE5hbWVkRnJhZ21lbnQge1xuICAgIC8qKlxuICAgICAqICBJZiB0aGUgZnVuY3Rpb24gaXMgY29uc3RhbnQgKGUuZy4gYGBwdXJlYGAgb3IgYGB2aWV3YGAgZnVuY3Rpb25zKS5cbiAgICAgKi9cbiAgICBjb25zdGFudDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHJldHVybmVkIHR5cGVzIGZvciB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBvdXRwdXRzO1xuICAgIC8qKlxuICAgICAqICBUaGUgc3RhdGUgbXV0YWJpbGl0eSAoZS5nLiBgYHBheWFibGVgYCwgYGBub25wYXlhYmxlYGAsIGBgdmlld2BgXG4gICAgICogIG9yIGBgcHVyZWBgKVxuICAgICAqL1xuICAgIHN0YXRlTXV0YWJpbGl0eTtcbiAgICAvKipcbiAgICAgKiAgSWYgdGhlIGZ1bmN0aW9uIGNhbiBiZSBzZW50IHZhbHVlIGR1cmluZyBpbnZvY2F0aW9uLlxuICAgICAqL1xuICAgIHBheWFibGU7XG4gICAgLyoqXG4gICAgICogIFRoZSByZWNvbW1lbmRlZCBnYXMgbGltaXQgdG8gc2VuZCB3aGVuIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBnYXM7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIG5hbWUsIHN0YXRlTXV0YWJpbGl0eSwgaW5wdXRzLCBvdXRwdXRzLCBnYXMpIHtcbiAgICAgICAgc3VwZXIoZ3VhcmQsIFwiZnVuY3Rpb25cIiwgbmFtZSwgaW5wdXRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiBGdW5jdGlvbkZyYWdtZW50SW50ZXJuYWwgfSk7XG4gICAgICAgIG91dHB1dHMgPSBPYmplY3QuZnJlZXplKG91dHB1dHMuc2xpY2UoKSk7XG4gICAgICAgIGNvbnN0IGNvbnN0YW50ID0gKHN0YXRlTXV0YWJpbGl0eSA9PT0gXCJ2aWV3XCIgfHwgc3RhdGVNdXRhYmlsaXR5ID09PSBcInB1cmVcIik7XG4gICAgICAgIGNvbnN0IHBheWFibGUgPSAoc3RhdGVNdXRhYmlsaXR5ID09PSBcInBheWFibGVcIik7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBjb25zdGFudCwgZ2FzLCBvdXRwdXRzLCBwYXlhYmxlLCBzdGF0ZU11dGFiaWxpdHkgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgRnVuY3Rpb24gc2VsZWN0b3IuXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdG9yKCkge1xuICAgICAgICByZXR1cm4gaWQodGhpcy5mb3JtYXQoXCJzaWdoYXNoXCIpKS5zdWJzdHJpbmcoMCwgMTApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGFzICUlZm9ybWF0JSUuXG4gICAgICovXG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwic2lnaGFzaFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwianNvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICAgICAgY29uc3RhbnQ6IHRoaXMuY29uc3RhbnQsXG4gICAgICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAoKHRoaXMuc3RhdGVNdXRhYmlsaXR5ICE9PSBcIm5vbnBheWFibGVcIikgPyB0aGlzLnN0YXRlTXV0YWJpbGl0eSA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgcGF5YWJsZTogdGhpcy5wYXlhYmxlLFxuICAgICAgICAgICAgICAgIGdhczogKCh0aGlzLmdhcyAhPSBudWxsKSA/IHRoaXMuZ2FzIDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLm1hcCgoaSkgPT4gSlNPTi5wYXJzZShpLmZvcm1hdChmb3JtYXQpKSksXG4gICAgICAgICAgICAgICAgb3V0cHV0czogdGhpcy5vdXRwdXRzLm1hcCgobykgPT4gSlNPTi5wYXJzZShvLmZvcm1hdChmb3JtYXQpKSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gXCJzaWdoYXNoXCIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFwiZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5uYW1lICsgam9pblBhcmFtcyhmb3JtYXQsIHRoaXMuaW5wdXRzKSk7XG4gICAgICAgIGlmIChmb3JtYXQgIT09IFwic2lnaGFzaFwiKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZU11dGFiaWxpdHkgIT09IFwibm9ucGF5YWJsZVwiKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5zdGF0ZU11dGFiaWxpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0cyAmJiB0aGlzLm91dHB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJyZXR1cm5zXCIpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGpvaW5QYXJhbXMoZm9ybWF0LCB0aGlzLm91dHB1dHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmdhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYEAke3RoaXMuZ2FzLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgc2VsZWN0b3IgZm9yIGEgZnVuY3Rpb24gd2l0aCAlJW5hbWUlJSBhbmQgJSVwYXJhbXMlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2VsZWN0b3IobmFtZSwgcGFyYW1zKSB7XG4gICAgICAgIHBhcmFtcyA9IChwYXJhbXMgfHwgW10pLm1hcCgocCkgPT4gUGFyYW1UeXBlLmZyb20ocCkpO1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IG5ldyBGdW5jdGlvbkZyYWdtZW50KF9ndWFyZCwgbmFtZSwgXCJ2aWV3XCIsIHBhcmFtcywgW10sIG51bGwpO1xuICAgICAgICByZXR1cm4gZnJhZ21lbnQuc2VsZWN0b3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3ICoqRnVuY3Rpb25GcmFnbWVudCoqIGZvciAlJW9iaiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG9iaikge1xuICAgICAgICBpZiAoRnVuY3Rpb25GcmFnbWVudC5pc0ZyYWdtZW50KG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb25GcmFnbWVudC5mcm9tKGxleChvYmopKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgZnVuY3Rpb24gZnJhZ21lbnRcIiwgXCJvYmpcIiwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvbnN1bWVOYW1lKFwiZnVuY3Rpb25cIiwgb2JqKTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgIGNvbnN0IG11dGFiaWxpdHkgPSBjb25zdW1lTXV0YWJpbGl0eShvYmopO1xuICAgICAgICAgICAgbGV0IG91dHB1dHMgPSBbXTtcbiAgICAgICAgICAgIGlmIChjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1wicmV0dXJuc1wiXSkpLmhhcyhcInJldHVybnNcIikpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRzID0gY29uc3VtZVBhcmFtcyhvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZ2FzID0gY29uc3VtZUdhcyhvYmopO1xuICAgICAgICAgICAgY29uc3VtZUVvaShvYmopO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbkZyYWdtZW50KF9ndWFyZCwgbmFtZSwgbXV0YWJpbGl0eSwgaW5wdXRzLCBvdXRwdXRzLCBnYXMpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGF0ZU11dGFiaWxpdHkgPSBvYmouc3RhdGVNdXRhYmlsaXR5O1xuICAgICAgICAvLyBVc2UgbGVnYWN5IFNvbGlkaXR5IEFCSSBsb2dpYyBpZiBzdGF0ZU11dGFiaWxpdHkgaXMgbWlzc2luZ1xuICAgICAgICBpZiAoc3RhdGVNdXRhYmlsaXR5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eSA9IFwicGF5YWJsZVwiO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAob2JqLmNvbnN0YW50KSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHkgPSBcInZpZXdcIjtcbiAgICAgICAgICAgICAgICBpZiAoIW9iai5jb25zdGFudCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHkgPSBcInBheWFibGVcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAob2JqLnBheWFibGUpID09PSBcImJvb2xlYW5cIiAmJiAhb2JqLnBheWFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eSA9IFwibm9ucGF5YWJsZVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIChvYmoucGF5YWJsZSkgPT09IFwiYm9vbGVhblwiICYmICFvYmoucGF5YWJsZSkge1xuICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eSA9IFwibm9ucGF5YWJsZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEBUT0RPOiB2ZXJpZnlTdGF0ZSBmb3Igc3RhdGVNdXRhYmlsaXR5IChlLmcuIHRocm93IGlmXG4gICAgICAgIC8vICAgICAgICBwYXlhYmxlOiBmYWxzZSBidXQgc3RhdGVNdXRhYmlsaXR5IGlzIFwibm9ucGF5YWJsZVwiKVxuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uRnJhZ21lbnQoX2d1YXJkLCBvYmoubmFtZSwgc3RhdGVNdXRhYmlsaXR5LCBvYmouaW5wdXRzID8gb2JqLmlucHV0cy5tYXAoUGFyYW1UeXBlLmZyb20pIDogW10sIG9iai5vdXRwdXRzID8gb2JqLm91dHB1dHMubWFwKFBhcmFtVHlwZS5mcm9tKSA6IFtdLCAob2JqLmdhcyAhPSBudWxsKSA/IG9iai5nYXMgOiBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpZiAlJXZhbHVlJSUgaXMgYVxuICAgICAqICAqKkZ1bmN0aW9uRnJhZ21lbnQqKi5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNGcmFnbWVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlW2ludGVybmFsXSA9PT0gRnVuY3Rpb25GcmFnbWVudEludGVybmFsKTtcbiAgICB9XG59XG4vKipcbiAqICBBIEZyYWdtZW50IHdoaWNoIHJlcHJlc2VudHMgYSBzdHJ1Y3R1cmUuXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHJ1Y3RGcmFnbWVudCBleHRlbmRzIE5hbWVkRnJhZ21lbnQge1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBuYW1lLCBpbnB1dHMpIHtcbiAgICAgICAgc3VwZXIoZ3VhcmQsIFwic3RydWN0XCIsIG5hbWUsIGlucHV0cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZTogU3RydWN0RnJhZ21lbnRJbnRlcm5hbCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzdHJ1Y3QgYXMgJSVmb3JtYXQlJS5cbiAgICAgKi9cbiAgICBmb3JtYXQoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBUT0RPXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyAqKlN0cnVjdEZyYWdtZW50KiogZm9yICUlb2JqJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cnVjdEZyYWdtZW50LmZyb20obGV4KG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBzdHJ1Y3QgZnJhZ21lbnRcIiwgXCJvYmpcIiwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvbnN1bWVOYW1lKFwic3RydWN0XCIsIG9iaik7XG4gICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XG4gICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cnVjdEZyYWdtZW50KF9ndWFyZCwgbmFtZSwgaW5wdXRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFN0cnVjdEZyYWdtZW50KF9ndWFyZCwgb2JqLm5hbWUsIG9iai5pbnB1dHMgPyBvYmouaW5wdXRzLm1hcChQYXJhbVR5cGUuZnJvbSkgOiBbXSk7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBmaXggdGhpcyByZXR1cm4gdHlwZVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaWYgJSV2YWx1ZSUlIGlzIGFcbiAgICAgKiAgKipTdHJ1Y3RGcmFnbWVudCoqLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0ZyYWdtZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWVbaW50ZXJuYWxdID09PSBTdHJ1Y3RGcmFnbWVudEludGVybmFsKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mcmFnbWVudHMuanMubWFwIl0sIm5hbWVzIjpbImRlZmluZVByb3BlcnRpZXMiLCJnZXRCaWdJbnQiLCJnZXROdW1iZXIiLCJhc3NlcnQiLCJhc3NlcnRQcml2YXRlIiwiYXNzZXJ0QXJndW1lbnQiLCJpZCIsInNldGlmeSIsIml0ZW1zIiwicmVzdWx0IiwiU2V0IiwiZm9yRWFjaCIsImsiLCJhZGQiLCJPYmplY3QiLCJmcmVlemUiLCJfa3dWaXNpYkRlcGxveSIsIkt3VmlzaWJEZXBsb3kiLCJzcGxpdCIsIl9rd1Zpc2liIiwiS3dWaXNpYiIsIl9rd1R5cGVzIiwiS3dUeXBlcyIsIl9rd01vZGlmaWVycyIsIkt3TW9kaWZpZXJzIiwiX2t3T3RoZXIiLCJfa2V5d29yZHMiLCJqb2luIiwiS2V5d29yZHMiLCJTaW1wbGVUb2tlbnMiLCJyZWdleFdoaXRlc3BhY2VQcmVmaXgiLCJSZWdFeHAiLCJyZWdleE51bWJlclByZWZpeCIsInJlZ2V4SWRQcmVmaXgiLCJyZWdleElkIiwicmVnZXhUeXBlIiwiVG9rZW5TdHJpbmciLCJvZmZzZXQiLCJsZW5ndGgiLCJ0b2tlbnMiLCJjbG9uZSIsInJlc2V0IiwicG9wS2V5d29yZCIsImFsbG93ZWQiLCJ0b3AiLCJwZWVrIiwidHlwZSIsImhhcyIsInRleHQiLCJFcnJvciIsInBvcCIsInBvcFR5cGUiLCJKU09OIiwic3RyaW5naWZ5IiwicG9wUGFyZW4iLCJzdWJUb2tlblN0cmluZyIsIm1hdGNoIiwicG9wUGFyYW1zIiwibGluayIsImxpbmtOZXh0IiwicHVzaCIsInBlZWtLZXl3b3JkIiwicGVla1R5cGUiLCJ0b1N0cmluZyIsImkiLCJ0b2tlbiIsImNvbnN0cnVjdG9yIiwic2xpY2UiLCJmcm9tIiwidG8iLCJtYXAiLCJ0IiwiYXNzaWduIiwibGlua0JhY2siLCJsZXgiLCJ0aHJvd0Vycm9yIiwibWVzc2FnZSIsImJyYWNrZXRzIiwiY29tbWFzIiwiY3VyIiwic3Vic3RyaW5nIiwiZGVwdGgiLCJ2YWx1ZSIsInN1ZmZpeCIsImFsbG93U2luZ2xlIiwic2V0IiwiaW5jbHVkZWQiLCJrZXkiLCJrZXlzIiwiY29uc3VtZU5hbWUiLCJrZXl3b3JkIiwiY29uc3VtZUtleXdvcmRzIiwia2V5d29yZHMiLCJjb25zdW1lTXV0YWJpbGl0eSIsIm1vZGlmaWVycyIsImNvbnN1bWVQYXJhbXMiLCJhbGxvd0luZGV4ZWQiLCJQYXJhbVR5cGUiLCJjb25zdW1lR2FzIiwiY29uc3VtZUVvaSIsInJlZ2V4QXJyYXlUeXBlIiwidmVyaWZ5QmFzaWNUeXBlIiwicGFyc2VJbnQiLCJzaXplIiwiX2d1YXJkIiwiaW50ZXJuYWwiLCJTeW1ib2wiLCJmb3IiLCJQYXJhbVR5cGVJbnRlcm5hbCIsIkVycm9yRnJhZ21lbnRJbnRlcm5hbCIsIkV2ZW50RnJhZ21lbnRJbnRlcm5hbCIsIkNvbnN0cnVjdG9yRnJhZ21lbnRJbnRlcm5hbCIsIkZhbGxiYWNrRnJhZ21lbnRJbnRlcm5hbCIsIkZ1bmN0aW9uRnJhZ21lbnRJbnRlcm5hbCIsIlN0cnVjdEZyYWdtZW50SW50ZXJuYWwiLCJmb3JtYXQiLCJuYW1lIiwiaXNBcnJheSIsInBhcnNlIiwiYXJyYXlDaGlsZHJlbiIsImFycmF5TGVuZ3RoIiwiU3RyaW5nIiwiYmFzZVR5cGUiLCJpbmRleGVkIiwiaXNUdXBsZSIsImNvbXBvbmVudHMiLCJjIiwiY29tcCIsImlzSW5kZXhhYmxlIiwid2FsayIsInByb2Nlc3MiLCJBcnJheSIsIl90aGlzIiwidiIsIndhbGtBc3luYyIsInByb21pc2VzIiwiUHJvbWlzZSIsImFsbCIsIm9iaiIsImlzUGFyYW1UeXBlIiwiZXJyb3IiLCJjb21wcyIsImJyYWNrZXQiLCJhcnJheU1hdGNoIiwic3RhcnRzV2l0aCIsInR1cGxlIiwiZ3VhcmQiLCJkZWZpbmVQcm9wZXJ0eSIsInNldFZhbHVlIiwiY2hpbGRUeXBlIiwiaW5kZXgiLCJwYXJhbSIsInRoZW4iLCJGcmFnbWVudCIsImUiLCJDb25zdHJ1Y3RvckZyYWdtZW50IiwiRXJyb3JGcmFnbWVudCIsIkV2ZW50RnJhZ21lbnQiLCJGYWxsYmFja0ZyYWdtZW50IiwiRnVuY3Rpb25GcmFnbWVudCIsIlN0cnVjdEZyYWdtZW50Iiwib3BlcmF0aW9uIiwiaXNDb25zdHJ1Y3RvciIsImlzRnJhZ21lbnQiLCJpc0Vycm9yIiwiaXNFdmVudCIsImlzRnVuY3Rpb24iLCJpc1N0cnVjdCIsImlucHV0cyIsIk5hbWVkRnJhZ21lbnQiLCJqb2luUGFyYW1zIiwicGFyYW1zIiwicCIsInNlbGVjdG9yIiwiaW5wdXQiLCJ0b3BpY0hhc2giLCJhbm9ueW1vdXMiLCJnZXRUb3BpY0hhc2giLCJmcmFnbWVudCIsInN0YXRlTXV0YWJpbGl0eSIsInBheWFibGUiLCJnYXMiLCJ1bmRlZmluZWQiLCJlcnJvck9iaiIsInRvcElzVmFsaWQiLCJtdXRhYmlsaXR5Iiwib3V0cHV0cyIsImNvbnN0YW50IiwibyIsImdldFNlbGVjdG9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/abi/fragments.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/abi/interface.js":
/*!******************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/interface.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ErrorDescription: function() { return /* binding */ ErrorDescription; },\n/* harmony export */   Indexed: function() { return /* binding */ Indexed; },\n/* harmony export */   Interface: function() { return /* binding */ Interface; },\n/* harmony export */   LogDescription: function() { return /* binding */ LogDescription; },\n/* harmony export */   Result: function() { return /* reexport safe */ _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Result; },\n/* harmony export */   TransactionDescription: function() { return /* binding */ TransactionDescription; },\n/* harmony export */   checkResultErrors: function() { return /* reexport safe */ _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.checkResultErrors; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_get */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_get.js\");\n/* harmony import */ var _swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_init */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_init.js\");\n/* harmony import */ var _swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_set */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_set.js\");\n/* harmony import */ var _swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @swc/helpers/_/_class_private_method_get */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_method_get.js\");\n/* harmony import */ var _swc_helpers_class_private_method_init__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @swc/helpers/_/_class_private_method_init */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_method_init.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../crypto/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../hash/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/hash/id.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _abi_coder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abi-coder.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/abi-coder.js\");\n/* harmony import */ var _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./coders/abstract-coder.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n/* harmony import */ var _fragments_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./fragments.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/fragments.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./typed.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/**\n *  The Interface class is a low-level class that accepts an\n *  ABI and provides all the necessary functionality to encode\n *  and decode paramaters to and results from methods, events\n *  and errors.\n *\n *  It also provides several convenience methods to automatically\n *  search and find matching transactions and events to parse them.\n *\n *  @_subsection api/abi:Interfaces  [interfaces]\n */ \n\n\n\n\n\n\n\n\n\n\n\n\n/**\n *  When using the [[Interface-parseLog]] to automatically match a Log to its event\n *  for parsing, a **LogDescription** is returned.\n */ class LogDescription {\n    /**\n     *  @_ignore:\n     */ constructor(fragment, topic, args){\n        const name = fragment.name, signature = fragment.format();\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            fragment,\n            name,\n            signature,\n            topic,\n            args\n        });\n    }\n}\n/**\n *  When using the [[Interface-parseTransaction]] to automatically match\n *  a transaction data to its function for parsing,\n *  a **TransactionDescription** is returned.\n */ class TransactionDescription {\n    /**\n     *  @_ignore:\n     */ constructor(fragment, selector, args, value){\n        const name = fragment.name, signature = fragment.format();\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            fragment,\n            name,\n            args,\n            signature,\n            selector,\n            value\n        });\n    }\n}\n/**\n *  When using the [[Interface-parseError]] to automatically match an\n *  error for a call result for parsing, an **ErrorDescription** is returned.\n */ class ErrorDescription {\n    /**\n     *  @_ignore:\n     */ constructor(fragment, selector, args){\n        const name = fragment.name, signature = fragment.format();\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            fragment,\n            name,\n            args,\n            signature,\n            selector\n        });\n    }\n}\n/**\n *  An **Indexed** is used as a value when a value that does not\n *  fit within a topic (i.e. not a fixed-length, 32-byte type). It\n *  is the ``keccak256`` of the value, and used for types such as\n *  arrays, tuples, bytes and strings.\n */ class Indexed {\n    /**\n     *  Returns ``true`` if %%value%% is an **Indexed**.\n     *\n     *  This provides a Type Guard for property access.\n     */ static isIndexed(value) {\n        return !!(value && value._isIndexed);\n    }\n    /**\n     *  @_ignore:\n     */ constructor(hash){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            hash,\n            _isIndexed: true\n        });\n    }\n}\n// https://docs.soliditylang.org/en/v0.8.13/control-structures.html?highlight=panic#panic-via-assert-and-error-via-require\nconst PanicReasons = {\n    \"0\": \"generic panic\",\n    \"1\": \"assert(false)\",\n    \"17\": \"arithmetic overflow\",\n    \"18\": \"division or modulo by zero\",\n    \"33\": \"enum overflow\",\n    \"34\": \"invalid encoded storage byte array accessed\",\n    \"49\": \"out-of-bounds array access; popping on an empty array\",\n    \"50\": \"out-of-bounds access of an array or bytesN\",\n    \"65\": \"out of memory\",\n    \"81\": \"uninitialized function\"\n};\nconst BuiltinErrors = {\n    \"0x08c379a0\": {\n        signature: \"Error(string)\",\n        name: \"Error\",\n        inputs: [\n            \"string\"\n        ],\n        reason: (message)=>{\n            return \"reverted with reason string \".concat(JSON.stringify(message));\n        }\n    },\n    \"0x4e487b71\": {\n        signature: \"Panic(uint256)\",\n        name: \"Panic\",\n        inputs: [\n            \"uint256\"\n        ],\n        reason: (code)=>{\n            let reason = \"unknown panic code\";\n            if (code >= 0 && code <= 0xff && PanicReasons[code.toString()]) {\n                reason = PanicReasons[code.toString()];\n            }\n            return \"reverted with panic code 0x\".concat(code.toString(16), \" (\").concat(reason, \")\");\n        }\n    }\n};\nvar _errors = /*#__PURE__*/ new WeakMap(), _events = /*#__PURE__*/ new WeakMap(), _functions = /*#__PURE__*/ new WeakMap(), //    #structs: Map<string, StructFragment>;\n_abiCoder = /*#__PURE__*/ new WeakMap(), // Find a function definition by any means necessary (unless it is ambiguous)\n_getFunction = /*#__PURE__*/ new WeakSet(), // Find an event definition by any means necessary (unless it is ambiguous)\n_getEvent = /*#__PURE__*/ new WeakSet();\n/**\n *  An Interface abstracts many of the low-level details for\n *  encoding and decoding the data on the blockchain.\n *\n *  An ABI provides information on how to encode data to send to\n *  a Contract, how to decode the results and events and how to\n *  interpret revert errors.\n *\n *  The ABI can be specified by [any supported format](InterfaceAbi).\n */ class Interface {\n    /**\n     *  Returns the entire Human-Readable ABI, as an array of\n     *  signatures, optionally as %%minimal%% strings, which\n     *  removes parameter names and unneceesary spaces.\n     */ format(minimal) {\n        const format = minimal ? \"minimal\" : \"full\";\n        const abi = this.fragments.map((f)=>f.format(format));\n        return abi;\n    }\n    /**\n     *  Return the JSON-encoded ABI. This is the format Solidiy\n     *  returns.\n     */ formatJson() {\n        const abi = this.fragments.map((f)=>f.format(\"json\"));\n        // We need to re-bundle the JSON fragments a bit\n        return JSON.stringify(abi.map((j)=>JSON.parse(j)));\n    }\n    /**\n     *  The ABI coder that will be used to encode and decode binary\n     *  data.\n     */ getAbiCoder() {\n        return _abi_coder_js__WEBPACK_IMPORTED_MODULE_2__.AbiCoder.defaultAbiCoder();\n    }\n    /**\n     *  Get the function name for %%key%%, which may be a function selector,\n     *  function name or function signature that belongs to the ABI.\n     */ getFunctionName(key) {\n        const fragment = (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _getFunction, getFunction).call(this, key, null, false);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assertArgument)(fragment, \"no matching function\", \"key\", key);\n        return fragment.name;\n    }\n    /**\n     *  Returns true if %%key%% (a function selector, function name or\n     *  function signature) is present in the ABI.\n     *\n     *  In the case of a function name, the name may be ambiguous, so\n     *  accessing the [[FunctionFragment]] may require refinement.\n     */ hasFunction(key) {\n        return !!(0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _getFunction, getFunction).call(this, key, null, false);\n    }\n    /**\n     *  Get the [[FunctionFragment]] for %%key%%, which may be a function\n     *  selector, function name or function signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple functions match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single function in\n     *  the ABI, this will throw.\n     */ getFunction(key, values) {\n        return (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _getFunction, getFunction).call(this, key, values || null, true);\n    }\n    /**\n     *  Iterate over all functions, calling %%callback%%, sorted by their name.\n     */ forEachFunction(callback) {\n        const names = Array.from((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_5__._)(this, _functions).keys());\n        names.sort((a, b)=>a.localeCompare(b));\n        for(let i = 0; i < names.length; i++){\n            const name = names[i];\n            callback((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_5__._)(this, _functions).get(name), i);\n        }\n    }\n    /**\n     *  Get the event name for %%key%%, which may be a topic hash,\n     *  event name or event signature that belongs to the ABI.\n     */ getEventName(key) {\n        const fragment = (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _getEvent, getEvent).call(this, key, null, false);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assertArgument)(fragment, \"no matching event\", \"key\", key);\n        return fragment.name;\n    }\n    /**\n     *  Returns true if %%key%% (an event topic hash, event name or\n     *  event signature) is present in the ABI.\n     *\n     *  In the case of an event name, the name may be ambiguous, so\n     *  accessing the [[EventFragment]] may require refinement.\n     */ hasEvent(key) {\n        return !!(0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _getEvent, getEvent).call(this, key, null, false);\n    }\n    /**\n     *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,\n     *  event name or event signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple events match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single event in\n     *  the ABI, this will throw.\n     */ getEvent(key, values) {\n        return (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _getEvent, getEvent).call(this, key, values || null, true);\n    }\n    /**\n     *  Iterate over all events, calling %%callback%%, sorted by their name.\n     */ forEachEvent(callback) {\n        const names = Array.from((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_5__._)(this, _events).keys());\n        names.sort((a, b)=>a.localeCompare(b));\n        for(let i = 0; i < names.length; i++){\n            const name = names[i];\n            callback((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_5__._)(this, _events).get(name), i);\n        }\n    }\n    /**\n     *  Get the [[ErrorFragment]] for %%key%%, which may be an error\n     *  selector, error name or error signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple errors match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single error in\n     *  the ABI, this will throw.\n     */ getError(key, values) {\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.isHexString)(key)) {\n            const selector = key.toLowerCase();\n            if (BuiltinErrors[selector]) {\n                return _fragments_js__WEBPACK_IMPORTED_MODULE_7__.ErrorFragment.from(BuiltinErrors[selector].signature);\n            }\n            for (const fragment of (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_5__._)(this, _errors).values()){\n                if (selector === fragment.selector) {\n                    return fragment;\n                }\n            }\n            return null;\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching = [];\n            for (const [name, fragment] of (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_5__._)(this, _errors)){\n                if (name.split(\"(\" /* fix:) */ )[0] === key) {\n                    matching.push(fragment);\n                }\n            }\n            if (matching.length === 0) {\n                if (key === \"Error\") {\n                    return _fragments_js__WEBPACK_IMPORTED_MODULE_7__.ErrorFragment.from(\"error Error(string)\");\n                }\n                if (key === \"Panic\") {\n                    return _fragments_js__WEBPACK_IMPORTED_MODULE_7__.ErrorFragment.from(\"error Panic(uint256)\");\n                }\n                return null;\n            } else if (matching.length > 1) {\n                const matchStr = matching.map((m)=>JSON.stringify(m.format())).join(\", \");\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assertArgument)(false, \"ambiguous error description (i.e. \".concat(matchStr, \")\"), \"name\", key);\n            }\n            return matching[0];\n        }\n        // Normalize the signature and lookup the function\n        key = _fragments_js__WEBPACK_IMPORTED_MODULE_7__.ErrorFragment.from(key).format();\n        if (key === \"Error(string)\") {\n            return _fragments_js__WEBPACK_IMPORTED_MODULE_7__.ErrorFragment.from(\"error Error(string)\");\n        }\n        if (key === \"Panic(uint256)\") {\n            return _fragments_js__WEBPACK_IMPORTED_MODULE_7__.ErrorFragment.from(\"error Panic(uint256)\");\n        }\n        const result = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_5__._)(this, _errors).get(key);\n        if (result) {\n            return result;\n        }\n        return null;\n    }\n    /**\n     *  Iterate over all errors, calling %%callback%%, sorted by their name.\n     */ forEachError(callback) {\n        const names = Array.from((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_5__._)(this, _errors).keys());\n        names.sort((a, b)=>a.localeCompare(b));\n        for(let i = 0; i < names.length; i++){\n            const name = names[i];\n            callback((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_5__._)(this, _errors).get(name), i);\n        }\n    }\n    // Get the 4-byte selector used by Solidity to identify a function\n    /*\ngetSelector(fragment: ErrorFragment | FunctionFragment): string {\n    if (typeof(fragment) === \"string\") {\n        const matches: Array<Fragment> = [ ];\n\n        try { matches.push(this.getFunction(fragment)); } catch (error) { }\n        try { matches.push(this.getError(<string>fragment)); } catch (_) { }\n\n        if (matches.length === 0) {\n            logger.throwArgumentError(\"unknown fragment\", \"key\", fragment);\n        } else if (matches.length > 1) {\n            logger.throwArgumentError(\"ambiguous fragment matches function and error\", \"key\", fragment);\n        }\n\n        fragment = matches[0];\n    }\n\n    return dataSlice(id(fragment.format()), 0, 4);\n}\n    */ // Get the 32-byte topic hash used by Solidity to identify an event\n    /*\n    getEventTopic(fragment: EventFragment): string {\n        //if (typeof(fragment) === \"string\") { fragment = this.getEvent(eventFragment); }\n        return id(fragment.format());\n    }\n    */ _decodeParams(params, data) {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_5__._)(this, _abiCoder).decode(params, data);\n    }\n    _encodeParams(params, values) {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_5__._)(this, _abiCoder).encode(params, values);\n    }\n    /**\n     *  Encodes a ``tx.data`` object for deploying the Contract with\n     *  the %%values%% as the constructor arguments.\n     */ encodeDeploy(values) {\n        return this._encodeParams(this.deploy.inputs, values || []);\n    }\n    /**\n     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n     *  specified error (see [[getError]] for valid values for\n     *  %%key%%).\n     *\n     *  Most developers should prefer the [[parseCallResult]] method instead,\n     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n     *  corresponding error.\n     */ decodeErrorResult(fragment, data) {\n        if (typeof fragment === \"string\") {\n            const f = this.getError(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assertArgument)(f, \"unknown error\", \"fragment\", fragment);\n            fragment = f;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.dataSlice)(data, 0, 4) === fragment.selector, \"data signature does not match error \".concat(fragment.name, \".\"), \"data\", data);\n        return this._decodeParams(fragment.inputs, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.dataSlice)(data, 4));\n    }\n    /**\n     *  Encodes the transaction revert data for a call result that\n     *  reverted from the the Contract with the sepcified %%error%%\n     *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.\n     *\n     *  This is generally not used by most developers, unless trying to mock\n     *  a result from a Contract.\n     */ encodeErrorResult(fragment, values) {\n        if (typeof fragment === \"string\") {\n            const f = this.getError(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assertArgument)(f, \"unknown error\", \"fragment\", fragment);\n            fragment = f;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.concat)([\n            fragment.selector,\n            this._encodeParams(fragment.inputs, values || [])\n        ]);\n    }\n    /**\n     *  Decodes the %%data%% from a transaction ``tx.data`` for\n     *  the function specified (see [[getFunction]] for valid values\n     *  for %%fragment%%).\n     *\n     *  Most developers should prefer the [[parseTransaction]] method\n     *  instead, which will automatically detect the fragment.\n     */ decodeFunctionData(fragment, data) {\n        if (typeof fragment === \"string\") {\n            const f = this.getFunction(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.dataSlice)(data, 0, 4) === fragment.selector, \"data signature does not match function \".concat(fragment.name, \".\"), \"data\", data);\n        return this._decodeParams(fragment.inputs, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.dataSlice)(data, 4));\n    }\n    /**\n     *  Encodes the ``tx.data`` for a transaction that calls the function\n     *  specified (see [[getFunction]] for valid values for %%fragment%%) with\n     *  the %%values%%.\n     */ encodeFunctionData(fragment, values) {\n        if (typeof fragment === \"string\") {\n            const f = this.getFunction(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.concat)([\n            fragment.selector,\n            this._encodeParams(fragment.inputs, values || [])\n        ]);\n    }\n    /**\n     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n     *  specified function (see [[getFunction]] for valid values for\n     *  %%key%%).\n     *\n     *  Most developers should prefer the [[parseCallResult]] method instead,\n     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n     *  corresponding error.\n     */ decodeFunctionResult(fragment, data) {\n        if (typeof fragment === \"string\") {\n            const f = this.getFunction(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        let message = \"invalid length for result data\";\n        const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBytesCopy)(data);\n        if (bytes.length % 32 === 0) {\n            try {\n                return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_5__._)(this, _abiCoder).decode(fragment.outputs, bytes);\n            } catch (error) {\n                message = \"could not decode result data\";\n            }\n        }\n        // Call returned data with no error, but the data is junk\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(false, message, \"BAD_DATA\", {\n            value: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.hexlify)(bytes),\n            info: {\n                method: fragment.name,\n                signature: fragment.format()\n            }\n        });\n    }\n    makeError(_data, tx) {\n        const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBytes)(_data, \"data\");\n        const error = _abi_coder_js__WEBPACK_IMPORTED_MODULE_2__.AbiCoder.getBuiltinCallException(\"call\", tx, data);\n        // Not a built-in error; try finding a custom error\n        const customPrefix = \"execution reverted (unknown custom error)\";\n        if (error.message.startsWith(customPrefix)) {\n            const selector = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.hexlify)(data.slice(0, 4));\n            const ef = this.getError(selector);\n            if (ef) {\n                try {\n                    const args = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_5__._)(this, _abiCoder).decode(ef.inputs, data.slice(4));\n                    error.revert = {\n                        name: ef.name,\n                        signature: ef.format(),\n                        args\n                    };\n                    error.reason = error.revert.signature;\n                    error.message = \"execution reverted: \".concat(error.reason);\n                } catch (e) {\n                    error.message = \"execution reverted (coult not decode custom error)\";\n                }\n            }\n        }\n        // Add the invocation, if available\n        const parsed = this.parseTransaction(tx);\n        if (parsed) {\n            error.invocation = {\n                method: parsed.name,\n                signature: parsed.signature,\n                args: parsed.args\n            };\n        }\n        return error;\n    }\n    /**\n     *  Encodes the result data (e.g. from an ``eth_call``) for the\n     *  specified function (see [[getFunction]] for valid values\n     *  for %%fragment%%) with %%values%%.\n     *\n     *  This is generally not used by most developers, unless trying to mock\n     *  a result from a Contract.\n     */ encodeFunctionResult(fragment, values) {\n        if (typeof fragment === \"string\") {\n            const f = this.getFunction(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.hexlify)((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_5__._)(this, _abiCoder).encode(fragment.outputs, values || []));\n    }\n    /*\n        spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {\n            const promises: Array<Promise<>> = [ ];\n            const process = function(type: ParamType, value: any): any {\n                if (type.baseType === \"array\") {\n                    return descend(type.child\n                }\n                if (type. === \"address\") {\n                }\n            };\n    \n            const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {\n                if (inputs.length !== values.length) { throw new Error(\"length mismatch\"); }\n                \n            };\n    \n            const result: Array<any> = [ ];\n            values.forEach((value, index) => {\n                if (value == null) {\n                    topics.push(null);\n                } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                    logger.throwArgumentError(\"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n                } else if (Array.isArray(value)) {\n                    topics.push(value.map((value) => encodeTopic(param, value)));\n                } else {\n                    topics.push(encodeTopic(param, value));\n                }\n            });\n        }\n    */ // Create the filter for the event with search criteria (e.g. for eth_filterLog)\n    encodeFilterTopics(fragment, values) {\n        if (typeof fragment === \"string\") {\n            const f = this.getEvent(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assertArgument)(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(values.length <= fragment.inputs.length, \"too many arguments for \".concat(fragment.format()), \"UNEXPECTED_ARGUMENT\", {\n            count: values.length,\n            expectedCount: fragment.inputs.length\n        });\n        const topics = [];\n        if (!fragment.anonymous) {\n            topics.push(fragment.topicHash);\n        }\n        // @TODO: Use the coders for this; to properly support tuples, etc.\n        const encodeTopic = (param, value)=>{\n            if (param.type === \"string\") {\n                return (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_8__.id)(value);\n            } else if (param.type === \"bytes\") {\n                return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_9__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.hexlify)(value));\n            }\n            if (param.type === \"bool\" && typeof value === \"boolean\") {\n                value = value ? \"0x01\" : \"0x00\";\n            } else if (param.type.match(/^u?int/)) {\n                value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.toBeHex)(value); // @TODO: Should this toTwos??\n            } else if (param.type.match(/^bytes/)) {\n                value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.zeroPadBytes)(value, 32);\n            } else if (param.type === \"address\") {\n                // Check addresses are valid\n                (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_5__._)(this, _abiCoder).encode([\n                    \"address\"\n                ], [\n                    value\n                ]);\n            }\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.zeroPadValue)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.hexlify)(value), 32);\n        };\n        values.forEach((value, index)=>{\n            const param = fragment.inputs[index];\n            if (!param.indexed) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assertArgument)(value == null, \"cannot filter non-indexed parameters; must be null\", \"contract.\" + param.name, value);\n                return;\n            }\n            if (value == null) {\n                topics.push(null);\n            } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assertArgument)(false, \"filtering with tuples or arrays not supported\", \"contract.\" + param.name, value);\n            } else if (Array.isArray(value)) {\n                topics.push(value.map((value)=>encodeTopic(param, value)));\n            } else {\n                topics.push(encodeTopic(param, value));\n            }\n        });\n        // Trim off trailing nulls\n        while(topics.length && topics[topics.length - 1] === null){\n            topics.pop();\n        }\n        return topics;\n    }\n    encodeEventLog(fragment, values) {\n        if (typeof fragment === \"string\") {\n            const f = this.getEvent(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assertArgument)(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n        const topics = [];\n        const dataTypes = [];\n        const dataValues = [];\n        if (!fragment.anonymous) {\n            topics.push(fragment.topicHash);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assertArgument)(values.length === fragment.inputs.length, \"event arguments/values mismatch\", \"values\", values);\n        fragment.inputs.forEach((param, index)=>{\n            const value = values[index];\n            if (param.indexed) {\n                if (param.type === \"string\") {\n                    topics.push((0,_hash_index_js__WEBPACK_IMPORTED_MODULE_8__.id)(value));\n                } else if (param.type === \"bytes\") {\n                    topics.push((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_9__.keccak256)(value));\n                } else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    // @TODO\n                    throw new Error(\"not implemented\");\n                } else {\n                    topics.push((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_5__._)(this, _abiCoder).encode([\n                        param.type\n                    ], [\n                        value\n                    ]));\n                }\n            } else {\n                dataTypes.push(param);\n                dataValues.push(value);\n            }\n        });\n        return {\n            data: (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_5__._)(this, _abiCoder).encode(dataTypes, dataValues),\n            topics: topics\n        };\n    }\n    // Decode a filter for the event and the search criteria\n    decodeEventLog(fragment, data, topics) {\n        if (typeof fragment === \"string\") {\n            const f = this.getEvent(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assertArgument)(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n        if (topics != null && !fragment.anonymous) {\n            const eventTopic = fragment.topicHash;\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.isHexString)(topics[0], 32) && topics[0].toLowerCase() === eventTopic, \"fragment/topic mismatch\", \"topics[0]\", topics[0]);\n            topics = topics.slice(1);\n        }\n        const indexed = [];\n        const nonIndexed = [];\n        const dynamic = [];\n        fragment.inputs.forEach((param, index)=>{\n            if (param.indexed) {\n                if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    indexed.push(_fragments_js__WEBPACK_IMPORTED_MODULE_7__.ParamType.from({\n                        type: \"bytes32\",\n                        name: param.name\n                    }));\n                    dynamic.push(true);\n                } else {\n                    indexed.push(param);\n                    dynamic.push(false);\n                }\n            } else {\n                nonIndexed.push(param);\n                dynamic.push(false);\n            }\n        });\n        const resultIndexed = topics != null ? (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_5__._)(this, _abiCoder).decode(indexed, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.concat)(topics)) : null;\n        const resultNonIndexed = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_5__._)(this, _abiCoder).decode(nonIndexed, data, true);\n        //const result: (Array<any> & { [ key: string ]: any }) = [ ];\n        const values = [];\n        const keys = [];\n        let nonIndexedIndex = 0, indexedIndex = 0;\n        fragment.inputs.forEach((param, index)=>{\n            let value = null;\n            if (param.indexed) {\n                if (resultIndexed == null) {\n                    value = new Indexed(null);\n                } else if (dynamic[index]) {\n                    value = new Indexed(resultIndexed[indexedIndex++]);\n                } else {\n                    try {\n                        value = resultIndexed[indexedIndex++];\n                    } catch (error) {\n                        value = error;\n                    }\n                }\n            } else {\n                try {\n                    value = resultNonIndexed[nonIndexedIndex++];\n                } catch (error) {\n                    value = error;\n                }\n            }\n            values.push(value);\n            keys.push(param.name || null);\n        });\n        return _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Result.fromItems(values, keys);\n    }\n    /**\n     *  Parses a transaction, finding the matching function and extracts\n     *  the parameter values along with other useful function details.\n     *\n     *  If the matching function cannot be found, return null.\n     */ parseTransaction(tx) {\n        const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBytes)(tx.data, \"tx.data\");\n        const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.getBigInt)(tx.value != null ? tx.value : 0, \"tx.value\");\n        const fragment = this.getFunction((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.hexlify)(data.slice(0, 4)));\n        if (!fragment) {\n            return null;\n        }\n        const args = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_5__._)(this, _abiCoder).decode(fragment.inputs, data.slice(4));\n        return new TransactionDescription(fragment, fragment.selector, args, value);\n    }\n    parseCallResult(data) {\n        throw new Error(\"@TODO\");\n    }\n    /**\n     *  Parses a receipt log, finding the matching event and extracts\n     *  the parameter values along with other useful event details.\n     *\n     *  If the matching event cannot be found, returns null.\n     */ parseLog(log) {\n        const fragment = this.getEvent(log.topics[0]);\n        if (!fragment || fragment.anonymous) {\n            return null;\n        }\n        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n        //        Probably not, because just because it is the only event in the ABI does\n        //        not mean we have the full ABI; maybe just a fragment?\n        return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));\n    }\n    /**\n     *  Parses a revert data, finding the matching error and extracts\n     *  the parameter values along with other useful error details.\n     *\n     *  If the matching error cannot be found, returns null.\n     */ parseError(data) {\n        const hexData = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.hexlify)(data);\n        const fragment = this.getError((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.dataSlice)(hexData, 0, 4));\n        if (!fragment) {\n            return null;\n        }\n        const args = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_5__._)(this, _abiCoder).decode(fragment.inputs, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.dataSlice)(hexData, 4));\n        return new ErrorDescription(fragment, fragment.selector, args);\n    }\n    /**\n     *  Creates a new [[Interface]] from the ABI %%value%%.\n     *\n     *  The %%value%% may be provided as an existing [[Interface]] object,\n     *  a JSON-encoded ABI or any Human-Readable ABI format.\n     */ static from(value) {\n        // Already an Interface, which is immutable\n        if (value instanceof Interface) {\n            return value;\n        }\n        // JSON\n        if (typeof value === \"string\") {\n            return new Interface(JSON.parse(value));\n        }\n        // An Interface; possibly from another v6 instance\n        if (typeof value.formatJson === \"function\") {\n            return new Interface(value.formatJson());\n        }\n        // A legacy Interface; from an older version\n        if (typeof value.format === \"function\") {\n            return new Interface(value.format(\"json\"));\n        }\n        // Array of fragments\n        return new Interface(value);\n    }\n    /**\n     *  Create a new Interface for the %%fragments%%.\n     */ constructor(fragments){\n        (0,_swc_helpers_class_private_method_init__WEBPACK_IMPORTED_MODULE_11__._)(this, _getFunction);\n        (0,_swc_helpers_class_private_method_init__WEBPACK_IMPORTED_MODULE_11__._)(this, _getEvent);\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_12__._)(this, _errors, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_12__._)(this, _events, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_12__._)(this, _functions, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_12__._)(this, _abiCoder, {\n            writable: true,\n            value: void 0\n        });\n        let abi = [];\n        if (typeof fragments === \"string\") {\n            abi = JSON.parse(fragments);\n        } else {\n            abi = fragments;\n        }\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_13__._)(this, _functions, new Map());\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_13__._)(this, _errors, new Map());\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_13__._)(this, _events, new Map());\n        //        this.#structs = new Map();\n        const frags = [];\n        for (const a of abi){\n            try {\n                frags.push(_fragments_js__WEBPACK_IMPORTED_MODULE_7__.Fragment.from(a));\n            } catch (error) {\n                console.log(\"[Warning] Invalid Fragment \".concat(JSON.stringify(a), \":\"), error.message);\n            }\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            fragments: Object.freeze(frags)\n        });\n        let fallback = null;\n        let receive = false;\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_13__._)(this, _abiCoder, this.getAbiCoder());\n        // Add all fragments by their signature\n        this.fragments.forEach((fragment, index)=>{\n            let bucket;\n            switch(fragment.type){\n                case \"constructor\":\n                    if (this.deploy) {\n                        console.log(\"duplicate definition - constructor\");\n                        return;\n                    }\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n                        deploy: fragment\n                    });\n                    return;\n                case \"fallback\":\n                    if (fragment.inputs.length === 0) {\n                        receive = true;\n                    } else {\n                        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assertArgument)(!fallback || fragment.payable !== fallback.payable, \"conflicting fallback fragments\", \"fragments[\".concat(index, \"]\"), fragment);\n                        fallback = fragment;\n                        receive = fallback.payable;\n                    }\n                    return;\n                case \"function\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    //checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\n                    bucket = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_5__._)(this, _functions);\n                    break;\n                case \"event\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    bucket = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_5__._)(this, _events);\n                    break;\n                case \"error\":\n                    bucket = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_5__._)(this, _errors);\n                    break;\n                default:\n                    return;\n            }\n            // Two identical entries; ignore it\n            const signature = fragment.format();\n            if (bucket.has(signature)) {\n                return;\n            }\n            bucket.set(signature, fragment);\n        });\n        // If we do not have a constructor add a default\n        if (!this.deploy) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n                deploy: _fragments_js__WEBPACK_IMPORTED_MODULE_7__.ConstructorFragment.from(\"constructor()\")\n            });\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            fallback,\n            receive\n        });\n    }\n} //# sourceMappingURL=interface.js.map\nfunction getFunction(key, values, forceUnique) {\n    // Selector\n    if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.isHexString)(key)) {\n        const selector = key.toLowerCase();\n        for (const fragment of (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_5__._)(this, _functions).values()){\n            if (selector === fragment.selector) {\n                return fragment;\n            }\n        }\n        return null;\n    }\n    // It is a bare name, look up the function (will return null if ambiguous)\n    if (key.indexOf(\"(\") === -1) {\n        const matching = [];\n        for (const [name, fragment] of (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_5__._)(this, _functions)){\n            if (name.split(\"(\" /* fix:) */ )[0] === key) {\n                matching.push(fragment);\n            }\n        }\n        if (values) {\n            const lastValue = values.length > 0 ? values[values.length - 1] : null;\n            let valueLength = values.length;\n            let allowOptions = true;\n            if (_typed_js__WEBPACK_IMPORTED_MODULE_14__.Typed.isTyped(lastValue) && lastValue.type === \"overrides\") {\n                allowOptions = false;\n                valueLength--;\n            }\n            // Remove all matches that don't have a compatible length. The args\n            // may contain an overrides, so the match may have n or n - 1 parameters\n            for(let i = matching.length - 1; i >= 0; i--){\n                const inputs = matching[i].inputs.length;\n                if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {\n                    matching.splice(i, 1);\n                }\n            }\n            // Remove all matches that don't match the Typed signature\n            for(let i = matching.length - 1; i >= 0; i--){\n                const inputs = matching[i].inputs;\n                for(let j = 0; j < values.length; j++){\n                    // Not a typed value\n                    if (!_typed_js__WEBPACK_IMPORTED_MODULE_14__.Typed.isTyped(values[j])) {\n                        continue;\n                    }\n                    // We are past the inputs\n                    if (j >= inputs.length) {\n                        if (values[j].type === \"overrides\") {\n                            continue;\n                        }\n                        matching.splice(i, 1);\n                        break;\n                    }\n                    // Make sure the value type matches the input type\n                    if (values[j].type !== inputs[j].baseType) {\n                        matching.splice(i, 1);\n                        break;\n                    }\n                }\n            }\n        }\n        // We found a single matching signature with an overrides, but the\n        // last value is something that cannot possibly be an options\n        if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {\n            const lastArg = values[values.length - 1];\n            if (lastArg == null || Array.isArray(lastArg) || typeof lastArg !== \"object\") {\n                matching.splice(0, 1);\n            }\n        }\n        if (matching.length === 0) {\n            return null;\n        }\n        if (matching.length > 1 && forceUnique) {\n            const matchStr = matching.map((m)=>JSON.stringify(m.format())).join(\", \");\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assertArgument)(false, \"ambiguous function description (i.e. matches \".concat(matchStr, \")\"), \"key\", key);\n        }\n        return matching[0];\n    }\n    // Normalize the signature and lookup the function\n    const result = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_5__._)(this, _functions).get(_fragments_js__WEBPACK_IMPORTED_MODULE_7__.FunctionFragment.from(key).format());\n    if (result) {\n        return result;\n    }\n    return null;\n}\nfunction getEvent(key, values, forceUnique) {\n    // EventTopic\n    if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.isHexString)(key)) {\n        const eventTopic = key.toLowerCase();\n        for (const fragment of (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_5__._)(this, _events).values()){\n            if (eventTopic === fragment.topicHash) {\n                return fragment;\n            }\n        }\n        return null;\n    }\n    // It is a bare name, look up the function (will return null if ambiguous)\n    if (key.indexOf(\"(\") === -1) {\n        const matching = [];\n        for (const [name, fragment] of (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_5__._)(this, _events)){\n            if (name.split(\"(\" /* fix:) */ )[0] === key) {\n                matching.push(fragment);\n            }\n        }\n        if (values) {\n            // Remove all matches that don't have a compatible length.\n            for(let i = matching.length - 1; i >= 0; i--){\n                if (matching[i].inputs.length < values.length) {\n                    matching.splice(i, 1);\n                }\n            }\n            // Remove all matches that don't match the Typed signature\n            for(let i = matching.length - 1; i >= 0; i--){\n                const inputs = matching[i].inputs;\n                for(let j = 0; j < values.length; j++){\n                    // Not a typed value\n                    if (!_typed_js__WEBPACK_IMPORTED_MODULE_14__.Typed.isTyped(values[j])) {\n                        continue;\n                    }\n                    // Make sure the value type matches the input type\n                    if (values[j].type !== inputs[j].baseType) {\n                        matching.splice(i, 1);\n                        break;\n                    }\n                }\n            }\n        }\n        if (matching.length === 0) {\n            return null;\n        }\n        if (matching.length > 1 && forceUnique) {\n            const matchStr = matching.map((m)=>JSON.stringify(m.format())).join(\", \");\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assertArgument)(false, \"ambiguous event description (i.e. matches \".concat(matchStr, \")\"), \"key\", key);\n        }\n        return matching[0];\n    }\n    // Normalize the signature and lookup the function\n    const result = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_5__._)(this, _events).get(_fragments_js__WEBPACK_IMPORTED_MODULE_7__.EventFragment.from(key).format());\n    if (result) {\n        return result;\n    }\n    return null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvaW50ZXJmYWNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7OztDQVVDOzs7OztBQUM4QztBQUNUO0FBQ3dKO0FBQ3BKO0FBQzZCO0FBQ21EO0FBQ3ZGO0FBQ0U7QUFDckM7OztDQUdDLEdBQ00sTUFBTXlCO0lBcUJUOztLQUVDLEdBQ0RDLFlBQVlDLFFBQVEsRUFBRUMsS0FBSyxFQUFFQyxJQUFJLENBQUU7UUFDL0IsTUFBTUMsT0FBT0gsU0FBU0csSUFBSSxFQUFFQyxZQUFZSixTQUFTSyxNQUFNO1FBQ3ZEckIsaUVBQWdCQSxDQUFDLElBQUksRUFBRTtZQUNuQmdCO1lBQVVHO1lBQU1DO1lBQVdIO1lBQU9DO1FBQ3RDO0lBQ0o7QUFDSjtBQUNBOzs7O0NBSUMsR0FDTSxNQUFNSTtJQXlCVDs7S0FFQyxHQUNEUCxZQUFZQyxRQUFRLEVBQUVPLFFBQVEsRUFBRUwsSUFBSSxFQUFFTSxLQUFLLENBQUU7UUFDekMsTUFBTUwsT0FBT0gsU0FBU0csSUFBSSxFQUFFQyxZQUFZSixTQUFTSyxNQUFNO1FBQ3ZEckIsaUVBQWdCQSxDQUFDLElBQUksRUFBRTtZQUNuQmdCO1lBQVVHO1lBQU1EO1lBQU1FO1lBQVdHO1lBQVVDO1FBQy9DO0lBQ0o7QUFDSjtBQUNBOzs7Q0FHQyxHQUNNLE1BQU1DO0lBcUJUOztLQUVDLEdBQ0RWLFlBQVlDLFFBQVEsRUFBRU8sUUFBUSxFQUFFTCxJQUFJLENBQUU7UUFDbEMsTUFBTUMsT0FBT0gsU0FBU0csSUFBSSxFQUFFQyxZQUFZSixTQUFTSyxNQUFNO1FBQ3ZEckIsaUVBQWdCQSxDQUFDLElBQUksRUFBRTtZQUNuQmdCO1lBQVVHO1lBQU1EO1lBQU1FO1lBQVdHO1FBQ3JDO0lBQ0o7QUFDSjtBQUNBOzs7OztDQUtDLEdBQ00sTUFBTUc7SUFTVDs7OztLQUlDLEdBQ0QsT0FBT0MsVUFBVUgs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U0FBUyxDQUFDOEMsRUFBRTdELE1BQU0sS0FBSzhELElBQUksQ0FBQztZQUN0RWxGLCtEQUFjQSxDQUFDLE9BQU8sNkNBQXNELE9BQVRnRixVQUFTLE1BQUksT0FBTzlCO1FBQzNGO1FBQ0EsT0FBTzJCLFFBQVEsQ0FBQyxFQUFFO0lBQ3RCO0lBQ0Esa0RBQWtEO0lBQ2xELE1BQU1NLFNBQVMsNEVBQUksRUFBRVgsU0FBT0wsR0FBRyxDQUFDM0Qsd0RBQWFBLENBQUNrRCxJQUFJLENBQUNSLEtBQUs5QixNQUFNO0lBQzlELElBQUkrRCxRQUFRO1FBQ1IsT0FBT0E7SUFDWDtJQUNBLE9BQU87QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2ludGVyZmFjZS5qcz9lNTY3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIFRoZSBJbnRlcmZhY2UgY2xhc3MgaXMgYSBsb3ctbGV2ZWwgY2xhc3MgdGhhdCBhY2NlcHRzIGFuXG4gKiAgQUJJIGFuZCBwcm92aWRlcyBhbGwgdGhlIG5lY2Vzc2FyeSBmdW5jdGlvbmFsaXR5IHRvIGVuY29kZVxuICogIGFuZCBkZWNvZGUgcGFyYW1hdGVycyB0byBhbmQgcmVzdWx0cyBmcm9tIG1ldGhvZHMsIGV2ZW50c1xuICogIGFuZCBlcnJvcnMuXG4gKlxuICogIEl0IGFsc28gcHJvdmlkZXMgc2V2ZXJhbCBjb252ZW5pZW5jZSBtZXRob2RzIHRvIGF1dG9tYXRpY2FsbHlcbiAqICBzZWFyY2ggYW5kIGZpbmQgbWF0Y2hpbmcgdHJhbnNhY3Rpb25zIGFuZCBldmVudHMgdG8gcGFyc2UgdGhlbS5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uIGFwaS9hYmk6SW50ZXJmYWNlcyAgW2ludGVyZmFjZXNdXG4gKi9cbmltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbmltcG9ydCB7IGlkIH0gZnJvbSBcIi4uL2hhc2gvaW5kZXguanNcIjtcbmltcG9ydCB7IGNvbmNhdCwgZGF0YVNsaWNlLCBnZXRCaWdJbnQsIGdldEJ5dGVzLCBnZXRCeXRlc0NvcHksIGhleGxpZnksIHplcm9QYWRCeXRlcywgemVyb1BhZFZhbHVlLCBpc0hleFN0cmluZywgZGVmaW5lUHJvcGVydGllcywgYXNzZXJ0QXJndW1lbnQsIHRvQmVIZXgsIGFzc2VydCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQWJpQ29kZXIgfSBmcm9tIFwiLi9hYmktY29kZXIuanNcIjtcbmltcG9ydCB7IGNoZWNrUmVzdWx0RXJyb3JzLCBSZXN1bHQgfSBmcm9tIFwiLi9jb2RlcnMvYWJzdHJhY3QtY29kZXIuanNcIjtcbmltcG9ydCB7IENvbnN0cnVjdG9yRnJhZ21lbnQsIEVycm9yRnJhZ21lbnQsIEV2ZW50RnJhZ21lbnQsIEZyYWdtZW50LCBGdW5jdGlvbkZyYWdtZW50LCBQYXJhbVR5cGUgfSBmcm9tIFwiLi9mcmFnbWVudHMuanNcIjtcbmltcG9ydCB7IFR5cGVkIH0gZnJvbSBcIi4vdHlwZWQuanNcIjtcbmV4cG9ydCB7IGNoZWNrUmVzdWx0RXJyb3JzLCBSZXN1bHQgfTtcbi8qKlxuICogIFdoZW4gdXNpbmcgdGhlIFtbSW50ZXJmYWNlLXBhcnNlTG9nXV0gdG8gYXV0b21hdGljYWxseSBtYXRjaCBhIExvZyB0byBpdHMgZXZlbnRcbiAqICBmb3IgcGFyc2luZywgYSAqKkxvZ0Rlc2NyaXB0aW9uKiogaXMgcmV0dXJuZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBMb2dEZXNjcmlwdGlvbiB7XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXRjaGluZyBmcmFnbWVudCBmb3IgdGhlIGBgdG9waWMwYGAuXG4gICAgICovXG4gICAgZnJhZ21lbnQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lIG9mIHRoZSBFdmVudC5cbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8qKlxuICAgICAqICBUaGUgZnVsbCBFdmVudCBzaWduYXR1cmUuXG4gICAgICovXG4gICAgc2lnbmF0dXJlO1xuICAgIC8qKlxuICAgICAqICBUaGUgdG9waWMgaGFzaCBmb3IgdGhlIEV2ZW50LlxuICAgICAqL1xuICAgIHRvcGljO1xuICAgIC8qKlxuICAgICAqICBUaGUgYXJndW1lbnRzIHBhc3NlZCBpbnRvIHRoZSBFdmVudCB3aXRoIGBgZW1pdGBgLlxuICAgICAqL1xuICAgIGFyZ3M7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGZyYWdtZW50LCB0b3BpYywgYXJncykge1xuICAgICAgICBjb25zdCBuYW1lID0gZnJhZ21lbnQubmFtZSwgc2lnbmF0dXJlID0gZnJhZ21lbnQuZm9ybWF0KCk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgZnJhZ21lbnQsIG5hbWUsIHNpZ25hdHVyZSwgdG9waWMsIGFyZ3NcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiAgV2hlbiB1c2luZyB0aGUgW1tJbnRlcmZhY2UtcGFyc2VUcmFuc2FjdGlvbl1dIHRvIGF1dG9tYXRpY2FsbHkgbWF0Y2hcbiAqICBhIHRyYW5zYWN0aW9uIGRhdGEgdG8gaXRzIGZ1bmN0aW9uIGZvciBwYXJzaW5nLFxuICogIGEgKipUcmFuc2FjdGlvbkRlc2NyaXB0aW9uKiogaXMgcmV0dXJuZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBUcmFuc2FjdGlvbkRlc2NyaXB0aW9uIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIG1hdGNoaW5nIGZyYWdtZW50IGZyb20gdGhlIHRyYW5zYWN0aW9uIGBgZGF0YWBgLlxuICAgICAqL1xuICAgIGZyYWdtZW50O1xuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgRnVuY3Rpb24gZnJvbSB0aGUgdHJhbnNhY3Rpb24gYGBkYXRhYGAuXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIEZ1bmN0aW9uIGZyb20gdGhlIHRyYW5zYWN0aW9uIGBgZGF0YWBgLlxuICAgICAqL1xuICAgIGFyZ3M7XG4gICAgLyoqXG4gICAgICogIFRoZSBmdWxsIEZ1bmN0aW9uIHNpZ25hdHVyZSBmcm9tIHRoZSB0cmFuc2FjdGlvbiBgYGRhdGFgYC5cbiAgICAgKi9cbiAgICBzaWduYXR1cmU7XG4gICAgLyoqXG4gICAgICogIFRoZSBzZWxlY3RvciBmb3IgdGhlIEZ1bmN0aW9uIGZyb20gdGhlIHRyYW5zYWN0aW9uIGBgZGF0YWBgLlxuICAgICAqL1xuICAgIHNlbGVjdG9yO1xuICAgIC8qKlxuICAgICAqICBUaGUgYGB2YWx1ZWBgIChpbiB3ZWkpIGZyb20gdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIHZhbHVlO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudCwgc2VsZWN0b3IsIGFyZ3MsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBmcmFnbWVudC5uYW1lLCBzaWduYXR1cmUgPSBmcmFnbWVudC5mb3JtYXQoKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBmcmFnbWVudCwgbmFtZSwgYXJncywgc2lnbmF0dXJlLCBzZWxlY3RvciwgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiAgV2hlbiB1c2luZyB0aGUgW1tJbnRlcmZhY2UtcGFyc2VFcnJvcl1dIHRvIGF1dG9tYXRpY2FsbHkgbWF0Y2ggYW5cbiAqICBlcnJvciBmb3IgYSBjYWxsIHJlc3VsdCBmb3IgcGFyc2luZywgYW4gKipFcnJvckRlc2NyaXB0aW9uKiogaXMgcmV0dXJuZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBFcnJvckRlc2NyaXB0aW9uIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIG1hdGNoaW5nIGZyYWdtZW50LlxuICAgICAqL1xuICAgIGZyYWdtZW50O1xuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgRXJyb3IuXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIEVycm9yIHdpdGggYGByZXZlcnRgYC5cbiAgICAgKi9cbiAgICBhcmdzO1xuICAgIC8qKlxuICAgICAqICBUaGUgZnVsbCBFcnJvciBzaWduYXR1cmUuXG4gICAgICovXG4gICAgc2lnbmF0dXJlO1xuICAgIC8qKlxuICAgICAqICBUaGUgc2VsZWN0b3IgZm9yIHRoZSBFcnJvci5cbiAgICAgKi9cbiAgICBzZWxlY3RvcjtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnQsIHNlbGVjdG9yLCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBmcmFnbWVudC5uYW1lLCBzaWduYXR1cmUgPSBmcmFnbWVudC5mb3JtYXQoKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBmcmFnbWVudCwgbmFtZSwgYXJncywgc2lnbmF0dXJlLCBzZWxlY3RvclxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqICBBbiAqKkluZGV4ZWQqKiBpcyB1c2VkIGFzIGEgdmFsdWUgd2hlbiBhIHZhbHVlIHRoYXQgZG9lcyBub3RcbiAqICBmaXQgd2l0aGluIGEgdG9waWMgKGkuZS4gbm90IGEgZml4ZWQtbGVuZ3RoLCAzMi1ieXRlIHR5cGUpLiBJdFxuICogIGlzIHRoZSBgYGtlY2NhazI1NmBgIG9mIHRoZSB2YWx1ZSwgYW5kIHVzZWQgZm9yIHR5cGVzIHN1Y2ggYXNcbiAqICBhcnJheXMsIHR1cGxlcywgYnl0ZXMgYW5kIHN0cmluZ3MuXG4gKi9cbmV4cG9ydCBjbGFzcyBJbmRleGVkIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGBga2VjY2FrMjU2YGAgb2YgdGhlIHZhbHVlIGxvZ2dlZC5cbiAgICAgKi9cbiAgICBoYXNoO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBfaXNJbmRleGVkO1xuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGlmICUldmFsdWUlJSBpcyBhbiAqKkluZGV4ZWQqKi5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCBmb3IgcHJvcGVydHkgYWNjZXNzLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0luZGV4ZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc0luZGV4ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaGFzaCkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgaGFzaCwgX2lzSW5kZXhlZDogdHJ1ZSB9KTtcbiAgICB9XG59XG4vLyBodHRwczovL2RvY3Muc29saWRpdHlsYW5nLm9yZy9lbi92MC44LjEzL2NvbnRyb2wtc3RydWN0dXJlcy5odG1sP2hpZ2hsaWdodD1wYW5pYyNwYW5pYy12aWEtYXNzZXJ0LWFuZC1lcnJvci12aWEtcmVxdWlyZVxuY29uc3QgUGFuaWNSZWFzb25zID0ge1xuICAgIFwiMFwiOiBcImdlbmVyaWMgcGFuaWNcIixcbiAgICBcIjFcIjogXCJhc3NlcnQoZmFsc2UpXCIsXG4gICAgXCIxN1wiOiBcImFyaXRobWV0aWMgb3ZlcmZsb3dcIixcbiAgICBcIjE4XCI6IFwiZGl2aXNpb24gb3IgbW9kdWxvIGJ5IHplcm9cIixcbiAgICBcIjMzXCI6IFwiZW51bSBvdmVyZmxvd1wiLFxuICAgIFwiMzRcIjogXCJpbnZhbGlkIGVuY29kZWQgc3RvcmFnZSBieXRlIGFycmF5IGFjY2Vzc2VkXCIsXG4gICAgXCI0OVwiOiBcIm91dC1vZi1ib3VuZHMgYXJyYXkgYWNjZXNzOyBwb3BwaW5nIG9uIGFuIGVtcHR5IGFycmF5XCIsXG4gICAgXCI1MFwiOiBcIm91dC1vZi1ib3VuZHMgYWNjZXNzIG9mIGFuIGFycmF5IG9yIGJ5dGVzTlwiLFxuICAgIFwiNjVcIjogXCJvdXQgb2YgbWVtb3J5XCIsXG4gICAgXCI4MVwiOiBcInVuaW5pdGlhbGl6ZWQgZnVuY3Rpb25cIixcbn07XG5jb25zdCBCdWlsdGluRXJyb3JzID0ge1xuICAgIFwiMHgwOGMzNzlhMFwiOiB7XG4gICAgICAgIHNpZ25hdHVyZTogXCJFcnJvcihzdHJpbmcpXCIsXG4gICAgICAgIG5hbWU6IFwiRXJyb3JcIixcbiAgICAgICAgaW5wdXRzOiBbXCJzdHJpbmdcIl0sXG4gICAgICAgIHJlYXNvbjogKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBgcmV2ZXJ0ZWQgd2l0aCByZWFzb24gc3RyaW5nICR7SlNPTi5zdHJpbmdpZnkobWVzc2FnZSl9YDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCIweDRlNDg3YjcxXCI6IHtcbiAgICAgICAgc2lnbmF0dXJlOiBcIlBhbmljKHVpbnQyNTYpXCIsXG4gICAgICAgIG5hbWU6IFwiUGFuaWNcIixcbiAgICAgICAgaW5wdXRzOiBbXCJ1aW50MjU2XCJdLFxuICAgICAgICByZWFzb246IChjb2RlKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVhc29uID0gXCJ1bmtub3duIHBhbmljIGNvZGVcIjtcbiAgICAgICAgICAgIGlmIChjb2RlID49IDAgJiYgY29kZSA8PSAweGZmICYmIFBhbmljUmVhc29uc1tjb2RlLnRvU3RyaW5nKCldKSB7XG4gICAgICAgICAgICAgICAgcmVhc29uID0gUGFuaWNSZWFzb25zW2NvZGUudG9TdHJpbmcoKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYHJldmVydGVkIHdpdGggcGFuaWMgY29kZSAweCR7Y29kZS50b1N0cmluZygxNil9ICgke3JlYXNvbn0pYDtcbiAgICAgICAgfVxuICAgIH1cbn07XG4vKipcbiAqICBBbiBJbnRlcmZhY2UgYWJzdHJhY3RzIG1hbnkgb2YgdGhlIGxvdy1sZXZlbCBkZXRhaWxzIGZvclxuICogIGVuY29kaW5nIGFuZCBkZWNvZGluZyB0aGUgZGF0YSBvbiB0aGUgYmxvY2tjaGFpbi5cbiAqXG4gKiAgQW4gQUJJIHByb3ZpZGVzIGluZm9ybWF0aW9uIG9uIGhvdyB0byBlbmNvZGUgZGF0YSB0byBzZW5kIHRvXG4gKiAgYSBDb250cmFjdCwgaG93IHRvIGRlY29kZSB0aGUgcmVzdWx0cyBhbmQgZXZlbnRzIGFuZCBob3cgdG9cbiAqICBpbnRlcnByZXQgcmV2ZXJ0IGVycm9ycy5cbiAqXG4gKiAgVGhlIEFCSSBjYW4gYmUgc3BlY2lmaWVkIGJ5IFthbnkgc3VwcG9ydGVkIGZvcm1hdF0oSW50ZXJmYWNlQWJpKS5cbiAqL1xuZXhwb3J0IGNsYXNzIEludGVyZmFjZSB7XG4gICAgLyoqXG4gICAgICogIEFsbCB0aGUgQ29udHJhY3QgQUJJIG1lbWJlcnMgKGkuZS4gbWV0aG9kcywgZXZlbnRzLCBlcnJvcnMsIGV0YykuXG4gICAgICovXG4gICAgZnJhZ21lbnRzO1xuICAgIC8qKlxuICAgICAqICBUaGUgQ29udHJhY3QgY29uc3RydWN0b3IuXG4gICAgICovXG4gICAgZGVwbG95O1xuICAgIC8qKlxuICAgICAqICBUaGUgRmFsbGJhY2sgbWV0aG9kLCBpZiBhbnkuXG4gICAgICovXG4gICAgZmFsbGJhY2s7XG4gICAgLyoqXG4gICAgICogIElmIHJlY2VpdmluZyBldGhlciBpcyBzdXBwb3J0ZWQuXG4gICAgICovXG4gICAgcmVjZWl2ZTtcbiAgICAjZXJyb3JzO1xuICAgICNldmVudHM7XG4gICAgI2Z1bmN0aW9ucztcbiAgICAvLyAgICAjc3RydWN0czogTWFwPHN0cmluZywgU3RydWN0RnJhZ21lbnQ+O1xuICAgICNhYmlDb2RlcjtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3IEludGVyZmFjZSBmb3IgdGhlICUlZnJhZ21lbnRzJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnRzKSB7XG4gICAgICAgIGxldCBhYmkgPSBbXTtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnRzKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgYWJpID0gSlNPTi5wYXJzZShmcmFnbWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWJpID0gZnJhZ21lbnRzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2Z1bmN0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jZXJyb3JzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLiNldmVudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vICAgICAgICB0aGlzLiNzdHJ1Y3RzID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBmcmFncyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGEgb2YgYWJpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZyYWdzLnB1c2goRnJhZ21lbnQuZnJvbShhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW1dhcm5pbmddIEludmFsaWQgRnJhZ21lbnQgJHtKU09OLnN0cmluZ2lmeShhKX06YCwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBmcmFnbWVudHM6IE9iamVjdC5mcmVlemUoZnJhZ3MpXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgZmFsbGJhY2sgPSBudWxsO1xuICAgICAgICBsZXQgcmVjZWl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNhYmlDb2RlciA9IHRoaXMuZ2V0QWJpQ29kZXIoKTtcbiAgICAgICAgLy8gQWRkIGFsbCBmcmFnbWVudHMgYnkgdGhlaXIgc2lnbmF0dXJlXG4gICAgICAgIHRoaXMuZnJhZ21lbnRzLmZvckVhY2goKGZyYWdtZW50LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgbGV0IGJ1Y2tldDtcbiAgICAgICAgICAgIHN3aXRjaCAoZnJhZ21lbnQudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjb25zdHJ1Y3RvclwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZXBsb3kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZHVwbGljYXRlIGRlZmluaXRpb24gLSBjb25zdHJ1Y3RvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrTmFtZXMoZnJhZ21lbnQsIFwiaW5wdXRcIiwgZnJhZ21lbnQuaW5wdXRzKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGRlcGxveTogZnJhZ21lbnQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmFsbGJhY2tcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWdtZW50LmlucHV0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoIWZhbGxiYWNrIHx8IGZyYWdtZW50LnBheWFibGUgIT09IGZhbGxiYWNrLnBheWFibGUsIFwiY29uZmxpY3RpbmcgZmFsbGJhY2sgZnJhZ21lbnRzXCIsIGBmcmFnbWVudHNbJHtpbmRleH1dYCwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2sgPSBmcmFnbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmUgPSBmYWxsYmFjay5wYXlhYmxlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgLy9jaGVja05hbWVzKGZyYWdtZW50LCBcImlucHV0XCIsIGZyYWdtZW50LmlucHV0cyk7XG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2tOYW1lcyhmcmFnbWVudCwgXCJvdXRwdXRcIiwgKDxGdW5jdGlvbkZyYWdtZW50PmZyYWdtZW50KS5vdXRwdXRzKTtcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0ID0gdGhpcy4jZnVuY3Rpb25zO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXZlbnRcIjpcbiAgICAgICAgICAgICAgICAgICAgLy9jaGVja05hbWVzKGZyYWdtZW50LCBcImlucHV0XCIsIGZyYWdtZW50LmlucHV0cyk7XG4gICAgICAgICAgICAgICAgICAgIGJ1Y2tldCA9IHRoaXMuI2V2ZW50cztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgICAgICAgIGJ1Y2tldCA9IHRoaXMuI2Vycm9ycztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVHdvIGlkZW50aWNhbCBlbnRyaWVzOyBpZ25vcmUgaXRcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGZyYWdtZW50LmZvcm1hdCgpO1xuICAgICAgICAgICAgaWYgKGJ1Y2tldC5oYXMoc2lnbmF0dXJlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1Y2tldC5zZXQoc2lnbmF0dXJlLCBmcmFnbWVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBJZiB3ZSBkbyBub3QgaGF2ZSBhIGNvbnN0cnVjdG9yIGFkZCBhIGRlZmF1bHRcbiAgICAgICAgaWYgKCF0aGlzLmRlcGxveSkge1xuICAgICAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICAgICAgZGVwbG95OiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb20oXCJjb25zdHJ1Y3RvcigpXCIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgZmFsbGJhY2ssIHJlY2VpdmUgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBlbnRpcmUgSHVtYW4tUmVhZGFibGUgQUJJLCBhcyBhbiBhcnJheSBvZlxuICAgICAqICBzaWduYXR1cmVzLCBvcHRpb25hbGx5IGFzICUlbWluaW1hbCUlIHN0cmluZ3MsIHdoaWNoXG4gICAgICogIHJlbW92ZXMgcGFyYW1ldGVyIG5hbWVzIGFuZCB1bm5lY2Vlc2FyeSBzcGFjZXMuXG4gICAgICovXG4gICAgZm9ybWF0KG1pbmltYWwpIHtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gKG1pbmltYWwgPyBcIm1pbmltYWxcIiA6IFwiZnVsbFwiKTtcbiAgICAgICAgY29uc3QgYWJpID0gdGhpcy5mcmFnbWVudHMubWFwKChmKSA9PiBmLmZvcm1hdChmb3JtYXQpKTtcbiAgICAgICAgcmV0dXJuIGFiaTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgSlNPTi1lbmNvZGVkIEFCSS4gVGhpcyBpcyB0aGUgZm9ybWF0IFNvbGlkaXlcbiAgICAgKiAgcmV0dXJucy5cbiAgICAgKi9cbiAgICBmb3JtYXRKc29uKCkge1xuICAgICAgICBjb25zdCBhYmkgPSB0aGlzLmZyYWdtZW50cy5tYXAoKGYpID0+IGYuZm9ybWF0KFwianNvblwiKSk7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gcmUtYnVuZGxlIHRoZSBKU09OIGZyYWdtZW50cyBhIGJpdFxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYWJpLm1hcCgoaikgPT4gSlNPTi5wYXJzZShqKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIEFCSSBjb2RlciB0aGF0IHdpbGwgYmUgdXNlZCB0byBlbmNvZGUgYW5kIGRlY29kZSBiaW5hcnlcbiAgICAgKiAgZGF0YS5cbiAgICAgKi9cbiAgICBnZXRBYmlDb2RlcigpIHtcbiAgICAgICAgcmV0dXJuIEFiaUNvZGVyLmRlZmF1bHRBYmlDb2RlcigpO1xuICAgIH1cbiAgICAvLyBGaW5kIGEgZnVuY3Rpb24gZGVmaW5pdGlvbiBieSBhbnkgbWVhbnMgbmVjZXNzYXJ5ICh1bmxlc3MgaXQgaXMgYW1iaWd1b3VzKVxuICAgICNnZXRGdW5jdGlvbihrZXksIHZhbHVlcywgZm9yY2VVbmlxdWUpIHtcbiAgICAgICAgLy8gU2VsZWN0b3JcbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZyYWdtZW50IG9mIHRoaXMuI2Z1bmN0aW9ucy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RvciA9PT0gZnJhZ21lbnQuc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0IGlzIGEgYmFyZSBuYW1lLCBsb29rIHVwIHRoZSBmdW5jdGlvbiAod2lsbCByZXR1cm4gbnVsbCBpZiBhbWJpZ3VvdXMpXG4gICAgICAgIGlmIChrZXkuaW5kZXhPZihcIihcIikgPT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgZnJhZ21lbnRdIG9mIHRoaXMuI2Z1bmN0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lLnNwbGl0KFwiKFwiIC8qIGZpeDopICovKVswXSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnB1c2goZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0VmFsdWUgPSAodmFsdWVzLmxlbmd0aCA+IDApID8gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlTGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsZXQgYWxsb3dPcHRpb25zID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoVHlwZWQuaXNUeXBlZChsYXN0VmFsdWUpICYmIGxhc3RWYWx1ZS50eXBlID09PSBcIm92ZXJyaWRlc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3B0aW9ucyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZUxlbmd0aC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYWxsIG1hdGNoZXMgdGhhdCBkb24ndCBoYXZlIGEgY29tcGF0aWJsZSBsZW5ndGguIFRoZSBhcmdzXG4gICAgICAgICAgICAgICAgLy8gbWF5IGNvbnRhaW4gYW4gb3ZlcnJpZGVzLCBzbyB0aGUgbWF0Y2ggbWF5IGhhdmUgbiBvciBuIC0gMSBwYXJhbWV0ZXJzXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IG1hdGNoaW5nLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IG1hdGNoaW5nW2ldLmlucHV0cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dHMgIT09IHZhbHVlTGVuZ3RoICYmICghYWxsb3dPcHRpb25zIHx8IGlucHV0cyAhPT0gdmFsdWVMZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgbWF0Y2hlcyB0aGF0IGRvbid0IG1hdGNoIHRoZSBUeXBlZCBzaWduYXR1cmVcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbWF0Y2hpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gbWF0Y2hpbmdbaV0uaW5wdXRzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbHVlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90IGEgdHlwZWQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghVHlwZWQuaXNUeXBlZCh2YWx1ZXNbal0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBhcmUgcGFzdCB0aGUgaW5wdXRzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaiA+PSBpbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlc1tqXS50eXBlID09PSBcIm92ZXJyaWRlc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHZhbHVlIHR5cGUgbWF0Y2hlcyB0aGUgaW5wdXQgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlc1tqXS50eXBlICE9PSBpbnB1dHNbal0uYmFzZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSBmb3VuZCBhIHNpbmdsZSBtYXRjaGluZyBzaWduYXR1cmUgd2l0aCBhbiBvdmVycmlkZXMsIGJ1dCB0aGVcbiAgICAgICAgICAgIC8vIGxhc3QgdmFsdWUgaXMgc29tZXRoaW5nIHRoYXQgY2Fubm90IHBvc3NpYmx5IGJlIGFuIG9wdGlvbnNcbiAgICAgICAgICAgIGlmIChtYXRjaGluZy5sZW5ndGggPT09IDEgJiYgdmFsdWVzICYmIHZhbHVlcy5sZW5ndGggIT09IG1hdGNoaW5nWzBdLmlucHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0QXJnID0gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdEFyZyA9PSBudWxsIHx8IEFycmF5LmlzQXJyYXkobGFzdEFyZykgfHwgdHlwZW9mIChsYXN0QXJnKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoMCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA+IDEgJiYgZm9yY2VVbmlxdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaFN0ciA9IG1hdGNoaW5nLm1hcCgobSkgPT4gSlNPTi5zdHJpbmdpZnkobS5mb3JtYXQoKSkpLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGFtYmlndW91cyBmdW5jdGlvbiBkZXNjcmlwdGlvbiAoaS5lLiBtYXRjaGVzICR7bWF0Y2hTdHJ9KWAsIFwia2V5XCIsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hpbmdbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBzaWduYXR1cmUgYW5kIGxvb2t1cCB0aGUgZnVuY3Rpb25cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy4jZnVuY3Rpb25zLmdldChGdW5jdGlvbkZyYWdtZW50LmZyb20oa2V5KS5mb3JtYXQoKSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIGZ1bmN0aW9uIG5hbWUgZm9yICUla2V5JSUsIHdoaWNoIG1heSBiZSBhIGZ1bmN0aW9uIHNlbGVjdG9yLFxuICAgICAqICBmdW5jdGlvbiBuYW1lIG9yIGZ1bmN0aW9uIHNpZ25hdHVyZSB0aGF0IGJlbG9uZ3MgdG8gdGhlIEFCSS5cbiAgICAgKi9cbiAgICBnZXRGdW5jdGlvbk5hbWUoa2V5KSB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy4jZ2V0RnVuY3Rpb24oa2V5LCBudWxsLCBmYWxzZSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGZ1bmN0aW9uXCIsIFwia2V5XCIsIGtleSk7XG4gICAgICAgIHJldHVybiBmcmFnbWVudC5uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUla2V5JSUgKGEgZnVuY3Rpb24gc2VsZWN0b3IsIGZ1bmN0aW9uIG5hbWUgb3JcbiAgICAgKiAgZnVuY3Rpb24gc2lnbmF0dXJlKSBpcyBwcmVzZW50IGluIHRoZSBBQkkuXG4gICAgICpcbiAgICAgKiAgSW4gdGhlIGNhc2Ugb2YgYSBmdW5jdGlvbiBuYW1lLCB0aGUgbmFtZSBtYXkgYmUgYW1iaWd1b3VzLCBzb1xuICAgICAqICBhY2Nlc3NpbmcgdGhlIFtbRnVuY3Rpb25GcmFnbWVudF1dIG1heSByZXF1aXJlIHJlZmluZW1lbnQuXG4gICAgICovXG4gICAgaGFzRnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuI2dldEZ1bmN0aW9uKGtleSwgbnVsbCwgZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSBbW0Z1bmN0aW9uRnJhZ21lbnRdXSBmb3IgJSVrZXklJSwgd2hpY2ggbWF5IGJlIGEgZnVuY3Rpb25cbiAgICAgKiAgc2VsZWN0b3IsIGZ1bmN0aW9uIG5hbWUgb3IgZnVuY3Rpb24gc2lnbmF0dXJlIHRoYXQgYmVsb25ncyB0byB0aGUgQUJJLlxuICAgICAqXG4gICAgICogIElmICUldmFsdWVzJSUgaXMgcHJvdmlkZWQsIGl0IHdpbGwgdXNlIHRoZSBUeXBlZCBBUEkgdG8gaGFuZGxlXG4gICAgICogIGFtYmlndW91cyBjYXNlcyB3aGVyZSBtdWx0aXBsZSBmdW5jdGlvbnMgbWF0Y2ggYnkgbmFtZS5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgJSVrZXklJSBhbmQgJSV2YWx1ZXMlJSBkbyBub3QgcmVmaW5lIHRvIGEgc2luZ2xlIGZ1bmN0aW9uIGluXG4gICAgICogIHRoZSBBQkksIHRoaXMgd2lsbCB0aHJvdy5cbiAgICAgKi9cbiAgICBnZXRGdW5jdGlvbihrZXksIHZhbHVlcykge1xuICAgICAgICByZXR1cm4gdGhpcy4jZ2V0RnVuY3Rpb24oa2V5LCB2YWx1ZXMgfHwgbnVsbCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJdGVyYXRlIG92ZXIgYWxsIGZ1bmN0aW9ucywgY2FsbGluZyAlJWNhbGxiYWNrJSUsIHNvcnRlZCBieSB0aGVpciBuYW1lLlxuICAgICAqL1xuICAgIGZvckVhY2hGdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBuYW1lcyA9IEFycmF5LmZyb20odGhpcy4jZnVuY3Rpb25zLmtleXMoKSk7XG4gICAgICAgIG5hbWVzLnNvcnQoKGEsIGIpID0+IGEubG9jYWxlQ29tcGFyZShiKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCh0aGlzLiNmdW5jdGlvbnMuZ2V0KG5hbWUpKSwgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRmluZCBhbiBldmVudCBkZWZpbml0aW9uIGJ5IGFueSBtZWFucyBuZWNlc3NhcnkgKHVubGVzcyBpdCBpcyBhbWJpZ3VvdXMpXG4gICAgI2dldEV2ZW50KGtleSwgdmFsdWVzLCBmb3JjZVVuaXF1ZSkge1xuICAgICAgICAvLyBFdmVudFRvcGljXG4gICAgICAgIGlmIChpc0hleFN0cmluZyhrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCBldmVudFRvcGljID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZyYWdtZW50IG9mIHRoaXMuI2V2ZW50cy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudFRvcGljID09PSBmcmFnbWVudC50b3BpY0hhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0IGlzIGEgYmFyZSBuYW1lLCBsb29rIHVwIHRoZSBmdW5jdGlvbiAod2lsbCByZXR1cm4gbnVsbCBpZiBhbWJpZ3VvdXMpXG4gICAgICAgIGlmIChrZXkuaW5kZXhPZihcIihcIikgPT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgZnJhZ21lbnRdIG9mIHRoaXMuI2V2ZW50cykge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lLnNwbGl0KFwiKFwiIC8qIGZpeDopICovKVswXSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnB1c2goZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYWxsIG1hdGNoZXMgdGhhdCBkb24ndCBoYXZlIGEgY29tcGF0aWJsZSBsZW5ndGguXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IG1hdGNoaW5nLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGluZ1tpXS5pbnB1dHMubGVuZ3RoIDwgdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgbWF0Y2hlcyB0aGF0IGRvbid0IG1hdGNoIHRoZSBUeXBlZCBzaWduYXR1cmVcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbWF0Y2hpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gbWF0Y2hpbmdbaV0uaW5wdXRzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbHVlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90IGEgdHlwZWQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghVHlwZWQuaXNUeXBlZCh2YWx1ZXNbal0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHZhbHVlIHR5cGUgbWF0Y2hlcyB0aGUgaW5wdXQgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlc1tqXS50eXBlICE9PSBpbnB1dHNbal0uYmFzZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoID4gMSAmJiBmb3JjZVVuaXF1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoU3RyID0gbWF0Y2hpbmcubWFwKChtKSA9PiBKU09OLnN0cmluZ2lmeShtLmZvcm1hdCgpKSkuam9pbihcIiwgXCIpO1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgYW1iaWd1b3VzIGV2ZW50IGRlc2NyaXB0aW9uIChpLmUuIG1hdGNoZXMgJHttYXRjaFN0cn0pYCwgXCJrZXlcIiwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGluZ1swXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIHNpZ25hdHVyZSBhbmQgbG9va3VwIHRoZSBmdW5jdGlvblxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNldmVudHMuZ2V0KEV2ZW50RnJhZ21lbnQuZnJvbShrZXkpLmZvcm1hdCgpKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgZXZlbnQgbmFtZSBmb3IgJSVrZXklJSwgd2hpY2ggbWF5IGJlIGEgdG9waWMgaGFzaCxcbiAgICAgKiAgZXZlbnQgbmFtZSBvciBldmVudCBzaWduYXR1cmUgdGhhdCBiZWxvbmdzIHRvIHRoZSBBQkkuXG4gICAgICovXG4gICAgZ2V0RXZlbnROYW1lKGtleSkge1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuI2dldEV2ZW50KGtleSwgbnVsbCwgZmFsc2UpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChmcmFnbWVudCwgXCJubyBtYXRjaGluZyBldmVudFwiLCBcImtleVwiLCBrZXkpO1xuICAgICAgICByZXR1cm4gZnJhZ21lbnQubmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJWtleSUlIChhbiBldmVudCB0b3BpYyBoYXNoLCBldmVudCBuYW1lIG9yXG4gICAgICogIGV2ZW50IHNpZ25hdHVyZSkgaXMgcHJlc2VudCBpbiB0aGUgQUJJLlxuICAgICAqXG4gICAgICogIEluIHRoZSBjYXNlIG9mIGFuIGV2ZW50IG5hbWUsIHRoZSBuYW1lIG1heSBiZSBhbWJpZ3VvdXMsIHNvXG4gICAgICogIGFjY2Vzc2luZyB0aGUgW1tFdmVudEZyYWdtZW50XV0gbWF5IHJlcXVpcmUgcmVmaW5lbWVudC5cbiAgICAgKi9cbiAgICBoYXNFdmVudChrZXkpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy4jZ2V0RXZlbnQoa2V5LCBudWxsLCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIFtbRXZlbnRGcmFnbWVudF1dIGZvciAlJWtleSUlLCB3aGljaCBtYXkgYmUgYSB0b3BpYyBoYXNoLFxuICAgICAqICBldmVudCBuYW1lIG9yIGV2ZW50IHNpZ25hdHVyZSB0aGF0IGJlbG9uZ3MgdG8gdGhlIEFCSS5cbiAgICAgKlxuICAgICAqICBJZiAlJXZhbHVlcyUlIGlzIHByb3ZpZGVkLCBpdCB3aWxsIHVzZSB0aGUgVHlwZWQgQVBJIHRvIGhhbmRsZVxuICAgICAqICBhbWJpZ3VvdXMgY2FzZXMgd2hlcmUgbXVsdGlwbGUgZXZlbnRzIG1hdGNoIGJ5IG5hbWUuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlICUla2V5JSUgYW5kICUldmFsdWVzJSUgZG8gbm90IHJlZmluZSB0byBhIHNpbmdsZSBldmVudCBpblxuICAgICAqICB0aGUgQUJJLCB0aGlzIHdpbGwgdGhyb3cuXG4gICAgICovXG4gICAgZ2V0RXZlbnQoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2dldEV2ZW50KGtleSwgdmFsdWVzIHx8IG51bGwsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSXRlcmF0ZSBvdmVyIGFsbCBldmVudHMsIGNhbGxpbmcgJSVjYWxsYmFjayUlLCBzb3J0ZWQgYnkgdGhlaXIgbmFtZS5cbiAgICAgKi9cbiAgICBmb3JFYWNoRXZlbnQoY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSBBcnJheS5mcm9tKHRoaXMuI2V2ZW50cy5rZXlzKCkpO1xuICAgICAgICBuYW1lcy5zb3J0KChhLCBiKSA9PiBhLmxvY2FsZUNvbXBhcmUoYikpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgICAgICBjYWxsYmFjaygodGhpcy4jZXZlbnRzLmdldChuYW1lKSksIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIFtbRXJyb3JGcmFnbWVudF1dIGZvciAlJWtleSUlLCB3aGljaCBtYXkgYmUgYW4gZXJyb3JcbiAgICAgKiAgc2VsZWN0b3IsIGVycm9yIG5hbWUgb3IgZXJyb3Igc2lnbmF0dXJlIHRoYXQgYmVsb25ncyB0byB0aGUgQUJJLlxuICAgICAqXG4gICAgICogIElmICUldmFsdWVzJSUgaXMgcHJvdmlkZWQsIGl0IHdpbGwgdXNlIHRoZSBUeXBlZCBBUEkgdG8gaGFuZGxlXG4gICAgICogIGFtYmlndW91cyBjYXNlcyB3aGVyZSBtdWx0aXBsZSBlcnJvcnMgbWF0Y2ggYnkgbmFtZS5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgJSVrZXklJSBhbmQgJSV2YWx1ZXMlJSBkbyBub3QgcmVmaW5lIHRvIGEgc2luZ2xlIGVycm9yIGluXG4gICAgICogIHRoZSBBQkksIHRoaXMgd2lsbCB0aHJvdy5cbiAgICAgKi9cbiAgICBnZXRFcnJvcihrZXksIHZhbHVlcykge1xuICAgICAgICBpZiAoaXNIZXhTdHJpbmcoa2V5KSkge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChCdWlsdGluRXJyb3JzW3NlbGVjdG9yXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb20oQnVpbHRpbkVycm9yc1tzZWxlY3Rvcl0uc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgZnJhZ21lbnQgb2YgdGhpcy4jZXJyb3JzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yID09PSBmcmFnbWVudC5zZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXQgaXMgYSBiYXJlIG5hbWUsIGxvb2sgdXAgdGhlIGZ1bmN0aW9uICh3aWxsIHJldHVybiBudWxsIGlmIGFtYmlndW91cylcbiAgICAgICAgaWYgKGtleS5pbmRleE9mKFwiKFwiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBmcmFnbWVudF0gb2YgdGhpcy4jZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUuc3BsaXQoXCIoXCIgLyogZml4OikgKi8pWzBdID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcucHVzaChmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwiRXJyb3JcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tKFwiZXJyb3IgRXJyb3Ioc3RyaW5nKVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJQYW5pY1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb20oXCJlcnJvciBQYW5pYyh1aW50MjU2KVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtYXRjaGluZy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hTdHIgPSBtYXRjaGluZy5tYXAoKG0pID0+IEpTT04uc3RyaW5naWZ5KG0uZm9ybWF0KCkpKS5qb2luKFwiLCBcIik7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBhbWJpZ3VvdXMgZXJyb3IgZGVzY3JpcHRpb24gKGkuZS4gJHttYXRjaFN0cn0pYCwgXCJuYW1lXCIsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hpbmdbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBzaWduYXR1cmUgYW5kIGxvb2t1cCB0aGUgZnVuY3Rpb25cbiAgICAgICAga2V5ID0gRXJyb3JGcmFnbWVudC5mcm9tKGtleSkuZm9ybWF0KCk7XG4gICAgICAgIGlmIChrZXkgPT09IFwiRXJyb3Ioc3RyaW5nKVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tKFwiZXJyb3IgRXJyb3Ioc3RyaW5nKVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5ID09PSBcIlBhbmljKHVpbnQyNTYpXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb20oXCJlcnJvciBQYW5pYyh1aW50MjU2KVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNlcnJvcnMuZ2V0KGtleSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJdGVyYXRlIG92ZXIgYWxsIGVycm9ycywgY2FsbGluZyAlJWNhbGxiYWNrJSUsIHNvcnRlZCBieSB0aGVpciBuYW1lLlxuICAgICAqL1xuICAgIGZvckVhY2hFcnJvcihjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBuYW1lcyA9IEFycmF5LmZyb20odGhpcy4jZXJyb3JzLmtleXMoKSk7XG4gICAgICAgIG5hbWVzLnNvcnQoKGEsIGIpID0+IGEubG9jYWxlQ29tcGFyZShiKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCh0aGlzLiNlcnJvcnMuZ2V0KG5hbWUpKSwgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gR2V0IHRoZSA0LWJ5dGUgc2VsZWN0b3IgdXNlZCBieSBTb2xpZGl0eSB0byBpZGVudGlmeSBhIGZ1bmN0aW9uXG4gICAgLypcbmdldFNlbGVjdG9yKGZyYWdtZW50OiBFcnJvckZyYWdtZW50IHwgRnVuY3Rpb25GcmFnbWVudCk6IHN0cmluZyB7XG4gICAgaWYgKHR5cGVvZihmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlczogQXJyYXk8RnJhZ21lbnQ+ID0gWyBdO1xuXG4gICAgICAgIHRyeSB7IG1hdGNoZXMucHVzaCh0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KSk7IH0gY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgdHJ5IHsgbWF0Y2hlcy5wdXNoKHRoaXMuZ2V0RXJyb3IoPHN0cmluZz5mcmFnbWVudCkpOyB9IGNhdGNoIChfKSB7IH1cblxuICAgICAgICBpZiAobWF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bmtub3duIGZyYWdtZW50XCIsIFwia2V5XCIsIGZyYWdtZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJhbWJpZ3VvdXMgZnJhZ21lbnQgbWF0Y2hlcyBmdW5jdGlvbiBhbmQgZXJyb3JcIiwgXCJrZXlcIiwgZnJhZ21lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnJhZ21lbnQgPSBtYXRjaGVzWzBdO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhU2xpY2UoaWQoZnJhZ21lbnQuZm9ybWF0KCkpLCAwLCA0KTtcbn1cbiAgICAqL1xuICAgIC8vIEdldCB0aGUgMzItYnl0ZSB0b3BpYyBoYXNoIHVzZWQgYnkgU29saWRpdHkgdG8gaWRlbnRpZnkgYW4gZXZlbnRcbiAgICAvKlxuICAgIGdldEV2ZW50VG9waWMoZnJhZ21lbnQ6IEV2ZW50RnJhZ21lbnQpOiBzdHJpbmcge1xuICAgICAgICAvL2lmICh0eXBlb2YoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7IGZyYWdtZW50ID0gdGhpcy5nZXRFdmVudChldmVudEZyYWdtZW50KTsgfVxuICAgICAgICByZXR1cm4gaWQoZnJhZ21lbnQuZm9ybWF0KCkpO1xuICAgIH1cbiAgICAqL1xuICAgIF9kZWNvZGVQYXJhbXMocGFyYW1zLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNhYmlDb2Rlci5kZWNvZGUocGFyYW1zLCBkYXRhKTtcbiAgICB9XG4gICAgX2VuY29kZVBhcmFtcyhwYXJhbXMsIHZhbHVlcykge1xuICAgICAgICByZXR1cm4gdGhpcy4jYWJpQ29kZXIuZW5jb2RlKHBhcmFtcywgdmFsdWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEVuY29kZXMgYSBgYHR4LmRhdGFgYCBvYmplY3QgZm9yIGRlcGxveWluZyB0aGUgQ29udHJhY3Qgd2l0aFxuICAgICAqICB0aGUgJSV2YWx1ZXMlJSBhcyB0aGUgY29uc3RydWN0b3IgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGVuY29kZURlcGxveSh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuY29kZVBhcmFtcyh0aGlzLmRlcGxveS5pbnB1dHMsIHZhbHVlcyB8fCBbXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBEZWNvZGVzIHRoZSByZXN1bHQgJSVkYXRhJSUgKGUuZy4gZnJvbSBhbiBgYGV0aF9jYWxsYGApIGZvciB0aGVcbiAgICAgKiAgc3BlY2lmaWVkIGVycm9yIChzZWUgW1tnZXRFcnJvcl1dIGZvciB2YWxpZCB2YWx1ZXMgZm9yXG4gICAgICogICUla2V5JSUpLlxuICAgICAqXG4gICAgICogIE1vc3QgZGV2ZWxvcGVycyBzaG91bGQgcHJlZmVyIHRoZSBbW3BhcnNlQ2FsbFJlc3VsdF1dIG1ldGhvZCBpbnN0ZWFkLFxuICAgICAqICB3aGljaCB3aWxsIGF1dG9tYXRpY2FsbHkgZGV0ZWN0IGEgYGBDQUxMX0VYQ0VQVElPTmBgIGFuZCB0aHJvdyB0aGVcbiAgICAgKiAgY29ycmVzcG9uZGluZyBlcnJvci5cbiAgICAgKi9cbiAgICBkZWNvZGVFcnJvclJlc3VsdChmcmFnbWVudCwgZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEVycm9yKGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBlcnJvclwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhU2xpY2UoZGF0YSwgMCwgNCkgPT09IGZyYWdtZW50LnNlbGVjdG9yLCBgZGF0YSBzaWduYXR1cmUgZG9lcyBub3QgbWF0Y2ggZXJyb3IgJHtmcmFnbWVudC5uYW1lfS5gLCBcImRhdGFcIiwgZGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVQYXJhbXMoZnJhZ21lbnQuaW5wdXRzLCBkYXRhU2xpY2UoZGF0YSwgNCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRW5jb2RlcyB0aGUgdHJhbnNhY3Rpb24gcmV2ZXJ0IGRhdGEgZm9yIGEgY2FsbCByZXN1bHQgdGhhdFxuICAgICAqICByZXZlcnRlZCBmcm9tIHRoZSB0aGUgQ29udHJhY3Qgd2l0aCB0aGUgc2VwY2lmaWVkICUlZXJyb3IlJVxuICAgICAqICAoc2VlIFtbZ2V0RXJyb3JdXSBmb3IgdmFsaWQgdmFsdWVzIGZvciAlJWZyYWdtZW50JSUpIHdpdGggdGhlICUldmFsdWVzJSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBnZW5lcmFsbHkgbm90IHVzZWQgYnkgbW9zdCBkZXZlbG9wZXJzLCB1bmxlc3MgdHJ5aW5nIHRvIG1vY2tcbiAgICAgKiAgYSByZXN1bHQgZnJvbSBhIENvbnRyYWN0LlxuICAgICAqL1xuICAgIGVuY29kZUVycm9yUmVzdWx0KGZyYWdtZW50LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRFcnJvcihmcmFnbWVudCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmLCBcInVua25vd24gZXJyb3JcIiwgXCJmcmFnbWVudFwiLCBmcmFnbWVudCk7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbmNhdChbXG4gICAgICAgICAgICBmcmFnbWVudC5zZWxlY3RvcixcbiAgICAgICAgICAgIHRoaXMuX2VuY29kZVBhcmFtcyhmcmFnbWVudC5pbnB1dHMsIHZhbHVlcyB8fCBbXSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBEZWNvZGVzIHRoZSAlJWRhdGElJSBmcm9tIGEgdHJhbnNhY3Rpb24gYGB0eC5kYXRhYGAgZm9yXG4gICAgICogIHRoZSBmdW5jdGlvbiBzcGVjaWZpZWQgKHNlZSBbW2dldEZ1bmN0aW9uXV0gZm9yIHZhbGlkIHZhbHVlc1xuICAgICAqICBmb3IgJSVmcmFnbWVudCUlKS5cbiAgICAgKlxuICAgICAqICBNb3N0IGRldmVsb3BlcnMgc2hvdWxkIHByZWZlciB0aGUgW1twYXJzZVRyYW5zYWN0aW9uXV0gbWV0aG9kXG4gICAgICogIGluc3RlYWQsIHdoaWNoIHdpbGwgYXV0b21hdGljYWxseSBkZXRlY3QgdGhlIGZyYWdtZW50LlxuICAgICAqL1xuICAgIGRlY29kZUZ1bmN0aW9uRGF0YShmcmFnbWVudCwgZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBmdW5jdGlvblwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhU2xpY2UoZGF0YSwgMCwgNCkgPT09IGZyYWdtZW50LnNlbGVjdG9yLCBgZGF0YSBzaWduYXR1cmUgZG9lcyBub3QgbWF0Y2ggZnVuY3Rpb24gJHtmcmFnbWVudC5uYW1lfS5gLCBcImRhdGFcIiwgZGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVQYXJhbXMoZnJhZ21lbnQuaW5wdXRzLCBkYXRhU2xpY2UoZGF0YSwgNCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRW5jb2RlcyB0aGUgYGB0eC5kYXRhYGAgZm9yIGEgdHJhbnNhY3Rpb24gdGhhdCBjYWxscyB0aGUgZnVuY3Rpb25cbiAgICAgKiAgc3BlY2lmaWVkIChzZWUgW1tnZXRGdW5jdGlvbl1dIGZvciB2YWxpZCB2YWx1ZXMgZm9yICUlZnJhZ21lbnQlJSkgd2l0aFxuICAgICAqICB0aGUgJSV2YWx1ZXMlJS5cbiAgICAgKi9cbiAgICBlbmNvZGVGdW5jdGlvbkRhdGEoZnJhZ21lbnQsIHZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBmdW5jdGlvblwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uY2F0KFtcbiAgICAgICAgICAgIGZyYWdtZW50LnNlbGVjdG9yLFxuICAgICAgICAgICAgdGhpcy5fZW5jb2RlUGFyYW1zKGZyYWdtZW50LmlucHV0cywgdmFsdWVzIHx8IFtdKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIERlY29kZXMgdGhlIHJlc3VsdCAlJWRhdGElJSAoZS5nLiBmcm9tIGFuIGBgZXRoX2NhbGxgYCkgZm9yIHRoZVxuICAgICAqICBzcGVjaWZpZWQgZnVuY3Rpb24gKHNlZSBbW2dldEZ1bmN0aW9uXV0gZm9yIHZhbGlkIHZhbHVlcyBmb3JcbiAgICAgKiAgJSVrZXklJSkuXG4gICAgICpcbiAgICAgKiAgTW9zdCBkZXZlbG9wZXJzIHNob3VsZCBwcmVmZXIgdGhlIFtbcGFyc2VDYWxsUmVzdWx0XV0gbWV0aG9kIGluc3RlYWQsXG4gICAgICogIHdoaWNoIHdpbGwgYXV0b21hdGljYWxseSBkZXRlY3QgYSBgYENBTExfRVhDRVBUSU9OYGAgYW5kIHRocm93IHRoZVxuICAgICAqICBjb3JyZXNwb25kaW5nIGVycm9yLlxuICAgICAqL1xuICAgIGRlY29kZUZ1bmN0aW9uUmVzdWx0KGZyYWdtZW50LCBkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RnVuY3Rpb24oZnJhZ21lbnQpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZiwgXCJ1bmtub3duIGZ1bmN0aW9uXCIsIFwiZnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtZXNzYWdlID0gXCJpbnZhbGlkIGxlbmd0aCBmb3IgcmVzdWx0IGRhdGFcIjtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlc0NvcHkoZGF0YSk7XG4gICAgICAgIGlmICgoYnl0ZXMubGVuZ3RoICUgMzIpID09PSAwKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiNhYmlDb2Rlci5kZWNvZGUoZnJhZ21lbnQub3V0cHV0cywgYnl0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiY291bGQgbm90IGRlY29kZSByZXN1bHQgZGF0YVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENhbGwgcmV0dXJuZWQgZGF0YSB3aXRoIG5vIGVycm9yLCBidXQgdGhlIGRhdGEgaXMganVua1xuICAgICAgICBhc3NlcnQoZmFsc2UsIG1lc3NhZ2UsIFwiQkFEX0RBVEFcIiwge1xuICAgICAgICAgICAgdmFsdWU6IGhleGxpZnkoYnl0ZXMpLFxuICAgICAgICAgICAgaW5mbzogeyBtZXRob2Q6IGZyYWdtZW50Lm5hbWUsIHNpZ25hdHVyZTogZnJhZ21lbnQuZm9ybWF0KCkgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWFrZUVycm9yKF9kYXRhLCB0eCkge1xuICAgICAgICBjb25zdCBkYXRhID0gZ2V0Qnl0ZXMoX2RhdGEsIFwiZGF0YVwiKTtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBBYmlDb2Rlci5nZXRCdWlsdGluQ2FsbEV4Y2VwdGlvbihcImNhbGxcIiwgdHgsIGRhdGEpO1xuICAgICAgICAvLyBOb3QgYSBidWlsdC1pbiBlcnJvcjsgdHJ5IGZpbmRpbmcgYSBjdXN0b20gZXJyb3JcbiAgICAgICAgY29uc3QgY3VzdG9tUHJlZml4ID0gXCJleGVjdXRpb24gcmV2ZXJ0ZWQgKHVua25vd24gY3VzdG9tIGVycm9yKVwiO1xuICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKGN1c3RvbVByZWZpeCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0gaGV4bGlmeShkYXRhLnNsaWNlKDAsIDQpKTtcbiAgICAgICAgICAgIGNvbnN0IGVmID0gdGhpcy5nZXRFcnJvcihzZWxlY3Rvcik7XG4gICAgICAgICAgICBpZiAoZWYpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKGVmLmlucHV0cywgZGF0YS5zbGljZSg0KSk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLnJldmVydCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGVmLm5hbWUsIHNpZ25hdHVyZTogZWYuZm9ybWF0KCksIGFyZ3NcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IucmVhc29uID0gZXJyb3IucmV2ZXJ0LnNpZ25hdHVyZTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9IGBleGVjdXRpb24gcmV2ZXJ0ZWQ6ICR7ZXJyb3IucmVhc29ufWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPSBgZXhlY3V0aW9uIHJldmVydGVkIChjb3VsdCBub3QgZGVjb2RlIGN1c3RvbSBlcnJvcilgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGludm9jYXRpb24sIGlmIGF2YWlsYWJsZVxuICAgICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLnBhcnNlVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICBlcnJvci5pbnZvY2F0aW9uID0ge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogcGFyc2VkLm5hbWUsXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBwYXJzZWQuc2lnbmF0dXJlLFxuICAgICAgICAgICAgICAgIGFyZ3M6IHBhcnNlZC5hcmdzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEVuY29kZXMgdGhlIHJlc3VsdCBkYXRhIChlLmcuIGZyb20gYW4gYGBldGhfY2FsbGBgKSBmb3IgdGhlXG4gICAgICogIHNwZWNpZmllZCBmdW5jdGlvbiAoc2VlIFtbZ2V0RnVuY3Rpb25dXSBmb3IgdmFsaWQgdmFsdWVzXG4gICAgICogIGZvciAlJWZyYWdtZW50JSUpIHdpdGggJSV2YWx1ZXMlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIGdlbmVyYWxseSBub3QgdXNlZCBieSBtb3N0IGRldmVsb3BlcnMsIHVubGVzcyB0cnlpbmcgdG8gbW9ja1xuICAgICAqICBhIHJlc3VsdCBmcm9tIGEgQ29udHJhY3QuXG4gICAgICovXG4gICAgZW5jb2RlRnVuY3Rpb25SZXN1bHQoZnJhZ21lbnQsIHZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBmdW5jdGlvblwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGV4bGlmeSh0aGlzLiNhYmlDb2Rlci5lbmNvZGUoZnJhZ21lbnQub3V0cHV0cywgdmFsdWVzIHx8IFtdKSk7XG4gICAgfVxuICAgIC8qXG4gICAgICAgIHNwZWx1bmsoaW5wdXRzOiBBcnJheTxQYXJhbVR5cGU+LCB2YWx1ZXM6IFJlYWRvbmx5QXJyYXk8YW55PiwgcHJvY2Vzc2Z1bmM6ICh0eXBlOiBzdHJpbmcsIHZhbHVlOiBhbnkpID0+IFByb21pc2U8YW55Pik6IFByb21pc2U8QXJyYXk8YW55Pj4ge1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXM6IEFycmF5PFByb21pc2U8Pj4gPSBbIF07XG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzID0gZnVuY3Rpb24odHlwZTogUGFyYW1UeXBlLCB2YWx1ZTogYW55KTogYW55IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXNjZW5kKHR5cGUuY2hpbGRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUuID09PSBcImFkZHJlc3NcIikge1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgICAgICBjb25zdCBkZXNjZW5kID0gZnVuY3Rpb24gKGlucHV0czogQXJyYXk8UGFyYW1UeXBlPiwgdmFsdWVzOiBSZWFkb25seUFycmF5PGFueT4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRzLmxlbmd0aCAhPT0gdmFsdWVzLmxlbmd0aCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggbWlzbWF0Y2hcIik7IH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgICAgICBjb25zdCByZXN1bHQ6IEFycmF5PGFueT4gPSBbIF07XG4gICAgICAgICAgICB2YWx1ZXMuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiIHx8IHBhcmFtLmJhc2VUeXBlID09PSBcInR1cGxlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImZpbHRlcmluZyB3aXRoIHR1cGxlcyBvciBhcnJheXMgbm90IHN1cHBvcnRlZFwiLCAoXCJjb250cmFjdC5cIiArIHBhcmFtLm5hbWUpLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaCh2YWx1ZS5tYXAoKHZhbHVlKSA9PiBlbmNvZGVUb3BpYyhwYXJhbSwgdmFsdWUpKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2goZW5jb2RlVG9waWMocGFyYW0sIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAqL1xuICAgIC8vIENyZWF0ZSB0aGUgZmlsdGVyIGZvciB0aGUgZXZlbnQgd2l0aCBzZWFyY2ggY3JpdGVyaWEgKGUuZy4gZm9yIGV0aF9maWx0ZXJMb2cpXG4gICAgZW5jb2RlRmlsdGVyVG9waWNzKGZyYWdtZW50LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRFdmVudChmcmFnbWVudCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmLCBcInVua25vd24gZXZlbnRcIiwgXCJldmVudEZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQodmFsdWVzLmxlbmd0aCA8PSBmcmFnbWVudC5pbnB1dHMubGVuZ3RoLCBgdG9vIG1hbnkgYXJndW1lbnRzIGZvciAke2ZyYWdtZW50LmZvcm1hdCgpfWAsIFwiVU5FWFBFQ1RFRF9BUkdVTUVOVFwiLCB7IGNvdW50OiB2YWx1ZXMubGVuZ3RoLCBleHBlY3RlZENvdW50OiBmcmFnbWVudC5pbnB1dHMubGVuZ3RoIH0pO1xuICAgICAgICBjb25zdCB0b3BpY3MgPSBbXTtcbiAgICAgICAgaWYgKCFmcmFnbWVudC5hbm9ueW1vdXMpIHtcbiAgICAgICAgICAgIHRvcGljcy5wdXNoKGZyYWdtZW50LnRvcGljSGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQFRPRE86IFVzZSB0aGUgY29kZXJzIGZvciB0aGlzOyB0byBwcm9wZXJseSBzdXBwb3J0IHR1cGxlcywgZXRjLlxuICAgICAgICBjb25zdCBlbmNvZGVUb3BpYyA9IChwYXJhbSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLnR5cGUgPT09IFwiYnl0ZXNcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBrZWNjYWsyNTYoaGV4bGlmeSh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IFwiYm9vbFwiICYmIHR5cGVvZiAodmFsdWUpID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gKHZhbHVlID8gXCIweDAxXCIgOiBcIjB4MDBcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbS50eXBlLm1hdGNoKC9edT9pbnQvKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdG9CZUhleCh2YWx1ZSk7IC8vIEBUT0RPOiBTaG91bGQgdGhpcyB0b1R3b3M/P1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0udHlwZS5tYXRjaCgvXmJ5dGVzLykpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHplcm9QYWRCeXRlcyh2YWx1ZSwgMzIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0udHlwZSA9PT0gXCJhZGRyZXNzXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBhZGRyZXNzZXMgYXJlIHZhbGlkXG4gICAgICAgICAgICAgICAgdGhpcy4jYWJpQ29kZXIuZW5jb2RlKFtcImFkZHJlc3NcIl0sIFt2YWx1ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHplcm9QYWRWYWx1ZShoZXhsaWZ5KHZhbHVlKSwgMzIpO1xuICAgICAgICB9O1xuICAgICAgICB2YWx1ZXMuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbSA9IGZyYWdtZW50LmlucHV0c1tpbmRleF07XG4gICAgICAgICAgICBpZiAoIXBhcmFtLmluZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZSA9PSBudWxsLCBcImNhbm5vdCBmaWx0ZXIgbm9uLWluZGV4ZWQgcGFyYW1ldGVyczsgbXVzdCBiZSBudWxsXCIsIChcImNvbnRyYWN0LlwiICsgcGFyYW0ubmFtZSksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0uYmFzZVR5cGUgPT09IFwiYXJyYXlcIiB8fCBwYXJhbS5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiZmlsdGVyaW5nIHdpdGggdHVwbGVzIG9yIGFycmF5cyBub3Qgc3VwcG9ydGVkXCIsIChcImNvbnRyYWN0LlwiICsgcGFyYW0ubmFtZSksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdG9waWNzLnB1c2godmFsdWUubWFwKCh2YWx1ZSkgPT4gZW5jb2RlVG9waWMocGFyYW0sIHZhbHVlKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9waWNzLnB1c2goZW5jb2RlVG9waWMocGFyYW0sIHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUcmltIG9mZiB0cmFpbGluZyBudWxsc1xuICAgICAgICB3aGlsZSAodG9waWNzLmxlbmd0aCAmJiB0b3BpY3NbdG9waWNzLmxlbmd0aCAtIDFdID09PSBudWxsKSB7XG4gICAgICAgICAgICB0b3BpY3MucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvcGljcztcbiAgICB9XG4gICAgZW5jb2RlRXZlbnRMb2coZnJhZ21lbnQsIHZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEV2ZW50KGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBldmVudFwiLCBcImV2ZW50RnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvcGljcyA9IFtdO1xuICAgICAgICBjb25zdCBkYXRhVHlwZXMgPSBbXTtcbiAgICAgICAgY29uc3QgZGF0YVZhbHVlcyA9IFtdO1xuICAgICAgICBpZiAoIWZyYWdtZW50LmFub255bW91cykge1xuICAgICAgICAgICAgdG9waWNzLnB1c2goZnJhZ21lbnQudG9waWNIYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZXMubGVuZ3RoID09PSBmcmFnbWVudC5pbnB1dHMubGVuZ3RoLCBcImV2ZW50IGFyZ3VtZW50cy92YWx1ZXMgbWlzbWF0Y2hcIiwgXCJ2YWx1ZXNcIiwgdmFsdWVzKTtcbiAgICAgICAgZnJhZ21lbnQuaW5wdXRzLmZvckVhY2goKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHBhcmFtLmluZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChpZCh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbS50eXBlID09PSBcImJ5dGVzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2goa2VjY2FrMjU2KHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLmJhc2VUeXBlID09PSBcInR1cGxlXCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBAVE9ET1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaCh0aGlzLiNhYmlDb2Rlci5lbmNvZGUoW3BhcmFtLnR5cGVdLCBbdmFsdWVdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YVR5cGVzLnB1c2gocGFyYW0pO1xuICAgICAgICAgICAgICAgIGRhdGFWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogdGhpcy4jYWJpQ29kZXIuZW5jb2RlKGRhdGFUeXBlcywgZGF0YVZhbHVlcyksXG4gICAgICAgICAgICB0b3BpY3M6IHRvcGljc1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBEZWNvZGUgYSBmaWx0ZXIgZm9yIHRoZSBldmVudCBhbmQgdGhlIHNlYXJjaCBjcml0ZXJpYVxuICAgIGRlY29kZUV2ZW50TG9nKGZyYWdtZW50LCBkYXRhLCB0b3BpY3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRFdmVudChmcmFnbWVudCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmLCBcInVua25vd24gZXZlbnRcIiwgXCJldmVudEZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9waWNzICE9IG51bGwgJiYgIWZyYWdtZW50LmFub255bW91cykge1xuICAgICAgICAgICAgY29uc3QgZXZlbnRUb3BpYyA9IGZyYWdtZW50LnRvcGljSGFzaDtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGlzSGV4U3RyaW5nKHRvcGljc1swXSwgMzIpICYmIHRvcGljc1swXS50b0xvd2VyQ2FzZSgpID09PSBldmVudFRvcGljLCBcImZyYWdtZW50L3RvcGljIG1pc21hdGNoXCIsIFwidG9waWNzWzBdXCIsIHRvcGljc1swXSk7XG4gICAgICAgICAgICB0b3BpY3MgPSB0b3BpY3Muc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kZXhlZCA9IFtdO1xuICAgICAgICBjb25zdCBub25JbmRleGVkID0gW107XG4gICAgICAgIGNvbnN0IGR5bmFtaWMgPSBbXTtcbiAgICAgICAgZnJhZ21lbnQuaW5wdXRzLmZvckVhY2goKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBhcmFtLmluZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBwYXJhbS50eXBlID09PSBcImJ5dGVzXCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwidHVwbGVcIiB8fCBwYXJhbS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ZWQucHVzaChQYXJhbVR5cGUuZnJvbSh7IHR5cGU6IFwiYnl0ZXMzMlwiLCBuYW1lOiBwYXJhbS5uYW1lIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pYy5wdXNoKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhlZC5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pYy5wdXNoKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub25JbmRleGVkLnB1c2gocGFyYW0pO1xuICAgICAgICAgICAgICAgIGR5bmFtaWMucHVzaChmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHRJbmRleGVkID0gKHRvcGljcyAhPSBudWxsKSA/IHRoaXMuI2FiaUNvZGVyLmRlY29kZShpbmRleGVkLCBjb25jYXQodG9waWNzKSkgOiBudWxsO1xuICAgICAgICBjb25zdCByZXN1bHROb25JbmRleGVkID0gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKG5vbkluZGV4ZWQsIGRhdGEsIHRydWUpO1xuICAgICAgICAvL2NvbnN0IHJlc3VsdDogKEFycmF5PGFueT4gJiB7IFsga2V5OiBzdHJpbmcgXTogYW55IH0pID0gWyBdO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgY29uc3Qga2V5cyA9IFtdO1xuICAgICAgICBsZXQgbm9uSW5kZXhlZEluZGV4ID0gMCwgaW5kZXhlZEluZGV4ID0gMDtcbiAgICAgICAgZnJhZ21lbnQuaW5wdXRzLmZvckVhY2goKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChwYXJhbS5pbmRleGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdEluZGV4ZWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBJbmRleGVkKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkeW5hbWljW2luZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBJbmRleGVkKHJlc3VsdEluZGV4ZWRbaW5kZXhlZEluZGV4KytdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdEluZGV4ZWRbaW5kZXhlZEluZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0Tm9uSW5kZXhlZFtub25JbmRleGVkSW5kZXgrK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIGtleXMucHVzaChwYXJhbS5uYW1lIHx8IG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC5mcm9tSXRlbXModmFsdWVzLCBrZXlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFBhcnNlcyBhIHRyYW5zYWN0aW9uLCBmaW5kaW5nIHRoZSBtYXRjaGluZyBmdW5jdGlvbiBhbmQgZXh0cmFjdHNcbiAgICAgKiAgdGhlIHBhcmFtZXRlciB2YWx1ZXMgYWxvbmcgd2l0aCBvdGhlciB1c2VmdWwgZnVuY3Rpb24gZGV0YWlscy5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgbWF0Y2hpbmcgZnVuY3Rpb24gY2Fubm90IGJlIGZvdW5kLCByZXR1cm4gbnVsbC5cbiAgICAgKi9cbiAgICBwYXJzZVRyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBnZXRCeXRlcyh0eC5kYXRhLCBcInR4LmRhdGFcIik7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0QmlnSW50KCh0eC52YWx1ZSAhPSBudWxsKSA/IHR4LnZhbHVlIDogMCwgXCJ0eC52YWx1ZVwiKTtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLmdldEZ1bmN0aW9uKGhleGxpZnkoZGF0YS5zbGljZSgwLCA0KSkpO1xuICAgICAgICBpZiAoIWZyYWdtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKGZyYWdtZW50LmlucHV0cywgZGF0YS5zbGljZSg0KSk7XG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25EZXNjcmlwdGlvbihmcmFnbWVudCwgZnJhZ21lbnQuc2VsZWN0b3IsIGFyZ3MsIHZhbHVlKTtcbiAgICB9XG4gICAgcGFyc2VDYWxsUmVzdWx0KGRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQFRPRE9cIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQYXJzZXMgYSByZWNlaXB0IGxvZywgZmluZGluZyB0aGUgbWF0Y2hpbmcgZXZlbnQgYW5kIGV4dHJhY3RzXG4gICAgICogIHRoZSBwYXJhbWV0ZXIgdmFsdWVzIGFsb25nIHdpdGggb3RoZXIgdXNlZnVsIGV2ZW50IGRldGFpbHMuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlIG1hdGNoaW5nIGV2ZW50IGNhbm5vdCBiZSBmb3VuZCwgcmV0dXJucyBudWxsLlxuICAgICAqL1xuICAgIHBhcnNlTG9nKGxvZykge1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuZ2V0RXZlbnQobG9nLnRvcGljc1swXSk7XG4gICAgICAgIGlmICghZnJhZ21lbnQgfHwgZnJhZ21lbnQuYW5vbnltb3VzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBAVE9ETzogSWYgYW5vbnltb3VzLCBhbmQgdGhlIG9ubHkgbWV0aG9kLCBhbmQgdGhlIGlucHV0IGNvdW50IG1hdGNoZXMsIHNob3VsZCB3ZSBwYXJzZT9cbiAgICAgICAgLy8gICAgICAgIFByb2JhYmx5IG5vdCwgYmVjYXVzZSBqdXN0IGJlY2F1c2UgaXQgaXMgdGhlIG9ubHkgZXZlbnQgaW4gdGhlIEFCSSBkb2VzXG4gICAgICAgIC8vICAgICAgICBub3QgbWVhbiB3ZSBoYXZlIHRoZSBmdWxsIEFCSTsgbWF5YmUganVzdCBhIGZyYWdtZW50P1xuICAgICAgICByZXR1cm4gbmV3IExvZ0Rlc2NyaXB0aW9uKGZyYWdtZW50LCBmcmFnbWVudC50b3BpY0hhc2gsIHRoaXMuZGVjb2RlRXZlbnRMb2coZnJhZ21lbnQsIGxvZy5kYXRhLCBsb2cudG9waWNzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQYXJzZXMgYSByZXZlcnQgZGF0YSwgZmluZGluZyB0aGUgbWF0Y2hpbmcgZXJyb3IgYW5kIGV4dHJhY3RzXG4gICAgICogIHRoZSBwYXJhbWV0ZXIgdmFsdWVzIGFsb25nIHdpdGggb3RoZXIgdXNlZnVsIGVycm9yIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlIG1hdGNoaW5nIGVycm9yIGNhbm5vdCBiZSBmb3VuZCwgcmV0dXJucyBudWxsLlxuICAgICAqL1xuICAgIHBhcnNlRXJyb3IoZGF0YSkge1xuICAgICAgICBjb25zdCBoZXhEYXRhID0gaGV4bGlmeShkYXRhKTtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLmdldEVycm9yKGRhdGFTbGljZShoZXhEYXRhLCAwLCA0KSk7XG4gICAgICAgIGlmICghZnJhZ21lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLiNhYmlDb2Rlci5kZWNvZGUoZnJhZ21lbnQuaW5wdXRzLCBkYXRhU2xpY2UoaGV4RGF0YSwgNCkpO1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yRGVzY3JpcHRpb24oZnJhZ21lbnQsIGZyYWdtZW50LnNlbGVjdG9yLCBhcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgW1tJbnRlcmZhY2VdXSBmcm9tIHRoZSBBQkkgJSV2YWx1ZSUlLlxuICAgICAqXG4gICAgICogIFRoZSAlJXZhbHVlJSUgbWF5IGJlIHByb3ZpZGVkIGFzIGFuIGV4aXN0aW5nIFtbSW50ZXJmYWNlXV0gb2JqZWN0LFxuICAgICAqICBhIEpTT04tZW5jb2RlZCBBQkkgb3IgYW55IEh1bWFuLVJlYWRhYmxlIEFCSSBmb3JtYXQuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20odmFsdWUpIHtcbiAgICAgICAgLy8gQWxyZWFkeSBhbiBJbnRlcmZhY2UsIHdoaWNoIGlzIGltbXV0YWJsZVxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJbnRlcmZhY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBKU09OXG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRlcmZhY2UoSlNPTi5wYXJzZSh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFuIEludGVyZmFjZTsgcG9zc2libHkgZnJvbSBhbm90aGVyIHY2IGluc3RhbmNlXG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlLmZvcm1hdEpzb24pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50ZXJmYWNlKHZhbHVlLmZvcm1hdEpzb24oKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQSBsZWdhY3kgSW50ZXJmYWNlOyBmcm9tIGFuIG9sZGVyIHZlcnNpb25cbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUuZm9ybWF0KSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludGVyZmFjZSh2YWx1ZS5mb3JtYXQoXCJqc29uXCIpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcnJheSBvZiBmcmFnbWVudHNcbiAgICAgICAgcmV0dXJuIG5ldyBJbnRlcmZhY2UodmFsdWUpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyZmFjZS5qcy5tYXAiXSwibmFtZXMiOlsia2VjY2FrMjU2IiwiaWQiLCJjb25jYXQiLCJkYXRhU2xpY2UiLCJnZXRCaWdJbnQiLCJnZXRCeXRlcyIsImdldEJ5dGVzQ29weSIsImhleGxpZnkiLCJ6ZXJvUGFkQnl0ZXMiLCJ6ZXJvUGFkVmFsdWUiLCJpc0hleFN0cmluZyIsImRlZmluZVByb3BlcnRpZXMiLCJhc3NlcnRBcmd1bWVudCIsInRvQmVIZXgiLCJhc3NlcnQiLCJBYmlDb2RlciIsImNoZWNrUmVzdWx0RXJyb3JzIiwiUmVzdWx0IiwiQ29uc3RydWN0b3JGcmFnbWVudCIsIkVycm9yRnJhZ21lbnQiLCJFdmVudEZyYWdtZW50IiwiRnJhZ21lbnQiLCJGdW5jdGlvbkZyYWdtZW50IiwiUGFyYW1UeXBlIiwiVHlwZWQiLCJMb2dEZXNjcmlwdGlvbiIsImNvbnN0cnVjdG9yIiwiZnJhZ21lbnQiLCJ0b3BpYyIsImFyZ3MiLCJuYW1lIiwic2lnbmF0dXJlIiwiZm9ybWF0IiwiVHJhbnNhY3Rpb25EZXNjcmlwdGlvbiIsInNlbGVjdG9yIiwidmFsdWUiLCJFcnJvckRlc2NyaXB0aW9uIiwiSW5kZXhlZCIsImlzSW5kZXhlZCIsIl9pc0luZGV4ZWQiLCJoYXNoIiwiUGFuaWNSZWFzb25zIiwiQnVpbHRpbkVycm9ycyIsImlucHV0cyIsInJlYXNvbiIsIm1lc3NhZ2UiLCJKU09OIiwic3RyaW5naWZ5IiwiY29kZSIsInRvU3RyaW5nIiwiSW50ZXJmYWNlIiwibWluaW1hbCIsImFiaSIsImZyYWdtZW50cyIsIm1hcCIsImYiLCJmb3JtYXRKc29uIiwiaiIsInBhcnNlIiwiZ2V0QWJpQ29kZXIiLCJkZWZhdWx0QWJpQ29kZXIiLCJnZXRGdW5jdGlvbk5hbWUiLCJrZXkiLCJnZXRGdW5jdGlvbiIsImhhc0Z1bmN0aW9uIiwidmFsdWVzIiwiZm9yRWFjaEZ1bmN0aW9uIiwiY2FsbGJhY2siLCJuYW1lcyIsIkFycmF5IiwiZnJvbSIsImZ1bmN0aW9ucyIsImtleXMiLCJzb3J0IiwiYSIsImIiLCJsb2NhbGVDb21wYXJlIiwiaSIsImxlbmd0aCIsImdldCIsImdldEV2ZW50TmFtZSIsImdldEV2ZW50IiwiaGFzRXZlbnQiLCJmb3JFYWNoRXZlbnQiLCJldmVudHMiLCJnZXRFcnJvciIsInRvTG93ZXJDYXNlIiwiZXJyb3JzIiwiaW5kZXhPZiIsIm1hdGNoaW5nIiwic3BsaXQiLCJwdXNoIiwibWF0Y2hTdHIiLCJtIiwiam9pbiIsInJlc3VsdCIsImZvckVhY2hFcnJvciIsIl9kZWNvZGVQYXJhbXMiLCJwYXJhbXMiLCJkYXRhIiwiYWJpQ29kZXIiLCJkZWNvZGUiLCJfZW5jb2RlUGFyYW1zIiwiZW5jb2RlIiwiZW5jb2RlRGVwbG95IiwiZGVwbG95IiwiZGVjb2RlRXJyb3JSZXN1bHQiLCJlbmNvZGVFcnJvclJlc3VsdCIsImRlY29kZUZ1bmN0aW9uRGF0YSIsImVuY29kZUZ1bmN0aW9uRGF0YSIsImRlY29kZUZ1bmN0aW9uUmVzdWx0IiwiYnl0ZXMiLCJvdXRwdXRzIiwiZXJyb3IiLCJpbmZvIiwibWV0aG9kIiwibWFrZUVycm9yIiwiX2RhdGEiLCJ0eCIsImdldEJ1aWx0aW5DYWxsRXhjZXB0aW9uIiwiY3VzdG9tUHJlZml4Iiwic3RhcnRzV2l0aCIsInNsaWNlIiwiZWYiLCJyZXZlcnQiLCJlIiwicGFyc2VkIiwicGFyc2VUcmFuc2FjdGlvbiIsImludm9jYXRpb24iLCJlbmNvZGVGdW5jdGlvblJlc3VsdCIsImVuY29kZUZpbHRlclRvcGljcyIsImNvdW50IiwiZXhwZWN0ZWRDb3VudCIsInRvcGljcyIsImFub255bW91cyIsInRvcGljSGFzaCIsImVuY29kZVRvcGljIiwicGFyYW0iLCJ0eXBlIiwibWF0Y2giLCJmb3JFYWNoIiwiaW5kZXgiLCJpbmRleGVkIiwiYmFzZVR5cGUiLCJpc0FycmF5IiwicG9wIiwiZW5jb2RlRXZlbnRMb2ciLCJkYXRhVHlwZXMiLCJkYXRhVmFsdWVzIiwiRXJyb3IiLCJkZWNvZGVFdmVudExvZyIsImV2ZW50VG9waWMiLCJub25JbmRleGVkIiwiZHluYW1pYyIsInJlc3VsdEluZGV4ZWQiLCJyZXN1bHROb25JbmRleGVkIiwibm9uSW5kZXhlZEluZGV4IiwiaW5kZXhlZEluZGV4IiwiZnJvbUl0ZW1zIiwicGFyc2VDYWxsUmVzdWx0IiwicGFyc2VMb2ciLCJsb2ciLCJwYXJzZUVycm9yIiwiaGV4RGF0YSIsIk1hcCIsImZyYWdzIiwiY29uc29sZSIsIk9iamVjdCIsImZyZWV6ZSIsImZhbGxiYWNrIiwicmVjZWl2ZSIsImJ1Y2tldCIsInBheWFibGUiLCJoYXMiLCJzZXQiLCJmb3JjZVVuaXF1ZSIsImxhc3RWYWx1ZSIsInZhbHVlTGVuZ3RoIiwiYWxsb3dPcHRpb25zIiwiaXNUeXBlZCIsInNwbGljZSIsImxhc3RBcmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/abi/interface.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/abi/typed.js":
/*!**************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/typed.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Typed: function() { return /* binding */ Typed; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_get */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_get.js\");\n/* harmony import */ var _swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_init */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_init.js\");\n/* harmony import */ var _swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_set */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_set.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/**\n *  A Typed object allows a value to have its type explicitly\n *  specified.\n *\n *  For example, in Solidity, the value ``45`` could represent a\n *  ``uint8`` or a ``uint256``. The value ``0x1234`` could represent\n *  a ``bytes2`` or ``bytes``.\n *\n *  Since JavaScript has no meaningful way to explicitly inform any\n *  APIs which what the type is, this allows transparent interoperation\n *  with Soldity.\n *\n *  @_subsection: api/abi:Typed Values\n */ \n\n\n\nconst _gaurd = {};\nfunction n(value, width) {\n    let signed = false;\n    if (width < 0) {\n        signed = true;\n        width *= -1;\n    }\n    // @TODO: Check range is valid for value\n    return new Typed(_gaurd, \"\".concat(signed ? \"\" : \"u\", \"int\").concat(width), value, {\n        signed,\n        width\n    });\n}\nfunction b(value, size) {\n    // @TODO: Check range is valid for value\n    return new Typed(_gaurd, \"bytes\".concat(size ? size : \"\"), value, {\n        size\n    });\n}\nconst _typedSymbol = Symbol.for(\"_ethers_typed\");\nvar _options = /*#__PURE__*/ new WeakMap();\n/**\n *  The **Typed** class to wrap values providing explicit type information.\n */ class Typed {\n    /**\n     *  Format the type as a Human-Readable type.\n     */ format() {\n        if (this.type === \"array\") {\n            throw new Error(\"\");\n        } else if (this.type === \"dynamicArray\") {\n            throw new Error(\"\");\n        } else if (this.type === \"tuple\") {\n            return \"tuple(\".concat(this.value.map((v)=>v.format()).join(\",\"), \")\");\n        }\n        return this.type;\n    }\n    /**\n     *  The default value returned by this type.\n     */ defaultValue() {\n        return 0;\n    }\n    /**\n     *  The minimum value for numeric types.\n     */ minValue() {\n        return 0;\n    }\n    /**\n     *  The maximum value for numeric types.\n     */ maxValue() {\n        return 0;\n    }\n    /**\n     *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].\n     */ isBigInt() {\n        return !!this.type.match(/^u?int[0-9]+$/);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard is this is a [[TypedData]].\n     */ isData() {\n        return this.type.startsWith(\"bytes\");\n    }\n    /**\n     *  Returns ``true`` and provides a type guard is this is a [[TypedString]].\n     */ isString() {\n        return this.type === \"string\";\n    }\n    /**\n     *  Returns the tuple name, if this is a tuple. Throws otherwise.\n     */ get tupleName() {\n        if (this.type !== \"tuple\") {\n            throw TypeError(\"not a tuple\");\n        }\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _options);\n    }\n    // Returns the length of this type as an array\n    // - `null` indicates the length is unforced, it could be dynamic\n    // - `-1` indicates the length is dynamic\n    // - any other value indicates it is a static array and is its length\n    /**\n     *  Returns the length of the array type or ``-1`` if it is dynamic.\n     *\n     *  Throws if the type is not an array.\n     */ get arrayLength() {\n        if (this.type !== \"array\") {\n            throw TypeError(\"not an array\");\n        }\n        if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _options) === true) {\n            return -1;\n        }\n        if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _options) === false) {\n            return this.value.length;\n        }\n        return null;\n    }\n    /**\n     *  Returns a new **Typed** of %%type%% with the %%value%%.\n     */ static from(type, value) {\n        return new Typed(_gaurd, type, value);\n    }\n    /**\n     *  Return a new ``uint8`` type for %%v%%.\n     */ static uint8(v) {\n        return n(v, 8);\n    }\n    /**\n     *  Return a new ``uint16`` type for %%v%%.\n     */ static uint16(v) {\n        return n(v, 16);\n    }\n    /**\n     *  Return a new ``uint24`` type for %%v%%.\n     */ static uint24(v) {\n        return n(v, 24);\n    }\n    /**\n     *  Return a new ``uint32`` type for %%v%%.\n     */ static uint32(v) {\n        return n(v, 32);\n    }\n    /**\n     *  Return a new ``uint40`` type for %%v%%.\n     */ static uint40(v) {\n        return n(v, 40);\n    }\n    /**\n     *  Return a new ``uint48`` type for %%v%%.\n     */ static uint48(v) {\n        return n(v, 48);\n    }\n    /**\n     *  Return a new ``uint56`` type for %%v%%.\n     */ static uint56(v) {\n        return n(v, 56);\n    }\n    /**\n     *  Return a new ``uint64`` type for %%v%%.\n     */ static uint64(v) {\n        return n(v, 64);\n    }\n    /**\n     *  Return a new ``uint72`` type for %%v%%.\n     */ static uint72(v) {\n        return n(v, 72);\n    }\n    /**\n     *  Return a new ``uint80`` type for %%v%%.\n     */ static uint80(v) {\n        return n(v, 80);\n    }\n    /**\n     *  Return a new ``uint88`` type for %%v%%.\n     */ static uint88(v) {\n        return n(v, 88);\n    }\n    /**\n     *  Return a new ``uint96`` type for %%v%%.\n     */ static uint96(v) {\n        return n(v, 96);\n    }\n    /**\n     *  Return a new ``uint104`` type for %%v%%.\n     */ static uint104(v) {\n        return n(v, 104);\n    }\n    /**\n     *  Return a new ``uint112`` type for %%v%%.\n     */ static uint112(v) {\n        return n(v, 112);\n    }\n    /**\n     *  Return a new ``uint120`` type for %%v%%.\n     */ static uint120(v) {\n        return n(v, 120);\n    }\n    /**\n     *  Return a new ``uint128`` type for %%v%%.\n     */ static uint128(v) {\n        return n(v, 128);\n    }\n    /**\n     *  Return a new ``uint136`` type for %%v%%.\n     */ static uint136(v) {\n        return n(v, 136);\n    }\n    /**\n     *  Return a new ``uint144`` type for %%v%%.\n     */ static uint144(v) {\n        return n(v, 144);\n    }\n    /**\n     *  Return a new ``uint152`` type for %%v%%.\n     */ static uint152(v) {\n        return n(v, 152);\n    }\n    /**\n     *  Return a new ``uint160`` type for %%v%%.\n     */ static uint160(v) {\n        return n(v, 160);\n    }\n    /**\n     *  Return a new ``uint168`` type for %%v%%.\n     */ static uint168(v) {\n        return n(v, 168);\n    }\n    /**\n     *  Return a new ``uint176`` type for %%v%%.\n     */ static uint176(v) {\n        return n(v, 176);\n    }\n    /**\n     *  Return a new ``uint184`` type for %%v%%.\n     */ static uint184(v) {\n        return n(v, 184);\n    }\n    /**\n     *  Return a new ``uint192`` type for %%v%%.\n     */ static uint192(v) {\n        return n(v, 192);\n    }\n    /**\n     *  Return a new ``uint200`` type for %%v%%.\n     */ static uint200(v) {\n        return n(v, 200);\n    }\n    /**\n     *  Return a new ``uint208`` type for %%v%%.\n     */ static uint208(v) {\n        return n(v, 208);\n    }\n    /**\n     *  Return a new ``uint216`` type for %%v%%.\n     */ static uint216(v) {\n        return n(v, 216);\n    }\n    /**\n     *  Return a new ``uint224`` type for %%v%%.\n     */ static uint224(v) {\n        return n(v, 224);\n    }\n    /**\n     *  Return a new ``uint232`` type for %%v%%.\n     */ static uint232(v) {\n        return n(v, 232);\n    }\n    /**\n     *  Return a new ``uint240`` type for %%v%%.\n     */ static uint240(v) {\n        return n(v, 240);\n    }\n    /**\n     *  Return a new ``uint248`` type for %%v%%.\n     */ static uint248(v) {\n        return n(v, 248);\n    }\n    /**\n     *  Return a new ``uint256`` type for %%v%%.\n     */ static uint256(v) {\n        return n(v, 256);\n    }\n    /**\n     *  Return a new ``uint256`` type for %%v%%.\n     */ static uint(v) {\n        return n(v, 256);\n    }\n    /**\n     *  Return a new ``int8`` type for %%v%%.\n     */ static int8(v) {\n        return n(v, -8);\n    }\n    /**\n     *  Return a new ``int16`` type for %%v%%.\n     */ static int16(v) {\n        return n(v, -16);\n    }\n    /**\n     *  Return a new ``int24`` type for %%v%%.\n     */ static int24(v) {\n        return n(v, -24);\n    }\n    /**\n     *  Return a new ``int32`` type for %%v%%.\n     */ static int32(v) {\n        return n(v, -32);\n    }\n    /**\n     *  Return a new ``int40`` type for %%v%%.\n     */ static int40(v) {\n        return n(v, -40);\n    }\n    /**\n     *  Return a new ``int48`` type for %%v%%.\n     */ static int48(v) {\n        return n(v, -48);\n    }\n    /**\n     *  Return a new ``int56`` type for %%v%%.\n     */ static int56(v) {\n        return n(v, -56);\n    }\n    /**\n     *  Return a new ``int64`` type for %%v%%.\n     */ static int64(v) {\n        return n(v, -64);\n    }\n    /**\n     *  Return a new ``int72`` type for %%v%%.\n     */ static int72(v) {\n        return n(v, -72);\n    }\n    /**\n     *  Return a new ``int80`` type for %%v%%.\n     */ static int80(v) {\n        return n(v, -80);\n    }\n    /**\n     *  Return a new ``int88`` type for %%v%%.\n     */ static int88(v) {\n        return n(v, -88);\n    }\n    /**\n     *  Return a new ``int96`` type for %%v%%.\n     */ static int96(v) {\n        return n(v, -96);\n    }\n    /**\n     *  Return a new ``int104`` type for %%v%%.\n     */ static int104(v) {\n        return n(v, -104);\n    }\n    /**\n     *  Return a new ``int112`` type for %%v%%.\n     */ static int112(v) {\n        return n(v, -112);\n    }\n    /**\n     *  Return a new ``int120`` type for %%v%%.\n     */ static int120(v) {\n        return n(v, -120);\n    }\n    /**\n     *  Return a new ``int128`` type for %%v%%.\n     */ static int128(v) {\n        return n(v, -128);\n    }\n    /**\n     *  Return a new ``int136`` type for %%v%%.\n     */ static int136(v) {\n        return n(v, -136);\n    }\n    /**\n     *  Return a new ``int144`` type for %%v%%.\n     */ static int144(v) {\n        return n(v, -144);\n    }\n    /**\n     *  Return a new ``int52`` type for %%v%%.\n     */ static int152(v) {\n        return n(v, -152);\n    }\n    /**\n     *  Return a new ``int160`` type for %%v%%.\n     */ static int160(v) {\n        return n(v, -160);\n    }\n    /**\n     *  Return a new ``int168`` type for %%v%%.\n     */ static int168(v) {\n        return n(v, -168);\n    }\n    /**\n     *  Return a new ``int176`` type for %%v%%.\n     */ static int176(v) {\n        return n(v, -176);\n    }\n    /**\n     *  Return a new ``int184`` type for %%v%%.\n     */ static int184(v) {\n        return n(v, -184);\n    }\n    /**\n     *  Return a new ``int92`` type for %%v%%.\n     */ static int192(v) {\n        return n(v, -192);\n    }\n    /**\n     *  Return a new ``int200`` type for %%v%%.\n     */ static int200(v) {\n        return n(v, -200);\n    }\n    /**\n     *  Return a new ``int208`` type for %%v%%.\n     */ static int208(v) {\n        return n(v, -208);\n    }\n    /**\n     *  Return a new ``int216`` type for %%v%%.\n     */ static int216(v) {\n        return n(v, -216);\n    }\n    /**\n     *  Return a new ``int224`` type for %%v%%.\n     */ static int224(v) {\n        return n(v, -224);\n    }\n    /**\n     *  Return a new ``int232`` type for %%v%%.\n     */ static int232(v) {\n        return n(v, -232);\n    }\n    /**\n     *  Return a new ``int240`` type for %%v%%.\n     */ static int240(v) {\n        return n(v, -240);\n    }\n    /**\n     *  Return a new ``int248`` type for %%v%%.\n     */ static int248(v) {\n        return n(v, -248);\n    }\n    /**\n     *  Return a new ``int256`` type for %%v%%.\n     */ static int256(v) {\n        return n(v, -256);\n    }\n    /**\n     *  Return a new ``int256`` type for %%v%%.\n     */ static int(v) {\n        return n(v, -256);\n    }\n    /**\n     *  Return a new ``bytes1`` type for %%v%%.\n     */ static bytes1(v) {\n        return b(v, 1);\n    }\n    /**\n     *  Return a new ``bytes2`` type for %%v%%.\n     */ static bytes2(v) {\n        return b(v, 2);\n    }\n    /**\n     *  Return a new ``bytes3`` type for %%v%%.\n     */ static bytes3(v) {\n        return b(v, 3);\n    }\n    /**\n     *  Return a new ``bytes4`` type for %%v%%.\n     */ static bytes4(v) {\n        return b(v, 4);\n    }\n    /**\n     *  Return a new ``bytes5`` type for %%v%%.\n     */ static bytes5(v) {\n        return b(v, 5);\n    }\n    /**\n     *  Return a new ``bytes6`` type for %%v%%.\n     */ static bytes6(v) {\n        return b(v, 6);\n    }\n    /**\n     *  Return a new ``bytes7`` type for %%v%%.\n     */ static bytes7(v) {\n        return b(v, 7);\n    }\n    /**\n     *  Return a new ``bytes8`` type for %%v%%.\n     */ static bytes8(v) {\n        return b(v, 8);\n    }\n    /**\n     *  Return a new ``bytes9`` type for %%v%%.\n     */ static bytes9(v) {\n        return b(v, 9);\n    }\n    /**\n     *  Return a new ``bytes10`` type for %%v%%.\n     */ static bytes10(v) {\n        return b(v, 10);\n    }\n    /**\n     *  Return a new ``bytes11`` type for %%v%%.\n     */ static bytes11(v) {\n        return b(v, 11);\n    }\n    /**\n     *  Return a new ``bytes12`` type for %%v%%.\n     */ static bytes12(v) {\n        return b(v, 12);\n    }\n    /**\n     *  Return a new ``bytes13`` type for %%v%%.\n     */ static bytes13(v) {\n        return b(v, 13);\n    }\n    /**\n     *  Return a new ``bytes14`` type for %%v%%.\n     */ static bytes14(v) {\n        return b(v, 14);\n    }\n    /**\n     *  Return a new ``bytes15`` type for %%v%%.\n     */ static bytes15(v) {\n        return b(v, 15);\n    }\n    /**\n     *  Return a new ``bytes16`` type for %%v%%.\n     */ static bytes16(v) {\n        return b(v, 16);\n    }\n    /**\n     *  Return a new ``bytes17`` type for %%v%%.\n     */ static bytes17(v) {\n        return b(v, 17);\n    }\n    /**\n     *  Return a new ``bytes18`` type for %%v%%.\n     */ static bytes18(v) {\n        return b(v, 18);\n    }\n    /**\n     *  Return a new ``bytes19`` type for %%v%%.\n     */ static bytes19(v) {\n        return b(v, 19);\n    }\n    /**\n     *  Return a new ``bytes20`` type for %%v%%.\n     */ static bytes20(v) {\n        return b(v, 20);\n    }\n    /**\n     *  Return a new ``bytes21`` type for %%v%%.\n     */ static bytes21(v) {\n        return b(v, 21);\n    }\n    /**\n     *  Return a new ``bytes22`` type for %%v%%.\n     */ static bytes22(v) {\n        return b(v, 22);\n    }\n    /**\n     *  Return a new ``bytes23`` type for %%v%%.\n     */ static bytes23(v) {\n        return b(v, 23);\n    }\n    /**\n     *  Return a new ``bytes24`` type for %%v%%.\n     */ static bytes24(v) {\n        return b(v, 24);\n    }\n    /**\n     *  Return a new ``bytes25`` type for %%v%%.\n     */ static bytes25(v) {\n        return b(v, 25);\n    }\n    /**\n     *  Return a new ``bytes26`` type for %%v%%.\n     */ static bytes26(v) {\n        return b(v, 26);\n    }\n    /**\n     *  Return a new ``bytes27`` type for %%v%%.\n     */ static bytes27(v) {\n        return b(v, 27);\n    }\n    /**\n     *  Return a new ``bytes28`` type for %%v%%.\n     */ static bytes28(v) {\n        return b(v, 28);\n    }\n    /**\n     *  Return a new ``bytes29`` type for %%v%%.\n     */ static bytes29(v) {\n        return b(v, 29);\n    }\n    /**\n     *  Return a new ``bytes30`` type for %%v%%.\n     */ static bytes30(v) {\n        return b(v, 30);\n    }\n    /**\n     *  Return a new ``bytes31`` type for %%v%%.\n     */ static bytes31(v) {\n        return b(v, 31);\n    }\n    /**\n     *  Return a new ``bytes32`` type for %%v%%.\n     */ static bytes32(v) {\n        return b(v, 32);\n    }\n    /**\n     *  Return a new ``address`` type for %%v%%.\n     */ static address(v) {\n        return new Typed(_gaurd, \"address\", v);\n    }\n    /**\n     *  Return a new ``bool`` type for %%v%%.\n     */ static bool(v) {\n        return new Typed(_gaurd, \"bool\", !!v);\n    }\n    /**\n     *  Return a new ``bytes`` type for %%v%%.\n     */ static bytes(v) {\n        return new Typed(_gaurd, \"bytes\", v);\n    }\n    /**\n     *  Return a new ``string`` type for %%v%%.\n     */ static string(v) {\n        return new Typed(_gaurd, \"string\", v);\n    }\n    /**\n     *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.\n     */ static array(v, dynamic) {\n        throw new Error(\"not implemented yet\");\n        return new Typed(_gaurd, \"array\", v, dynamic);\n    }\n    /**\n     *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.\n     */ static tuple(v, name) {\n        throw new Error(\"not implemented yet\");\n        return new Typed(_gaurd, \"tuple\", v, name);\n    }\n    /**\n     *  Return a new ``uint8`` type for %%v%%.\n     */ static overrides(v) {\n        return new Typed(_gaurd, \"overrides\", Object.assign({}, v));\n    }\n    /**\n     *  Returns true only if %%value%% is a [[Typed]] instance.\n     */ static isTyped(value) {\n        return value && typeof value === \"object\" && \"_typedSymbol\" in value && value._typedSymbol === _typedSymbol;\n    }\n    /**\n     *  If the value is a [[Typed]] instance, validates the underlying value\n     *  and returns it, otherwise returns value directly.\n     *\n     *  This is useful for functions that with to accept either a [[Typed]]\n     *  object or values.\n     */ static dereference(value, type) {\n        if (Typed.isTyped(value)) {\n            if (value.type !== type) {\n                throw new Error(\"invalid type: expecetd \".concat(type, \", got \").concat(value.type));\n            }\n            return value.value;\n        }\n        return value;\n    }\n    /**\n     *  @_ignore:\n     */ constructor(gaurd, type, value, options){\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_1__._)(this, _options, {\n            writable: true,\n            value: void 0\n        });\n        if (options == null) {\n            options = null;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertPrivate)(_gaurd, gaurd, \"Typed\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.defineProperties)(this, {\n            _typedSymbol,\n            type,\n            value\n        });\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_4__._)(this, _options, options);\n        // Check the value is valid\n        this.format();\n    }\n} //# sourceMappingURL=typed.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvdHlwZWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Q0FhQzs7O0FBQ21FO0FBQ3BFLE1BQU1FLFNBQVMsQ0FBQztBQUNoQixTQUFTQyxFQUFFQyxLQUFLLEVBQUVDLEtBQUs7SUFDbkIsSUFBSUMsU0FBUztJQUNiLElBQUlELFFBQVEsR0FBRztRQUNYQyxTQUFTO1FBQ1RELFNBQVMsQ0FBQztJQUNkO0lBQ0Esd0NBQXdDO0lBQ3hDLE9BQU8sSUFBSUUsTUFBTUwsUUFBUSxHQUEwQkcsT0FBdkJDLFNBQVMsS0FBSyxLQUFJLE9BQVcsT0FBTkQsUUFBU0QsT0FBTztRQUFFRTtRQUFRRDtJQUFNO0FBQ3ZGO0FBQ0EsU0FBU0csRUFBRUosS0FBSyxFQUFFSyxJQUFJO0lBQ2xCLHdDQUF3QztJQUN4QyxPQUFPLElBQUlGLE1BQU1MLFFBQVEsUUFBMkIsT0FBbkIsT0FBU08sT0FBTyxLQUFNTCxPQUFPO1FBQUVLO0lBQUs7QUFDekU7QUFDQSxNQUFNQyxlQUFlQyxPQUFPQyxHQUFHLENBQUM7SUFhNUI7QUFaSjs7Q0FFQyxHQUNNLE1BQU1MO0lBMkJUOztLQUVDLEdBQ0RNLFNBQVM7UUFDTCxJQUFJLElBQUksQ0FBQ0MsSUFBSSxLQUFLLFNBQVM7WUFDdkIsTUFBTSxJQUFJQyxNQUFNO1FBQ3BCLE9BQ0ssSUFBSSxJQUFJLENBQUNELElBQUksS0FBSyxnQkFBZ0I7WUFDbkMsTUFBTSxJQUFJQyxNQUFNO1FBQ3BCLE9BQ0ssSUFBSSxJQUFJLENBQUNELElBQUksS0FBSyxTQUFTO1lBQzVCLE9BQU8sU0FBcUQsT0FBNUMsSUFBSSxDQUFDVixLQUFLLENBQUNZLEdBQUcsQ0FBQyxDQUFDQyxJQUFNQSxFQUFFSixNQUFNLElBQUlLLElBQUksQ0FBQyxNQUFLO1FBQ2hFO1FBQ0EsT0FBTyxJQUFJLENBQUNKLElBQUk7SUFDcEI7SUFDQTs7S0FFQyxH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YWJpL3R5cGVkLmpzPzJkZTQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgQSBUeXBlZCBvYmplY3QgYWxsb3dzIGEgdmFsdWUgdG8gaGF2ZSBpdHMgdHlwZSBleHBsaWNpdGx5XG4gKiAgc3BlY2lmaWVkLlxuICpcbiAqICBGb3IgZXhhbXBsZSwgaW4gU29saWRpdHksIHRoZSB2YWx1ZSBgYDQ1YGAgY291bGQgcmVwcmVzZW50IGFcbiAqICBgYHVpbnQ4YGAgb3IgYSBgYHVpbnQyNTZgYC4gVGhlIHZhbHVlIGBgMHgxMjM0YGAgY291bGQgcmVwcmVzZW50XG4gKiAgYSBgYGJ5dGVzMmBgIG9yIGBgYnl0ZXNgYC5cbiAqXG4gKiAgU2luY2UgSmF2YVNjcmlwdCBoYXMgbm8gbWVhbmluZ2Z1bCB3YXkgdG8gZXhwbGljaXRseSBpbmZvcm0gYW55XG4gKiAgQVBJcyB3aGljaCB3aGF0IHRoZSB0eXBlIGlzLCB0aGlzIGFsbG93cyB0cmFuc3BhcmVudCBpbnRlcm9wZXJhdGlvblxuICogIHdpdGggU29sZGl0eS5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvYWJpOlR5cGVkIFZhbHVlc1xuICovXG5pbXBvcnQgeyBhc3NlcnRQcml2YXRlLCBkZWZpbmVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5jb25zdCBfZ2F1cmQgPSB7fTtcbmZ1bmN0aW9uIG4odmFsdWUsIHdpZHRoKSB7XG4gICAgbGV0IHNpZ25lZCA9IGZhbHNlO1xuICAgIGlmICh3aWR0aCA8IDApIHtcbiAgICAgICAgc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgd2lkdGggKj0gLTE7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBDaGVjayByYW5nZSBpcyB2YWxpZCBmb3IgdmFsdWVcbiAgICByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgYCR7c2lnbmVkID8gXCJcIiA6IFwidVwifWludCR7d2lkdGh9YCwgdmFsdWUsIHsgc2lnbmVkLCB3aWR0aCB9KTtcbn1cbmZ1bmN0aW9uIGIodmFsdWUsIHNpemUpIHtcbiAgICAvLyBAVE9ETzogQ2hlY2sgcmFuZ2UgaXMgdmFsaWQgZm9yIHZhbHVlXG4gICAgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIGBieXRlcyR7KHNpemUpID8gc2l6ZSA6IFwiXCJ9YCwgdmFsdWUsIHsgc2l6ZSB9KTtcbn1cbmNvbnN0IF90eXBlZFN5bWJvbCA9IFN5bWJvbC5mb3IoXCJfZXRoZXJzX3R5cGVkXCIpO1xuLyoqXG4gKiAgVGhlICoqVHlwZWQqKiBjbGFzcyB0byB3cmFwIHZhbHVlcyBwcm92aWRpbmcgZXhwbGljaXQgdHlwZSBpbmZvcm1hdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFR5cGVkIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHR5cGUsIGFzIGEgU29saWRpdHktY29tcGF0aWJsZSB0eXBlLlxuICAgICAqL1xuICAgIHR5cGU7XG4gICAgLyoqXG4gICAgICogIFRoZSBhY3R1YWwgdmFsdWUuXG4gICAgICovXG4gICAgdmFsdWU7XG4gICAgI29wdGlvbnM7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIF90eXBlZFN5bWJvbDtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ2F1cmQsIHR5cGUsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFByaXZhdGUoX2dhdXJkLCBnYXVyZCwgXCJUeXBlZFwiKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IF90eXBlZFN5bWJvbCwgdHlwZSwgdmFsdWUgfSk7XG4gICAgICAgIHRoaXMuI29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAvLyBDaGVjayB0aGUgdmFsdWUgaXMgdmFsaWRcbiAgICAgICAgdGhpcy5mb3JtYXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEZvcm1hdCB0aGUgdHlwZSBhcyBhIEh1bWFuLVJlYWRhYmxlIHR5cGUuXG4gICAgICovXG4gICAgZm9ybWF0KCkge1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09IFwiZHluYW1pY0FycmF5XCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09IFwidHVwbGVcIikge1xuICAgICAgICAgICAgcmV0dXJuIGB0dXBsZSgke3RoaXMudmFsdWUubWFwKCh2KSA9PiB2LmZvcm1hdCgpKS5qb2luKFwiLFwiKX0pYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50eXBlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGRlZmF1bHQgdmFsdWUgcmV0dXJuZWQgYnkgdGhpcyB0eXBlLlxuICAgICAqL1xuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbWluaW11bSB2YWx1ZSBmb3IgbnVtZXJpYyB0eXBlcy5cbiAgICAgKi9cbiAgICBtaW5WYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSB2YWx1ZSBmb3IgbnVtZXJpYyB0eXBlcy5cbiAgICAgKi9cbiAgICBtYXhWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaXMgdGhpcyBpcyBhIFtbVHlwZWRCaWdJbnRdXS5cbiAgICAgKi9cbiAgICBpc0JpZ0ludCgpIHtcbiAgICAgICAgcmV0dXJuICEhKHRoaXMudHlwZS5tYXRjaCgvXnU/aW50WzAtOV0rJC8pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpcyB0aGlzIGlzIGEgW1tUeXBlZERhdGFdXS5cbiAgICAgKi9cbiAgICBpc0RhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUuc3RhcnRzV2l0aChcImJ5dGVzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlzIHRoaXMgaXMgYSBbW1R5cGVkU3RyaW5nXV0uXG4gICAgICovXG4gICAgaXNTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSBcInN0cmluZ1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHR1cGxlIG5hbWUsIGlmIHRoaXMgaXMgYSB0dXBsZS4gVGhyb3dzIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBnZXQgdHVwbGVOYW1lKCkge1xuICAgICAgICBpZiAodGhpcy50eXBlICE9PSBcInR1cGxlXCIpIHtcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIm5vdCBhIHR1cGxlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiNvcHRpb25zO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhpcyB0eXBlIGFzIGFuIGFycmF5XG4gICAgLy8gLSBgbnVsbGAgaW5kaWNhdGVzIHRoZSBsZW5ndGggaXMgdW5mb3JjZWQsIGl0IGNvdWxkIGJlIGR5bmFtaWNcbiAgICAvLyAtIGAtMWAgaW5kaWNhdGVzIHRoZSBsZW5ndGggaXMgZHluYW1pY1xuICAgIC8vIC0gYW55IG90aGVyIHZhbHVlIGluZGljYXRlcyBpdCBpcyBhIHN0YXRpYyBhcnJheSBhbmQgaXMgaXRzIGxlbmd0aFxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5IHR5cGUgb3IgYGAtMWBgIGlmIGl0IGlzIGR5bmFtaWMuXG4gICAgICpcbiAgICAgKiAgVGhyb3dzIGlmIHRoZSB0eXBlIGlzIG5vdCBhbiBhcnJheS5cbiAgICAgKi9cbiAgICBnZXQgYXJyYXlMZW5ndGgoKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwibm90IGFuIGFycmF5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiNvcHRpb25zID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI29wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMudmFsdWUpLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgKipUeXBlZCoqIG9mICUldHlwZSUlIHdpdGggdGhlICUldmFsdWUlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbSh0eXBlLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgdHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDgodikgeyByZXR1cm4gbih2LCA4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE2KHYpIHsgcmV0dXJuIG4odiwgMTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjQodikgeyByZXR1cm4gbih2LCAyNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDMyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQzMih2KSB7IHJldHVybiBuKHYsIDMyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50NDBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDQwKHYpIHsgcmV0dXJuIG4odiwgNDApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ0OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50NDgodikgeyByZXR1cm4gbih2LCA0OCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDU2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQ1Nih2KSB7IHJldHVybiBuKHYsIDU2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50NjRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDY0KHYpIHsgcmV0dXJuIG4odiwgNjQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ3MmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50NzIodikgeyByZXR1cm4gbih2LCA3Mik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDgwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQ4MCh2KSB7IHJldHVybiBuKHYsIDgwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50ODhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDg4KHYpIHsgcmV0dXJuIG4odiwgODgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ5NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50OTYodikgeyByZXR1cm4gbih2LCA5Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDEwNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTA0KHYpIHsgcmV0dXJuIG4odiwgMTA0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTEyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxMTIodikgeyByZXR1cm4gbih2LCAxMTIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxMjBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDEyMCh2KSB7IHJldHVybiBuKHYsIDEyMCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDEyOGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTI4KHYpIHsgcmV0dXJuIG4odiwgMTI4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTM2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxMzYodikgeyByZXR1cm4gbih2LCAxMzYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxNDRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE0NCh2KSB7IHJldHVybiBuKHYsIDE0NCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE1MmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTUyKHYpIHsgcmV0dXJuIG4odiwgMTUyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTYwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxNjAodikgeyByZXR1cm4gbih2LCAxNjApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxNjhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE2OCh2KSB7IHJldHVybiBuKHYsIDE2OCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE3NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTc2KHYpIHsgcmV0dXJuIG4odiwgMTc2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTg0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxODQodikgeyByZXR1cm4gbih2LCAxODQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxOTJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE5Mih2KSB7IHJldHVybiBuKHYsIDE5Mik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDIwMGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjAwKHYpIHsgcmV0dXJuIG4odiwgMjAwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjA4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyMDgodikgeyByZXR1cm4gbih2LCAyMDgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyMTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDIxNih2KSB7IHJldHVybiBuKHYsIDIxNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDIyNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjI0KHYpIHsgcmV0dXJuIG4odiwgMjI0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjMyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyMzIodikgeyByZXR1cm4gbih2LCAyMzIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyNDBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDI0MCh2KSB7IHJldHVybiBuKHYsIDI0MCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDI0OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjQ4KHYpIHsgcmV0dXJuIG4odiwgMjQ4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjU2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyNTYodikgeyByZXR1cm4gbih2LCAyNTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyNTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludCh2KSB7IHJldHVybiBuKHYsIDI1Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ4KHYpIHsgcmV0dXJuIG4odiwgLTgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDE2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDE2KHYpIHsgcmV0dXJuIG4odiwgLTE2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyNCh2KSB7IHJldHVybiBuKHYsIC0yNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MzJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MzIodikgeyByZXR1cm4gbih2LCAtMzIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDQwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDQwKHYpIHsgcmV0dXJuIG4odiwgLTQwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ0OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ0OCh2KSB7IHJldHVybiBuKHYsIC00OCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50NTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50NTYodikgeyByZXR1cm4gbih2LCAtNTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDY0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDY0KHYpIHsgcmV0dXJuIG4odiwgLTY0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ3MmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ3Mih2KSB7IHJldHVybiBuKHYsIC03Mik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50ODBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50ODAodikgeyByZXR1cm4gbih2LCAtODApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDg4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDg4KHYpIHsgcmV0dXJuIG4odiwgLTg4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ5NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ5Nih2KSB7IHJldHVybiBuKHYsIC05Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTA0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDEwNCh2KSB7IHJldHVybiBuKHYsIC0xMDQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDExMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxMTIodikgeyByZXR1cm4gbih2LCAtMTEyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxMjBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTIwKHYpIHsgcmV0dXJuIG4odiwgLTEyMCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTI4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDEyOCh2KSB7IHJldHVybiBuKHYsIC0xMjgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDEzNmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxMzYodikgeyByZXR1cm4gbih2LCAtMTM2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxNDRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTQ0KHYpIHsgcmV0dXJuIG4odiwgLTE0NCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50NTJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTUyKHYpIHsgcmV0dXJuIG4odiwgLTE1Mik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTYwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDE2MCh2KSB7IHJldHVybiBuKHYsIC0xNjApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDE2OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxNjgodikgeyByZXR1cm4gbih2LCAtMTY4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxNzZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTc2KHYpIHsgcmV0dXJuIG4odiwgLTE3Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTg0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDE4NCh2KSB7IHJldHVybiBuKHYsIC0xODQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDkyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDE5Mih2KSB7IHJldHVybiBuKHYsIC0xOTIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDIwMGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyMDAodikgeyByZXR1cm4gbih2LCAtMjAwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyMDhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjA4KHYpIHsgcmV0dXJuIG4odiwgLTIwOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjE2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDIxNih2KSB7IHJldHVybiBuKHYsIC0yMTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDIyNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyMjQodikgeyByZXR1cm4gbih2LCAtMjI0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyMzJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjMyKHYpIHsgcmV0dXJuIG4odiwgLTIzMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjQwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDI0MCh2KSB7IHJldHVybiBuKHYsIC0yNDApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDI0OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyNDgodikgeyByZXR1cm4gbih2LCAtMjQ4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyNTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjU2KHYpIHsgcmV0dXJuIG4odiwgLTI1Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjU2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludCh2KSB7IHJldHVybiBuKHYsIC0yNTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczEodikgeyByZXR1cm4gYih2LCAxKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyKHYpIHsgcmV0dXJuIGIodiwgMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMzYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMyh2KSB7IHJldHVybiBiKHYsIDMpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczQodikgeyByZXR1cm4gYih2LCA0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczVgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXM1KHYpIHsgcmV0dXJuIGIodiwgNSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXM2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzNih2KSB7IHJldHVybiBiKHYsIDYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzN2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczcodikgeyByZXR1cm4gYih2LCA3KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXM4KHYpIHsgcmV0dXJuIGIodiwgOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXM5YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzOSh2KSB7IHJldHVybiBiKHYsIDkpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxMCh2KSB7IHJldHVybiBiKHYsIDEwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczExYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTEodikgeyByZXR1cm4gYih2LCAxMSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczEyKHYpIHsgcmV0dXJuIGIodiwgMTIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTNgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxMyh2KSB7IHJldHVybiBiKHYsIDEzKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczE0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTQodikgeyByZXR1cm4gYih2LCAxNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxNWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczE1KHYpIHsgcmV0dXJuIGIodiwgMTUpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxNih2KSB7IHJldHVybiBiKHYsIDE2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczE3YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTcodikgeyByZXR1cm4gYih2LCAxNyk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxOGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczE4KHYpIHsgcmV0dXJuIGIodiwgMTgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTlgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxOSh2KSB7IHJldHVybiBiKHYsIDE5KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczIwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjAodikgeyByZXR1cm4gYih2LCAyMCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyMWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczIxKHYpIHsgcmV0dXJuIGIodiwgMjEpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyMih2KSB7IHJldHVybiBiKHYsIDIyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczIzYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjModikgeyByZXR1cm4gYih2LCAyMyk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczI0KHYpIHsgcmV0dXJuIGIodiwgMjQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjVgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyNSh2KSB7IHJldHVybiBiKHYsIDI1KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczI2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjYodikgeyByZXR1cm4gYih2LCAyNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyN2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczI3KHYpIHsgcmV0dXJuIGIodiwgMjcpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyOCh2KSB7IHJldHVybiBiKHYsIDI4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczI5YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjkodikgeyByZXR1cm4gYih2LCAyOSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMzMGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczMwKHYpIHsgcmV0dXJuIGIodiwgMzApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMzFgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMzMSh2KSB7IHJldHVybiBiKHYsIDMxKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczMyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMzIodikgeyByZXR1cm4gYih2LCAzMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYWRkcmVzc2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRyZXNzKHYpIHsgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIFwiYWRkcmVzc1wiLCB2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBib29sYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJvb2wodikgeyByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJib29sXCIsICEhdik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXNgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXModikgeyByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJieXRlc1wiLCB2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBzdHJpbmdgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgc3RyaW5nKHYpIHsgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIFwic3RyaW5nXCIsIHYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGFycmF5YGAgdHlwZSBmb3IgJSV2JSUsIGFsbG93aW5nICUlZHluYW1pYyUlIGxlbmd0aC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXJyYXkodiwgZHluYW1pYykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWQgeWV0XCIpO1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJhcnJheVwiLCB2LCBkeW5hbWljKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHR1cGxlYGAgdHlwZSBmb3IgJSV2JSUsIHdpdGggdGhlIG9wdGlvbmFsICUlbmFtZSUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB0dXBsZSh2LCBuYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZCB5ZXRcIik7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBcInR1cGxlXCIsIHYsIG5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgb3ZlcnJpZGVzKHYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIFwib3ZlcnJpZGVzXCIsIE9iamVjdC5hc3NpZ24oe30sIHYpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBvbmx5IGlmICUldmFsdWUlJSBpcyBhIFtbVHlwZWRdXSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNUeXBlZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlXG4gICAgICAgICAgICAmJiB0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIlxuICAgICAgICAgICAgJiYgXCJfdHlwZWRTeW1ib2xcIiBpbiB2YWx1ZVxuICAgICAgICAgICAgJiYgdmFsdWUuX3R5cGVkU3ltYm9sID09PSBfdHlwZWRTeW1ib2wpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSWYgdGhlIHZhbHVlIGlzIGEgW1tUeXBlZF1dIGluc3RhbmNlLCB2YWxpZGF0ZXMgdGhlIHVuZGVybHlpbmcgdmFsdWVcbiAgICAgKiAgYW5kIHJldHVybnMgaXQsIG90aGVyd2lzZSByZXR1cm5zIHZhbHVlIGRpcmVjdGx5LlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgdXNlZnVsIGZvciBmdW5jdGlvbnMgdGhhdCB3aXRoIHRvIGFjY2VwdCBlaXRoZXIgYSBbW1R5cGVkXV1cbiAgICAgKiAgb2JqZWN0IG9yIHZhbHVlcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVyZWZlcmVuY2UodmFsdWUsIHR5cGUpIHtcbiAgICAgICAgaWYgKFR5cGVkLmlzVHlwZWQodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUudHlwZSAhPT0gdHlwZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB0eXBlOiBleHBlY2V0ZCAke3R5cGV9LCBnb3QgJHt2YWx1ZS50eXBlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlZC5qcy5tYXAiXSwibmFtZXMiOlsiYXNzZXJ0UHJpdmF0ZSIsImRlZmluZVByb3BlcnRpZXMiLCJfZ2F1cmQiLCJuIiwidmFsdWUiLCJ3aWR0aCIsInNpZ25lZCIsIlR5cGVkIiwiYiIsInNpemUiLCJfdHlwZWRTeW1ib2wiLCJTeW1ib2wiLCJmb3IiLCJmb3JtYXQiLCJ0eXBlIiwiRXJyb3IiLCJtYXAiLCJ2Iiwiam9pbiIsImRlZmF1bHRWYWx1ZSIsIm1pblZhbHVlIiwibWF4VmFsdWUiLCJpc0JpZ0ludCIsIm1hdGNoIiwiaXNEYXRhIiwic3RhcnRzV2l0aCIsImlzU3RyaW5nIiwidHVwbGVOYW1lIiwiVHlwZUVycm9yIiwib3B0aW9ucyIsImFycmF5TGVuZ3RoIiwibGVuZ3RoIiwiZnJvbSIsInVpbnQ4IiwidWludDE2IiwidWludDI0IiwidWludDMyIiwidWludDQwIiwidWludDQ4IiwidWludDU2IiwidWludDY0IiwidWludDcyIiwidWludDgwIiwidWludDg4IiwidWludDk2IiwidWludDEwNCIsInVpbnQxMTIiLCJ1aW50MTIwIiwidWludDEyOCIsInVpbnQxMzYiLCJ1aW50MTQ0IiwidWludDE1MiIsInVpbnQxNjAiLCJ1aW50MTY4IiwidWludDE3NiIsInVpbnQxODQiLCJ1aW50MTkyIiwidWludDIwMCIsInVpbnQyMDgiLCJ1aW50MjE2IiwidWludDIyNCIsInVpbnQyMzIiLCJ1aW50MjQwIiwidWludDI0OCIsInVpbnQyNTYiLCJ1aW50IiwiaW50OCIsImludDE2IiwiaW50MjQiLCJpbnQzMiIsImludDQwIiwiaW50NDgiLCJpbnQ1NiIsImludDY0IiwiaW50NzIiLCJpbnQ4MCIsImludDg4IiwiaW50OTYiLCJpbnQxMDQiLCJpbnQxMTIiLCJpbnQxMjAiLCJpbnQxMjgiLCJpbnQxMzYiLCJpbnQxNDQiLCJpbnQxNTIiLCJpbnQxNjAiLCJpbnQxNjgiLCJpbnQxNzYiLCJpbnQxODQiLCJpbnQxOTIiLCJpbnQyMDAiLCJpbnQyMDgiLCJpbnQyMTYiLCJpbnQyMjQiLCJpbnQyMzIiLCJpbnQyNDAiLCJpbnQyNDgiLCJpbnQyNTYiLCJpbnQiLCJieXRlczEiLCJieXRlczIiLCJieXRlczMiLCJieXRlczQiLCJieXRlczUiLCJieXRlczYiLCJieXRlczciLCJieXRlczgiLCJieXRlczkiLCJieXRlczEwIiwiYnl0ZXMxMSIsImJ5dGVzMTIiLCJieXRlczEzIiwiYnl0ZXMxNCIsImJ5dGVzMTUiLCJieXRlczE2IiwiYnl0ZXMxNyIsImJ5dGVzMTgiLCJieXRlczE5IiwiYnl0ZXMyMCIsImJ5dGVzMjEiLCJieXRlczIyIiwiYnl0ZXMyMyIsImJ5dGVzMjQiLCJieXRlczI1IiwiYnl0ZXMyNiIsImJ5dGVzMjciLCJieXRlczI4IiwiYnl0ZXMyOSIsImJ5dGVzMzAiLCJieXRlczMxIiwiYnl0ZXMzMiIsImFkZHJlc3MiLCJib29sIiwiYnl0ZXMiLCJzdHJpbmciLCJhcnJheSIsImR5bmFtaWMiLCJ0dXBsZSIsIm5hbWUiLCJvdmVycmlkZXMiLCJPYmplY3QiLCJhc3NpZ24iLCJpc1R5cGVkIiwiZGVyZWZlcmVuY2UiLCJjb25zdHJ1Y3RvciIsImdhdXJkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/abi/typed.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/address/address.js":
/*!********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/address/address.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAddress: function() { return /* binding */ getAddress; },\n/* harmony export */   getIcapAddress: function() { return /* binding */ getIcapAddress; }\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../crypto/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n\n\nconst BN_0 = BigInt(0);\nconst BN_36 = BigInt(36);\nfunction getChecksumAddress(address) {\n    //    if (!isHexString(address, 20)) {\n    //        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    //    }\n    address = address.toLowerCase();\n    const chars = address.substring(2).split(\"\");\n    const expanded = new Uint8Array(40);\n    for(let i = 0; i < 40; i++){\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n    const hashed = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.keccak256)(expanded));\n    for(let i = 0; i < 40; i += 2){\n        if (hashed[i >> 1] >> 4 >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n    return \"0x\" + chars.join(\"\");\n}\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n// Create lookup table\nconst ibanLookup = {};\nfor(let i = 0; i < 10; i++){\n    ibanLookup[String(i)] = String(i);\n}\nfor(let i = 0; i < 26; i++){\n    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);\n}\n// How many decimal digits can we process? (for 64-bit float, this is 15)\n// i.e. Math.floor(Math.log10(Number.MAX_SAFE_INTEGER));\nconst safeDigits = 15;\nfunction ibanChecksum(address) {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n    let expanded = address.split(\"\").map((c)=>{\n        return ibanLookup[c];\n    }).join(\"\");\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while(expanded.length >= safeDigits){\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n    let checksum = String(98 - parseInt(expanded, 10) % 97);\n    while(checksum.length < 2){\n        checksum = \"0\" + checksum;\n    }\n    return checksum;\n}\n;\nconst Base36 = function() {\n    ;\n    const result = {};\n    for(let i = 0; i < 36; i++){\n        const key = \"0123456789abcdefghijklmnopqrstuvwxyz\"[i];\n        result[key] = BigInt(i);\n    }\n    return result;\n}();\nfunction fromBase36(value) {\n    value = value.toLowerCase();\n    let result = BN_0;\n    for(let i = 0; i < value.length; i++){\n        result = result * BN_36 + Base36[value[i]];\n    }\n    return result;\n}\n/**\n *  Returns a normalized and checksumed address for %%address%%.\n *  This accepts non-checksum addresses, checksum addresses and\n *  [[getIcapAddress]] formats.\n *\n *  The checksum in Ethereum uses the capitalization (upper-case\n *  vs lower-case) of the characters within an address to encode\n *  its checksum, which offers, on average, a checksum of 15-bits.\n *\n *  If %%address%% contains both upper-case and lower-case, it is\n *  assumed to already be a checksum address and its checksum is\n *  validated, and if the address fails its expected checksum an\n *  error is thrown.\n *\n *  If you wish the checksum of %%address%% to be ignore, it should\n *  be converted to lower-case (i.e. ``.toLowercase()``) before\n *  being passed in. This should be a very rare situation though,\n *  that you wish to bypass the safegaurds in place to protect\n *  against an address that has been incorrectly copied from another\n *  source.\n *\n *  @example:\n *    // Adds the checksum (via upper-casing specific letters)\n *    getAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\")\n *    //_result:\n *\n *    // Converts ICAP address and adds checksum\n *    getAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n *    //_result:\n *\n *    // Throws an error if an address contains mixed case,\n *    // but the checksum fails\n *    getAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_error:\n */ function getAddress(address) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(typeof address === \"string\", \"invalid address\", \"address\", address);\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n        // Missing the 0x prefix\n        if (!address.startsWith(\"0x\")) {\n            address = \"0x\" + address;\n        }\n        const result = getChecksumAddress(address);\n        // It is a checksummed address with a bad checksum\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, \"bad address checksum\", \"address\", address);\n        return result;\n    }\n    // Maybe ICAP? (we only support direct mode)\n    if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n        // It is an ICAP address with a bad checksum\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(address.substring(2, 4) === ibanChecksum(address), \"bad icap checksum\", \"address\", address);\n        let result = fromBase36(address.substring(4)).toString(16);\n        while(result.length < 40){\n            result = \"0\" + result;\n        }\n        return getChecksumAddress(\"0x\" + result);\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, \"invalid address\", \"address\", address);\n}\n/**\n *  The [ICAP Address format](link-icap) format is an early checksum\n *  format which attempts to be compatible with the banking\n *  industry [IBAN format](link-wiki-iban) for bank accounts.\n *\n *  It is no longer common or a recommended format.\n *\n *  @example:\n *    getIcapAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\");\n *    //_result:\n *\n *    getIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n *    //_result:\n *\n *    // Throws an error if the ICAP checksum is wrong\n *    getIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK37\");\n *    //_error:\n */ function getIcapAddress(address) {\n    //let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    let base36 = BigInt(getAddress(address)).toString(36).toUpperCase();\n    while(base36.length < 30){\n        base36 = \"0\" + base36;\n    }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n} //# sourceMappingURL=address.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hZGRyZXNzL2FkZHJlc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBK0M7QUFDYztBQUM3RCxNQUFNRyxPQUFPQyxPQUFPO0FBQ3BCLE1BQU1DLFFBQVFELE9BQU87QUFDckIsU0FBU0UsbUJBQW1CQyxPQUFPO0lBQy9CLHNDQUFzQztJQUN0QywyRUFBMkU7SUFDM0UsT0FBTztJQUNQQSxVQUFVQSxRQUFRQyxXQUFXO0lBQzdCLE1BQU1DLFFBQVFGLFFBQVFHLFNBQVMsQ0FBQyxHQUFHQyxLQUFLLENBQUM7SUFDekMsTUFBTUMsV0FBVyxJQUFJQyxXQUFXO0lBQ2hDLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJLElBQUlBLElBQUs7UUFDekJGLFFBQVEsQ0FBQ0UsRUFBRSxHQUFHTCxLQUFLLENBQUNLLEVBQUUsQ0FBQ0MsVUFBVSxDQUFDO0lBQ3RDO0lBQ0EsTUFBTUMsU0FBU2YseURBQVFBLENBQUNELDJEQUFTQSxDQUFDWTtJQUNsQyxJQUFLLElBQUlFLElBQUksR0FBR0EsSUFBSSxJQUFJQSxLQUFLLEVBQUc7UUFDNUIsSUFBSSxNQUFPLENBQUNBLEtBQUssRUFBRSxJQUFJLEtBQU0sR0FBRztZQUM1QkwsS0FBSyxDQUFDSyxFQUFFLEdBQUdMLEtBQUssQ0FBQ0ssRUFBRSxDQUFDRyxXQUFXO1FBQ25DO1FBQ0EsSUFBSSxDQUFDRCxNQUFNLENBQUNGLEtBQUssRUFBRSxHQUFHLElBQUcsS0FBTSxHQUFHO1lBQzlCTCxLQUFLLENBQUNLLElBQUksRUFBRSxHQUFHTCxLQUFLLENBQUNLLElBQUksRUFBRSxDQUFDRyxXQUFXO1FBQzNDO0lBQ0o7SUFDQSxPQUFPLE9BQU9SLE1BQU1TLElBQUksQ0FBQztBQUM3QjtBQUNBLHVFQUF1RTtBQUN2RSxzQkFBc0I7QUFDdEIsTUFBTUMsYUFBYSxDQUFDO0FBQ3BCLElBQUssSUFBSUwsSUFBSSxHQUFHQSxJQUFJLElBQUlB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QUNNLFNBQVNnQyxlQUFlaEMsT0FBTztJQUNsQywyRUFBMkU7SUFDM0UsSUFBSWlDLFNBQVNwQyxPQUFPK0IsV0FBVzVCLFVBQVUrQixRQUFRLENBQUMsSUFBSXJCLFdBQVc7SUFDakUsTUFBT3VCLE9BQU9kLE1BQU0sR0FBRyxHQUFJO1FBQ3ZCYyxTQUFTLE1BQU1BO0lBQ25CO0lBQ0EsT0FBTyxPQUFPakIsYUFBYSxTQUFTaUIsVUFBVUE7QUFDbEQsRUFDQSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FkZHJlc3MvYWRkcmVzcy5qcz9hMTk3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbmltcG9ydCB7IGdldEJ5dGVzLCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmNvbnN0IEJOXzM2ID0gQmlnSW50KDM2KTtcbmZ1bmN0aW9uIGdldENoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgLy8gICAgaWYgKCFpc0hleFN0cmluZyhhZGRyZXNzLCAyMCkpIHtcbiAgICAvLyAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWRkcmVzc1wiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgLy8gICAgfVxuICAgIGFkZHJlc3MgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgY2hhcnMgPSBhZGRyZXNzLnN1YnN0cmluZygyKS5zcGxpdChcIlwiKTtcbiAgICBjb25zdCBleHBhbmRlZCA9IG5ldyBVaW50OEFycmF5KDQwKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQwOyBpKyspIHtcbiAgICAgICAgZXhwYW5kZWRbaV0gPSBjaGFyc1tpXS5jaGFyQ29kZUF0KDApO1xuICAgIH1cbiAgICBjb25zdCBoYXNoZWQgPSBnZXRCeXRlcyhrZWNjYWsyNTYoZXhwYW5kZWQpKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQwOyBpICs9IDIpIHtcbiAgICAgICAgaWYgKChoYXNoZWRbaSA+PiAxXSA+PiA0KSA+PSA4KSB7XG4gICAgICAgICAgICBjaGFyc1tpXSA9IGNoYXJzW2ldLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChoYXNoZWRbaSA+PiAxXSAmIDB4MGYpID49IDgpIHtcbiAgICAgICAgICAgIGNoYXJzW2kgKyAxXSA9IGNoYXJzW2kgKyAxXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyBjaGFycy5qb2luKFwiXCIpO1xufVxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnRlcm5hdGlvbmFsX0JhbmtfQWNjb3VudF9OdW1iZXJcbi8vIENyZWF0ZSBsb29rdXAgdGFibGVcbmNvbnN0IGliYW5Mb29rdXAgPSB7fTtcbmZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgIGliYW5Mb29rdXBbU3RyaW5nKGkpXSA9IFN0cmluZyhpKTtcbn1cbmZvciAobGV0IGkgPSAwOyBpIDwgMjY7IGkrKykge1xuICAgIGliYW5Mb29rdXBbU3RyaW5nLmZyb21DaGFyQ29kZSg2NSArIGkpXSA9IFN0cmluZygxMCArIGkpO1xufVxuLy8gSG93IG1hbnkgZGVjaW1hbCBkaWdpdHMgY2FuIHdlIHByb2Nlc3M/IChmb3IgNjQtYml0IGZsb2F0LCB0aGlzIGlzIDE1KVxuLy8gaS5lLiBNYXRoLmZsb29yKE1hdGgubG9nMTAoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpKTtcbmNvbnN0IHNhZmVEaWdpdHMgPSAxNTtcbmZ1bmN0aW9uIGliYW5DaGVja3N1bShhZGRyZXNzKSB7XG4gICAgYWRkcmVzcyA9IGFkZHJlc3MudG9VcHBlckNhc2UoKTtcbiAgICBhZGRyZXNzID0gYWRkcmVzcy5zdWJzdHJpbmcoNCkgKyBhZGRyZXNzLnN1YnN0cmluZygwLCAyKSArIFwiMDBcIjtcbiAgICBsZXQgZXhwYW5kZWQgPSBhZGRyZXNzLnNwbGl0KFwiXCIpLm1hcCgoYykgPT4geyByZXR1cm4gaWJhbkxvb2t1cFtjXTsgfSkuam9pbihcIlwiKTtcbiAgICAvLyBKYXZhc2NyaXB0IGNhbiBoYW5kbGUgaW50ZWdlcnMgc2FmZWx5IHVwIHRvIDE1IChkZWNpbWFsKSBkaWdpdHNcbiAgICB3aGlsZSAoZXhwYW5kZWQubGVuZ3RoID49IHNhZmVEaWdpdHMpIHtcbiAgICAgICAgbGV0IGJsb2NrID0gZXhwYW5kZWQuc3Vic3RyaW5nKDAsIHNhZmVEaWdpdHMpO1xuICAgICAgICBleHBhbmRlZCA9IHBhcnNlSW50KGJsb2NrLCAxMCkgJSA5NyArIGV4cGFuZGVkLnN1YnN0cmluZyhibG9jay5sZW5ndGgpO1xuICAgIH1cbiAgICBsZXQgY2hlY2tzdW0gPSBTdHJpbmcoOTggLSAocGFyc2VJbnQoZXhwYW5kZWQsIDEwKSAlIDk3KSk7XG4gICAgd2hpbGUgKGNoZWNrc3VtLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgY2hlY2tzdW0gPSBcIjBcIiArIGNoZWNrc3VtO1xuICAgIH1cbiAgICByZXR1cm4gY2hlY2tzdW07XG59XG47XG5jb25zdCBCYXNlMzYgPSAoZnVuY3Rpb24gKCkge1xuICAgIDtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM2OyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIltpXTtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBCaWdJbnQoaSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59KSgpO1xuZnVuY3Rpb24gZnJvbUJhc2UzNih2YWx1ZSkge1xuICAgIHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICBsZXQgcmVzdWx0ID0gQk5fMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCAqIEJOXzM2ICsgQmFzZTM2W3ZhbHVlW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogIFJldHVybnMgYSBub3JtYWxpemVkIGFuZCBjaGVja3N1bWVkIGFkZHJlc3MgZm9yICUlYWRkcmVzcyUlLlxuICogIFRoaXMgYWNjZXB0cyBub24tY2hlY2tzdW0gYWRkcmVzc2VzLCBjaGVja3N1bSBhZGRyZXNzZXMgYW5kXG4gKiAgW1tnZXRJY2FwQWRkcmVzc11dIGZvcm1hdHMuXG4gKlxuICogIFRoZSBjaGVja3N1bSBpbiBFdGhlcmV1bSB1c2VzIHRoZSBjYXBpdGFsaXphdGlvbiAodXBwZXItY2FzZVxuICogIHZzIGxvd2VyLWNhc2UpIG9mIHRoZSBjaGFyYWN0ZXJzIHdpdGhpbiBhbiBhZGRyZXNzIHRvIGVuY29kZVxuICogIGl0cyBjaGVja3N1bSwgd2hpY2ggb2ZmZXJzLCBvbiBhdmVyYWdlLCBhIGNoZWNrc3VtIG9mIDE1LWJpdHMuXG4gKlxuICogIElmICUlYWRkcmVzcyUlIGNvbnRhaW5zIGJvdGggdXBwZXItY2FzZSBhbmQgbG93ZXItY2FzZSwgaXQgaXNcbiAqICBhc3N1bWVkIHRvIGFscmVhZHkgYmUgYSBjaGVja3N1bSBhZGRyZXNzIGFuZCBpdHMgY2hlY2tzdW0gaXNcbiAqICB2YWxpZGF0ZWQsIGFuZCBpZiB0aGUgYWRkcmVzcyBmYWlscyBpdHMgZXhwZWN0ZWQgY2hlY2tzdW0gYW5cbiAqICBlcnJvciBpcyB0aHJvd24uXG4gKlxuICogIElmIHlvdSB3aXNoIHRoZSBjaGVja3N1bSBvZiAlJWFkZHJlc3MlJSB0byBiZSBpZ25vcmUsIGl0IHNob3VsZFxuICogIGJlIGNvbnZlcnRlZCB0byBsb3dlci1jYXNlIChpLmUuIGBgLnRvTG93ZXJjYXNlKClgYCkgYmVmb3JlXG4gKiAgYmVpbmcgcGFzc2VkIGluLiBUaGlzIHNob3VsZCBiZSBhIHZlcnkgcmFyZSBzaXR1YXRpb24gdGhvdWdoLFxuICogIHRoYXQgeW91IHdpc2ggdG8gYnlwYXNzIHRoZSBzYWZlZ2F1cmRzIGluIHBsYWNlIHRvIHByb3RlY3RcbiAqICBhZ2FpbnN0IGFuIGFkZHJlc3MgdGhhdCBoYXMgYmVlbiBpbmNvcnJlY3RseSBjb3BpZWQgZnJvbSBhbm90aGVyXG4gKiAgc291cmNlLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIC8vIEFkZHMgdGhlIGNoZWNrc3VtICh2aWEgdXBwZXItY2FzaW5nIHNwZWNpZmljIGxldHRlcnMpXG4gKiAgICBnZXRBZGRyZXNzKFwiMHg4YmExZjEwOTU1MWJkNDMyODAzMDEyNjQ1YWMxMzZkZGQ2NGRiYTcyXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gQ29udmVydHMgSUNBUCBhZGRyZXNzIGFuZCBhZGRzIGNoZWNrc3VtXG4gKiAgICBnZXRBZGRyZXNzKFwiWEU2NUdCNkxETlhZT0ZUWDBOU1YzRlVXS09XSVhBTUpLMzZcIik7XG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gVGhyb3dzIGFuIGVycm9yIGlmIGFuIGFkZHJlc3MgY29udGFpbnMgbWl4ZWQgY2FzZSxcbiAqICAgIC8vIGJ1dCB0aGUgY2hlY2tzdW0gZmFpbHNcbiAqICAgIGdldEFkZHJlc3MoXCIweDhCYTFmMTA5NTUxYkQ0MzI4MDMwMTI2NDVBYzEzNmRkZDY0REJBNzJcIilcbiAqICAgIC8vX2Vycm9yOlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChhZGRyZXNzKSA9PT0gXCJzdHJpbmdcIiwgXCJpbnZhbGlkIGFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuICAgIGlmIChhZGRyZXNzLm1hdGNoKC9eKDB4KT9bMC05YS1mQS1GXXs0MH0kLykpIHtcbiAgICAgICAgLy8gTWlzc2luZyB0aGUgMHggcHJlZml4XG4gICAgICAgIGlmICghYWRkcmVzcy5zdGFydHNXaXRoKFwiMHhcIikpIHtcbiAgICAgICAgICAgIGFkZHJlc3MgPSBcIjB4XCIgKyBhZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGdldENoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgLy8gSXQgaXMgYSBjaGVja3N1bW1lZCBhZGRyZXNzIHdpdGggYSBiYWQgY2hlY2tzdW1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoIWFkZHJlc3MubWF0Y2goLyhbQS1GXS4qW2EtZl0pfChbYS1mXS4qW0EtRl0pLykgfHwgcmVzdWx0ID09PSBhZGRyZXNzLCBcImJhZCBhZGRyZXNzIGNoZWNrc3VtXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gTWF5YmUgSUNBUD8gKHdlIG9ubHkgc3VwcG9ydCBkaXJlY3QgbW9kZSlcbiAgICBpZiAoYWRkcmVzcy5tYXRjaCgvXlhFWzAtOV17Mn1bMC05QS1aYS16XXszMCwzMX0kLykpIHtcbiAgICAgICAgLy8gSXQgaXMgYW4gSUNBUCBhZGRyZXNzIHdpdGggYSBiYWQgY2hlY2tzdW1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoYWRkcmVzcy5zdWJzdHJpbmcoMiwgNCkgPT09IGliYW5DaGVja3N1bShhZGRyZXNzKSwgXCJiYWQgaWNhcCBjaGVja3N1bVwiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgICAgIGxldCByZXN1bHQgPSBmcm9tQmFzZTM2KGFkZHJlc3Muc3Vic3RyaW5nKDQpKS50b1N0cmluZygxNik7XG4gICAgICAgIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgNDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRDaGVja3N1bUFkZHJlc3MoXCIweFwiICsgcmVzdWx0KTtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBhZGRyZXNzXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbn1cbi8qKlxuICogIFRoZSBbSUNBUCBBZGRyZXNzIGZvcm1hdF0obGluay1pY2FwKSBmb3JtYXQgaXMgYW4gZWFybHkgY2hlY2tzdW1cbiAqICBmb3JtYXQgd2hpY2ggYXR0ZW1wdHMgdG8gYmUgY29tcGF0aWJsZSB3aXRoIHRoZSBiYW5raW5nXG4gKiAgaW5kdXN0cnkgW0lCQU4gZm9ybWF0XShsaW5rLXdpa2ktaWJhbikgZm9yIGJhbmsgYWNjb3VudHMuXG4gKlxuICogIEl0IGlzIG5vIGxvbmdlciBjb21tb24gb3IgYSByZWNvbW1lbmRlZCBmb3JtYXQuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgZ2V0SWNhcEFkZHJlc3MoXCIweDhiYTFmMTA5NTUxYmQ0MzI4MDMwMTI2NDVhYzEzNmRkZDY0ZGJhNzJcIik7XG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgZ2V0SWNhcEFkZHJlc3MoXCJYRTY1R0I2TEROWFlPRlRYME5TVjNGVVdLT1dJWEFNSkszNlwiKTtcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIElDQVAgY2hlY2tzdW0gaXMgd3JvbmdcbiAqICAgIGdldEljYXBBZGRyZXNzKFwiWEU2NUdCNkxETlhZT0ZUWDBOU1YzRlVXS09XSVhBTUpLMzdcIik7XG4gKiAgICAvL19lcnJvcjpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEljYXBBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICAvL2xldCBiYXNlMzYgPSBfYmFzZTE2VG8zNihnZXRBZGRyZXNzKGFkZHJlc3MpLnN1YnN0cmluZygyKSkudG9VcHBlckNhc2UoKTtcbiAgICBsZXQgYmFzZTM2ID0gQmlnSW50KGdldEFkZHJlc3MoYWRkcmVzcykpLnRvU3RyaW5nKDM2KS50b1VwcGVyQ2FzZSgpO1xuICAgIHdoaWxlIChiYXNlMzYubGVuZ3RoIDwgMzApIHtcbiAgICAgICAgYmFzZTM2ID0gXCIwXCIgKyBiYXNlMzY7XG4gICAgfVxuICAgIHJldHVybiBcIlhFXCIgKyBpYmFuQ2hlY2tzdW0oXCJYRTAwXCIgKyBiYXNlMzYpICsgYmFzZTM2O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkcmVzcy5qcy5tYXAiXSwibmFtZXMiOlsia2VjY2FrMjU2IiwiZ2V0Qnl0ZXMiLCJhc3NlcnRBcmd1bWVudCIsIkJOXzAiLCJCaWdJbnQiLCJCTl8zNiIsImdldENoZWNrc3VtQWRkcmVzcyIsImFkZHJlc3MiLCJ0b0xvd2VyQ2FzZSIsImNoYXJzIiwic3Vic3RyaW5nIiwic3BsaXQiLCJleHBhbmRlZCIsIlVpbnQ4QXJyYXkiLCJpIiwiY2hhckNvZGVBdCIsImhhc2hlZCIsInRvVXBwZXJDYXNlIiwiam9pbiIsImliYW5Mb29rdXAiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJzYWZlRGlnaXRzIiwiaWJhbkNoZWNrc3VtIiwibWFwIiwiYyIsImxlbmd0aCIsImJsb2NrIiwicGFyc2VJbnQiLCJjaGVja3N1bSIsIkJhc2UzNiIsInJlc3VsdCIsImtleSIsImZyb21CYXNlMzYiLCJ2YWx1ZSIsImdldEFkZHJlc3MiLCJtYXRjaCIsInN0YXJ0c1dpdGgiLCJ0b1N0cmluZyIsImdldEljYXBBZGRyZXNzIiwiYmFzZTM2Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/address/address.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/address/checks.js":
/*!*******************************************************!*\
  !*** ./node_modules/ethers/lib.esm/address/checks.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isAddress: function() { return /* binding */ isAddress; },\n/* harmony export */   isAddressable: function() { return /* binding */ isAddressable; },\n/* harmony export */   resolveAddress: function() { return /* binding */ resolveAddress; }\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _address_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./address.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/address/address.js\");\n\n\n/**\n *  Returns true if %%value%% is an object which implements the\n *  [[Addressable]] interface.\n *\n *  @example:\n *    // Wallets and AbstractSigner sub-classes\n *    isAddressable(Wallet.createRandom())\n *    //_result:\n *\n *    // Contracts\n *    contract = new Contract(\"dai.tokens.ethers.eth\", [ ], provider)\n *    isAddressable(contract)\n *    //_result:\n */ function isAddressable(value) {\n    return value && typeof value.getAddress === \"function\";\n}\n/**\n *  Returns true if %%value%% is a valid address.\n *\n *  @example:\n *    // Valid address\n *    isAddress(\"0x8ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_result:\n *\n *    // Valid ICAP address\n *    isAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\")\n *    //_result:\n *\n *    // Invalid checksum\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBa72\")\n *    //_result:\n *\n *    // Invalid ICAP checksum\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_result:\n *\n *    // Not an address (an ENS name requires a provided and an\n *    // asynchronous API to access)\n *    isAddress(\"ricmoo.eth\")\n *    //_result:\n */ function isAddress(value) {\n    try {\n        (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(value);\n        return true;\n    } catch (error) {}\n    return false;\n}\nasync function checkAddress(target, promise) {\n    const result = await promise;\n    if (result == null || result === \"0x0000000000000000000000000000000000000000\") {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(typeof target !== \"string\", \"unconfigured name\", \"UNCONFIGURED_NAME\", {\n            value: target\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid AddressLike value; did not resolve to a value address\", \"target\", target);\n    }\n    return (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(result);\n}\n/**\n *  Resolves to an address for the %%target%%, which may be any\n *  supported address type, an [[Addressable]] or a Promise which\n *  resolves to an address.\n *\n *  If an ENS name is provided, but that name has not been correctly\n *  configured a [[UnconfiguredNameError]] is thrown.\n *\n *  @example:\n *    addr = \"0x6B175474E89094C44Da98b954EedeAC495271d0F\"\n *\n *    // Addresses are return synchronously\n *    resolveAddress(addr, provider)\n *    //_result:\n *\n *    // Address promises are resolved asynchronously\n *    resolveAddress(Promise.resolve(addr))\n *    //_result:\n *\n *    // ENS names are resolved asynchronously\n *    resolveAddress(\"dai.tokens.ethers.eth\", provider)\n *    //_result:\n *\n *    // Addressable objects are resolved asynchronously\n *    contract = new Contract(addr, [ ])\n *    resolveAddress(contract, provider)\n *    //_result:\n *\n *    // Unconfigured ENS names reject\n *    resolveAddress(\"nothing-here.ricmoo.eth\", provider)\n *    //_error:\n *\n *    // ENS names require a NameResolver object passed in\n *    // (notice the provider was omitted)\n *    resolveAddress(\"nothing-here.ricmoo.eth\")\n *    //_error:\n */ function resolveAddress(target, resolver) {\n    if (typeof target === \"string\") {\n        if (target.match(/^0x[0-9a-f]{40}$/i)) {\n            return (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(target);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(resolver != null, \"ENS resolution requires a provider\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"resolveName\"\n        });\n        return checkAddress(target, resolver.resolveName(target));\n    } else if (isAddressable(target)) {\n        return checkAddress(target, target.getAddress());\n    } else if (target && typeof target.then === \"function\") {\n        return checkAddress(target, target);\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"unsupported addressable value\", \"target\", target);\n} //# sourceMappingURL=checks.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hZGRyZXNzL2NoZWNrcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEyRDtBQUNqQjtBQUMxQzs7Ozs7Ozs7Ozs7OztDQWFDLEdBQ00sU0FBU0csY0FBY0MsS0FBSztJQUMvQixPQUFRQSxTQUFTLE9BQVFBLE1BQU1GLFVBQVUsS0FBTTtBQUNuRDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F3QkMsR0FDTSxTQUFTRyxVQUFVRCxLQUFLO0lBQzNCLElBQUk7UUFDQUYsdURBQVVBLENBQUNFO1FBQ1gsT0FBTztJQUNYLEVBQ0EsT0FBT0UsT0FBTyxDQUFFO0lBQ2hCLE9BQU87QUFDWDtBQUNBLGVBQWVDLGFBQWFDLE1BQU0sRUFBRUMsT0FBTztJQUN2QyxNQUFNQyxTQUFTLE1BQU1EO0lBQ3JCLElBQUlDLFVBQVUsUUFBUUEsV0FBVyw4Q0FBOEM7UUFDM0VWLHVEQUFNQSxDQUFDLE9BQVFRLFdBQVksVUFBVSxxQkFBcUIscUJBQXFCO1lBQUVKLE9BQU9JO1FBQU87UUFDL0ZQLCtEQUFjQSxDQUFDLE9BQU8saUVBQWlFLFVBQVVPO0lBQ3JHO0lBQ0EsT0FBT04sdURBQVVBLENBQUNRO0FBQ3RCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW9DQyxHQUNNLFNBQVNDLGVBQWVILE1BQU0sRUFBRUksUUFBUTtJQUMzQyxJQUFJLE9BQVFKLFdBQVksVUFBVTtRQUM5QixJQUFJQSxPQUFPSyxLQUFLLENBQUMsc0JBQXNCO1lBQ25DLE9BQU9YLHVEQUFVQSxDQUFDTTtRQUN0QjtRQUNBUix1REFBTUEsQ0FBQ1ksWUFBWSxNQUFNLHNDQUFzQyx5QkFBeUI7WUFBRUUsV0FBVztRQUFjO1FBQ25ILE9BQU9QLGFBQWFDLFFBQVFJLFNBQVNHLFdBQVcsQ0FBQ1A7SUFDckQsT0FDSyxJQUFJTCxjQUFjSyxTQUFTO1FBQzVCLE9BQU9ELGFBQWFDLFFBQVFBLE9BQU9OLFVBQVU7SUFDakQsT0FDSyxJQUFJTSxVQUFVLE9BQVFBLE9BQU9RLElBQUksS0FBTSxZQUFZO1FBQ3BELE9BQU9ULGFBQWFDLFFBQVFBO0lBQ2hDO0lBQ0FQLCtEQUFjQSxDQUFDLE9BQU8saUNBQWlDLFVBQVVPO0FBQ3JFLEVBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hZGRyZXNzL2NoZWNrcy5qcz84NDcyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi9hZGRyZXNzLmpzXCI7XG4vKipcbiAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGFuIG9iamVjdCB3aGljaCBpbXBsZW1lbnRzIHRoZVxuICogIFtbQWRkcmVzc2FibGVdXSBpbnRlcmZhY2UuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgLy8gV2FsbGV0cyBhbmQgQWJzdHJhY3RTaWduZXIgc3ViLWNsYXNzZXNcbiAqICAgIGlzQWRkcmVzc2FibGUoV2FsbGV0LmNyZWF0ZVJhbmRvbSgpKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIENvbnRyYWN0c1xuICogICAgY29udHJhY3QgPSBuZXcgQ29udHJhY3QoXCJkYWkudG9rZW5zLmV0aGVycy5ldGhcIiwgWyBdLCBwcm92aWRlcilcbiAqICAgIGlzQWRkcmVzc2FibGUoY29udHJhY3QpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FkZHJlc3NhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLmdldEFkZHJlc3MpID09PSBcImZ1bmN0aW9uXCIpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhIHZhbGlkIGFkZHJlc3MuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgLy8gVmFsaWQgYWRkcmVzc1xuICogICAgaXNBZGRyZXNzKFwiMHg4YmExZjEwOTU1MWJENDMyODAzMDEyNjQ1QWMxMzZkZGQ2NERCQTcyXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gVmFsaWQgSUNBUCBhZGRyZXNzXG4gKiAgICBpc0FkZHJlc3MoXCJYRTY1R0I2TEROWFlPRlRYME5TVjNGVVdLT1dJWEFNSkszNlwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEludmFsaWQgY2hlY2tzdW1cbiAqICAgIGlzQWRkcmVzcyhcIjB4OEJhMWYxMDk1NTFiRDQzMjgwMzAxMjY0NUFjMTM2ZGRkNjREQmE3MlwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEludmFsaWQgSUNBUCBjaGVja3N1bVxuICogICAgaXNBZGRyZXNzKFwiMHg4QmExZjEwOTU1MWJENDMyODAzMDEyNjQ1QWMxMzZkZGQ2NERCQTcyXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gTm90IGFuIGFkZHJlc3MgKGFuIEVOUyBuYW1lIHJlcXVpcmVzIGEgcHJvdmlkZWQgYW5kIGFuXG4gKiAgICAvLyBhc3luY2hyb25vdXMgQVBJIHRvIGFjY2VzcylcbiAqICAgIGlzQWRkcmVzcyhcInJpY21vby5ldGhcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQWRkcmVzcyh2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGdldEFkZHJlc3ModmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5hc3luYyBmdW5jdGlvbiBjaGVja0FkZHJlc3ModGFyZ2V0LCBwcm9taXNlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvbWlzZTtcbiAgICBpZiAocmVzdWx0ID09IG51bGwgfHwgcmVzdWx0ID09PSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiKSB7XG4gICAgICAgIGFzc2VydCh0eXBlb2YgKHRhcmdldCkgIT09IFwic3RyaW5nXCIsIFwidW5jb25maWd1cmVkIG5hbWVcIiwgXCJVTkNPTkZJR1VSRURfTkFNRVwiLCB7IHZhbHVlOiB0YXJnZXQgfSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgQWRkcmVzc0xpa2UgdmFsdWU7IGRpZCBub3QgcmVzb2x2ZSB0byBhIHZhbHVlIGFkZHJlc3NcIiwgXCJ0YXJnZXRcIiwgdGFyZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEFkZHJlc3MocmVzdWx0KTtcbn1cbi8qKlxuICogIFJlc29sdmVzIHRvIGFuIGFkZHJlc3MgZm9yIHRoZSAlJXRhcmdldCUlLCB3aGljaCBtYXkgYmUgYW55XG4gKiAgc3VwcG9ydGVkIGFkZHJlc3MgdHlwZSwgYW4gW1tBZGRyZXNzYWJsZV1dIG9yIGEgUHJvbWlzZSB3aGljaFxuICogIHJlc29sdmVzIHRvIGFuIGFkZHJlc3MuXG4gKlxuICogIElmIGFuIEVOUyBuYW1lIGlzIHByb3ZpZGVkLCBidXQgdGhhdCBuYW1lIGhhcyBub3QgYmVlbiBjb3JyZWN0bHlcbiAqICBjb25maWd1cmVkIGEgW1tVbmNvbmZpZ3VyZWROYW1lRXJyb3JdXSBpcyB0aHJvd24uXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgYWRkciA9IFwiMHg2QjE3NTQ3NEU4OTA5NEM0NERhOThiOTU0RWVkZUFDNDk1MjcxZDBGXCJcbiAqXG4gKiAgICAvLyBBZGRyZXNzZXMgYXJlIHJldHVybiBzeW5jaHJvbm91c2x5XG4gKiAgICByZXNvbHZlQWRkcmVzcyhhZGRyLCBwcm92aWRlcilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBBZGRyZXNzIHByb21pc2VzIGFyZSByZXNvbHZlZCBhc3luY2hyb25vdXNseVxuICogICAgcmVzb2x2ZUFkZHJlc3MoUHJvbWlzZS5yZXNvbHZlKGFkZHIpKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEVOUyBuYW1lcyBhcmUgcmVzb2x2ZWQgYXN5bmNocm9ub3VzbHlcbiAqICAgIHJlc29sdmVBZGRyZXNzKFwiZGFpLnRva2Vucy5ldGhlcnMuZXRoXCIsIHByb3ZpZGVyKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEFkZHJlc3NhYmxlIG9iamVjdHMgYXJlIHJlc29sdmVkIGFzeW5jaHJvbm91c2x5XG4gKiAgICBjb250cmFjdCA9IG5ldyBDb250cmFjdChhZGRyLCBbIF0pXG4gKiAgICByZXNvbHZlQWRkcmVzcyhjb250cmFjdCwgcHJvdmlkZXIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gVW5jb25maWd1cmVkIEVOUyBuYW1lcyByZWplY3RcbiAqICAgIHJlc29sdmVBZGRyZXNzKFwibm90aGluZy1oZXJlLnJpY21vby5ldGhcIiwgcHJvdmlkZXIpXG4gKiAgICAvL19lcnJvcjpcbiAqXG4gKiAgICAvLyBFTlMgbmFtZXMgcmVxdWlyZSBhIE5hbWVSZXNvbHZlciBvYmplY3QgcGFzc2VkIGluXG4gKiAgICAvLyAobm90aWNlIHRoZSBwcm92aWRlciB3YXMgb21pdHRlZClcbiAqICAgIHJlc29sdmVBZGRyZXNzKFwibm90aGluZy1oZXJlLnJpY21vby5ldGhcIilcbiAqICAgIC8vX2Vycm9yOlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUFkZHJlc3ModGFyZ2V0LCByZXNvbHZlcikge1xuICAgIGlmICh0eXBlb2YgKHRhcmdldCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHRhcmdldC5tYXRjaCgvXjB4WzAtOWEtZl17NDB9JC9pKSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEFkZHJlc3ModGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQocmVzb2x2ZXIgIT0gbnVsbCwgXCJFTlMgcmVzb2x1dGlvbiByZXF1aXJlcyBhIHByb3ZpZGVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInJlc29sdmVOYW1lXCIgfSk7XG4gICAgICAgIHJldHVybiBjaGVja0FkZHJlc3ModGFyZ2V0LCByZXNvbHZlci5yZXNvbHZlTmFtZSh0YXJnZXQpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNBZGRyZXNzYWJsZSh0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybiBjaGVja0FkZHJlc3ModGFyZ2V0LCB0YXJnZXQuZ2V0QWRkcmVzcygpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGFyZ2V0ICYmIHR5cGVvZiAodGFyZ2V0LnRoZW4pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrQWRkcmVzcyh0YXJnZXQsIHRhcmdldCk7XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVuc3VwcG9ydGVkIGFkZHJlc3NhYmxlIHZhbHVlXCIsIFwidGFyZ2V0XCIsIHRhcmdldCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGVja3MuanMubWFwIl0sIm5hbWVzIjpbImFzc2VydCIsImFzc2VydEFyZ3VtZW50IiwiZ2V0QWRkcmVzcyIsImlzQWRkcmVzc2FibGUiLCJ2YWx1ZSIsImlzQWRkcmVzcyIsImVycm9yIiwiY2hlY2tBZGRyZXNzIiwidGFyZ2V0IiwicHJvbWlzZSIsInJlc3VsdCIsInJlc29sdmVBZGRyZXNzIiwicmVzb2x2ZXIiLCJtYXRjaCIsIm9wZXJhdGlvbiIsInJlc29sdmVOYW1lIiwidGhlbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/address/checks.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/address/contract-address.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/address/contract-address.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCreate2Address: function() { return /* binding */ getCreate2Address; },\n/* harmony export */   getCreateAddress: function() { return /* binding */ getCreateAddress; }\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../crypto/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/rlp-encode.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _address_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./address.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/address/address.js\");\n\n\n\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\n/**\n *  Returns the address that would result from a ``CREATE`` for %%tx%%.\n *\n *  This can be used to compute the address a contract will be\n *  deployed to by an EOA when sending a deployment transaction (i.e.\n *  when the ``to`` address is ``null``).\n *\n *  This can also be used to compute the address a contract will be\n *  deployed to by a contract, by using the contract's address as the\n *  ``to`` and the contract's nonce.\n *\n *  @example\n *    from = \"0x8ba1f109551bD432803012645Ac136ddd64DBA72\";\n *    nonce = 5;\n *\n *    getCreateAddress({ from, nonce });\n *    //_result:\n */ function getCreateAddress(tx) {\n    const from = (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(tx.from);\n    const nonce = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(tx.nonce, \"tx.nonce\");\n    let nonceHex = nonce.toString(16);\n    if (nonceHex === \"0\") {\n        nonceHex = \"0x\";\n    } else if (nonceHex.length % 2) {\n        nonceHex = \"0x0\" + nonceHex;\n    } else {\n        nonceHex = \"0x\" + nonceHex;\n    }\n    return (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.dataSlice)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.encodeRlp)([\n        from,\n        nonceHex\n    ])), 12));\n}\n/**\n *  Returns the address that would result from a ``CREATE2`` operation\n *  with the given %%from%%, %%salt%% and %%initCodeHash%%.\n *\n *  To compute the %%initCodeHash%% from a contract's init code, use\n *  the [[keccak256]] function.\n *\n *  For a quick overview and example of ``CREATE2``, see [[link-ricmoo-wisps]].\n *\n *  @example\n *    // The address of the contract\n *    from = \"0x8ba1f109551bD432803012645Ac136ddd64DBA72\"\n *\n *    // The salt\n *    salt = id(\"HelloWorld\")\n *\n *    // The hash of the initCode\n *    initCode = \"0x6394198df16000526103ff60206004601c335afa6040516060f3\";\n *    initCodeHash = keccak256(initCode)\n *\n *    getCreate2Address(from, salt, initCodeHash)\n *    //_result:\n */ function getCreate2Address(_from, _salt, _initCodeHash) {\n    const from = (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(_from);\n    const salt = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(_salt, \"salt\");\n    const initCodeHash = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(_initCodeHash, \"initCodeHash\");\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.assertArgument)(salt.length === 32, \"salt must be 32 bytes\", \"salt\", _salt);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.assertArgument)(initCodeHash.length === 32, \"initCodeHash must be 32 bytes\", \"initCodeHash\", _initCodeHash);\n    return (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.dataSlice)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.concat)([\n        \"0xff\",\n        from,\n        salt,\n        initCodeHash\n    ])), 12));\n} //# sourceMappingURL=contract-address.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hZGRyZXNzL2NvbnRyYWN0LWFkZHJlc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBK0M7QUFDdUQ7QUFDNUQ7QUFDMUMsc0dBQXNHO0FBQ3RHOzs7Ozs7Ozs7Ozs7Ozs7OztDQWlCQyxHQUNNLFNBQVNRLGlCQUFpQkMsRUFBRTtJQUMvQixNQUFNQyxPQUFPSCx1REFBVUEsQ0FBQ0UsR0FBR0MsSUFBSTtJQUMvQixNQUFNQyxRQUFRUiwwREFBU0EsQ0FBQ00sR0FBR0UsS0FBSyxFQUFFO0lBQ2xDLElBQUlDLFdBQVdELE1BQU1FLFFBQVEsQ0FBQztJQUM5QixJQUFJRCxhQUFhLEtBQUs7UUFDbEJBLFdBQVc7SUFDZixPQUNLLElBQUlBLFNBQVNFLE1BQU0sR0FBRyxHQUFHO1FBQzFCRixXQUFXLFFBQVFBO0lBQ3ZCLE9BQ0s7UUFDREEsV0FBVyxPQUFPQTtJQUN0QjtJQUNBLE9BQU9MLHVEQUFVQSxDQUFDTCwwREFBU0EsQ0FBQ0YsMkRBQVNBLENBQUNLLDBEQUFTQSxDQUFDO1FBQUNLO1FBQU1FO0tBQVMsSUFBSTtBQUN4RTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBc0JDLEdBQ00sU0FBU0csa0JBQWtCQyxLQUFLLEVBQUVDLEtBQUssRUFBRUMsYUFBYTtJQUN6RCxNQUFNUixPQUFPSCx1REFBVUEsQ0FBQ1M7SUFDeEIsTUFBTUcsT0FBT2YseURBQVFBLENBQUNhLE9BQU87SUFDN0IsTUFBTUcsZUFBZWhCLHlEQUFRQSxDQUFDYyxlQUFlO0lBQzdDWiwrREFBY0EsQ0FBQ2EsS0FBS0wsTUFBTSxLQUFLLElBQUkseUJBQXlCLFFBQVFHO0lBQ3BFWCwrREFBY0EsQ0FBQ2MsYUFBYU4sTUFBTSxLQUFLLElBQUksaUNBQWlDLGdCQUFnQkk7SUFDNUYsT0FBT1gsdURBQVVBLENBQUNMLDBEQUFTQSxDQUFDRiwyREFBU0EsQ0FBQ0MsdURBQU1BLENBQUM7UUFBQztRQUFRUztRQUFNUztRQUFNQztLQUFhLElBQUk7QUFDdkYsRUFDQSw0Q0FBNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FkZHJlc3MvY29udHJhY3QtYWRkcmVzcy5qcz9jMGJhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbmltcG9ydCB7IGNvbmNhdCwgZGF0YVNsaWNlLCBnZXRCaWdJbnQsIGdldEJ5dGVzLCBlbmNvZGVSbHAsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4vYWRkcmVzcy5qc1wiO1xuLy8gaHR0cDovL2V0aGVyZXVtLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy83NjAvaG93LWlzLXRoZS1hZGRyZXNzLW9mLWFuLWV0aGVyZXVtLWNvbnRyYWN0LWNvbXB1dGVkXG4vKipcbiAqICBSZXR1cm5zIHRoZSBhZGRyZXNzIHRoYXQgd291bGQgcmVzdWx0IGZyb20gYSBgYENSRUFURWBgIGZvciAlJXR4JSUuXG4gKlxuICogIFRoaXMgY2FuIGJlIHVzZWQgdG8gY29tcHV0ZSB0aGUgYWRkcmVzcyBhIGNvbnRyYWN0IHdpbGwgYmVcbiAqICBkZXBsb3llZCB0byBieSBhbiBFT0Egd2hlbiBzZW5kaW5nIGEgZGVwbG95bWVudCB0cmFuc2FjdGlvbiAoaS5lLlxuICogIHdoZW4gdGhlIGBgdG9gYCBhZGRyZXNzIGlzIGBgbnVsbGBgKS5cbiAqXG4gKiAgVGhpcyBjYW4gYWxzbyBiZSB1c2VkIHRvIGNvbXB1dGUgdGhlIGFkZHJlc3MgYSBjb250cmFjdCB3aWxsIGJlXG4gKiAgZGVwbG95ZWQgdG8gYnkgYSBjb250cmFjdCwgYnkgdXNpbmcgdGhlIGNvbnRyYWN0J3MgYWRkcmVzcyBhcyB0aGVcbiAqICBgYHRvYGAgYW5kIHRoZSBjb250cmFjdCdzIG5vbmNlLlxuICpcbiAqICBAZXhhbXBsZVxuICogICAgZnJvbSA9IFwiMHg4YmExZjEwOTU1MWJENDMyODAzMDEyNjQ1QWMxMzZkZGQ2NERCQTcyXCI7XG4gKiAgICBub25jZSA9IDU7XG4gKlxuICogICAgZ2V0Q3JlYXRlQWRkcmVzcyh7IGZyb20sIG5vbmNlIH0pO1xuICogICAgLy9fcmVzdWx0OlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3JlYXRlQWRkcmVzcyh0eCkge1xuICAgIGNvbnN0IGZyb20gPSBnZXRBZGRyZXNzKHR4LmZyb20pO1xuICAgIGNvbnN0IG5vbmNlID0gZ2V0QmlnSW50KHR4Lm5vbmNlLCBcInR4Lm5vbmNlXCIpO1xuICAgIGxldCBub25jZUhleCA9IG5vbmNlLnRvU3RyaW5nKDE2KTtcbiAgICBpZiAobm9uY2VIZXggPT09IFwiMFwiKSB7XG4gICAgICAgIG5vbmNlSGV4ID0gXCIweFwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChub25jZUhleC5sZW5ndGggJSAyKSB7XG4gICAgICAgIG5vbmNlSGV4ID0gXCIweDBcIiArIG5vbmNlSGV4O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbm9uY2VIZXggPSBcIjB4XCIgKyBub25jZUhleDtcbiAgICB9XG4gICAgcmV0dXJuIGdldEFkZHJlc3MoZGF0YVNsaWNlKGtlY2NhazI1NihlbmNvZGVSbHAoW2Zyb20sIG5vbmNlSGV4XSkpLCAxMikpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgYWRkcmVzcyB0aGF0IHdvdWxkIHJlc3VsdCBmcm9tIGEgYGBDUkVBVEUyYGAgb3BlcmF0aW9uXG4gKiAgd2l0aCB0aGUgZ2l2ZW4gJSVmcm9tJSUsICUlc2FsdCUlIGFuZCAlJWluaXRDb2RlSGFzaCUlLlxuICpcbiAqICBUbyBjb21wdXRlIHRoZSAlJWluaXRDb2RlSGFzaCUlIGZyb20gYSBjb250cmFjdCdzIGluaXQgY29kZSwgdXNlXG4gKiAgdGhlIFtba2VjY2FrMjU2XV0gZnVuY3Rpb24uXG4gKlxuICogIEZvciBhIHF1aWNrIG92ZXJ2aWV3IGFuZCBleGFtcGxlIG9mIGBgQ1JFQVRFMmBgLCBzZWUgW1tsaW5rLXJpY21vby13aXNwc11dLlxuICpcbiAqICBAZXhhbXBsZVxuICogICAgLy8gVGhlIGFkZHJlc3Mgb2YgdGhlIGNvbnRyYWN0XG4gKiAgICBmcm9tID0gXCIweDhiYTFmMTA5NTUxYkQ0MzI4MDMwMTI2NDVBYzEzNmRkZDY0REJBNzJcIlxuICpcbiAqICAgIC8vIFRoZSBzYWx0XG4gKiAgICBzYWx0ID0gaWQoXCJIZWxsb1dvcmxkXCIpXG4gKlxuICogICAgLy8gVGhlIGhhc2ggb2YgdGhlIGluaXRDb2RlXG4gKiAgICBpbml0Q29kZSA9IFwiMHg2Mzk0MTk4ZGYxNjAwMDUyNjEwM2ZmNjAyMDYwMDQ2MDFjMzM1YWZhNjA0MDUxNjA2MGYzXCI7XG4gKiAgICBpbml0Q29kZUhhc2ggPSBrZWNjYWsyNTYoaW5pdENvZGUpXG4gKlxuICogICAgZ2V0Q3JlYXRlMkFkZHJlc3MoZnJvbSwgc2FsdCwgaW5pdENvZGVIYXNoKVxuICogICAgLy9fcmVzdWx0OlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3JlYXRlMkFkZHJlc3MoX2Zyb20sIF9zYWx0LCBfaW5pdENvZGVIYXNoKSB7XG4gICAgY29uc3QgZnJvbSA9IGdldEFkZHJlc3MoX2Zyb20pO1xuICAgIGNvbnN0IHNhbHQgPSBnZXRCeXRlcyhfc2FsdCwgXCJzYWx0XCIpO1xuICAgIGNvbnN0IGluaXRDb2RlSGFzaCA9IGdldEJ5dGVzKF9pbml0Q29kZUhhc2gsIFwiaW5pdENvZGVIYXNoXCIpO1xuICAgIGFzc2VydEFyZ3VtZW50KHNhbHQubGVuZ3RoID09PSAzMiwgXCJzYWx0IG11c3QgYmUgMzIgYnl0ZXNcIiwgXCJzYWx0XCIsIF9zYWx0KTtcbiAgICBhc3NlcnRBcmd1bWVudChpbml0Q29kZUhhc2gubGVuZ3RoID09PSAzMiwgXCJpbml0Q29kZUhhc2ggbXVzdCBiZSAzMiBieXRlc1wiLCBcImluaXRDb2RlSGFzaFwiLCBfaW5pdENvZGVIYXNoKTtcbiAgICByZXR1cm4gZ2V0QWRkcmVzcyhkYXRhU2xpY2Uoa2VjY2FrMjU2KGNvbmNhdChbXCIweGZmXCIsIGZyb20sIHNhbHQsIGluaXRDb2RlSGFzaF0pKSwgMTIpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnRyYWN0LWFkZHJlc3MuanMubWFwIl0sIm5hbWVzIjpbImtlY2NhazI1NiIsImNvbmNhdCIsImRhdGFTbGljZSIsImdldEJpZ0ludCIsImdldEJ5dGVzIiwiZW5jb2RlUmxwIiwiYXNzZXJ0QXJndW1lbnQiLCJnZXRBZGRyZXNzIiwiZ2V0Q3JlYXRlQWRkcmVzcyIsInR4IiwiZnJvbSIsIm5vbmNlIiwibm9uY2VIZXgiLCJ0b1N0cmluZyIsImxlbmd0aCIsImdldENyZWF0ZTJBZGRyZXNzIiwiX2Zyb20iLCJfc2FsdCIsIl9pbml0Q29kZUhhc2giLCJzYWx0IiwiaW5pdENvZGVIYXNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/address/contract-address.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/constants/addresses.js":
/*!************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/constants/addresses.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZeroAddress: function() { return /* binding */ ZeroAddress; }\n/* harmony export */ });\n/**\n *  A constant for the zero address.\n *\n *  (**i.e.** ``\"0x0000000000000000000000000000000000000000\"``)\n */ const ZeroAddress = \"0x0000000000000000000000000000000000000000\"; //# sourceMappingURL=addresses.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jb25zdGFudHMvYWRkcmVzc2VzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7OztDQUlDLEdBQ00sTUFBTUEsY0FBYyw2Q0FBNkMsQ0FDeEUscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jb25zdGFudHMvYWRkcmVzc2VzLmpzPzIzMWQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgQSBjb25zdGFudCBmb3IgdGhlIHplcm8gYWRkcmVzcy5cbiAqXG4gKiAgKCoqaS5lLioqIGBgXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcImBgKVxuICovXG5leHBvcnQgY29uc3QgWmVyb0FkZHJlc3MgPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkcmVzc2VzLmpzLm1hcCJdLCJuYW1lcyI6WyJaZXJvQWRkcmVzcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/constants/addresses.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/constants/hashes.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/constants/hashes.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZeroHash: function() { return /* binding */ ZeroHash; }\n/* harmony export */ });\n/**\n *  A constant for the zero hash.\n *\n *  (**i.e.** ``\"0x0000000000000000000000000000000000000000000000000000000000000000\"``)\n */ const ZeroHash = \"0x0000000000000000000000000000000000000000000000000000000000000000\"; //# sourceMappingURL=hashes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jb25zdGFudHMvaGFzaGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7OztDQUlDLEdBQ00sTUFBTUEsV0FBVyxxRUFBcUUsQ0FDN0Ysa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jb25zdGFudHMvaGFzaGVzLmpzPzk3ZDkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgQSBjb25zdGFudCBmb3IgdGhlIHplcm8gaGFzaC5cbiAqXG4gKiAgKCoqaS5lLioqIGBgXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcImBgKVxuICovXG5leHBvcnQgY29uc3QgWmVyb0hhc2ggPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzaGVzLmpzLm1hcCJdLCJuYW1lcyI6WyJaZXJvSGFzaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/constants/hashes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/contract/contract.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/contract/contract.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseContract: function() { return /* binding */ BaseContract; },\n/* harmony export */   Contract: function() { return /* binding */ Contract; },\n/* harmony export */   copyOverrides: function() { return /* binding */ copyOverrides; },\n/* harmony export */   resolveArgs: function() { return /* binding */ resolveArgs; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_get */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_get.js\");\n/* harmony import */ var _swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_init */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_init.js\");\n/* harmony import */ var _swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_set */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_set.js\");\n/* harmony import */ var _abi_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../abi/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abi_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../abi/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/interface.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../address/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/address/checks.js\");\n/* harmony import */ var _providers_provider_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../providers/provider.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/providers/provider.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _wrappers_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./wrappers.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/contract/wrappers.js\");\n\n\n\n\n\n// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\n\n\n\nconst BN_0 = BigInt(0);\nfunction canCall(value) {\n    return value && typeof value.call === \"function\";\n}\nfunction canEstimate(value) {\n    return value && typeof value.estimateGas === \"function\";\n}\nfunction canResolve(value) {\n    return value && typeof value.resolveName === \"function\";\n}\nfunction canSend(value) {\n    return value && typeof value.sendTransaction === \"function\";\n}\nfunction getResolver(value) {\n    if (value != null) {\n        if (canResolve(value)) {\n            return value;\n        }\n        if (value.provider) {\n            return value.provider;\n        }\n    }\n    return undefined;\n}\nvar _filter = /*#__PURE__*/ new WeakMap();\nclass PreparedTopicFilter {\n    getTopicFilter() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _filter);\n    }\n    constructor(contract, fragment, args){\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_1__._)(this, _filter, {\n            writable: true,\n            value: void 0\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            fragment\n        });\n        if (fragment.inputs.length < args.length) {\n            throw new Error(\"too many arguments\");\n        }\n        // Recursively descend into args and resolve any addresses\n        const runner = getRunner(contract.runner, \"resolveName\");\n        const resolver = canResolve(runner) ? runner : null;\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_3__._)(this, _filter, async function() {\n            const resolvedArgs = await Promise.all(fragment.inputs.map((param, index)=>{\n                const arg = args[index];\n                if (arg == null) {\n                    return null;\n                }\n                return param.walkAsync(args[index], (type, value)=>{\n                    if (type === \"address\") {\n                        if (Array.isArray(value)) {\n                            return Promise.all(value.map((v)=>(0,_address_index_js__WEBPACK_IMPORTED_MODULE_4__.resolveAddress)(v, resolver)));\n                        }\n                        return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_4__.resolveAddress)(value, resolver);\n                    }\n                    return value;\n                });\n            }));\n            return contract.interface.encodeFilterTopics(fragment, resolvedArgs);\n        }());\n    }\n}\n// A = Arguments passed in as a tuple\n// R = The result type of the call (i.e. if only one return type,\n//     the qualified type, otherwise Result)\n// D = The type the default call will return (i.e. R for view/pure,\n//     TransactionResponse otherwise)\n//export interface ContractMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = ContractTransactionResponse> {\nfunction getRunner(value, feature) {\n    if (value == null) {\n        return null;\n    }\n    if (typeof value[feature] === \"function\") {\n        return value;\n    }\n    if (value.provider && typeof value.provider[feature] === \"function\") {\n        return value.provider;\n    }\n    return null;\n}\nfunction getProvider(value) {\n    if (value == null) {\n        return null;\n    }\n    return value.provider || null;\n}\n/**\n *  @_ignore:\n */ async function copyOverrides(arg, allowed) {\n    // Make sure the overrides passed in are a valid overrides object\n    const _overrides = _abi_index_js__WEBPACK_IMPORTED_MODULE_5__.Typed.dereference(arg, \"overrides\");\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.assertArgument)(typeof _overrides === \"object\", \"invalid overrides parameter\", \"overrides\", arg);\n    // Create a shallow copy (we'll deep-ify anything needed during normalizing)\n    const overrides = (0,_providers_provider_js__WEBPACK_IMPORTED_MODULE_7__.copyRequest)(_overrides);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.assertArgument)(overrides.to == null || (allowed || []).indexOf(\"to\") >= 0, \"cannot override to\", \"overrides.to\", overrides.to);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.assertArgument)(overrides.data == null || (allowed || []).indexOf(\"data\") >= 0, \"cannot override data\", \"overrides.data\", overrides.data);\n    // Resolve any from\n    if (overrides.from) {\n        overrides.from = overrides.from;\n    }\n    return overrides;\n}\n/**\n *  @_ignore:\n */ async function resolveArgs(_runner, inputs, args) {\n    // Recursively descend into args and resolve any addresses\n    const runner = getRunner(_runner, \"resolveName\");\n    const resolver = canResolve(runner) ? runner : null;\n    return await Promise.all(inputs.map((param, index)=>{\n        return param.walkAsync(args[index], (type, value)=>{\n            value = _abi_index_js__WEBPACK_IMPORTED_MODULE_5__.Typed.dereference(value, type);\n            if (type === \"address\") {\n                return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_4__.resolveAddress)(value, resolver);\n            }\n            return value;\n        });\n    }));\n}\nfunction buildWrappedFallback(contract) {\n    const populateTransaction = async function(overrides) {\n        // If an overrides was passed in, copy it and normalize the values\n        const tx = await copyOverrides(overrides, [\n            \"data\"\n        ]);\n        tx.to = await contract.getAddress();\n        if (tx.from) {\n            tx.from = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_4__.resolveAddress)(tx.from, getResolver(contract.runner));\n        }\n        const iface = contract.interface;\n        const noValue = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getBigInt)(tx.value || BN_0, \"overrides.value\") === BN_0;\n        const noData = (tx.data || \"0x\") === \"0x\";\n        if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.assertArgument)(false, \"cannot send data to receive or send value to non-payable fallback\", \"overrides\", overrides);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.assertArgument)(iface.fallback || noData, \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n        // Only allow payable contracts to set non-zero value\n        const payable = iface.receive || iface.fallback && iface.fallback.payable;\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.assertArgument)(payable || noValue, \"cannot send value to non-payable fallback\", \"overrides.value\", tx.value);\n        // Only allow fallback contracts to set non-empty data\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.assertArgument)(iface.fallback || noData, \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n        return tx;\n    };\n    const staticCall = async function(overrides) {\n        const runner = getRunner(contract.runner, \"call\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.assert)(canCall(runner), \"contract runner does not support calling\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"call\"\n        });\n        const tx = await populateTransaction(overrides);\n        try {\n            return await runner.call(tx);\n        } catch (error) {\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.isCallException)(error) && error.data) {\n                throw contract.interface.makeError(error.data, tx);\n            }\n            throw error;\n        }\n    };\n    const send = async function(overrides) {\n        const runner = contract.runner;\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.assert)(canSend(runner), \"contract runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"sendTransaction\"\n        });\n        const tx = await runner.sendTransaction(await populateTransaction(overrides));\n        const provider = getProvider(contract.runner);\n        // @TODO: the provider can be null; make a custom dummy provider that will throw a\n        // meaningful error\n        return new _wrappers_js__WEBPACK_IMPORTED_MODULE_9__.ContractTransactionResponse(contract.interface, provider, tx);\n    };\n    const estimateGas = async function(overrides) {\n        const runner = getRunner(contract.runner, \"estimateGas\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.assert)(canEstimate(runner), \"contract runner does not support gas estimation\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"estimateGas\"\n        });\n        return await runner.estimateGas(await populateTransaction(overrides));\n    };\n    const method = async (overrides)=>{\n        return await send(overrides);\n    };\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(method, {\n        _contract: contract,\n        estimateGas,\n        populateTransaction,\n        send,\n        staticCall\n    });\n    return method;\n}\nfunction buildWrappedMethod(contract, key) {\n    const getFragment = function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        const fragment = contract.interface.getFunction(key, args);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fragment\",\n            info: {\n                key,\n                args\n            }\n        });\n        return fragment;\n    };\n    const populateTransaction = async function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        const fragment = getFragment(...args);\n        // If an overrides was passed in, copy it and normalize the values\n        let overrides = {};\n        if (fragment.inputs.length + 1 === args.length) {\n            overrides = await copyOverrides(args.pop());\n            if (overrides.from) {\n                overrides.from = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_4__.resolveAddress)(overrides.from, getResolver(contract.runner));\n            }\n        }\n        if (fragment.inputs.length !== args.length) {\n            throw new Error(\"internal error: fragment inputs doesn't match arguments; should not happen\");\n        }\n        const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);\n        return Object.assign({}, overrides, await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveProperties)({\n            to: contract.getAddress(),\n            data: contract.interface.encodeFunctionData(fragment, resolvedArgs)\n        }));\n    };\n    const staticCall = async function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        const result = await staticCallResult(...args);\n        if (result.length === 1) {\n            return result[0];\n        }\n        return result;\n    };\n    const send = async function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        const runner = contract.runner;\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.assert)(canSend(runner), \"contract runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"sendTransaction\"\n        });\n        const tx = await runner.sendTransaction(await populateTransaction(...args));\n        const provider = getProvider(contract.runner);\n        // @TODO: the provider can be null; make a custom dummy provider that will throw a\n        // meaningful error\n        return new _wrappers_js__WEBPACK_IMPORTED_MODULE_9__.ContractTransactionResponse(contract.interface, provider, tx);\n    };\n    const estimateGas = async function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        const runner = getRunner(contract.runner, \"estimateGas\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.assert)(canEstimate(runner), \"contract runner does not support gas estimation\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"estimateGas\"\n        });\n        return await runner.estimateGas(await populateTransaction(...args));\n    };\n    const staticCallResult = async function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        const runner = getRunner(contract.runner, \"call\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.assert)(canCall(runner), \"contract runner does not support calling\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"call\"\n        });\n        const tx = await populateTransaction(...args);\n        let result = \"0x\";\n        try {\n            result = await runner.call(tx);\n        } catch (error) {\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.isCallException)(error) && error.data) {\n                throw contract.interface.makeError(error.data, tx);\n            }\n            throw error;\n        }\n        const fragment = getFragment(...args);\n        return contract.interface.decodeFunctionResult(fragment, result);\n    };\n    const method = async function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        const fragment = getFragment(...args);\n        if (fragment.constant) {\n            return await staticCall(...args);\n        }\n        return await send(...args);\n    };\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(method, {\n        name: contract.interface.getFunctionName(key),\n        _contract: contract,\n        _key: key,\n        getFragment,\n        estimateGas,\n        populateTransaction,\n        send,\n        staticCall,\n        staticCallResult\n    });\n    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n    Object.defineProperty(method, \"fragment\", {\n        configurable: false,\n        enumerable: true,\n        get: ()=>{\n            const fragment = contract.interface.getFunction(key);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"fragment\",\n                info: {\n                    key\n                }\n            });\n            return fragment;\n        }\n    });\n    return method;\n}\nfunction buildWrappedEvent(contract, key) {\n    const getFragment = function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        const fragment = contract.interface.getEvent(key, args);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fragment\",\n            info: {\n                key,\n                args\n            }\n        });\n        return fragment;\n    };\n    const method = function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return new PreparedTopicFilter(contract, getFragment(...args), args);\n    };\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(method, {\n        name: contract.interface.getEventName(key),\n        _contract: contract,\n        _key: key,\n        getFragment\n    });\n    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n    Object.defineProperty(method, \"fragment\", {\n        configurable: false,\n        enumerable: true,\n        get: ()=>{\n            const fragment = contract.interface.getEvent(key);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"fragment\",\n                info: {\n                    key\n                }\n            });\n            return fragment;\n        }\n    });\n    return method;\n}\n// The combination of TypeScrype, Private Fields and Proxies makes\n// the world go boom; so we hide variables with some trickery keeping\n// a symbol attached to each BaseContract which its sub-class (even\n// via a Proxy) can reach and use to look up its internal values.\nconst internal = Symbol.for(\"_ethersInternal_contract\");\nconst internalValues = new WeakMap();\nfunction setInternal(contract, values) {\n    internalValues.set(contract[internal], values);\n}\nfunction getInternal(contract) {\n    return internalValues.get(contract[internal]);\n}\nfunction isDeferred(value) {\n    return value && typeof value === \"object\" && \"getTopicFilter\" in value && typeof value.getTopicFilter === \"function\" && value.fragment;\n}\nasync function getSubInfo(contract, event) {\n    let topics;\n    let fragment = null;\n    // Convert named events to topicHash and get the fragment for\n    // events which need deconstructing.\n    if (Array.isArray(event)) {\n        const topicHashify = function(name) {\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.isHexString)(name, 32)) {\n                return name;\n            }\n            const fragment = contract.interface.getEvent(name);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.assertArgument)(fragment, \"unknown fragment\", \"name\", name);\n            return fragment.topicHash;\n        };\n        // Array of Topics and Names; e.g. `[ \"0x1234...89ab\", \"Transfer(address)\" ]`\n        topics = event.map((e)=>{\n            if (e == null) {\n                return null;\n            }\n            if (Array.isArray(e)) {\n                return e.map(topicHashify);\n            }\n            return topicHashify(e);\n        });\n    } else if (event === \"*\") {\n        topics = [\n            null\n        ];\n    } else if (typeof event === \"string\") {\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.isHexString)(event, 32)) {\n            // Topic Hash\n            topics = [\n                event\n            ];\n        } else {\n            // Name or Signature; e.g. `\"Transfer\", `\"Transfer(address)\"`\n            fragment = contract.interface.getEvent(event);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.assertArgument)(fragment, \"unknown fragment\", \"event\", event);\n            topics = [\n                fragment.topicHash\n            ];\n        }\n    } else if (isDeferred(event)) {\n        // Deferred Topic Filter; e.g. `contract.filter.Transfer(from)`\n        topics = await event.getTopicFilter();\n    } else if (\"fragment\" in event) {\n        // ContractEvent; e.g. `contract.filter.Transfer`\n        fragment = event.fragment;\n        topics = [\n            fragment.topicHash\n        ];\n    } else {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.assertArgument)(false, \"unknown event name\", \"event\", event);\n    }\n    // Normalize topics and sort TopicSets\n    topics = topics.map((t)=>{\n        if (t == null) {\n            return null;\n        }\n        if (Array.isArray(t)) {\n            const items = Array.from(new Set(t.map((t)=>t.toLowerCase())).values());\n            if (items.length === 1) {\n                return items[0];\n            }\n            items.sort();\n            return items;\n        }\n        return t.toLowerCase();\n    });\n    const tag = topics.map((t)=>{\n        if (t == null) {\n            return \"null\";\n        }\n        if (Array.isArray(t)) {\n            return t.join(\"|\");\n        }\n        return t;\n    }).join(\"&\");\n    return {\n        fragment,\n        tag,\n        topics\n    };\n}\nasync function hasSub(contract, event) {\n    const { subs } = getInternal(contract);\n    return subs.get((await getSubInfo(contract, event)).tag) || null;\n}\nasync function getSub(contract, operation, event) {\n    // Make sure our runner can actually subscribe to events\n    const provider = getProvider(contract.runner);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.assert)(provider, \"contract runner does not support subscribing\", \"UNSUPPORTED_OPERATION\", {\n        operation\n    });\n    const { fragment, tag, topics } = await getSubInfo(contract, event);\n    const { addr, subs } = getInternal(contract);\n    let sub = subs.get(tag);\n    if (!sub) {\n        const address = addr ? addr : contract;\n        const filter = {\n            address,\n            topics\n        };\n        const listener = (log)=>{\n            let foundFragment = fragment;\n            if (foundFragment == null) {\n                try {\n                    foundFragment = contract.interface.getEvent(log.topics[0]);\n                } catch (error) {}\n            }\n            // If fragment is null, we do not deconstruct the args to emit\n            if (foundFragment) {\n                const _foundFragment = foundFragment;\n                const args = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics) : [];\n                emit(contract, event, args, (listener)=>{\n                    return new _wrappers_js__WEBPACK_IMPORTED_MODULE_9__.ContractEventPayload(contract, listener, event, _foundFragment, log);\n                });\n            } else {\n                emit(contract, event, [], (listener)=>{\n                    return new _wrappers_js__WEBPACK_IMPORTED_MODULE_9__.ContractUnknownEventPayload(contract, listener, event, log);\n                });\n            }\n        };\n        let starting = [];\n        const start = ()=>{\n            if (starting.length) {\n                return;\n            }\n            starting.push(provider.on(filter, listener));\n        };\n        const stop = async ()=>{\n            if (starting.length == 0) {\n                return;\n            }\n            let started = starting;\n            starting = [];\n            await Promise.all(started);\n            provider.off(filter, listener);\n        };\n        sub = {\n            tag,\n            listeners: [],\n            start,\n            stop\n        };\n        subs.set(tag, sub);\n    }\n    return sub;\n}\n// We use this to ensure one emit resolves before firing the next to\n// ensure correct ordering (note this cannot throw and just adds the\n// notice to the event queu using setTimeout).\nlet lastEmit = Promise.resolve();\nasync function _emit(contract, event, args, payloadFunc) {\n    await lastEmit;\n    const sub = await hasSub(contract, event);\n    if (!sub) {\n        return false;\n    }\n    const count = sub.listeners.length;\n    sub.listeners = sub.listeners.filter((param)=>{\n        let { listener, once } = param;\n        const passArgs = Array.from(args);\n        if (payloadFunc) {\n            passArgs.push(payloadFunc(once ? null : listener));\n        }\n        try {\n            listener.call(contract, ...passArgs);\n        } catch (error) {}\n        return !once;\n    });\n    if (sub.listeners.length === 0) {\n        sub.stop();\n        getInternal(contract).subs.delete(sub.tag);\n    }\n    return count > 0;\n}\nasync function emit(contract, event, args, payloadFunc) {\n    try {\n        await lastEmit;\n    } catch (error) {}\n    const resultPromise = _emit(contract, event, args, payloadFunc);\n    lastEmit = resultPromise;\n    return await resultPromise;\n}\nconst passProperties = [\n    \"then\"\n];\nclass BaseContract {\n    /**\n     *  Return a new Contract instance with the same target and ABI, but\n     *  a different %%runner%%.\n     */ connect(runner) {\n        return new BaseContract(this.target, this.interface, runner);\n    }\n    /**\n     *  Return a new Contract instance with the same ABI and runner, but\n     *  a different %%target%%.\n     */ attach(target) {\n        return new BaseContract(target, this.interface, this.runner);\n    }\n    /**\n     *  Return the resolved address of this Contract.\n     */ async getAddress() {\n        return await getInternal(this).addrPromise;\n    }\n    /**\n     *  Return the deployed bytecode or null if no bytecode is found.\n     */ async getDeployedCode() {\n        const provider = getProvider(this.runner);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.assert)(provider, \"runner does not support .provider\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"getDeployedCode\"\n        });\n        const code = await provider.getCode(await this.getAddress());\n        if (code === \"0x\") {\n            return null;\n        }\n        return code;\n    }\n    /**\n     *  Resolve to this Contract once the bytecode has been deployed, or\n     *  resolve immediately if already deployed.\n     */ async waitForDeployment() {\n        // We have the deployment transaction; just use that (throws if deployment fails)\n        const deployTx = this.deploymentTransaction();\n        if (deployTx) {\n            await deployTx.wait();\n            return this;\n        }\n        // Check for code\n        const code = await this.getDeployedCode();\n        if (code != null) {\n            return this;\n        }\n        // Make sure we can subscribe to a provider event\n        const provider = getProvider(this.runner);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.assert)(provider != null, \"contract runner does not support .provider\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"waitForDeployment\"\n        });\n        return new Promise((resolve, reject)=>{\n            const checkCode = async ()=>{\n                try {\n                    const code = await this.getDeployedCode();\n                    if (code != null) {\n                        return resolve(this);\n                    }\n                    provider.once(\"block\", checkCode);\n                } catch (error) {\n                    reject(error);\n                }\n            };\n            checkCode();\n        });\n    }\n    /**\n     *  Return the transaction used to deploy this contract.\n     *\n     *  This is only available if this instance was returned from a\n     *  [[ContractFactory]].\n     */ deploymentTransaction() {\n        return getInternal(this).deployTx;\n    }\n    /**\n     *  Return the function for a given name. This is useful when a contract\n     *  method name conflicts with a JavaScript name such as ``prototype`` or\n     *  when using a Contract programmatically.\n     */ getFunction(key) {\n        if (typeof key !== \"string\") {\n            key = key.format();\n        }\n        const func = buildWrappedMethod(this, key);\n        return func;\n    }\n    /**\n     *  Return the event for a given name. This is useful when a contract\n     *  event name conflicts with a JavaScript name such as ``prototype`` or\n     *  when using a Contract programmatically.\n     */ getEvent(key) {\n        if (typeof key !== \"string\") {\n            key = key.format();\n        }\n        return buildWrappedEvent(this, key);\n    }\n    /**\n     *  @_ignore:\n     */ async queryTransaction(hash) {\n        throw new Error(\"@TODO\");\n    }\n    /*\n    // @TODO: this is a non-backwards compatible change, but will be added\n    //        in v7 and in a potential SmartContract class in an upcoming\n    //        v6 release\n    async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {\n        const provider = getProvider(this.runner);\n        assert(provider, \"contract runner does not have a provider\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"queryTransaction\" });\n\n        const receipt = await provider.getTransactionReceipt(hash);\n        if (receipt == null) { return null; }\n\n        return new ContractTransactionReceipt(this.interface, provider, receipt);\n    }\n    */ /**\n     *  Provide historic access to event data for %%event%% in the range\n     *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``\"latest\"``)\n     *  inclusive.\n     */ async queryFilter(event, fromBlock, toBlock) {\n        if (fromBlock == null) {\n            fromBlock = 0;\n        }\n        if (toBlock == null) {\n            toBlock = \"latest\";\n        }\n        const { addr, addrPromise } = getInternal(this);\n        const address = addr ? addr : await addrPromise;\n        const { fragment, topics } = await getSubInfo(this, event);\n        const filter = {\n            address,\n            topics,\n            fromBlock,\n            toBlock\n        };\n        const provider = getProvider(this.runner);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.assert)(provider, \"contract runner does not have a provider\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"queryFilter\"\n        });\n        return (await provider.getLogs(filter)).map((log)=>{\n            let foundFragment = fragment;\n            if (foundFragment == null) {\n                try {\n                    foundFragment = this.interface.getEvent(log.topics[0]);\n                } catch (error) {}\n            }\n            if (foundFragment) {\n                try {\n                    return new _wrappers_js__WEBPACK_IMPORTED_MODULE_9__.EventLog(log, this.interface, foundFragment);\n                } catch (error) {\n                    return new _wrappers_js__WEBPACK_IMPORTED_MODULE_9__.UndecodedEventLog(log, error);\n                }\n            }\n            return new _providers_provider_js__WEBPACK_IMPORTED_MODULE_7__.Log(log, provider);\n        });\n    }\n    /**\n     *  Add an event %%listener%% for the %%event%%.\n     */ async on(event, listener) {\n        const sub = await getSub(this, \"on\", event);\n        sub.listeners.push({\n            listener,\n            once: false\n        });\n        sub.start();\n        return this;\n    }\n    /**\n     *  Add an event %%listener%% for the %%event%%, but remove the listener\n     *  after it is fired once.\n     */ async once(event, listener) {\n        const sub = await getSub(this, \"once\", event);\n        sub.listeners.push({\n            listener,\n            once: true\n        });\n        sub.start();\n        return this;\n    }\n    /**\n     *  Emit an %%event%% calling all listeners with %%args%%.\n     *\n     *  Resolves to ``true`` if any listeners were called.\n     */ async emit(event) {\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        return await emit(this, event, args, null);\n    }\n    /**\n     *  Resolves to the number of listeners of %%event%% or the total number\n     *  of listeners if unspecified.\n     */ async listenerCount(event) {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) {\n                return 0;\n            }\n            return sub.listeners.length;\n        }\n        const { subs } = getInternal(this);\n        let total = 0;\n        for (const { listeners } of subs.values()){\n            total += listeners.length;\n        }\n        return total;\n    }\n    /**\n     *  Resolves to the listeners subscribed to %%event%% or all listeners\n     *  if unspecified.\n     */ async listeners(event) {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) {\n                return [];\n            }\n            return sub.listeners.map((param)=>{\n                let { listener } = param;\n                return listener;\n            });\n        }\n        const { subs } = getInternal(this);\n        let result = [];\n        for (const { listeners } of subs.values()){\n            result = result.concat(listeners.map((param)=>{\n                let { listener } = param;\n                return listener;\n            }));\n        }\n        return result;\n    }\n    /**\n     *  Remove the %%listener%% from the listeners for %%event%% or remove\n     *  all listeners if unspecified.\n     */ async off(event, listener) {\n        const sub = await hasSub(this, event);\n        if (!sub) {\n            return this;\n        }\n        if (listener) {\n            const index = sub.listeners.map((param)=>{\n                let { listener } = param;\n                return listener;\n            }).indexOf(listener);\n            if (index >= 0) {\n                sub.listeners.splice(index, 1);\n            }\n        }\n        if (listener == null || sub.listeners.length === 0) {\n            sub.stop();\n            getInternal(this).subs.delete(sub.tag);\n        }\n        return this;\n    }\n    /**\n     *  Remove all the listeners for %%event%% or remove all listeners if\n     *  unspecified.\n     */ async removeAllListeners(event) {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) {\n                return this;\n            }\n            sub.stop();\n            getInternal(this).subs.delete(sub.tag);\n        } else {\n            const { subs } = getInternal(this);\n            for (const { tag, stop } of subs.values()){\n                stop();\n                subs.delete(tag);\n            }\n        }\n        return this;\n    }\n    /**\n     *  Alias for [on].\n     */ async addListener(event, listener) {\n        return await this.on(event, listener);\n    }\n    /**\n     *  Alias for [off].\n     */ async removeListener(event, listener) {\n        return await this.off(event, listener);\n    }\n    /**\n     *  Create a new Class for the %%abi%%.\n     */ static buildClass(abi) {\n        class CustomContract extends BaseContract {\n            constructor(address, runner = null){\n                super(address, abi, runner);\n            }\n        }\n        return CustomContract;\n    }\n    /**\n     *  Create a new BaseContract with a specified Interface.\n     */ static from(target, abi, runner) {\n        if (runner == null) {\n            runner = null;\n        }\n        const contract = new this(target, abi, runner);\n        return contract;\n    }\n    /**\n     *  Creates a new contract connected to %%target%% with the %%abi%% and\n     *  optionally connected to a %%runner%% to perform operations on behalf\n     *  of.\n     */ constructor(target, abi, runner, _deployTx){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.assertArgument)(typeof target === \"string\" || (0,_address_index_js__WEBPACK_IMPORTED_MODULE_4__.isAddressable)(target), \"invalid value for Contract target\", \"target\", target);\n        if (runner == null) {\n            runner = null;\n        }\n        const iface = _abi_index_js__WEBPACK_IMPORTED_MODULE_11__.Interface.from(abi);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            target,\n            runner,\n            interface: iface\n        });\n        Object.defineProperty(this, internal, {\n            value: {}\n        });\n        let addrPromise;\n        let addr = null;\n        let deployTx = null;\n        if (_deployTx) {\n            const provider = getProvider(runner);\n            // @TODO: the provider can be null; make a custom dummy provider that will throw a\n            // meaningful error\n            deployTx = new _wrappers_js__WEBPACK_IMPORTED_MODULE_9__.ContractTransactionResponse(this.interface, provider, _deployTx);\n        }\n        let subs = new Map();\n        // Resolve the target as the address\n        if (typeof target === \"string\") {\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.isHexString)(target)) {\n                addr = target;\n                addrPromise = Promise.resolve(target);\n            } else {\n                const resolver = getRunner(runner, \"resolveName\");\n                if (!canResolve(resolver)) {\n                    throw (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.makeError)(\"contract runner does not support name resolution\", \"UNSUPPORTED_OPERATION\", {\n                        operation: \"resolveName\"\n                    });\n                }\n                addrPromise = resolver.resolveName(target).then((addr)=>{\n                    if (addr == null) {\n                        throw (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.makeError)(\"an ENS name used for a contract target must be correctly configured\", \"UNCONFIGURED_NAME\", {\n                            value: target\n                        });\n                    }\n                    getInternal(this).addr = addr;\n                    return addr;\n                });\n            }\n        } else {\n            addrPromise = target.getAddress().then((addr)=>{\n                if (addr == null) {\n                    throw new Error(\"TODO\");\n                }\n                getInternal(this).addr = addr;\n                return addr;\n            });\n        }\n        // Set our private values\n        setInternal(this, {\n            addrPromise,\n            addr,\n            deployTx,\n            subs\n        });\n        // Add the event filters\n        const filters = new Proxy({}, {\n            get: (target, prop, receiver)=>{\n                // Pass important checks (like `then` for Promise) through\n                if (typeof prop === \"symbol\" || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.get(target, prop, receiver);\n                }\n                try {\n                    return this.getEvent(prop);\n                } catch (error) {\n                    if (!(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.isError)(error, \"INVALID_ARGUMENT\") || error.argument !== \"key\") {\n                        throw error;\n                    }\n                }\n                return undefined;\n            },\n            has: (target, prop)=>{\n                // Pass important checks (like `then` for Promise) through\n                if (passProperties.indexOf(prop) >= 0) {\n                    return Reflect.has(target, prop);\n                }\n                return Reflect.has(target, prop) || this.interface.hasEvent(String(prop));\n            }\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            filters\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            fallback: iface.receive || iface.fallback ? buildWrappedFallback(this) : null\n        });\n        // Return a Proxy that will respond to functions\n        return new Proxy(this, {\n            get: (target, prop, receiver)=>{\n                if (typeof prop === \"symbol\" || prop in target || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.get(target, prop, receiver);\n                }\n                // Undefined properties should return undefined\n                try {\n                    return target.getFunction(prop);\n                } catch (error) {\n                    if (!(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.isError)(error, \"INVALID_ARGUMENT\") || error.argument !== \"key\") {\n                        throw error;\n                    }\n                }\n                return undefined;\n            },\n            has: (target, prop)=>{\n                if (typeof prop === \"symbol\" || prop in target || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.has(target, prop);\n                }\n                return target.interface.hasFunction(prop);\n            }\n        });\n    }\n}\nfunction _ContractBase() {\n    return BaseContract;\n}\n/**\n *  A [[BaseContract]] with no type guards on its methods or events.\n */ class Contract extends _ContractBase() {\n} //# sourceMappingURL=contract.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jb250cmFjdC9jb250cmFjdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW1EO0FBQ2lCO0FBQ3BFLHNFQUFzRTtBQUN0RSx5QkFBeUI7QUFDbUM7QUFDaUc7QUFDakI7QUFDNUksTUFBTW9CLE9BQU9DLE9BQU87QUFDcEIsU0FBU0MsUUFBUUMsS0FBSztJQUNsQixPQUFRQSxTQUFTLE9BQVFBLE1BQU1DLElBQUksS0FBTTtBQUM3QztBQUNBLFNBQVNDLFlBQVlGLEtBQUs7SUFDdEIsT0FBUUEsU0FBUyxPQUFRQSxNQUFNRyxXQUFXLEtBQU07QUFDcEQ7QUFDQSxTQUFTQyxXQUFXSixLQUFLO0lBQ3JCLE9BQVFBLFNBQVMsT0FBUUEsTUFBTUssV0FBVyxLQUFNO0FBQ3BEO0FBQ0EsU0FBU0MsUUFBUU4sS0FBSztJQUNsQixPQUFRQSxTQUFTLE9BQVFBLE1BQU1PLGVBQWUsS0FBTTtBQUN4RDtBQUNBLFNBQVNDLFlBQVlSLEtBQUs7SUFDdEIsSUFBSUEsU0FBUyxNQUFNO1FBQ2YsSUFBSUksV0FBV0osUUFBUTtZQUNuQixPQUFPQTtRQUNYO1FBQ0EsSUFBSUEsTUFBTVMsUUFBUSxFQUFFO1lBQ2hCLE9BQU9ULE1BQU1TLFFBQVE7UUFDekI7SUFDSjtJQUNBLE9BQU9DO0FBQ1g7SUFFSTtBQURKLE1BQU1DO0lBOEJGQyxpQkFBaUI7UUFDYixPQUFPLDRFQUFJLEVBQUVDO0lBQ2pCO0lBN0JBQyxZQUFZQyxRQUFRLEVBQUVDLFFBQVEsRUFBRUMsSUFBSSxDQUFFO1FBRnRDOzttQkFBQTs7UUFHSWxDLGlFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFBRWlDO1FBQVM7UUFDbEMsSUFBSUEsU0FBU0UsTUFBTSxDQUFDQyxNQUFNLEdBQUdGLEtBQUtFLE1BQU0sRUFBRTtZQUN0QyxNQUFNLElBQUlDLE1BQU07UUFDcEI7UUFDQSwwREFBMEQ7UUFDMUQsTUFB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VUgsZUFBZWhHLE9BQU8sQ0FBQ3NJLFNBQVMsR0FBRztvQkFDbkYsT0FBT0UsUUFBUWhHLEdBQUcsQ0FBQzJELFFBQVFtQyxNQUFNQztnQkFDckM7Z0JBQ0EsK0NBQStDO2dCQUMvQyxJQUFJO29CQUNBLE9BQU9wQyxPQUFPM0UsV0FBVyxDQUFDOEc7Z0JBQzlCLEVBQ0EsT0FBT3JILE9BQU87b0JBQ1YsSUFBSSxDQUFDM0Usd0RBQU9BLENBQUMyRSxPQUFPLHVCQUF1QkEsTUFBTXdILFFBQVEsS0FBSyxPQUFPO3dCQUNqRSxNQUFNeEg7b0JBQ1Y7Z0JBQ0o7Z0JBQ0EsT0FBT3JEO1lBQ1g7WUFDQThLLEtBQUssQ0FBQ3ZDLFFBQVFtQztnQkFDVixJQUFJLE9BQVFBLFNBQVUsWUFBWUEsUUFBUW5DLFVBQVVILGVBQWVoRyxPQUFPLENBQUNzSSxTQUFTLEdBQUc7b0JBQ25GLE9BQU9FLFFBQVFFLEdBQUcsQ0FBQ3ZDLFFBQVFtQztnQkFDL0I7Z0JBQ0EsT0FBT25DLE9BQU83RyxTQUFTLENBQUN1SixXQUFXLENBQUNQO1lBQ3hDO1FBQ0o7SUFDSjtBQTBTSjtBQUNBLFNBQVNRO0lBQ0wsT0FBTzdDO0FBQ1g7QUFDQTs7Q0FFQyxHQUNNLE1BQU04QyxpQkFBaUJEO0FBQzlCLEVBQ0Esb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jb250cmFjdC9jb250cmFjdC5qcz8yNjYyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEludGVyZmFjZSwgVHlwZWQgfSBmcm9tIFwiLi4vYWJpL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBpc0FkZHJlc3NhYmxlLCByZXNvbHZlQWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG4vLyBpbXBvcnQgZnJvbSBwcm92aWRlci50cyBpbnN0ZWFkIG9mIGluZGV4LnRzIHRvIHByZXZlbnQgY2lyY3VsYXIgZGVwXG4vLyBmcm9tIEV0aGVyc2NhblByb3ZpZGVyXG5pbXBvcnQgeyBjb3B5UmVxdWVzdCwgTG9nIH0gZnJvbSBcIi4uL3Byb3ZpZGVycy9wcm92aWRlci5qc1wiO1xuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgZ2V0QmlnSW50LCBpc0NhbGxFeGNlcHRpb24sIGlzSGV4U3RyaW5nLCByZXNvbHZlUHJvcGVydGllcywgaXNFcnJvciwgbWFrZUVycm9yLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBDb250cmFjdEV2ZW50UGF5bG9hZCwgQ29udHJhY3RVbmtub3duRXZlbnRQYXlsb2FkLCBDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UsIEV2ZW50TG9nLCBVbmRlY29kZWRFdmVudExvZyB9IGZyb20gXCIuL3dyYXBwZXJzLmpzXCI7XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuZnVuY3Rpb24gY2FuQ2FsbCh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS5jYWxsKSA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIGNhbkVzdGltYXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLmVzdGltYXRlR2FzKSA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIGNhblJlc29sdmUodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUucmVzb2x2ZU5hbWUpID09PSBcImZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gY2FuU2VuZCh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS5zZW5kVHJhbnNhY3Rpb24pID09PSBcImZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gZ2V0UmVzb2x2ZXIodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBpZiAoY2FuUmVzb2x2ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUucHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5wcm92aWRlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuY2xhc3MgUHJlcGFyZWRUb3BpY0ZpbHRlciB7XG4gICAgI2ZpbHRlcjtcbiAgICBmcmFnbWVudDtcbiAgICBjb25zdHJ1Y3Rvcihjb250cmFjdCwgZnJhZ21lbnQsIGFyZ3MpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGZyYWdtZW50IH0pO1xuICAgICAgICBpZiAoZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0b28gbWFueSBhcmd1bWVudHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgZGVzY2VuZCBpbnRvIGFyZ3MgYW5kIHJlc29sdmUgYW55IGFkZHJlc3Nlc1xuICAgICAgICBjb25zdCBydW5uZXIgPSBnZXRSdW5uZXIoY29udHJhY3QucnVubmVyLCBcInJlc29sdmVOYW1lXCIpO1xuICAgICAgICBjb25zdCByZXNvbHZlciA9IGNhblJlc29sdmUocnVubmVyKSA/IHJ1bm5lciA6IG51bGw7XG4gICAgICAgIHRoaXMuI2ZpbHRlciA9IChhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZEFyZ3MgPSBhd2FpdCBQcm9taXNlLmFsbChmcmFnbWVudC5pbnB1dHMubWFwKChwYXJhbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmcgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoYXJnID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbS53YWxrQXN5bmMoYXJnc1tpbmRleF0sICh0eXBlLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJhZGRyZXNzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbCh2YWx1ZS5tYXAoKHYpID0+IHJlc29sdmVBZGRyZXNzKHYsIHJlc29sdmVyKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVBZGRyZXNzKHZhbHVlLCByZXNvbHZlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyYWN0LmludGVyZmFjZS5lbmNvZGVGaWx0ZXJUb3BpY3MoZnJhZ21lbnQsIHJlc29sdmVkQXJncyk7XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIGdldFRvcGljRmlsdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZmlsdGVyO1xuICAgIH1cbn1cbi8vIEEgPSBBcmd1bWVudHMgcGFzc2VkIGluIGFzIGEgdHVwbGVcbi8vIFIgPSBUaGUgcmVzdWx0IHR5cGUgb2YgdGhlIGNhbGwgKGkuZS4gaWYgb25seSBvbmUgcmV0dXJuIHR5cGUsXG4vLyAgICAgdGhlIHF1YWxpZmllZCB0eXBlLCBvdGhlcndpc2UgUmVzdWx0KVxuLy8gRCA9IFRoZSB0eXBlIHRoZSBkZWZhdWx0IGNhbGwgd2lsbCByZXR1cm4gKGkuZS4gUiBmb3Igdmlldy9wdXJlLFxuLy8gICAgIFRyYW5zYWN0aW9uUmVzcG9uc2Ugb3RoZXJ3aXNlKVxuLy9leHBvcnQgaW50ZXJmYWNlIENvbnRyYWN0TWV0aG9kPEEgZXh0ZW5kcyBBcnJheTxhbnk+ID0gQXJyYXk8YW55PiwgUiA9IGFueSwgRCBleHRlbmRzIFIgfCBDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UgPSBDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2U+IHtcbmZ1bmN0aW9uIGdldFJ1bm5lcih2YWx1ZSwgZmVhdHVyZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodHlwZW9mICh2YWx1ZVtmZWF0dXJlXSkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZS5wcm92aWRlciAmJiB0eXBlb2YgKHZhbHVlLnByb3ZpZGVyW2ZlYXR1cmVdKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5wcm92aWRlcjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRQcm92aWRlcih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUucHJvdmlkZXIgfHwgbnVsbDtcbn1cbi8qKlxuICogIEBfaWdub3JlOlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29weU92ZXJyaWRlcyhhcmcsIGFsbG93ZWQpIHtcbiAgICAvLyBNYWtlIHN1cmUgdGhlIG92ZXJyaWRlcyBwYXNzZWQgaW4gYXJlIGEgdmFsaWQgb3ZlcnJpZGVzIG9iamVjdFxuICAgIGNvbnN0IF9vdmVycmlkZXMgPSBUeXBlZC5kZXJlZmVyZW5jZShhcmcsIFwib3ZlcnJpZGVzXCIpO1xuICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAoX292ZXJyaWRlcykgPT09IFwib2JqZWN0XCIsIFwiaW52YWxpZCBvdmVycmlkZXMgcGFyYW1ldGVyXCIsIFwib3ZlcnJpZGVzXCIsIGFyZyk7XG4gICAgLy8gQ3JlYXRlIGEgc2hhbGxvdyBjb3B5ICh3ZSdsbCBkZWVwLWlmeSBhbnl0aGluZyBuZWVkZWQgZHVyaW5nIG5vcm1hbGl6aW5nKVxuICAgIGNvbnN0IG92ZXJyaWRlcyA9IGNvcHlSZXF1ZXN0KF9vdmVycmlkZXMpO1xuICAgIGFzc2VydEFyZ3VtZW50KG92ZXJyaWRlcy50byA9PSBudWxsIHx8IChhbGxvd2VkIHx8IFtdKS5pbmRleE9mKFwidG9cIikgPj0gMCwgXCJjYW5ub3Qgb3ZlcnJpZGUgdG9cIiwgXCJvdmVycmlkZXMudG9cIiwgb3ZlcnJpZGVzLnRvKTtcbiAgICBhc3NlcnRBcmd1bWVudChvdmVycmlkZXMuZGF0YSA9PSBudWxsIHx8IChhbGxvd2VkIHx8IFtdKS5pbmRleE9mKFwiZGF0YVwiKSA+PSAwLCBcImNhbm5vdCBvdmVycmlkZSBkYXRhXCIsIFwib3ZlcnJpZGVzLmRhdGFcIiwgb3ZlcnJpZGVzLmRhdGEpO1xuICAgIC8vIFJlc29sdmUgYW55IGZyb21cbiAgICBpZiAob3ZlcnJpZGVzLmZyb20pIHtcbiAgICAgICAgb3ZlcnJpZGVzLmZyb20gPSBvdmVycmlkZXMuZnJvbTtcbiAgICB9XG4gICAgcmV0dXJuIG92ZXJyaWRlcztcbn1cbi8qKlxuICogIEBfaWdub3JlOlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUFyZ3MoX3J1bm5lciwgaW5wdXRzLCBhcmdzKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgZGVzY2VuZCBpbnRvIGFyZ3MgYW5kIHJlc29sdmUgYW55IGFkZHJlc3Nlc1xuICAgIGNvbnN0IHJ1bm5lciA9IGdldFJ1bm5lcihfcnVubmVyLCBcInJlc29sdmVOYW1lXCIpO1xuICAgIGNvbnN0IHJlc29sdmVyID0gY2FuUmVzb2x2ZShydW5uZXIpID8gcnVubmVyIDogbnVsbDtcbiAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwoaW5wdXRzLm1hcCgocGFyYW0sIGluZGV4KSA9PiB7XG4gICAgICAgIHJldHVybiBwYXJhbS53YWxrQXN5bmMoYXJnc1tpbmRleF0sICh0eXBlLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdmFsdWUgPSBUeXBlZC5kZXJlZmVyZW5jZSh2YWx1ZSwgdHlwZSk7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJhZGRyZXNzXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZUFkZHJlc3ModmFsdWUsIHJlc29sdmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfSkpO1xufVxuZnVuY3Rpb24gYnVpbGRXcmFwcGVkRmFsbGJhY2soY29udHJhY3QpIHtcbiAgICBjb25zdCBwb3B1bGF0ZVRyYW5zYWN0aW9uID0gYXN5bmMgZnVuY3Rpb24gKG92ZXJyaWRlcykge1xuICAgICAgICAvLyBJZiBhbiBvdmVycmlkZXMgd2FzIHBhc3NlZCBpbiwgY29weSBpdCBhbmQgbm9ybWFsaXplIHRoZSB2YWx1ZXNcbiAgICAgICAgY29uc3QgdHggPSAoYXdhaXQgY29weU92ZXJyaWRlcyhvdmVycmlkZXMsIFtcImRhdGFcIl0pKTtcbiAgICAgICAgdHgudG8gPSBhd2FpdCBjb250cmFjdC5nZXRBZGRyZXNzKCk7XG4gICAgICAgIGlmICh0eC5mcm9tKSB7XG4gICAgICAgICAgICB0eC5mcm9tID0gYXdhaXQgcmVzb2x2ZUFkZHJlc3ModHguZnJvbSwgZ2V0UmVzb2x2ZXIoY29udHJhY3QucnVubmVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWZhY2UgPSBjb250cmFjdC5pbnRlcmZhY2U7XG4gICAgICAgIGNvbnN0IG5vVmFsdWUgPSAoZ2V0QmlnSW50KCh0eC52YWx1ZSB8fCBCTl8wKSwgXCJvdmVycmlkZXMudmFsdWVcIikgPT09IEJOXzApO1xuICAgICAgICBjb25zdCBub0RhdGEgPSAoKHR4LmRhdGEgfHwgXCIweFwiKSA9PT0gXCIweFwiKTtcbiAgICAgICAgaWYgKGlmYWNlLmZhbGxiYWNrICYmICFpZmFjZS5mYWxsYmFjay5wYXlhYmxlICYmIGlmYWNlLnJlY2VpdmUgJiYgIW5vRGF0YSAmJiAhbm9WYWx1ZSkge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiY2Fubm90IHNlbmQgZGF0YSB0byByZWNlaXZlIG9yIHNlbmQgdmFsdWUgdG8gbm9uLXBheWFibGUgZmFsbGJhY2tcIiwgXCJvdmVycmlkZXNcIiwgb3ZlcnJpZGVzKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChpZmFjZS5mYWxsYmFjayB8fCBub0RhdGEsIFwiY2Fubm90IHNlbmQgZGF0YSB0byByZWNlaXZlLW9ubHkgY29udHJhY3RcIiwgXCJvdmVycmlkZXMuZGF0YVwiLCB0eC5kYXRhKTtcbiAgICAgICAgLy8gT25seSBhbGxvdyBwYXlhYmxlIGNvbnRyYWN0cyB0byBzZXQgbm9uLXplcm8gdmFsdWVcbiAgICAgICAgY29uc3QgcGF5YWJsZSA9IGlmYWNlLnJlY2VpdmUgfHwgKGlmYWNlLmZhbGxiYWNrICYmIGlmYWNlLmZhbGxiYWNrLnBheWFibGUpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChwYXlhYmxlIHx8IG5vVmFsdWUsIFwiY2Fubm90IHNlbmQgdmFsdWUgdG8gbm9uLXBheWFibGUgZmFsbGJhY2tcIiwgXCJvdmVycmlkZXMudmFsdWVcIiwgdHgudmFsdWUpO1xuICAgICAgICAvLyBPbmx5IGFsbG93IGZhbGxiYWNrIGNvbnRyYWN0cyB0byBzZXQgbm9uLWVtcHR5IGRhdGFcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoaWZhY2UuZmFsbGJhY2sgfHwgbm9EYXRhLCBcImNhbm5vdCBzZW5kIGRhdGEgdG8gcmVjZWl2ZS1vbmx5IGNvbnRyYWN0XCIsIFwib3ZlcnJpZGVzLmRhdGFcIiwgdHguZGF0YSk7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9O1xuICAgIGNvbnN0IHN0YXRpY0NhbGwgPSBhc3luYyBmdW5jdGlvbiAob3ZlcnJpZGVzKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGdldFJ1bm5lcihjb250cmFjdC5ydW5uZXIsIFwiY2FsbFwiKTtcbiAgICAgICAgYXNzZXJ0KGNhbkNhbGwocnVubmVyKSwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBjYWxsaW5nXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImNhbGxcIiB9KTtcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCBwb3B1bGF0ZVRyYW5zYWN0aW9uKG92ZXJyaWRlcyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcnVubmVyLmNhbGwodHgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQ2FsbEV4Y2VwdGlvbihlcnJvcikgJiYgZXJyb3IuZGF0YSkge1xuICAgICAgICAgICAgICAgIHRocm93IGNvbnRyYWN0LmludGVyZmFjZS5tYWtlRXJyb3IoZXJyb3IuZGF0YSwgdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNlbmQgPSBhc3luYyBmdW5jdGlvbiAob3ZlcnJpZGVzKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGNvbnRyYWN0LnJ1bm5lcjtcbiAgICAgICAgYXNzZXJ0KGNhblNlbmQocnVubmVyKSwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBzZW5kaW5nIHRyYW5zYWN0aW9uc1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJzZW5kVHJhbnNhY3Rpb25cIiB9KTtcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCBydW5uZXIuc2VuZFRyYW5zYWN0aW9uKGF3YWl0IHBvcHVsYXRlVHJhbnNhY3Rpb24ob3ZlcnJpZGVzKSk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIoY29udHJhY3QucnVubmVyKTtcbiAgICAgICAgLy8gQFRPRE86IHRoZSBwcm92aWRlciBjYW4gYmUgbnVsbDsgbWFrZSBhIGN1c3RvbSBkdW1teSBwcm92aWRlciB0aGF0IHdpbGwgdGhyb3cgYVxuICAgICAgICAvLyBtZWFuaW5nZnVsIGVycm9yXG4gICAgICAgIHJldHVybiBuZXcgQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlKGNvbnRyYWN0LmludGVyZmFjZSwgcHJvdmlkZXIsIHR4KTtcbiAgICB9O1xuICAgIGNvbnN0IGVzdGltYXRlR2FzID0gYXN5bmMgZnVuY3Rpb24gKG92ZXJyaWRlcykge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBnZXRSdW5uZXIoY29udHJhY3QucnVubmVyLCBcImVzdGltYXRlR2FzXCIpO1xuICAgICAgICBhc3NlcnQoY2FuRXN0aW1hdGUocnVubmVyKSwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBnYXMgZXN0aW1hdGlvblwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJlc3RpbWF0ZUdhc1wiIH0pO1xuICAgICAgICByZXR1cm4gYXdhaXQgcnVubmVyLmVzdGltYXRlR2FzKGF3YWl0IHBvcHVsYXRlVHJhbnNhY3Rpb24ob3ZlcnJpZGVzKSk7XG4gICAgfTtcbiAgICBjb25zdCBtZXRob2QgPSBhc3luYyAob3ZlcnJpZGVzKSA9PiB7XG4gICAgICAgIHJldHVybiBhd2FpdCBzZW5kKG92ZXJyaWRlcyk7XG4gICAgfTtcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKG1ldGhvZCwge1xuICAgICAgICBfY29udHJhY3Q6IGNvbnRyYWN0LFxuICAgICAgICBlc3RpbWF0ZUdhcyxcbiAgICAgICAgcG9wdWxhdGVUcmFuc2FjdGlvbixcbiAgICAgICAgc2VuZCwgc3RhdGljQ2FsbFxuICAgIH0pO1xuICAgIHJldHVybiBtZXRob2Q7XG59XG5mdW5jdGlvbiBidWlsZFdyYXBwZWRNZXRob2QoY29udHJhY3QsIGtleSkge1xuICAgIGNvbnN0IGdldEZyYWdtZW50ID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RnVuY3Rpb24oa2V5LCBhcmdzKTtcbiAgICAgICAgYXNzZXJ0KGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGZyYWdtZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmcmFnbWVudFwiLFxuICAgICAgICAgICAgaW5mbzogeyBrZXksIGFyZ3MgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgIH07XG4gICAgY29uc3QgcG9wdWxhdGVUcmFuc2FjdGlvbiA9IGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gZ2V0RnJhZ21lbnQoLi4uYXJncyk7XG4gICAgICAgIC8vIElmIGFuIG92ZXJyaWRlcyB3YXMgcGFzc2VkIGluLCBjb3B5IGl0IGFuZCBub3JtYWxpemUgdGhlIHZhbHVlc1xuICAgICAgICBsZXQgb3ZlcnJpZGVzID0ge307XG4gICAgICAgIGlmIChmcmFnbWVudC5pbnB1dHMubGVuZ3RoICsgMSA9PT0gYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG92ZXJyaWRlcyA9IGF3YWl0IGNvcHlPdmVycmlkZXMoYXJncy5wb3AoKSk7XG4gICAgICAgICAgICBpZiAob3ZlcnJpZGVzLmZyb20pIHtcbiAgICAgICAgICAgICAgICBvdmVycmlkZXMuZnJvbSA9IGF3YWl0IHJlc29sdmVBZGRyZXNzKG92ZXJyaWRlcy5mcm9tLCBnZXRSZXNvbHZlcihjb250cmFjdC5ydW5uZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCAhPT0gYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludGVybmFsIGVycm9yOiBmcmFnbWVudCBpbnB1dHMgZG9lc24ndCBtYXRjaCBhcmd1bWVudHM7IHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc29sdmVkQXJncyA9IGF3YWl0IHJlc29sdmVBcmdzKGNvbnRyYWN0LnJ1bm5lciwgZnJhZ21lbnQuaW5wdXRzLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG92ZXJyaWRlcywgYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgdG86IGNvbnRyYWN0LmdldEFkZHJlc3MoKSxcbiAgICAgICAgICAgIGRhdGE6IGNvbnRyYWN0LmludGVyZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEoZnJhZ21lbnQsIHJlc29sdmVkQXJncylcbiAgICAgICAgfSkpO1xuICAgIH07XG4gICAgY29uc3Qgc3RhdGljQ2FsbCA9IGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN0YXRpY0NhbGxSZXN1bHQoLi4uYXJncyk7XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0WzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBjb25zdCBzZW5kID0gYXN5bmMgZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgcnVubmVyID0gY29udHJhY3QucnVubmVyO1xuICAgICAgICBhc3NlcnQoY2FuU2VuZChydW5uZXIpLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IHNlbmRpbmcgdHJhbnNhY3Rpb25zXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInNlbmRUcmFuc2FjdGlvblwiIH0pO1xuICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHJ1bm5lci5zZW5kVHJhbnNhY3Rpb24oYXdhaXQgcG9wdWxhdGVUcmFuc2FjdGlvbiguLi5hcmdzKSk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIoY29udHJhY3QucnVubmVyKTtcbiAgICAgICAgLy8gQFRPRE86IHRoZSBwcm92aWRlciBjYW4gYmUgbnVsbDsgbWFrZSBhIGN1c3RvbSBkdW1teSBwcm92aWRlciB0aGF0IHdpbGwgdGhyb3cgYVxuICAgICAgICAvLyBtZWFuaW5nZnVsIGVycm9yXG4gICAgICAgIHJldHVybiBuZXcgQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlKGNvbnRyYWN0LmludGVyZmFjZSwgcHJvdmlkZXIsIHR4KTtcbiAgICB9O1xuICAgIGNvbnN0IGVzdGltYXRlR2FzID0gYXN5bmMgZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgcnVubmVyID0gZ2V0UnVubmVyKGNvbnRyYWN0LnJ1bm5lciwgXCJlc3RpbWF0ZUdhc1wiKTtcbiAgICAgICAgYXNzZXJ0KGNhbkVzdGltYXRlKHJ1bm5lciksIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgZ2FzIGVzdGltYXRpb25cIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZXN0aW1hdGVHYXNcIiB9KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJ1bm5lci5lc3RpbWF0ZUdhcyhhd2FpdCBwb3B1bGF0ZVRyYW5zYWN0aW9uKC4uLmFyZ3MpKTtcbiAgICB9O1xuICAgIGNvbnN0IHN0YXRpY0NhbGxSZXN1bHQgPSBhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBnZXRSdW5uZXIoY29udHJhY3QucnVubmVyLCBcImNhbGxcIik7XG4gICAgICAgIGFzc2VydChjYW5DYWxsKHJ1bm5lciksIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgY2FsbGluZ1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJjYWxsXCIgfSk7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgcG9wdWxhdGVUcmFuc2FjdGlvbiguLi5hcmdzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiMHhcIjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IHJ1bm5lci5jYWxsKHR4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0NhbGxFeGNlcHRpb24oZXJyb3IpICYmIGVycm9yLmRhdGEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBjb250cmFjdC5pbnRlcmZhY2UubWFrZUVycm9yKGVycm9yLmRhdGEsIHR4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gZ2V0RnJhZ21lbnQoLi4uYXJncyk7XG4gICAgICAgIHJldHVybiBjb250cmFjdC5pbnRlcmZhY2UuZGVjb2RlRnVuY3Rpb25SZXN1bHQoZnJhZ21lbnQsIHJlc3VsdCk7XG4gICAgfTtcbiAgICBjb25zdCBtZXRob2QgPSBhc3luYyAoLi4uYXJncykgPT4ge1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IGdldEZyYWdtZW50KC4uLmFyZ3MpO1xuICAgICAgICBpZiAoZnJhZ21lbnQuY29uc3RhbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBzdGF0aWNDYWxsKC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCBzZW5kKC4uLmFyZ3MpO1xuICAgIH07XG4gICAgZGVmaW5lUHJvcGVydGllcyhtZXRob2QsIHtcbiAgICAgICAgbmFtZTogY29udHJhY3QuaW50ZXJmYWNlLmdldEZ1bmN0aW9uTmFtZShrZXkpLFxuICAgICAgICBfY29udHJhY3Q6IGNvbnRyYWN0LCBfa2V5OiBrZXksXG4gICAgICAgIGdldEZyYWdtZW50LFxuICAgICAgICBlc3RpbWF0ZUdhcyxcbiAgICAgICAgcG9wdWxhdGVUcmFuc2FjdGlvbixcbiAgICAgICAgc2VuZCwgc3RhdGljQ2FsbCwgc3RhdGljQ2FsbFJlc3VsdCxcbiAgICB9KTtcbiAgICAvLyBPbmx5IHdvcmtzIG9uIG5vbi1hbWJpZ3VvdXMga2V5cyAocmVmaW5lZCBmcmFnbWVudCBpcyBhbHdheXMgbm9uLWFtYmlndW91cylcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWV0aG9kLCBcImZyYWdtZW50XCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IGNvbnRyYWN0LmludGVyZmFjZS5nZXRGdW5jdGlvbihrZXkpO1xuICAgICAgICAgICAgYXNzZXJ0KGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGZyYWdtZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZnJhZ21lbnRcIixcbiAgICAgICAgICAgICAgICBpbmZvOiB7IGtleSB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBtZXRob2Q7XG59XG5mdW5jdGlvbiBidWlsZFdyYXBwZWRFdmVudChjb250cmFjdCwga2V5KSB7XG4gICAgY29uc3QgZ2V0RnJhZ21lbnQgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IGNvbnRyYWN0LmludGVyZmFjZS5nZXRFdmVudChrZXksIGFyZ3MpO1xuICAgICAgICBhc3NlcnQoZnJhZ21lbnQsIFwibm8gbWF0Y2hpbmcgZnJhZ21lbnRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImZyYWdtZW50XCIsXG4gICAgICAgICAgICBpbmZvOiB7IGtleSwgYXJncyB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgfTtcbiAgICBjb25zdCBtZXRob2QgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gbmV3IFByZXBhcmVkVG9waWNGaWx0ZXIoY29udHJhY3QsIGdldEZyYWdtZW50KC4uLmFyZ3MpLCBhcmdzKTtcbiAgICB9O1xuICAgIGRlZmluZVByb3BlcnRpZXMobWV0aG9kLCB7XG4gICAgICAgIG5hbWU6IGNvbnRyYWN0LmludGVyZmFjZS5nZXRFdmVudE5hbWUoa2V5KSxcbiAgICAgICAgX2NvbnRyYWN0OiBjb250cmFjdCwgX2tleToga2V5LFxuICAgICAgICBnZXRGcmFnbWVudFxuICAgIH0pO1xuICAgIC8vIE9ubHkgd29ya3Mgb24gbm9uLWFtYmlndW91cyBrZXlzIChyZWZpbmVkIGZyYWdtZW50IGlzIGFsd2F5cyBub24tYW1iaWd1b3VzKVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZXRob2QsIFwiZnJhZ21lbnRcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZyYWdtZW50ID0gY29udHJhY3QuaW50ZXJmYWNlLmdldEV2ZW50KGtleSk7XG4gICAgICAgICAgICBhc3NlcnQoZnJhZ21lbnQsIFwibm8gbWF0Y2hpbmcgZnJhZ21lbnRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmcmFnbWVudFwiLFxuICAgICAgICAgICAgICAgIGluZm86IHsga2V5IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG1ldGhvZDtcbn1cbi8vIFRoZSBjb21iaW5hdGlvbiBvZiBUeXBlU2NyeXBlLCBQcml2YXRlIEZpZWxkcyBhbmQgUHJveGllcyBtYWtlc1xuLy8gdGhlIHdvcmxkIGdvIGJvb207IHNvIHdlIGhpZGUgdmFyaWFibGVzIHdpdGggc29tZSB0cmlja2VyeSBrZWVwaW5nXG4vLyBhIHN5bWJvbCBhdHRhY2hlZCB0byBlYWNoIEJhc2VDb250cmFjdCB3aGljaCBpdHMgc3ViLWNsYXNzIChldmVuXG4vLyB2aWEgYSBQcm94eSkgY2FuIHJlYWNoIGFuZCB1c2UgdG8gbG9vayB1cCBpdHMgaW50ZXJuYWwgdmFsdWVzLlxuY29uc3QgaW50ZXJuYWwgPSBTeW1ib2wuZm9yKFwiX2V0aGVyc0ludGVybmFsX2NvbnRyYWN0XCIpO1xuY29uc3QgaW50ZXJuYWxWYWx1ZXMgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gc2V0SW50ZXJuYWwoY29udHJhY3QsIHZhbHVlcykge1xuICAgIGludGVybmFsVmFsdWVzLnNldChjb250cmFjdFtpbnRlcm5hbF0sIHZhbHVlcyk7XG59XG5mdW5jdGlvbiBnZXRJbnRlcm5hbChjb250cmFjdCkge1xuICAgIHJldHVybiBpbnRlcm5hbFZhbHVlcy5nZXQoY29udHJhY3RbaW50ZXJuYWxdKTtcbn1cbmZ1bmN0aW9uIGlzRGVmZXJyZWQodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiICYmIChcImdldFRvcGljRmlsdGVyXCIgaW4gdmFsdWUpICYmXG4gICAgICAgICh0eXBlb2YgKHZhbHVlLmdldFRvcGljRmlsdGVyKSA9PT0gXCJmdW5jdGlvblwiKSAmJiB2YWx1ZS5mcmFnbWVudCk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRTdWJJbmZvKGNvbnRyYWN0LCBldmVudCkge1xuICAgIGxldCB0b3BpY3M7XG4gICAgbGV0IGZyYWdtZW50ID0gbnVsbDtcbiAgICAvLyBDb252ZXJ0IG5hbWVkIGV2ZW50cyB0byB0b3BpY0hhc2ggYW5kIGdldCB0aGUgZnJhZ21lbnQgZm9yXG4gICAgLy8gZXZlbnRzIHdoaWNoIG5lZWQgZGVjb25zdHJ1Y3RpbmcuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICAgIGNvbnN0IHRvcGljSGFzaGlmeSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcobmFtZSwgMzIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IGNvbnRyYWN0LmludGVyZmFjZS5nZXRFdmVudChuYW1lKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZyYWdtZW50LCBcInVua25vd24gZnJhZ21lbnRcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50LnRvcGljSGFzaDtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQXJyYXkgb2YgVG9waWNzIGFuZCBOYW1lczsgZS5nLiBgWyBcIjB4MTIzNC4uLjg5YWJcIiwgXCJUcmFuc2ZlcihhZGRyZXNzKVwiIF1gXG4gICAgICAgIHRvcGljcyA9IGV2ZW50Lm1hcCgoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZS5tYXAodG9waWNIYXNoaWZ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b3BpY0hhc2hpZnkoZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChldmVudCA9PT0gXCIqXCIpIHtcbiAgICAgICAgdG9waWNzID0gW251bGxdO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgKGV2ZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoaXNIZXhTdHJpbmcoZXZlbnQsIDMyKSkge1xuICAgICAgICAgICAgLy8gVG9waWMgSGFzaFxuICAgICAgICAgICAgdG9waWNzID0gW2V2ZW50XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5hbWUgb3IgU2lnbmF0dXJlOyBlLmcuIGBcIlRyYW5zZmVyXCIsIGBcIlRyYW5zZmVyKGFkZHJlc3MpXCJgXG4gICAgICAgICAgICBmcmFnbWVudCA9IGNvbnRyYWN0LmludGVyZmFjZS5nZXRFdmVudChldmVudCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmcmFnbWVudCwgXCJ1bmtub3duIGZyYWdtZW50XCIsIFwiZXZlbnRcIiwgZXZlbnQpO1xuICAgICAgICAgICAgdG9waWNzID0gW2ZyYWdtZW50LnRvcGljSGFzaF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNEZWZlcnJlZChldmVudCkpIHtcbiAgICAgICAgLy8gRGVmZXJyZWQgVG9waWMgRmlsdGVyOyBlLmcuIGBjb250cmFjdC5maWx0ZXIuVHJhbnNmZXIoZnJvbSlgXG4gICAgICAgIHRvcGljcyA9IGF3YWl0IGV2ZW50LmdldFRvcGljRmlsdGVyKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKFwiZnJhZ21lbnRcIiBpbiBldmVudCkge1xuICAgICAgICAvLyBDb250cmFjdEV2ZW50OyBlLmcuIGBjb250cmFjdC5maWx0ZXIuVHJhbnNmZXJgXG4gICAgICAgIGZyYWdtZW50ID0gZXZlbnQuZnJhZ21lbnQ7XG4gICAgICAgIHRvcGljcyA9IFtmcmFnbWVudC50b3BpY0hhc2hdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5rbm93biBldmVudCBuYW1lXCIsIFwiZXZlbnRcIiwgZXZlbnQpO1xuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgdG9waWNzIGFuZCBzb3J0IFRvcGljU2V0c1xuICAgIHRvcGljcyA9IHRvcGljcy5tYXAoKHQpID0+IHtcbiAgICAgICAgaWYgKHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gQXJyYXkuZnJvbShuZXcgU2V0KHQubWFwKCh0KSA9PiB0LnRvTG93ZXJDYXNlKCkpKS52YWx1ZXMoKSk7XG4gICAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1zWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbXMuc29ydCgpO1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0LnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG4gICAgY29uc3QgdGFnID0gdG9waWNzLm1hcCgodCkgPT4ge1xuICAgICAgICBpZiAodCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0LmpvaW4oXCJ8XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH0pLmpvaW4oXCImXCIpO1xuICAgIHJldHVybiB7IGZyYWdtZW50LCB0YWcsIHRvcGljcyB9O1xufVxuYXN5bmMgZnVuY3Rpb24gaGFzU3ViKGNvbnRyYWN0LCBldmVudCkge1xuICAgIGNvbnN0IHsgc3VicyB9ID0gZ2V0SW50ZXJuYWwoY29udHJhY3QpO1xuICAgIHJldHVybiBzdWJzLmdldCgoYXdhaXQgZ2V0U3ViSW5mbyhjb250cmFjdCwgZXZlbnQpKS50YWcpIHx8IG51bGw7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRTdWIoY29udHJhY3QsIG9wZXJhdGlvbiwgZXZlbnQpIHtcbiAgICAvLyBNYWtlIHN1cmUgb3VyIHJ1bm5lciBjYW4gYWN0dWFsbHkgc3Vic2NyaWJlIHRvIGV2ZW50c1xuICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIoY29udHJhY3QucnVubmVyKTtcbiAgICBhc3NlcnQocHJvdmlkZXIsIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgc3Vic2NyaWJpbmdcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb24gfSk7XG4gICAgY29uc3QgeyBmcmFnbWVudCwgdGFnLCB0b3BpY3MgfSA9IGF3YWl0IGdldFN1YkluZm8oY29udHJhY3QsIGV2ZW50KTtcbiAgICBjb25zdCB7IGFkZHIsIHN1YnMgfSA9IGdldEludGVybmFsKGNvbnRyYWN0KTtcbiAgICBsZXQgc3ViID0gc3Vicy5nZXQodGFnKTtcbiAgICBpZiAoIXN1Yikge1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gKGFkZHIgPyBhZGRyIDogY29udHJhY3QpO1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSB7IGFkZHJlc3MsIHRvcGljcyB9O1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IChsb2cpID0+IHtcbiAgICAgICAgICAgIGxldCBmb3VuZEZyYWdtZW50ID0gZnJhZ21lbnQ7XG4gICAgICAgICAgICBpZiAoZm91bmRGcmFnbWVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRGcmFnbWVudCA9IGNvbnRyYWN0LmludGVyZmFjZS5nZXRFdmVudChsb2cudG9waWNzWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGZyYWdtZW50IGlzIG51bGwsIHdlIGRvIG5vdCBkZWNvbnN0cnVjdCB0aGUgYXJncyB0byBlbWl0XG4gICAgICAgICAgICBpZiAoZm91bmRGcmFnbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IF9mb3VuZEZyYWdtZW50ID0gZm91bmRGcmFnbWVudDtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gZnJhZ21lbnQgPyBjb250cmFjdC5pbnRlcmZhY2UuZGVjb2RlRXZlbnRMb2coZnJhZ21lbnQsIGxvZy5kYXRhLCBsb2cudG9waWNzKSA6IFtdO1xuICAgICAgICAgICAgICAgIGVtaXQoY29udHJhY3QsIGV2ZW50LCBhcmdzLCAobGlzdGVuZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb250cmFjdEV2ZW50UGF5bG9hZChjb250cmFjdCwgbGlzdGVuZXIsIGV2ZW50LCBfZm91bmRGcmFnbWVudCwgbG9nKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVtaXQoY29udHJhY3QsIGV2ZW50LCBbXSwgKGxpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29udHJhY3RVbmtub3duRXZlbnRQYXlsb2FkKGNvbnRyYWN0LCBsaXN0ZW5lciwgZXZlbnQsIGxvZyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxldCBzdGFydGluZyA9IFtdO1xuICAgICAgICBjb25zdCBzdGFydCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChzdGFydGluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydGluZy5wdXNoKHByb3ZpZGVyLm9uKGZpbHRlciwgbGlzdGVuZXIpKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3RvcCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmIChzdGFydGluZy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzdGFydGVkID0gc3RhcnRpbmc7XG4gICAgICAgICAgICBzdGFydGluZyA9IFtdO1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoc3RhcnRlZCk7XG4gICAgICAgICAgICBwcm92aWRlci5vZmYoZmlsdGVyLCBsaXN0ZW5lcik7XG4gICAgICAgIH07XG4gICAgICAgIHN1YiA9IHsgdGFnLCBsaXN0ZW5lcnM6IFtdLCBzdGFydCwgc3RvcCB9O1xuICAgICAgICBzdWJzLnNldCh0YWcsIHN1Yik7XG4gICAgfVxuICAgIHJldHVybiBzdWI7XG59XG4vLyBXZSB1c2UgdGhpcyB0byBlbnN1cmUgb25lIGVtaXQgcmVzb2x2ZXMgYmVmb3JlIGZpcmluZyB0aGUgbmV4dCB0b1xuLy8gZW5zdXJlIGNvcnJlY3Qgb3JkZXJpbmcgKG5vdGUgdGhpcyBjYW5ub3QgdGhyb3cgYW5kIGp1c3QgYWRkcyB0aGVcbi8vIG5vdGljZSB0byB0aGUgZXZlbnQgcXVldSB1c2luZyBzZXRUaW1lb3V0KS5cbmxldCBsYXN0RW1pdCA9IFByb21pc2UucmVzb2x2ZSgpO1xuYXN5bmMgZnVuY3Rpb24gX2VtaXQoY29udHJhY3QsIGV2ZW50LCBhcmdzLCBwYXlsb2FkRnVuYykge1xuICAgIGF3YWl0IGxhc3RFbWl0O1xuICAgIGNvbnN0IHN1YiA9IGF3YWl0IGhhc1N1Yihjb250cmFjdCwgZXZlbnQpO1xuICAgIGlmICghc3ViKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgY291bnQgPSBzdWIubGlzdGVuZXJzLmxlbmd0aDtcbiAgICBzdWIubGlzdGVuZXJzID0gc3ViLmxpc3RlbmVycy5maWx0ZXIoKHsgbGlzdGVuZXIsIG9uY2UgfSkgPT4ge1xuICAgICAgICBjb25zdCBwYXNzQXJncyA9IEFycmF5LmZyb20oYXJncyk7XG4gICAgICAgIGlmIChwYXlsb2FkRnVuYykge1xuICAgICAgICAgICAgcGFzc0FyZ3MucHVzaChwYXlsb2FkRnVuYyhvbmNlID8gbnVsbCA6IGxpc3RlbmVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwoY29udHJhY3QsIC4uLnBhc3NBcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICByZXR1cm4gIW9uY2U7XG4gICAgfSk7XG4gICAgaWYgKHN1Yi5saXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHN1Yi5zdG9wKCk7XG4gICAgICAgIGdldEludGVybmFsKGNvbnRyYWN0KS5zdWJzLmRlbGV0ZShzdWIudGFnKTtcbiAgICB9XG4gICAgcmV0dXJuIChjb3VudCA+IDApO1xufVxuYXN5bmMgZnVuY3Rpb24gZW1pdChjb250cmFjdCwgZXZlbnQsIGFyZ3MsIHBheWxvYWRGdW5jKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgbGFzdEVtaXQ7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgY29uc3QgcmVzdWx0UHJvbWlzZSA9IF9lbWl0KGNvbnRyYWN0LCBldmVudCwgYXJncywgcGF5bG9hZEZ1bmMpO1xuICAgIGxhc3RFbWl0ID0gcmVzdWx0UHJvbWlzZTtcbiAgICByZXR1cm4gYXdhaXQgcmVzdWx0UHJvbWlzZTtcbn1cbmNvbnN0IHBhc3NQcm9wZXJ0aWVzID0gW1widGhlblwiXTtcbmV4cG9ydCBjbGFzcyBCYXNlQ29udHJhY3Qge1xuICAgIC8qKlxuICAgICAqICBUaGUgdGFyZ2V0IHRvIGNvbm5lY3QgdG8uXG4gICAgICpcbiAgICAgKiAgVGhpcyBjYW4gYmUgYW4gYWRkcmVzcywgRU5TIG5hbWUgb3IgYW55IFtbQWRkcmVzc2FibGVdXSwgc3VjaCBhc1xuICAgICAqICBhbm90aGVyIGNvbnRyYWN0LiBUbyBnZXQgdGhlIHJlc29sdmVkIGFkZHJlc3MsIHVzZSB0aGUgYGBnZXRBZGRyZXNzYGBcbiAgICAgKiAgbWV0aG9kLlxuICAgICAqL1xuICAgIHRhcmdldDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGNvbnRyYWN0IEludGVyZmFjZS5cbiAgICAgKi9cbiAgICBpbnRlcmZhY2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBjb25uZWN0ZWQgcnVubmVyLiBUaGlzIGlzIGdlbmVyYWxseSBhIFtbUHJvdmlkZXJdXSBvciBhXG4gICAgICogIFtbU2lnbmVyXV0sIHdoaWNoIGRpY3RhdGVzIHdoYXQgb3BlcmF0aW9ucyBhcmUgc3VwcG9ydGVkLlxuICAgICAqXG4gICAgICogIEZvciBleGFtcGxlLCBhICoqQ29udHJhY3QqKiBjb25uZWN0ZWQgdG8gYSBbW1Byb3ZpZGVyXV0gbWF5XG4gICAgICogIG9ubHkgZXhlY3V0ZSByZWFkLW9ubHkgb3BlcmF0aW9ucy5cbiAgICAgKi9cbiAgICBydW5uZXI7XG4gICAgLyoqXG4gICAgICogIEFsbCB0aGUgRXZlbnRzIGF2YWlsYWJsZSBvbiB0aGlzIGNvbnRyYWN0LlxuICAgICAqL1xuICAgIGZpbHRlcnM7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIFtpbnRlcm5hbF07XG4gICAgLyoqXG4gICAgICogIFRoZSBmYWxsYmFjayBvciByZWNlaXZlIGZ1bmN0aW9uIGlmIGFueS5cbiAgICAgKi9cbiAgICBmYWxsYmFjaztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBjb250cmFjdCBjb25uZWN0ZWQgdG8gJSV0YXJnZXQlJSB3aXRoIHRoZSAlJWFiaSUlIGFuZFxuICAgICAqICBvcHRpb25hbGx5IGNvbm5lY3RlZCB0byBhICUlcnVubmVyJSUgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGJlaGFsZlxuICAgICAqICBvZi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGFiaSwgcnVubmVyLCBfZGVwbG95VHgpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mICh0YXJnZXQpID09PSBcInN0cmluZ1wiIHx8IGlzQWRkcmVzc2FibGUodGFyZ2V0KSwgXCJpbnZhbGlkIHZhbHVlIGZvciBDb250cmFjdCB0YXJnZXRcIiwgXCJ0YXJnZXRcIiwgdGFyZ2V0KTtcbiAgICAgICAgaWYgKHJ1bm5lciA9PSBudWxsKSB7XG4gICAgICAgICAgICBydW5uZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlmYWNlID0gSW50ZXJmYWNlLmZyb20oYWJpKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHRhcmdldCwgcnVubmVyLCBpbnRlcmZhY2U6IGlmYWNlIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IHt9IH0pO1xuICAgICAgICBsZXQgYWRkclByb21pc2U7XG4gICAgICAgIGxldCBhZGRyID0gbnVsbDtcbiAgICAgICAgbGV0IGRlcGxveVR4ID0gbnVsbDtcbiAgICAgICAgaWYgKF9kZXBsb3lUeCkge1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcihydW5uZXIpO1xuICAgICAgICAgICAgLy8gQFRPRE86IHRoZSBwcm92aWRlciBjYW4gYmUgbnVsbDsgbWFrZSBhIGN1c3RvbSBkdW1teSBwcm92aWRlciB0aGF0IHdpbGwgdGhyb3cgYVxuICAgICAgICAgICAgLy8gbWVhbmluZ2Z1bCBlcnJvclxuICAgICAgICAgICAgZGVwbG95VHggPSBuZXcgQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlKHRoaXMuaW50ZXJmYWNlLCBwcm92aWRlciwgX2RlcGxveVR4KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3VicyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gUmVzb2x2ZSB0aGUgdGFyZ2V0IGFzIHRoZSBhZGRyZXNzXG4gICAgICAgIGlmICh0eXBlb2YgKHRhcmdldCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmIChpc0hleFN0cmluZyh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgYWRkciA9IHRhcmdldDtcbiAgICAgICAgICAgICAgICBhZGRyUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBnZXRSdW5uZXIocnVubmVyLCBcInJlc29sdmVOYW1lXCIpO1xuICAgICAgICAgICAgICAgIGlmICghY2FuUmVzb2x2ZShyZXNvbHZlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbWFrZUVycm9yKFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgbmFtZSByZXNvbHV0aW9uXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJyZXNvbHZlTmFtZVwiXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRyUHJvbWlzZSA9IHJlc29sdmVyLnJlc29sdmVOYW1lKHRhcmdldCkudGhlbigoYWRkcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBtYWtlRXJyb3IoXCJhbiBFTlMgbmFtZSB1c2VkIGZvciBhIGNvbnRyYWN0IHRhcmdldCBtdXN0IGJlIGNvcnJlY3RseSBjb25maWd1cmVkXCIsIFwiVU5DT05GSUdVUkVEX05BTUVcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0YXJnZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGdldEludGVybmFsKHRoaXMpLmFkZHIgPSBhZGRyO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkcjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFkZHJQcm9taXNlID0gdGFyZ2V0LmdldEFkZHJlc3MoKS50aGVuKChhZGRyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGFkZHIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUT0RPXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnZXRJbnRlcm5hbCh0aGlzKS5hZGRyID0gYWRkcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWRkcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBvdXIgcHJpdmF0ZSB2YWx1ZXNcbiAgICAgICAgc2V0SW50ZXJuYWwodGhpcywgeyBhZGRyUHJvbWlzZSwgYWRkciwgZGVwbG95VHgsIHN1YnMgfSk7XG4gICAgICAgIC8vIEFkZCB0aGUgZXZlbnQgZmlsdGVyc1xuICAgICAgICBjb25zdCBmaWx0ZXJzID0gbmV3IFByb3h5KHt9LCB7XG4gICAgICAgICAgICBnZXQ6ICh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gUGFzcyBpbXBvcnRhbnQgY2hlY2tzIChsaWtlIGB0aGVuYCBmb3IgUHJvbWlzZSkgdGhyb3VnaFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHByb3ApID09PSBcInN5bWJvbFwiIHx8IHBhc3NQcm9wZXJ0aWVzLmluZGV4T2YocHJvcCkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEV2ZW50KHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Vycm9yKGVycm9yLCBcIklOVkFMSURfQVJHVU1FTlRcIikgfHwgZXJyb3IuYXJndW1lbnQgIT09IFwia2V5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFzOiAodGFyZ2V0LCBwcm9wKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gUGFzcyBpbXBvcnRhbnQgY2hlY2tzIChsaWtlIGB0aGVuYCBmb3IgUHJvbWlzZSkgdGhyb3VnaFxuICAgICAgICAgICAgICAgIGlmIChwYXNzUHJvcGVydGllcy5pbmRleE9mKHByb3ApID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApIHx8IHRoaXMuaW50ZXJmYWNlLmhhc0V2ZW50KFN0cmluZyhwcm9wKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgZmlsdGVycyB9KTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBmYWxsYmFjazogKChpZmFjZS5yZWNlaXZlIHx8IGlmYWNlLmZhbGxiYWNrKSA/IChidWlsZFdyYXBwZWRGYWxsYmFjayh0aGlzKSkgOiBudWxsKVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gUmV0dXJuIGEgUHJveHkgdGhhdCB3aWxsIHJlc3BvbmQgdG8gZnVuY3Rpb25zXG4gICAgICAgIHJldHVybiBuZXcgUHJveHkodGhpcywge1xuICAgICAgICAgICAgZ2V0OiAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHByb3ApID09PSBcInN5bWJvbFwiIHx8IHByb3AgaW4gdGFyZ2V0IHx8IHBhc3NQcm9wZXJ0aWVzLmluZGV4T2YocHJvcCkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVuZGVmaW5lZCBwcm9wZXJ0aWVzIHNob3VsZCByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5nZXRGdW5jdGlvbihwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNFcnJvcihlcnJvciwgXCJJTlZBTElEX0FSR1VNRU5UXCIpIHx8IGVycm9yLmFyZ3VtZW50ICE9PSBcImtleVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhczogKHRhcmdldCwgcHJvcCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHByb3ApID09PSBcInN5bWJvbFwiIHx8IHByb3AgaW4gdGFyZ2V0IHx8IHBhc3NQcm9wZXJ0aWVzLmluZGV4T2YocHJvcCkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5pbnRlcmZhY2UuaGFzRnVuY3Rpb24ocHJvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IENvbnRyYWN0IGluc3RhbmNlIHdpdGggdGhlIHNhbWUgdGFyZ2V0IGFuZCBBQkksIGJ1dFxuICAgICAqICBhIGRpZmZlcmVudCAlJXJ1bm5lciUlLlxuICAgICAqL1xuICAgIGNvbm5lY3QocnVubmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmFzZUNvbnRyYWN0KHRoaXMudGFyZ2V0LCB0aGlzLmludGVyZmFjZSwgcnVubmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBDb250cmFjdCBpbnN0YW5jZSB3aXRoIHRoZSBzYW1lIEFCSSBhbmQgcnVubmVyLCBidXRcbiAgICAgKiAgYSBkaWZmZXJlbnQgJSV0YXJnZXQlJS5cbiAgICAgKi9cbiAgICBhdHRhY2godGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQmFzZUNvbnRyYWN0KHRhcmdldCwgdGhpcy5pbnRlcmZhY2UsIHRoaXMucnVubmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgcmVzb2x2ZWQgYWRkcmVzcyBvZiB0aGlzIENvbnRyYWN0LlxuICAgICAqL1xuICAgIGFzeW5jIGdldEFkZHJlc3MoKSB7IHJldHVybiBhd2FpdCBnZXRJbnRlcm5hbCh0aGlzKS5hZGRyUHJvbWlzZTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGRlcGxveWVkIGJ5dGVjb2RlIG9yIG51bGwgaWYgbm8gYnl0ZWNvZGUgaXMgZm91bmQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0RGVwbG95ZWRDb2RlKCkge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKHRoaXMucnVubmVyKTtcbiAgICAgICAgYXNzZXJ0KHByb3ZpZGVyLCBcInJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IC5wcm92aWRlclwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJnZXREZXBsb3llZENvZGVcIiB9KTtcbiAgICAgICAgY29uc3QgY29kZSA9IGF3YWl0IHByb3ZpZGVyLmdldENvZGUoYXdhaXQgdGhpcy5nZXRBZGRyZXNzKCkpO1xuICAgICAgICBpZiAoY29kZSA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmUgdG8gdGhpcyBDb250cmFjdCBvbmNlIHRoZSBieXRlY29kZSBoYXMgYmVlbiBkZXBsb3llZCwgb3JcbiAgICAgKiAgcmVzb2x2ZSBpbW1lZGlhdGVseSBpZiBhbHJlYWR5IGRlcGxveWVkLlxuICAgICAqL1xuICAgIGFzeW5jIHdhaXRGb3JEZXBsb3ltZW50KCkge1xuICAgICAgICAvLyBXZSBoYXZlIHRoZSBkZXBsb3ltZW50IHRyYW5zYWN0aW9uOyBqdXN0IHVzZSB0aGF0ICh0aHJvd3MgaWYgZGVwbG95bWVudCBmYWlscylcbiAgICAgICAgY29uc3QgZGVwbG95VHggPSB0aGlzLmRlcGxveW1lbnRUcmFuc2FjdGlvbigpO1xuICAgICAgICBpZiAoZGVwbG95VHgpIHtcbiAgICAgICAgICAgIGF3YWl0IGRlcGxveVR4LndhaXQoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGZvciBjb2RlXG4gICAgICAgIGNvbnN0IGNvZGUgPSBhd2FpdCB0aGlzLmdldERlcGxveWVkQ29kZSgpO1xuICAgICAgICBpZiAoY29kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgY2FuIHN1YnNjcmliZSB0byBhIHByb3ZpZGVyIGV2ZW50XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIodGhpcy5ydW5uZXIpO1xuICAgICAgICBhc3NlcnQocHJvdmlkZXIgIT0gbnVsbCwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCAucHJvdmlkZXJcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwid2FpdEZvckRlcGxveW1lbnRcIiB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrQ29kZSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0gYXdhaXQgdGhpcy5nZXREZXBsb3llZENvZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIub25jZShcImJsb2NrXCIsIGNoZWNrQ29kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjaGVja0NvZGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHRyYW5zYWN0aW9uIHVzZWQgdG8gZGVwbG95IHRoaXMgY29udHJhY3QuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBvbmx5IGF2YWlsYWJsZSBpZiB0aGlzIGluc3RhbmNlIHdhcyByZXR1cm5lZCBmcm9tIGFcbiAgICAgKiAgW1tDb250cmFjdEZhY3RvcnldXS5cbiAgICAgKi9cbiAgICBkZXBsb3ltZW50VHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRJbnRlcm5hbCh0aGlzKS5kZXBsb3lUeDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgZnVuY3Rpb24gZm9yIGEgZ2l2ZW4gbmFtZS4gVGhpcyBpcyB1c2VmdWwgd2hlbiBhIGNvbnRyYWN0XG4gICAgICogIG1ldGhvZCBuYW1lIGNvbmZsaWN0cyB3aXRoIGEgSmF2YVNjcmlwdCBuYW1lIHN1Y2ggYXMgYGBwcm90b3R5cGVgYCBvclxuICAgICAqICB3aGVuIHVzaW5nIGEgQ29udHJhY3QgcHJvZ3JhbW1hdGljYWxseS5cbiAgICAgKi9cbiAgICBnZXRGdW5jdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoa2V5KSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAga2V5ID0ga2V5LmZvcm1hdCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZ1bmMgPSBidWlsZFdyYXBwZWRNZXRob2QodGhpcywga2V5KTtcbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGV2ZW50IGZvciBhIGdpdmVuIG5hbWUuIFRoaXMgaXMgdXNlZnVsIHdoZW4gYSBjb250cmFjdFxuICAgICAqICBldmVudCBuYW1lIGNvbmZsaWN0cyB3aXRoIGEgSmF2YVNjcmlwdCBuYW1lIHN1Y2ggYXMgYGBwcm90b3R5cGVgYCBvclxuICAgICAqICB3aGVuIHVzaW5nIGEgQ29udHJhY3QgcHJvZ3JhbW1hdGljYWxseS5cbiAgICAgKi9cbiAgICBnZXRFdmVudChrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoa2V5KSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAga2V5ID0ga2V5LmZvcm1hdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWlsZFdyYXBwZWRFdmVudCh0aGlzLCBrZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgYXN5bmMgcXVlcnlUcmFuc2FjdGlvbihoYXNoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBUT0RPXCIpO1xuICAgIH1cbiAgICAvKlxuICAgIC8vIEBUT0RPOiB0aGlzIGlzIGEgbm9uLWJhY2t3YXJkcyBjb21wYXRpYmxlIGNoYW5nZSwgYnV0IHdpbGwgYmUgYWRkZWRcbiAgICAvLyAgICAgICAgaW4gdjcgYW5kIGluIGEgcG90ZW50aWFsIFNtYXJ0Q29udHJhY3QgY2xhc3MgaW4gYW4gdXBjb21pbmdcbiAgICAvLyAgICAgICAgdjYgcmVsZWFzZVxuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uUmVjZWlwdChoYXNoOiBzdHJpbmcpOiBQcm9taXNlPG51bGwgfCBDb250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdD4ge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKHRoaXMucnVubmVyKTtcbiAgICAgICAgYXNzZXJ0KHByb3ZpZGVyLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBoYXZlIGEgcHJvdmlkZXJcIixcbiAgICAgICAgICAgIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInF1ZXJ5VHJhbnNhY3Rpb25cIiB9KTtcblxuICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgcHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGhhc2gpO1xuICAgICAgICBpZiAocmVjZWlwdCA9PSBudWxsKSB7IHJldHVybiBudWxsOyB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBDb250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdCh0aGlzLmludGVyZmFjZSwgcHJvdmlkZXIsIHJlY2VpcHQpO1xuICAgIH1cbiAgICAqL1xuICAgIC8qKlxuICAgICAqICBQcm92aWRlIGhpc3RvcmljIGFjY2VzcyB0byBldmVudCBkYXRhIGZvciAlJWV2ZW50JSUgaW4gdGhlIHJhbmdlXG4gICAgICogICUlZnJvbUJsb2NrJSUgKGRlZmF1bHQ6IGBgMGBgKSB0byAlJXRvQmxvY2slJSAoZGVmYXVsdDogYGBcImxhdGVzdFwiYGApXG4gICAgICogIGluY2x1c2l2ZS5cbiAgICAgKi9cbiAgICBhc3luYyBxdWVyeUZpbHRlcihldmVudCwgZnJvbUJsb2NrLCB0b0Jsb2NrKSB7XG4gICAgICAgIGlmIChmcm9tQmxvY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgZnJvbUJsb2NrID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9CbG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICB0b0Jsb2NrID0gXCJsYXRlc3RcIjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGFkZHIsIGFkZHJQcm9taXNlIH0gPSBnZXRJbnRlcm5hbCh0aGlzKTtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IChhZGRyID8gYWRkciA6IChhd2FpdCBhZGRyUHJvbWlzZSkpO1xuICAgICAgICBjb25zdCB7IGZyYWdtZW50LCB0b3BpY3MgfSA9IGF3YWl0IGdldFN1YkluZm8odGhpcywgZXZlbnQpO1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSB7IGFkZHJlc3MsIHRvcGljcywgZnJvbUJsb2NrLCB0b0Jsb2NrIH07XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIodGhpcy5ydW5uZXIpO1xuICAgICAgICBhc3NlcnQocHJvdmlkZXIsIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IGhhdmUgYSBwcm92aWRlclwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJxdWVyeUZpbHRlclwiIH0pO1xuICAgICAgICByZXR1cm4gKGF3YWl0IHByb3ZpZGVyLmdldExvZ3MoZmlsdGVyKSkubWFwKChsb2cpID0+IHtcbiAgICAgICAgICAgIGxldCBmb3VuZEZyYWdtZW50ID0gZnJhZ21lbnQ7XG4gICAgICAgICAgICBpZiAoZm91bmRGcmFnbWVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRGcmFnbWVudCA9IHRoaXMuaW50ZXJmYWNlLmdldEV2ZW50KGxvZy50b3BpY3NbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvdW5kRnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50TG9nKGxvZywgdGhpcy5pbnRlcmZhY2UsIGZvdW5kRnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVbmRlY29kZWRFdmVudExvZyhsb2csIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IExvZyhsb2csIHByb3ZpZGVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBBZGQgYW4gZXZlbnQgJSVsaXN0ZW5lciUlIGZvciB0aGUgJSVldmVudCUlLlxuICAgICAqL1xuICAgIGFzeW5jIG9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCBnZXRTdWIodGhpcywgXCJvblwiLCBldmVudCk7XG4gICAgICAgIHN1Yi5saXN0ZW5lcnMucHVzaCh7IGxpc3RlbmVyLCBvbmNlOiBmYWxzZSB9KTtcbiAgICAgICAgc3ViLnN0YXJ0KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQWRkIGFuIGV2ZW50ICUlbGlzdGVuZXIlJSBmb3IgdGhlICUlZXZlbnQlJSwgYnV0IHJlbW92ZSB0aGUgbGlzdGVuZXJcbiAgICAgKiAgYWZ0ZXIgaXQgaXMgZmlyZWQgb25jZS5cbiAgICAgKi9cbiAgICBhc3luYyBvbmNlKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCBnZXRTdWIodGhpcywgXCJvbmNlXCIsIGV2ZW50KTtcbiAgICAgICAgc3ViLmxpc3RlbmVycy5wdXNoKHsgbGlzdGVuZXIsIG9uY2U6IHRydWUgfSk7XG4gICAgICAgIHN1Yi5zdGFydCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEVtaXQgYW4gJSVldmVudCUlIGNhbGxpbmcgYWxsIGxpc3RlbmVycyB3aXRoICUlYXJncyUlLlxuICAgICAqXG4gICAgICogIFJlc29sdmVzIHRvIGBgdHJ1ZWBgIGlmIGFueSBsaXN0ZW5lcnMgd2VyZSBjYWxsZWQuXG4gICAgICovXG4gICAgYXN5bmMgZW1pdChldmVudCwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gYXdhaXQgZW1pdCh0aGlzLCBldmVudCwgYXJncywgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgbnVtYmVyIG9mIGxpc3RlbmVycyBvZiAlJWV2ZW50JSUgb3IgdGhlIHRvdGFsIG51bWJlclxuICAgICAqICBvZiBsaXN0ZW5lcnMgaWYgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgYXN5bmMgbGlzdGVuZXJDb3VudChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IGhhc1N1Yih0aGlzLCBldmVudCk7XG4gICAgICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1Yi5saXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc3VicyB9ID0gZ2V0SW50ZXJuYWwodGhpcyk7XG4gICAgICAgIGxldCB0b3RhbCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgeyBsaXN0ZW5lcnMgfSBvZiBzdWJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICB0b3RhbCArPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBsaXN0ZW5lcnMgc3Vic2NyaWJlZCB0byAlJWV2ZW50JSUgb3IgYWxsIGxpc3RlbmVyc1xuICAgICAqICBpZiB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCBoYXNTdWIodGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFzdWIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3ViLmxpc3RlbmVycy5tYXAoKHsgbGlzdGVuZXIgfSkgPT4gbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc3VicyB9ID0gZ2V0SW50ZXJuYWwodGhpcyk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB7IGxpc3RlbmVycyB9IG9mIHN1YnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQobGlzdGVuZXJzLm1hcCgoeyBsaXN0ZW5lciB9KSA9PiBsaXN0ZW5lcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZW1vdmUgdGhlICUlbGlzdGVuZXIlJSBmcm9tIHRoZSBsaXN0ZW5lcnMgZm9yICUlZXZlbnQlJSBvciByZW1vdmVcbiAgICAgKiAgYWxsIGxpc3RlbmVycyBpZiB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBhc3luYyBvZmYoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IGhhc1N1Yih0aGlzLCBldmVudCk7XG4gICAgICAgIGlmICghc3ViKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gc3ViLmxpc3RlbmVycy5tYXAoKHsgbGlzdGVuZXIgfSkgPT4gbGlzdGVuZXIpLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICBzdWIubGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpc3RlbmVyID09IG51bGwgfHwgc3ViLmxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHN1Yi5zdG9wKCk7XG4gICAgICAgICAgICBnZXRJbnRlcm5hbCh0aGlzKS5zdWJzLmRlbGV0ZShzdWIudGFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlbW92ZSBhbGwgdGhlIGxpc3RlbmVycyBmb3IgJSVldmVudCUlIG9yIHJlbW92ZSBhbGwgbGlzdGVuZXJzIGlmXG4gICAgICogIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIGFzeW5jIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IGhhc1N1Yih0aGlzLCBldmVudCk7XG4gICAgICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3ViLnN0b3AoKTtcbiAgICAgICAgICAgIGdldEludGVybmFsKHRoaXMpLnN1YnMuZGVsZXRlKHN1Yi50YWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgeyBzdWJzIH0gPSBnZXRJbnRlcm5hbCh0aGlzKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyB0YWcsIHN0b3AgfSBvZiBzdWJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICAgICAgICAgIHN1YnMuZGVsZXRlKHRhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBBbGlhcyBmb3IgW29uXS5cbiAgICAgKi9cbiAgICBhc3luYyBhZGRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMub24oZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEFsaWFzIGZvciBbb2ZmXS5cbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMub2ZmKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgQ2xhc3MgZm9yIHRoZSAlJWFiaSUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBidWlsZENsYXNzKGFiaSkge1xuICAgICAgICBjbGFzcyBDdXN0b21Db250cmFjdCBleHRlbmRzIEJhc2VDb250cmFjdCB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBydW5uZXIgPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3VwZXIoYWRkcmVzcywgYWJpLCBydW5uZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDdXN0b21Db250cmFjdDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgQmFzZUNvbnRyYWN0IHdpdGggYSBzcGVjaWZpZWQgSW50ZXJmYWNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKHRhcmdldCwgYWJpLCBydW5uZXIpIHtcbiAgICAgICAgaWYgKHJ1bm5lciA9PSBudWxsKSB7XG4gICAgICAgICAgICBydW5uZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IHRoaXModGFyZ2V0LCBhYmksIHJ1bm5lcik7XG4gICAgICAgIHJldHVybiBjb250cmFjdDtcbiAgICB9XG59XG5mdW5jdGlvbiBfQ29udHJhY3RCYXNlKCkge1xuICAgIHJldHVybiBCYXNlQ29udHJhY3Q7XG59XG4vKipcbiAqICBBIFtbQmFzZUNvbnRyYWN0XV0gd2l0aCBubyB0eXBlIGd1YXJkcyBvbiBpdHMgbWV0aG9kcyBvciBldmVudHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBDb250cmFjdCBleHRlbmRzIF9Db250cmFjdEJhc2UoKSB7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250cmFjdC5qcy5tYXAiXSwibmFtZXMiOlsiSW50ZXJmYWNlIiwiVHlwZWQiLCJpc0FkZHJlc3NhYmxlIiwicmVzb2x2ZUFkZHJlc3MiLCJjb3B5UmVxdWVzdCIsIkxvZyIsImRlZmluZVByb3BlcnRpZXMiLCJnZXRCaWdJbnQiLCJpc0NhbGxFeGNlcHRpb24iLCJpc0hleFN0cmluZyIsInJlc29sdmVQcm9wZXJ0aWVzIiwiaXNFcnJvciIsIm1ha2VFcnJvciIsImFzc2VydCIsImFzc2VydEFyZ3VtZW50IiwiQ29udHJhY3RFdmVudFBheWxvYWQiLCJDb250cmFjdFVua25vd25FdmVudFBheWxvYWQiLCJDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UiLCJFdmVudExvZyIsIlVuZGVjb2RlZEV2ZW50TG9nIiwiQk5fMCIsIkJpZ0ludCIsImNhbkNhbGwiLCJ2YWx1ZSIsImNhbGwiLCJjYW5Fc3RpbWF0ZSIsImVzdGltYXRlR2FzIiwiY2FuUmVzb2x2ZSIsInJlc29sdmVOYW1lIiwiY2FuU2VuZCIsInNlbmRUcmFuc2FjdGlvbiIsImdldFJlc29sdmVyIiwicHJvdmlkZXIiLCJ1bmRlZmluZWQiLCJQcmVwYXJlZFRvcGljRmlsdGVyIiwiZ2V0VG9waWNGaWx0ZXIiLCJmaWx0ZXIiLCJjb25zdHJ1Y3RvciIsImNvbnRyYWN0IiwiZnJhZ21lbnQiLCJhcmdzIiwiaW5wdXRzIiwibGVuZ3RoIiwiRXJyb3IiLCJydW5uZXIiLCJnZXRSdW5uZXIiLCJyZXNvbHZlciIsInJlc29sdmVkQXJncyIsIlByb21pc2UiLCJhbGwiLCJtYXAiLCJwYXJhbSIsImluZGV4IiwiYXJnIiwid2Fsa0FzeW5jIiwidHlwZSIsIkFycmF5IiwiaXNBcnJheSIsInYiLCJpbnRlcmZhY2UiLCJlbmNvZGVGaWx0ZXJUb3BpY3MiLCJmZWF0dXJlIiwiZ2V0UHJvdmlkZXIiLCJjb3B5T3ZlcnJpZGVzIiwiYWxsb3dlZCIsIl9vdmVycmlkZXMiLCJkZXJlZmVyZW5jZSIsIm92ZXJyaWRlcyIsInRvIiwiaW5kZXhPZiIsImRhdGEiLCJmcm9tIiwicmVzb2x2ZUFyZ3MiLCJfcnVubmVyIiwiYnVpbGRXcmFwcGVkRmFsbGJhY2siLCJwb3B1bGF0ZVRyYW5zYWN0aW9uIiwidHgiLCJnZXRBZGRyZXNzIiwiaWZhY2UiLCJub1ZhbHVlIiwibm9EYXRhIiwiZmFsbGJhY2siLCJwYXlhYmxlIiwicmVjZWl2ZSIsInN0YXRpY0NhbGwiLCJvcGVyYXRpb24iLCJlcnJvciIsInNlbmQiLCJtZXRob2QiLCJfY29udHJhY3QiLCJidWlsZFdyYXBwZWRNZXRob2QiLCJrZXkiLCJnZXRGcmFnbWVudCIsImdldEZ1bmN0aW9uIiwiaW5mbyIsInBvcCIsIk9iamVjdCIsImFzc2lnbiIsImVuY29kZUZ1bmN0aW9uRGF0YSIsInJlc3VsdCIsInN0YXRpY0NhbGxSZXN1bHQiLCJkZWNvZGVGdW5jdGlvblJlc3VsdCIsImNvbnN0YW50IiwibmFtZSIsImdldEZ1bmN0aW9uTmFtZSIsIl9rZXkiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJnZXQiLCJidWlsZFdyYXBwZWRFdmVudCIsImdldEV2ZW50IiwiZ2V0RXZlbnROYW1lIiwiaW50ZXJuYWwiLCJTeW1ib2wiLCJmb3IiLCJpbnRlcm5hbFZhbHVlcyIsIldlYWtNYXAiLCJzZXRJbnRlcm5hbCIsInZhbHVlcyIsInNldCIsImdldEludGVybmFsIiwiaXNEZWZlcnJlZCIsImdldFN1YkluZm8iLCJldmVudCIsInRvcGljcyIsInRvcGljSGFzaGlmeSIsInRvcGljSGFzaCIsImUiLCJ0IiwiaXRlbXMiLCJTZXQiLCJ0b0xvd2VyQ2FzZSIsInNvcnQiLCJ0YWciLCJqb2luIiwiaGFzU3ViIiwic3VicyIsImdldFN1YiIsImFkZHIiLCJzdWIiLCJhZGRyZXNzIiwibGlzdGVuZXIiLCJsb2ciLCJmb3VuZEZyYWdtZW50IiwiX2ZvdW5kRnJhZ21lbnQiLCJkZWNvZGVFdmVudExvZyIsImVtaXQiLCJzdGFydGluZyIsInN0YXJ0IiwicHVzaCIsIm9uIiwic3RvcCIsInN0YXJ0ZWQiLCJvZmYiLCJsaXN0ZW5lcnMiLCJsYXN0RW1pdCIsInJlc29sdmUiLCJfZW1pdCIsInBheWxvYWRGdW5jIiwiY291bnQiLCJvbmNlIiwicGFzc0FyZ3MiLCJkZWxldGUiLCJyZXN1bHRQcm9taXNlIiwicGFzc1Byb3BlcnRpZXMiLCJCYXNlQ29udHJhY3QiLCJjb25uZWN0IiwidGFyZ2V0IiwiYXR0YWNoIiwiYWRkclByb21pc2UiLCJnZXREZXBsb3llZENvZGUiLCJjb2RlIiwiZ2V0Q29kZSIsIndhaXRGb3JEZXBsb3ltZW50IiwiZGVwbG95VHgiLCJkZXBsb3ltZW50VHJhbnNhY3Rpb24iLCJ3YWl0IiwicmVqZWN0IiwiY2hlY2tDb2RlIiwiZm9ybWF0IiwiZnVuYyIsInF1ZXJ5VHJhbnNhY3Rpb24iLCJoYXNoIiwicXVlcnlGaWx0ZXIiLCJmcm9tQmxvY2siLCJ0b0Jsb2NrIiwiZ2V0TG9ncyIsImxpc3RlbmVyQ291bnQiLCJ0b3RhbCIsImNvbmNhdCIsInNwbGljZSIsInJlbW92ZUFsbExpc3RlbmVycyIsImFkZExpc3RlbmVyIiwicmVtb3ZlTGlzdGVuZXIiLCJidWlsZENsYXNzIiwiYWJpIiwiQ3VzdG9tQ29udHJhY3QiLCJfZGVwbG95VHgiLCJNYXAiLCJ0aGVuIiwiZmlsdGVycyIsIlByb3h5IiwicHJvcCIsInJlY2VpdmVyIiwiUmVmbGVjdCIsImFyZ3VtZW50IiwiaGFzIiwiaGFzRXZlbnQiLCJTdHJpbmciLCJoYXNGdW5jdGlvbiIsIl9Db250cmFjdEJhc2UiLCJDb250cmFjdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/contract/contract.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/contract/wrappers.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/contract/wrappers.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContractEventPayload: function() { return /* binding */ ContractEventPayload; },\n/* harmony export */   ContractTransactionReceipt: function() { return /* binding */ ContractTransactionReceipt; },\n/* harmony export */   ContractTransactionResponse: function() { return /* binding */ ContractTransactionResponse; },\n/* harmony export */   ContractUnknownEventPayload: function() { return /* binding */ ContractUnknownEventPayload; },\n/* harmony export */   EventLog: function() { return /* binding */ EventLog; },\n/* harmony export */   UndecodedEventLog: function() { return /* binding */ UndecodedEventLog; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_get */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_get.js\");\n/* harmony import */ var _swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_init */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_init.js\");\n/* harmony import */ var _swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_set */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_set.js\");\n/* harmony import */ var _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../providers/provider.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/providers/provider.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/events.js\");\n// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\n\n\n\n\n\n/**\n *  An **EventLog** contains additional properties parsed from the [[Log]].\n */ class EventLog extends _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__.Log {\n    /**\n     *  The name of the event.\n     */ get eventName() {\n        return this.fragment.name;\n    }\n    /**\n     *  The signature of the event.\n     */ get eventSignature() {\n        return this.fragment.format();\n    }\n    /**\n     * @_ignore:\n     */ constructor(log, iface, fragment){\n        super(log, log.provider);\n        const args = iface.decodeEventLog(fragment, log.data, log.topics);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            args,\n            fragment,\n            interface: iface\n        });\n    }\n}\n/**\n *  An **EventLog** contains additional properties parsed from the [[Log]].\n */ class UndecodedEventLog extends _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__.Log {\n    /**\n     * @_ignore:\n     */ constructor(log, error){\n        super(log, log.provider);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            error\n        });\n    }\n}\nvar _iface = /*#__PURE__*/ new WeakMap();\n/**\n *  A **ContractTransactionReceipt** includes the parsed logs from a\n *  [[TransactionReceipt]].\n */ class ContractTransactionReceipt extends _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__.TransactionReceipt {\n    /**\n     *  The parsed logs for any [[Log]] which has a matching event in the\n     *  Contract ABI.\n     */ get logs() {\n        return super.logs.map((log)=>{\n            const fragment = log.topics.length ? (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _iface).getEvent(log.topics[0]) : null;\n            if (fragment) {\n                try {\n                    return new EventLog(log, (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _iface), fragment);\n                } catch (error) {\n                    return new UndecodedEventLog(log, error);\n                }\n            }\n            return log;\n        });\n    }\n    /**\n     *  @_ignore:\n     */ constructor(iface, provider, tx){\n        super(tx, provider);\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_3__._)(this, _iface, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_4__._)(this, _iface, iface);\n    }\n}\nvar _iface1 = /*#__PURE__*/ new WeakMap();\n/**\n *  A **ContractTransactionResponse** will return a\n *  [[ContractTransactionReceipt]] when waited on.\n */ class ContractTransactionResponse extends _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__.TransactionResponse {\n    /**\n     *  Resolves once this transaction has been mined and has\n     *  %%confirms%% blocks including it (default: ``1``) with an\n     *  optional %%timeout%%.\n     *\n     *  This can resolve to ``null`` only if %%confirms%% is ``0``\n     *  and the transaction has not been mined, otherwise this will\n     *  wait until enough confirmations have completed.\n     */ async wait(confirms, timeout) {\n        const receipt = await super.wait(confirms, timeout);\n        if (receipt == null) {\n            return null;\n        }\n        return new ContractTransactionReceipt((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _iface1), this.provider, receipt);\n    }\n    /**\n     *  @_ignore:\n     */ constructor(iface, provider, tx){\n        super(tx, provider);\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_3__._)(this, _iface1, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_4__._)(this, _iface1, iface);\n    }\n}\n/**\n *  A **ContractUnknownEventPayload** is included as the last parameter to\n *  Contract Events when the event does not match any events in the ABI.\n */ class ContractUnknownEventPayload extends _utils_index_js__WEBPACK_IMPORTED_MODULE_5__.EventPayload {\n    /**\n     *  Resolves to the block the event occured in.\n     */ async getBlock() {\n        return await this.log.getBlock();\n    }\n    /**\n     *  Resolves to the transaction the event occured in.\n     */ async getTransaction() {\n        return await this.log.getTransaction();\n    }\n    /**\n     *  Resolves to the transaction receipt the event occured in.\n     */ async getTransactionReceipt() {\n        return await this.log.getTransactionReceipt();\n    }\n    /**\n     *  @_event:\n     */ constructor(contract, listener, filter, log){\n        super(contract, listener, filter);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            log\n        });\n    }\n}\n/**\n *  A **ContractEventPayload** is included as the last parameter to\n *  Contract Events when the event is known.\n */ class ContractEventPayload extends ContractUnknownEventPayload {\n    /**\n     *  The event name.\n     */ get eventName() {\n        return this.fragment.name;\n    }\n    /**\n     *  The event signature.\n     */ get eventSignature() {\n        return this.fragment.format();\n    }\n    /**\n     *  @_ignore:\n     */ constructor(contract, listener, filter, fragment, _log){\n        super(contract, listener, filter, new EventLog(_log, contract.interface, fragment));\n        const args = contract.interface.decodeEventLog(fragment, this.log.data, this.log.topics);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            args,\n            fragment\n        });\n    }\n} //# sourceMappingURL=wrappers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jb250cmFjdC93cmFwcGVycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQSxzRUFBc0U7QUFDdEUseUJBQXlCOzs7O0FBQytEO0FBQ3JCO0FBQ25FOztDQUVDLEdBQ00sTUFBTUssaUJBQWlCTCx1REFBR0E7SUFxQjdCOztLQUVDLEdBQ0QsSUFBSU0sWUFBWTtRQUFFLE9BQU8sSUFBSSxDQUFDQyxRQUFRLENBQUNDLElBQUk7SUFBRTtJQUM3Qzs7S0FFQyxHQUNELElBQUlDLGlCQUFpQjtRQUFFLE9BQU8sSUFBSSxDQUFDRixRQUFRLENBQUNHLE1BQU07SUFBSTtJQWZ0RDs7S0FFQyxHQUNEQyxZQUFZQyxHQUFHLEVBQUVDLEtBQUssRUFBRU4sUUFBUSxDQUFFO1FBQzlCLEtBQUssQ0FBQ0ssS0FBS0EsSUFBSUUsUUFBUTtRQUN2QixNQUFNQyxPQUFPRixNQUFNRyxjQUFjLENBQUNULFVBQVVLLElBQUlLLElBQUksRUFBRUwsSUFBSU0sTUFBTTtRQUNoRWYsaUVBQWdCQSxDQUFDLElBQUksRUFBRTtZQUFFWTtZQUFNUjtZQUFVWSxXQUFXTjtRQUFNO0lBQzlEO0FBU0o7QUFDQTs7Q0FFQyxHQUNNLE1BQU1PLDBCQUEwQnBCLHVEQUFHQTtJQUt0Qzs7S0FFQyxHQUNEVyxZQUFZQyxHQUFHLEVBQUVTLEtBQUssQ0FBRTtRQUNwQixLQUFLLENBQUNULEtBQUtBLElBQUlFLFFBQVE7UUFDdkJYLGlFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFBRWtCO1FBQU07SUFDbkM7QUFDSjtJQU1JO0FBTEo7OztDQUdDLEdBQ00sTUFBTUMsbUNBQW1DckIsc0VBQWtCQTtJQVM5RDs7O0tBR0MsR0FDRCxJQUFJc0IsT0FBTztRQUNQLE9BQU8sS0FBSyxDQUFDQSxLQUFLQyxHQUFHLENBQUMsQ0FBQ1o7WUFDbkIsTUFBTUwsV0FBV0ssSUFBSU0sTUFBTSxDQUFDTyxNQUFNLEdBQUcsNEVBQUksRUFBRVosUUFBTWEsUUFBUSxDQUFDZCxJQUFJTSxNQUFNLENBQUMsRUFBRSxJQUFJO1lBQzNFLElBQUlYLFVBQVU7Z0JBQ1YsSUFBSTtvQkFDQSxPQUFPLElBQUlGLFNBQVNPLEtBQUtBLHVFQUFBQSxDQUFBLElBQUksRUFBRUMsU0FBT047Z0JBQzFDLEVBQ0EsT0FBT2MsT0FBTztvQkFDVixPQUFPLElBQUlELGtCQUFrQlIsS0FBS1M7Z0JBQ3RDO1lBQ0o7WUFDQSxPQUFPVDtRQUNYO0lBQ0o7SUF4QkE7O0tBRUMsR0FDREQsWUFBWUUsS0FBSyxFQUFFQyxRQUFRLEVBQUVhLEVBQUUsQ0FBRTtRQUM3QixLQUFLLENBQUNBLElBQUliO1FBTGQ7O21CQUFBOztzRkFNVUQsUUFBUUE7SUFDbEI7QUFtQko7SUFNSTtBQUxKOzs7Q0FHQyxHQUNNLE1BQU1lLG9DQUFvQzFCLHVFQUFtQkE7SUFTaEU7Ozs7Ozs7O0tBUUMsR0FDRCxNQUFNMkIsS0FBS0MsUUFBUSxFQUFFQyxPQUFPLEVBQUU7UUFDMUIsTUFBTUMsVUFBVSxNQUFNLEtBQUssQ0FBQ0gsS0FBS0MsVUFBVUM7UUFDM0MsSUFBSUMsV0FBVyxNQUFNO1lBQ2pCLE9BQU87UUFDWDtRQUNBLE9BQU8sSUFBSVYsMkJBQTJCQSx1RUFBQUEsQ0FBQSxJQUFJLEVBQUVULFVBQU8sSUFBSSxDQUFDQyxRQUFRLEVBQUVrQjtJQUN0RTtJQXRCQTs7S0FFQyxHQUNEckIsWUFBWUUsS0FBSyxFQUFFQyxRQUFRLEVBQUVhLEVBQUUsQ0FBRTtRQUM3QixLQUFLLENBQUNBLElBQUliO1FBTGQ7O21CQUFBOztzRkFNVUQsU0FBUUE7SUFDbEI7QUFpQko7QUFDQTs7O0NBR0MsR0FDTSxNQUFNb0Isb0NBQW9DN0IseURBQVlBO0lBWXpEOztLQUVDLEdBQ0QsTUFBTThCLFdBQVc7UUFDYixPQUFPLE1BQU0sSUFBSSxDQUFDdEIsR0FBRyxDQUFDc0IsUUFBUTtJQUNsQztJQUNBOztLQUVDLEdBQ0QsTUFBTUMsaUJBQWlCO1FBQ25CLE9BQU8sTUFBTSxJQUFJLENBQUN2QixHQUFHLENBQUN1QixjQUFjO0lBQ3hDO0lBQ0E7O0tBRUMsR0FDRCxNQUFNQyx3QkFBd0I7UUFDMUIsT0FBTyxNQUFNLElBQUksQ0FBQ3hCLEdBQUcsQ0FBQ3dCLHFCQUFxQjtJQUMvQztJQXhCQTs7S0FFQyxHQUNEekIsWUFBWTBCLFFBQVEsRUFBRUMsUUFBUSxFQUFFQyxNQUFNLEVBQUUzQixHQUFHLENBQUU7UUFDekMsS0FBSyxDQUFDeUIsVUFBVUMsVUFBVUM7UUFDMUJwQyxpRUFBZ0JBLENBQUMsSUFBSSxFQUFFO1lBQUVTO1FBQUk7SUFDakM7QUFtQko7QUFDQTs7O0NBR0MsR0FDTSxNQUFNNEIsNkJBQTZCUDtJQVN0Qzs7S0FFQyxHQUNELElBQUkzQixZQUFZO1FBQ1osT0FBTyxJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSTtJQUM3QjtJQUNBOztLQUVDLEdBQ0QsSUFBSUMsaUJBQWlCO1FBQ2pCLE9BQU8sSUFBSSxDQUFDRixRQUFRLENBQUNHLE1BQU07SUFDL0I7SUFuQkE7O0tBRUMsR0FDREMsWUFBWTBCLFFBQVEsRUFBRUMsUUFBUSxFQUFFQyxNQUFNLEVBQUVoQyxRQUFRLEVBQUVrQyxJQUFJLENBQUU7UUFDcEQsS0FBSyxDQUFDSixVQUFVQyxVQUFVQyxRQUFRLElBQUlsQyxTQUFTb0MsTUFBTUosU0FBU2xCLFNBQVMsRUFBRVo7UUFDekUsTUFBTVEsT0FBT3NCLFNBQVNsQixTQUFTLENBQUNILGNBQWMsQ0FBQ1QsVUFBVSxJQUFJLENBQUNLLEdBQUcsQ0FBQ0ssSUFBSSxFQUFFLElBQUksQ0FBQ0wsR0FBRyxDQUFDTSxNQUFNO1FBQ3ZGZixpRUFBZ0JBLENBQUMsSUFBSSxFQUFFO1lBQUVZO1lBQU1SO1FBQVM7SUFDNUM7QUFhSixFQUNBLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY29udHJhY3Qvd3JhcHBlcnMuanM/ZTA2MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBpbXBvcnQgZnJvbSBwcm92aWRlci50cyBpbnN0ZWFkIG9mIGluZGV4LnRzIHRvIHByZXZlbnQgY2lyY3VsYXIgZGVwXG4vLyBmcm9tIEV0aGVyc2NhblByb3ZpZGVyXG5pbXBvcnQgeyBMb2csIFRyYW5zYWN0aW9uUmVjZWlwdCwgVHJhbnNhY3Rpb25SZXNwb25zZSB9IGZyb20gXCIuLi9wcm92aWRlcnMvcHJvdmlkZXIuanNcIjtcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIEV2ZW50UGF5bG9hZCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuLyoqXG4gKiAgQW4gKipFdmVudExvZyoqIGNvbnRhaW5zIGFkZGl0aW9uYWwgcHJvcGVydGllcyBwYXJzZWQgZnJvbSB0aGUgW1tMb2ddXS5cbiAqL1xuZXhwb3J0IGNsYXNzIEV2ZW50TG9nIGV4dGVuZHMgTG9nIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIENvbnRyYWN0IEludGVyZmFjZS5cbiAgICAgKi9cbiAgICBpbnRlcmZhY2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXRjaGluZyBldmVudC5cbiAgICAgKi9cbiAgICBmcmFnbWVudDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHBhcnNlZCBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBldmVudCBieSBgYGVtaXRgYC5cbiAgICAgKi9cbiAgICBhcmdzO1xuICAgIC8qKlxuICAgICAqIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxvZywgaWZhY2UsIGZyYWdtZW50KSB7XG4gICAgICAgIHN1cGVyKGxvZywgbG9nLnByb3ZpZGVyKTtcbiAgICAgICAgY29uc3QgYXJncyA9IGlmYWNlLmRlY29kZUV2ZW50TG9nKGZyYWdtZW50LCBsb2cuZGF0YSwgbG9nLnRvcGljcyk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBhcmdzLCBmcmFnbWVudCwgaW50ZXJmYWNlOiBpZmFjZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cbiAgICAgKi9cbiAgICBnZXQgZXZlbnROYW1lKCkgeyByZXR1cm4gdGhpcy5mcmFnbWVudC5uYW1lOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBzaWduYXR1cmUgb2YgdGhlIGV2ZW50LlxuICAgICAqL1xuICAgIGdldCBldmVudFNpZ25hdHVyZSgpIHsgcmV0dXJuIHRoaXMuZnJhZ21lbnQuZm9ybWF0KCk7IH1cbn1cbi8qKlxuICogIEFuICoqRXZlbnRMb2cqKiBjb250YWlucyBhZGRpdGlvbmFsIHByb3BlcnRpZXMgcGFyc2VkIGZyb20gdGhlIFtbTG9nXV0uXG4gKi9cbmV4cG9ydCBjbGFzcyBVbmRlY29kZWRFdmVudExvZyBleHRlbmRzIExvZyB7XG4gICAgLyoqXG4gICAgICogIFRoZSBlcnJvciBlbmNvdW50ZWQgd2hlbiB0cnlpbmcgdG8gZGVjb2RlIHRoZSBsb2cuXG4gICAgICovXG4gICAgZXJyb3I7XG4gICAgLyoqXG4gICAgICogQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IobG9nLCBlcnJvcikge1xuICAgICAgICBzdXBlcihsb2csIGxvZy5wcm92aWRlcik7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBlcnJvciB9KTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqQ29udHJhY3RUcmFuc2FjdGlvblJlY2VpcHQqKiBpbmNsdWRlcyB0aGUgcGFyc2VkIGxvZ3MgZnJvbSBhXG4gKiAgW1tUcmFuc2FjdGlvblJlY2VpcHRdXS5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0IGV4dGVuZHMgVHJhbnNhY3Rpb25SZWNlaXB0IHtcbiAgICAjaWZhY2U7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGlmYWNlLCBwcm92aWRlciwgdHgpIHtcbiAgICAgICAgc3VwZXIodHgsIHByb3ZpZGVyKTtcbiAgICAgICAgdGhpcy4jaWZhY2UgPSBpZmFjZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBwYXJzZWQgbG9ncyBmb3IgYW55IFtbTG9nXV0gd2hpY2ggaGFzIGEgbWF0Y2hpbmcgZXZlbnQgaW4gdGhlXG4gICAgICogIENvbnRyYWN0IEFCSS5cbiAgICAgKi9cbiAgICBnZXQgbG9ncygpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmxvZ3MubWFwKChsb2cpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZyYWdtZW50ID0gbG9nLnRvcGljcy5sZW5ndGggPyB0aGlzLiNpZmFjZS5nZXRFdmVudChsb2cudG9waWNzWzBdKSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoZnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50TG9nKGxvZywgdGhpcy4jaWZhY2UsIGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVW5kZWNvZGVkRXZlbnRMb2cobG9nLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxvZztcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSAqKkNvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZSoqIHdpbGwgcmV0dXJuIGFcbiAqICBbW0NvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0XV0gd2hlbiB3YWl0ZWQgb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UgZXh0ZW5kcyBUcmFuc2FjdGlvblJlc3BvbnNlIHtcbiAgICAjaWZhY2U7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGlmYWNlLCBwcm92aWRlciwgdHgpIHtcbiAgICAgICAgc3VwZXIodHgsIHByb3ZpZGVyKTtcbiAgICAgICAgdGhpcy4jaWZhY2UgPSBpZmFjZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIG9uY2UgdGhpcyB0cmFuc2FjdGlvbiBoYXMgYmVlbiBtaW5lZCBhbmQgaGFzXG4gICAgICogICUlY29uZmlybXMlJSBibG9ja3MgaW5jbHVkaW5nIGl0IChkZWZhdWx0OiBgYDFgYCkgd2l0aCBhblxuICAgICAqICBvcHRpb25hbCAlJXRpbWVvdXQlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIGNhbiByZXNvbHZlIHRvIGBgbnVsbGBgIG9ubHkgaWYgJSVjb25maXJtcyUlIGlzIGBgMGBgXG4gICAgICogIGFuZCB0aGUgdHJhbnNhY3Rpb24gaGFzIG5vdCBiZWVuIG1pbmVkLCBvdGhlcndpc2UgdGhpcyB3aWxsXG4gICAgICogIHdhaXQgdW50aWwgZW5vdWdoIGNvbmZpcm1hdGlvbnMgaGF2ZSBjb21wbGV0ZWQuXG4gICAgICovXG4gICAgYXN5bmMgd2FpdChjb25maXJtcywgdGltZW91dCkge1xuICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgc3VwZXIud2FpdChjb25maXJtcywgdGltZW91dCk7XG4gICAgICAgIGlmIChyZWNlaXB0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJhY3RUcmFuc2FjdGlvblJlY2VpcHQodGhpcy4jaWZhY2UsIHRoaXMucHJvdmlkZXIsIHJlY2VpcHQpO1xuICAgIH1cbn1cbi8qKlxuICogIEEgKipDb250cmFjdFVua25vd25FdmVudFBheWxvYWQqKiBpcyBpbmNsdWRlZCBhcyB0aGUgbGFzdCBwYXJhbWV0ZXIgdG9cbiAqICBDb250cmFjdCBFdmVudHMgd2hlbiB0aGUgZXZlbnQgZG9lcyBub3QgbWF0Y2ggYW55IGV2ZW50cyBpbiB0aGUgQUJJLlxuICovXG5leHBvcnQgY2xhc3MgQ29udHJhY3RVbmtub3duRXZlbnRQYXlsb2FkIGV4dGVuZHMgRXZlbnRQYXlsb2FkIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGxvZyB3aXRoIG5vIG1hdGNoaW5nIGV2ZW50cy5cbiAgICAgKi9cbiAgICBsb2c7XG4gICAgLyoqXG4gICAgICogIEBfZXZlbnQ6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29udHJhY3QsIGxpc3RlbmVyLCBmaWx0ZXIsIGxvZykge1xuICAgICAgICBzdXBlcihjb250cmFjdCwgbGlzdGVuZXIsIGZpbHRlcik7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBsb2cgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgYmxvY2sgdGhlIGV2ZW50IG9jY3VyZWQgaW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QmxvY2soKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmxvZy5nZXRCbG9jaygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIHRyYW5zYWN0aW9uIHRoZSBldmVudCBvY2N1cmVkIGluLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5sb2cuZ2V0VHJhbnNhY3Rpb24oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSB0cmFuc2FjdGlvbiByZWNlaXB0IHRoZSBldmVudCBvY2N1cmVkIGluLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uUmVjZWlwdCgpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubG9nLmdldFRyYW5zYWN0aW9uUmVjZWlwdCgpO1xuICAgIH1cbn1cbi8qKlxuICogIEEgKipDb250cmFjdEV2ZW50UGF5bG9hZCoqIGlzIGluY2x1ZGVkIGFzIHRoZSBsYXN0IHBhcmFtZXRlciB0b1xuICogIENvbnRyYWN0IEV2ZW50cyB3aGVuIHRoZSBldmVudCBpcyBrbm93bi5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbnRyYWN0RXZlbnRQYXlsb2FkIGV4dGVuZHMgQ29udHJhY3RVbmtub3duRXZlbnRQYXlsb2FkIHtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29udHJhY3QsIGxpc3RlbmVyLCBmaWx0ZXIsIGZyYWdtZW50LCBfbG9nKSB7XG4gICAgICAgIHN1cGVyKGNvbnRyYWN0LCBsaXN0ZW5lciwgZmlsdGVyLCBuZXcgRXZlbnRMb2coX2xvZywgY29udHJhY3QuaW50ZXJmYWNlLCBmcmFnbWVudCkpO1xuICAgICAgICBjb25zdCBhcmdzID0gY29udHJhY3QuaW50ZXJmYWNlLmRlY29kZUV2ZW50TG9nKGZyYWdtZW50LCB0aGlzLmxvZy5kYXRhLCB0aGlzLmxvZy50b3BpY3MpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgYXJncywgZnJhZ21lbnQgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgZXZlbnQgbmFtZS5cbiAgICAgKi9cbiAgICBnZXQgZXZlbnROYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcmFnbWVudC5uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGV2ZW50IHNpZ25hdHVyZS5cbiAgICAgKi9cbiAgICBnZXQgZXZlbnRTaWduYXR1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyYWdtZW50LmZvcm1hdCgpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdyYXBwZXJzLmpzLm1hcCJdLCJuYW1lcyI6WyJMb2ciLCJUcmFuc2FjdGlvblJlY2VpcHQiLCJUcmFuc2FjdGlvblJlc3BvbnNlIiwiZGVmaW5lUHJvcGVydGllcyIsIkV2ZW50UGF5bG9hZCIsIkV2ZW50TG9nIiwiZXZlbnROYW1lIiwiZnJhZ21lbnQiLCJuYW1lIiwiZXZlbnRTaWduYXR1cmUiLCJmb3JtYXQiLCJjb25zdHJ1Y3RvciIsImxvZyIsImlmYWNlIiwicHJvdmlkZXIiLCJhcmdzIiwiZGVjb2RlRXZlbnRMb2ciLCJkYXRhIiwidG9waWNzIiwiaW50ZXJmYWNlIiwiVW5kZWNvZGVkRXZlbnRMb2ciLCJlcnJvciIsIkNvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0IiwibG9ncyIsIm1hcCIsImxlbmd0aCIsImdldEV2ZW50IiwidHgiLCJDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UiLCJ3YWl0IiwiY29uZmlybXMiLCJ0aW1lb3V0IiwicmVjZWlwdCIsIkNvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZCIsImdldEJsb2NrIiwiZ2V0VHJhbnNhY3Rpb24iLCJnZXRUcmFuc2FjdGlvblJlY2VpcHQiLCJjb250cmFjdCIsImxpc3RlbmVyIiwiZmlsdGVyIiwiQ29udHJhY3RFdmVudFBheWxvYWQiLCJfbG9nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/contract/wrappers.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/crypto/crypto-browser.js":
/*!**************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/crypto/crypto-browser.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHash: function() { return /* binding */ createHash; },\n/* harmony export */   createHmac: function() { return /* binding */ createHmac; },\n/* harmony export */   pbkdf2Sync: function() { return /* binding */ pbkdf2Sync; },\n/* harmony export */   randomBytes: function() { return /* binding */ randomBytes; }\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_pbkdf2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/pbkdf2 */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/pbkdf2.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/sha512 */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/sha512.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* Browser Crypto Shims */ \n\n\n\n\nfunction getGlobal() {\n    if (typeof self !== \"undefined\") {\n        return self;\n    }\n    if (true) {\n        return window;\n    }\n    if (typeof global !== \"undefined\") {\n        return global;\n    }\n    throw new Error(\"unable to locate global object\");\n}\n;\nconst anyGlobal = getGlobal();\nconst crypto = anyGlobal.crypto || anyGlobal.msCrypto;\nfunction createHash(algo) {\n    switch(algo){\n        case \"sha256\":\n            return _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_0__.sha256.create();\n        case \"sha512\":\n            return _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512.create();\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, \"invalid hashing algorithm name\", \"algorithm\", algo);\n}\nfunction createHmac(_algo, key) {\n    const algo = {\n        sha256: _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_0__.sha256,\n        sha512: _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512\n    }[_algo];\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(algo != null, \"invalid hmac algorithm\", \"algorithm\", _algo);\n    return _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_3__.hmac.create(algo, key);\n}\nfunction pbkdf2Sync(password, salt, iterations, keylen, _algo) {\n    const algo = {\n        sha256: _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_0__.sha256,\n        sha512: _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512\n    }[_algo];\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(algo != null, \"invalid pbkdf2 algorithm\", \"algorithm\", _algo);\n    return (0,_noble_hashes_pbkdf2__WEBPACK_IMPORTED_MODULE_4__.pbkdf2)(algo, password, salt, {\n        c: iterations,\n        dkLen: keylen\n    });\n}\nfunction randomBytes(length) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assert)(crypto != null, \"platform does not support secure random numbers\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"randomBytes\"\n    });\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(Number.isInteger(length) && length > 0 && length <= 1024, \"invalid length\", \"length\", length);\n    const result = new Uint8Array(length);\n    crypto.getRandomValues(result);\n    return result;\n} //# sourceMappingURL=crypto-browser.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8vY3J5cHRvLWJyb3dzZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsd0JBQXdCLEdBQ2tCO0FBQ0k7QUFDQTtBQUNBO0FBQ2E7QUFDM0QsU0FBU007SUFDTCxJQUFJLE9BQU9DLFNBQVMsYUFBYTtRQUM3QixPQUFPQTtJQUNYO0lBQ0EsSUFBSSxJQUFrQixFQUFhO1FBQy9CLE9BQU9DO0lBQ1g7SUFDQSxJQUFJLE9BQU9DLFdBQVcsYUFBYTtRQUMvQixPQUFPQTtJQUNYO0lBQ0EsTUFBTSxJQUFJQyxNQUFNO0FBQ3BCOztBQUVBLE1BQU1DLFlBQVlMO0FBQ2xCLE1BQU1NLFNBQVNELFVBQVVDLE1BQU0sSUFBSUQsVUFBVUUsUUFBUTtBQUM5QyxTQUFTQyxXQUFXQyxJQUFJO0lBQzNCLE9BQVFBO1FBQ0osS0FBSztZQUFVLE9BQU9iLHdEQUFNQSxDQUFDYyxNQUFNO1FBQ25DLEtBQUs7WUFBVSxPQUFPYix3REFBTUEsQ0FBQ2EsTUFBTTtJQUN2QztJQUNBWCwrREFBY0EsQ0FBQyxPQUFPLGtDQUFrQyxhQUFhVTtBQUN6RTtBQUNPLFNBQVNFLFdBQVdDLEtBQUssRUFBRUMsR0FBRztJQUNqQyxNQUFNSixPQUFRO1FBQUViLE1BQU1BLDBEQUFBQTtRQUFFQyxNQUFNQSwwREFBQUE7SUFBQyxDQUFDLENBQUNlLE1BQU07SUFDdkNiLCtEQUFjQSxDQUFDVSxRQUFRLE1BQU0sMEJBQTBCLGFBQWFHO0lBQ3BFLE9BQU9sQixvREFBSUEsQ0FBQ2dCLE1BQU0sQ0FBQ0QsTUFBTUk7QUFDN0I7QUFDTyxTQUFTQyxXQUFXQyxRQUFRLEVBQUVDLElBQUksRUFBRUMsVUFBVSxFQUFFQyxNQUFNLEVBQUVOLEtBQUs7SUFDaEUsTUFBTUgsT0FBUTtRQUFFYixNQUFNQSwwREFBQUE7UUFBRUMsTUFBTUEsMERBQUFBO0lBQUMsQ0FBQyxDQUFDZSxNQUFNO0lBQ3ZDYiwrREFBY0EsQ0FBQ1UsUUFBUSxNQUFNLDRCQUE0QixhQUFhRztJQUN0RSxPQUFPakIsNERBQU1BLENBQUNjLE1BQU1NLFVBQVVDLE1BQU07UUFBRUcsR0FBR0Y7UUFBWUcsT0FBT0Y7SUFBTztBQUN2RTtBQUNPLFNBQVNHLFlBQVlDLE1BQU07SUFDOUJ4Qix1REFBTUEsQ0FBQ1EsVUFBVSxNQUFNLG1EQUFtRCx5QkFBeUI7UUFDL0ZpQixXQUFXO0lBQ2Y7SUFDQXhCLCtEQUFjQSxDQUFDeUIsT0FBT0MsU0FBUyxDQUFDSCxXQUFXQSxTQUFTLEtBQUtBLFVBQVUsTUFBTSxrQkFBa0IsVUFBVUE7SUFDckcsTUFBTUksU0FBUyxJQUFJQyxXQUFXTDtJQUM5QmhCLE9BQU9zQixlQUFlLENBQUNGO0lBQ3ZCLE9BQU9BO0FBQ1gsRUFDQSwwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NyeXB0by9jcnlwdG8tYnJvd3Nlci5qcz9kOWM1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIEJyb3dzZXIgQ3J5cHRvIFNoaW1zICovXG5pbXBvcnQgeyBobWFjIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvaG1hY1wiO1xuaW1wb3J0IHsgcGJrZGYyIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvcGJrZGYyXCI7XG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9zaGEyNTZcIjtcbmltcG9ydCB7IHNoYTUxMiB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3NoYTUxMlwiO1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuZnVuY3Rpb24gZ2V0R2xvYmFsKCkge1xuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gd2luZG93O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gbG9jYXRlIGdsb2JhbCBvYmplY3QnKTtcbn1cbjtcbmNvbnN0IGFueUdsb2JhbCA9IGdldEdsb2JhbCgpO1xuY29uc3QgY3J5cHRvID0gYW55R2xvYmFsLmNyeXB0byB8fCBhbnlHbG9iYWwubXNDcnlwdG87XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGFzaChhbGdvKSB7XG4gICAgc3dpdGNoIChhbGdvKSB7XG4gICAgICAgIGNhc2UgXCJzaGEyNTZcIjogcmV0dXJuIHNoYTI1Ni5jcmVhdGUoKTtcbiAgICAgICAgY2FzZSBcInNoYTUxMlwiOiByZXR1cm4gc2hhNTEyLmNyZWF0ZSgpO1xuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIGhhc2hpbmcgYWxnb3JpdGhtIG5hbWVcIiwgXCJhbGdvcml0aG1cIiwgYWxnbyk7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSG1hYyhfYWxnbywga2V5KSB7XG4gICAgY29uc3QgYWxnbyA9ICh7IHNoYTI1Niwgc2hhNTEyIH1bX2FsZ29dKTtcbiAgICBhc3NlcnRBcmd1bWVudChhbGdvICE9IG51bGwsIFwiaW52YWxpZCBobWFjIGFsZ29yaXRobVwiLCBcImFsZ29yaXRobVwiLCBfYWxnbyk7XG4gICAgcmV0dXJuIGhtYWMuY3JlYXRlKGFsZ28sIGtleSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcGJrZGYyU3luYyhwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9ucywga2V5bGVuLCBfYWxnbykge1xuICAgIGNvbnN0IGFsZ28gPSAoeyBzaGEyNTYsIHNoYTUxMiB9W19hbGdvXSk7XG4gICAgYXNzZXJ0QXJndW1lbnQoYWxnbyAhPSBudWxsLCBcImludmFsaWQgcGJrZGYyIGFsZ29yaXRobVwiLCBcImFsZ29yaXRobVwiLCBfYWxnbyk7XG4gICAgcmV0dXJuIHBia2RmMihhbGdvLCBwYXNzd29yZCwgc2FsdCwgeyBjOiBpdGVyYXRpb25zLCBka0xlbjoga2V5bGVuIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGxlbmd0aCkge1xuICAgIGFzc2VydChjcnlwdG8gIT0gbnVsbCwgXCJwbGF0Zm9ybSBkb2VzIG5vdCBzdXBwb3J0IHNlY3VyZSByYW5kb20gbnVtYmVyc1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgIG9wZXJhdGlvbjogXCJyYW5kb21CeXRlc1wiXG4gICAgfSk7XG4gICAgYXNzZXJ0QXJndW1lbnQoTnVtYmVyLmlzSW50ZWdlcihsZW5ndGgpICYmIGxlbmd0aCA+IDAgJiYgbGVuZ3RoIDw9IDEwMjQsIFwiaW52YWxpZCBsZW5ndGhcIiwgXCJsZW5ndGhcIiwgbGVuZ3RoKTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMocmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3J5cHRvLWJyb3dzZXIuanMubWFwIl0sIm5hbWVzIjpbImhtYWMiLCJwYmtkZjIiLCJzaGEyNTYiLCJzaGE1MTIiLCJhc3NlcnQiLCJhc3NlcnRBcmd1bWVudCIsImdldEdsb2JhbCIsInNlbGYiLCJ3aW5kb3ciLCJnbG9iYWwiLCJFcnJvciIsImFueUdsb2JhbCIsImNyeXB0byIsIm1zQ3J5cHRvIiwiY3JlYXRlSGFzaCIsImFsZ28iLCJjcmVhdGUiLCJjcmVhdGVIbWFjIiwiX2FsZ28iLCJrZXkiLCJwYmtkZjJTeW5jIiwicGFzc3dvcmQiLCJzYWx0IiwiaXRlcmF0aW9ucyIsImtleWxlbiIsImMiLCJka0xlbiIsInJhbmRvbUJ5dGVzIiwibGVuZ3RoIiwib3BlcmF0aW9uIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwicmVzdWx0IiwiVWludDhBcnJheSIsImdldFJhbmRvbVZhbHVlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/crypto/crypto-browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/crypto/keccak.js":
/*!******************************************************!*\
  !*** ./node_modules/ethers/lib.esm/crypto/keccak.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keccak256: function() { return /* binding */ keccak256; }\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/sha3.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/**\n *  Cryptographic hashing functions\n *\n *  @_subsection: api/crypto:Hash Functions [about-crypto-hashing]\n */ \n\nlet locked = false;\nconst _keccak256 = function(data) {\n    return (0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__.keccak_256)(data);\n};\nlet __keccak256 = _keccak256;\n/**\n *  Compute the cryptographic KECCAK256 hash of %%data%%.\n *\n *  The %%data%% **must** be a data representation, to compute the\n *  hash of UTF-8 data use the [[id]] function.\n *\n *  @returns DataHexstring\n *  @example:\n *    keccak256(\"0x\")\n *    //_result:\n *\n *    keccak256(\"0x1337\")\n *    //_result:\n *\n *    keccak256(new Uint8Array([ 0x13, 0x37 ]))\n *    //_result:\n *\n *    // Strings are assumed to be DataHexString, otherwise it will\n *    // throw. To hash UTF-8 data, see the note above.\n *    keccak256(\"Hello World\")\n *    //_error:\n */ function keccak256(_data) {\n    const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_data, \"data\");\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(__keccak256(data));\n}\nkeccak256._ = _keccak256;\nkeccak256.lock = function() {\n    locked = true;\n};\nkeccak256.register = function(func) {\n    if (locked) {\n        throw new TypeError(\"keccak256 is locked\");\n    }\n    __keccak256 = func;\n};\nObject.freeze(keccak256); //# sourceMappingURL=keccak.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8va2VjY2FrLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7O0NBSUMsR0FDK0M7QUFDTTtBQUN0RCxJQUFJRyxTQUFTO0FBQ2IsTUFBTUMsYUFBYSxTQUFVQyxJQUFJO0lBQzdCLE9BQU9MLDhEQUFVQSxDQUFDSztBQUN0QjtBQUNBLElBQUlDLGNBQWNGO0FBQ2xCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FxQkMsR0FDTSxTQUFTRyxVQUFVQyxLQUFLO0lBQzNCLE1BQU1ILE9BQU9KLHlEQUFRQSxDQUFDTyxPQUFPO0lBQzdCLE9BQU9OLHdEQUFPQSxDQUFDSSxZQUFZRDtBQUMvQjtBQUNBRSxVQUFVRSxDQUFDLEdBQUdMO0FBQ2RHLFVBQVVHLElBQUksR0FBRztJQUFjUCxTQUFTO0FBQU07QUFDOUNJLFVBQVVJLFFBQVEsR0FBRyxTQUFVQyxJQUFJO0lBQy9CLElBQUlULFFBQVE7UUFDUixNQUFNLElBQUlVLFVBQVU7SUFDeEI7SUFDQVAsY0FBY007QUFDbEI7QUFDQUUsT0FBT0MsTUFBTSxDQUFDUixZQUNkLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL2tlY2Nhay5qcz8xMzgxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIENyeXB0b2dyYXBoaWMgaGFzaGluZyBmdW5jdGlvbnNcbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvY3J5cHRvOkhhc2ggRnVuY3Rpb25zIFthYm91dC1jcnlwdG8taGFzaGluZ11cbiAqL1xuaW1wb3J0IHsga2VjY2FrXzI1NiB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3NoYTNcIjtcbmltcG9ydCB7IGdldEJ5dGVzLCBoZXhsaWZ5IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5sZXQgbG9ja2VkID0gZmFsc2U7XG5jb25zdCBfa2VjY2FrMjU2ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4ga2VjY2FrXzI1NihkYXRhKTtcbn07XG5sZXQgX19rZWNjYWsyNTYgPSBfa2VjY2FrMjU2O1xuLyoqXG4gKiAgQ29tcHV0ZSB0aGUgY3J5cHRvZ3JhcGhpYyBLRUNDQUsyNTYgaGFzaCBvZiAlJWRhdGElJS5cbiAqXG4gKiAgVGhlICUlZGF0YSUlICoqbXVzdCoqIGJlIGEgZGF0YSByZXByZXNlbnRhdGlvbiwgdG8gY29tcHV0ZSB0aGVcbiAqICBoYXNoIG9mIFVURi04IGRhdGEgdXNlIHRoZSBbW2lkXV0gZnVuY3Rpb24uXG4gKlxuICogIEByZXR1cm5zIERhdGFIZXhzdHJpbmdcbiAqICBAZXhhbXBsZTpcbiAqICAgIGtlY2NhazI1NihcIjB4XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAga2VjY2FrMjU2KFwiMHgxMzM3XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAga2VjY2FrMjU2KG5ldyBVaW50OEFycmF5KFsgMHgxMywgMHgzNyBdKSlcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBTdHJpbmdzIGFyZSBhc3N1bWVkIHRvIGJlIERhdGFIZXhTdHJpbmcsIG90aGVyd2lzZSBpdCB3aWxsXG4gKiAgICAvLyB0aHJvdy4gVG8gaGFzaCBVVEYtOCBkYXRhLCBzZWUgdGhlIG5vdGUgYWJvdmUuXG4gKiAgICBrZWNjYWsyNTYoXCJIZWxsbyBXb3JsZFwiKVxuICogICAgLy9fZXJyb3I6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBrZWNjYWsyNTYoX2RhdGEpIHtcbiAgICBjb25zdCBkYXRhID0gZ2V0Qnl0ZXMoX2RhdGEsIFwiZGF0YVwiKTtcbiAgICByZXR1cm4gaGV4bGlmeShfX2tlY2NhazI1NihkYXRhKSk7XG59XG5rZWNjYWsyNTYuXyA9IF9rZWNjYWsyNTY7XG5rZWNjYWsyNTYubG9jayA9IGZ1bmN0aW9uICgpIHsgbG9ja2VkID0gdHJ1ZTsgfTtcbmtlY2NhazI1Ni5yZWdpc3RlciA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgaWYgKGxvY2tlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2VjY2FrMjU2IGlzIGxvY2tlZFwiKTtcbiAgICB9XG4gICAgX19rZWNjYWsyNTYgPSBmdW5jO1xufTtcbk9iamVjdC5mcmVlemUoa2VjY2FrMjU2KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWtlY2Nhay5qcy5tYXAiXSwibmFtZXMiOlsia2VjY2FrXzI1NiIsImdldEJ5dGVzIiwiaGV4bGlmeSIsImxvY2tlZCIsIl9rZWNjYWsyNTYiLCJkYXRhIiwiX19rZWNjYWsyNTYiLCJrZWNjYWsyNTYiLCJfZGF0YSIsIl8iLCJsb2NrIiwicmVnaXN0ZXIiLCJmdW5jIiwiVHlwZUVycm9yIiwiT2JqZWN0IiwiZnJlZXplIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/crypto/keccak.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/crypto/sha2.js":
/*!****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/crypto/sha2.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha256: function() { return /* binding */ sha256; },\n/* harmony export */   sha512: function() { return /* binding */ sha512; }\n/* harmony export */ });\n/* harmony import */ var _crypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./crypto.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/crypto/crypto-browser.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n\n\nconst _sha256 = function(data) {\n    return (0,_crypto_js__WEBPACK_IMPORTED_MODULE_0__.createHash)(\"sha256\").update(data).digest();\n};\nconst _sha512 = function(data) {\n    return (0,_crypto_js__WEBPACK_IMPORTED_MODULE_0__.createHash)(\"sha512\").update(data).digest();\n};\nlet __sha256 = _sha256;\nlet __sha512 = _sha512;\nlet locked256 = false, locked512 = false;\n/**\n *  Compute the cryptographic SHA2-256 hash of %%data%%.\n *\n *  @_docloc: api/crypto:Hash Functions\n *  @returns DataHexstring\n *\n *  @example:\n *    sha256(\"0x\")\n *    //_result:\n *\n *    sha256(\"0x1337\")\n *    //_result:\n *\n *    sha256(new Uint8Array([ 0x13, 0x37 ]))\n *    //_result:\n *\n */ function sha256(_data) {\n    const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_data, \"data\");\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(__sha256(data));\n}\nsha256._ = _sha256;\nsha256.lock = function() {\n    locked256 = true;\n};\nsha256.register = function(func) {\n    if (locked256) {\n        throw new Error(\"sha256 is locked\");\n    }\n    __sha256 = func;\n};\nObject.freeze(sha256);\n/**\n *  Compute the cryptographic SHA2-512 hash of %%data%%.\n *\n *  @_docloc: api/crypto:Hash Functions\n *  @returns DataHexstring\n *\n *  @example:\n *    sha512(\"0x\")\n *    //_result:\n *\n *    sha512(\"0x1337\")\n *    //_result:\n *\n *    sha512(new Uint8Array([ 0x13, 0x37 ]))\n *    //_result:\n */ function sha512(_data) {\n    const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_data, \"data\");\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(__sha512(data));\n}\nsha512._ = _sha512;\nsha512.lock = function() {\n    locked512 = true;\n};\nsha512.register = function(func) {\n    if (locked512) {\n        throw new Error(\"sha512 is locked\");\n    }\n    __sha512 = func;\n};\nObject.freeze(sha256); //# sourceMappingURL=sha2.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8vc2hhMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXlDO0FBQ2E7QUFDdEQsTUFBTUcsVUFBVSxTQUFVQyxJQUFJO0lBQzFCLE9BQU9KLHNEQUFVQSxDQUFDLFVBQVVLLE1BQU0sQ0FBQ0QsTUFBTUUsTUFBTTtBQUNuRDtBQUNBLE1BQU1DLFVBQVUsU0FBVUgsSUFBSTtJQUMxQixPQUFPSixzREFBVUEsQ0FBQyxVQUFVSyxNQUFNLENBQUNELE1BQU1FLE1BQU07QUFDbkQ7QUFDQSxJQUFJRSxXQUFXTDtBQUNmLElBQUlNLFdBQVdGO0FBQ2YsSUFBSUcsWUFBWSxPQUFPQyxZQUFZO0FBQ25DOzs7Ozs7Ozs7Ozs7Ozs7O0NBZ0JDLEdBQ00sU0FBU0MsT0FBT0MsS0FBSztJQUN4QixNQUFNVCxPQUFPSCx5REFBUUEsQ0FBQ1ksT0FBTztJQUM3QixPQUFPWCx3REFBT0EsQ0FBQ00sU0FBU0o7QUFDNUI7QUFDQVEsT0FBT0UsQ0FBQyxHQUFHWDtBQUNYUyxPQUFPRyxJQUFJLEdBQUc7SUFBY0wsWUFBWTtBQUFNO0FBQzlDRSxPQUFPSSxRQUFRLEdBQUcsU0FBVUMsSUFBSTtJQUM1QixJQUFJUCxXQUFXO1FBQ1gsTUFBTSxJQUFJUSxNQUFNO0lBQ3BCO0lBQ0FWLFdBQVdTO0FBQ2Y7QUFDQUUsT0FBT0MsTUFBTSxDQUFDUjtBQUNkOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNNLFNBQVNTLE9BQU9SLEtBQUs7SUFDeEIsTUFBTVQsT0FBT0gseURBQVFBLENBQUNZLE9BQU87SUFDN0IsT0FBT1gsd0RBQU9BLENBQUNPLFNBQVNMO0FBQzVCO0FBQ0FpQixPQUFPUCxDQUFDLEdBQUdQO0FBQ1hjLE9BQU9OLElBQUksR0FBRztJQUFjSixZQUFZO0FBQU07QUFDOUNVLE9BQU9MLFFBQVEsR0FBRyxTQUFVQyxJQUFJO0lBQzVCLElBQUlOLFdBQVc7UUFDWCxNQUFNLElBQUlPLE1BQU07SUFDcEI7SUFDQVQsV0FBV1E7QUFDZjtBQUNBRSxPQUFPQyxNQUFNLENBQUNSLFNBQ2QsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8vc2hhMi5qcz8yZjVjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUhhc2ggfSBmcm9tIFwiLi9jcnlwdG8uanNcIjtcbmltcG9ydCB7IGdldEJ5dGVzLCBoZXhsaWZ5IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5jb25zdCBfc2hhMjU2ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gY3JlYXRlSGFzaChcInNoYTI1NlwiKS51cGRhdGUoZGF0YSkuZGlnZXN0KCk7XG59O1xuY29uc3QgX3NoYTUxMiA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhhc2goXCJzaGE1MTJcIikudXBkYXRlKGRhdGEpLmRpZ2VzdCgpO1xufTtcbmxldCBfX3NoYTI1NiA9IF9zaGEyNTY7XG5sZXQgX19zaGE1MTIgPSBfc2hhNTEyO1xubGV0IGxvY2tlZDI1NiA9IGZhbHNlLCBsb2NrZWQ1MTIgPSBmYWxzZTtcbi8qKlxuICogIENvbXB1dGUgdGhlIGNyeXB0b2dyYXBoaWMgU0hBMi0yNTYgaGFzaCBvZiAlJWRhdGElJS5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9jcnlwdG86SGFzaCBGdW5jdGlvbnNcbiAqICBAcmV0dXJucyBEYXRhSGV4c3RyaW5nXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgc2hhMjU2KFwiMHhcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICBzaGEyNTYoXCIweDEzMzdcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICBzaGEyNTYobmV3IFVpbnQ4QXJyYXkoWyAweDEzLCAweDM3IF0pKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNoYTI1NihfZGF0YSkge1xuICAgIGNvbnN0IGRhdGEgPSBnZXRCeXRlcyhfZGF0YSwgXCJkYXRhXCIpO1xuICAgIHJldHVybiBoZXhsaWZ5KF9fc2hhMjU2KGRhdGEpKTtcbn1cbnNoYTI1Ni5fID0gX3NoYTI1NjtcbnNoYTI1Ni5sb2NrID0gZnVuY3Rpb24gKCkgeyBsb2NrZWQyNTYgPSB0cnVlOyB9O1xuc2hhMjU2LnJlZ2lzdGVyID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICBpZiAobG9ja2VkMjU2KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInNoYTI1NiBpcyBsb2NrZWRcIik7XG4gICAgfVxuICAgIF9fc2hhMjU2ID0gZnVuYztcbn07XG5PYmplY3QuZnJlZXplKHNoYTI1Nik7XG4vKipcbiAqICBDb21wdXRlIHRoZSBjcnlwdG9ncmFwaGljIFNIQTItNTEyIGhhc2ggb2YgJSVkYXRhJSUuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvY3J5cHRvOkhhc2ggRnVuY3Rpb25zXG4gKiAgQHJldHVybnMgRGF0YUhleHN0cmluZ1xuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIHNoYTUxMihcIjB4XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgc2hhNTEyKFwiMHgxMzM3XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgc2hhNTEyKG5ldyBVaW50OEFycmF5KFsgMHgxMywgMHgzNyBdKSlcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNoYTUxMihfZGF0YSkge1xuICAgIGNvbnN0IGRhdGEgPSBnZXRCeXRlcyhfZGF0YSwgXCJkYXRhXCIpO1xuICAgIHJldHVybiBoZXhsaWZ5KF9fc2hhNTEyKGRhdGEpKTtcbn1cbnNoYTUxMi5fID0gX3NoYTUxMjtcbnNoYTUxMi5sb2NrID0gZnVuY3Rpb24gKCkgeyBsb2NrZWQ1MTIgPSB0cnVlOyB9O1xuc2hhNTEyLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICBpZiAobG9ja2VkNTEyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInNoYTUxMiBpcyBsb2NrZWRcIik7XG4gICAgfVxuICAgIF9fc2hhNTEyID0gZnVuYztcbn07XG5PYmplY3QuZnJlZXplKHNoYTI1Nik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyLmpzLm1hcCJdLCJuYW1lcyI6WyJjcmVhdGVIYXNoIiwiZ2V0Qnl0ZXMiLCJoZXhsaWZ5IiwiX3NoYTI1NiIsImRhdGEiLCJ1cGRhdGUiLCJkaWdlc3QiLCJfc2hhNTEyIiwiX19zaGEyNTYiLCJfX3NoYTUxMiIsImxvY2tlZDI1NiIsImxvY2tlZDUxMiIsInNoYTI1NiIsIl9kYXRhIiwiXyIsImxvY2siLCJyZWdpc3RlciIsImZ1bmMiLCJFcnJvciIsIk9iamVjdCIsImZyZWV6ZSIsInNoYTUxMiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/crypto/sha2.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/crypto/signature.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/crypto/signature.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Signature: function() { return /* binding */ Signature; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_get */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_get.js\");\n/* harmony import */ var _swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_init */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_init.js\");\n/* harmony import */ var _swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_set */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_set.js\");\n/* harmony import */ var _constants_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../constants/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/constants/hashes.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n\n\n\n\n\n// Constants\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_2 = BigInt(2);\nconst BN_27 = BigInt(27);\nconst BN_28 = BigInt(28);\nconst BN_35 = BigInt(35);\nconst BN_N = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\nconst BN_N_2 = BN_N / BN_2; // Must be integer (floor) division; do NOT shifts\nconst inspect = Symbol.for(\"nodejs.util.inspect.custom\");\nconst _guard = {};\nfunction toUint256(value) {\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toBeArray)(value), 32);\n}\nvar _r = /*#__PURE__*/ new WeakMap(), _s = /*#__PURE__*/ new WeakMap(), _v = /*#__PURE__*/ new WeakMap(), _networkV = /*#__PURE__*/ new WeakMap();\nlet _inspect = inspect;\n/**\n *  A Signature  @TODO\n *\n *\n *  @_docloc: api/crypto:Signing\n */ class Signature {\n    /**\n     *  The ``r`` value for a signature.\n     *\n     *  This represents the ``x`` coordinate of a \"reference\" or\n     *  challenge point, from which the ``y`` can be computed.\n     */ get r() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _r);\n    }\n    set r(value) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataLength)(value) === 32, \"invalid r\", \"value\", value);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_4__._)(this, _r, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(value));\n    }\n    /**\n     *  The ``s`` value for a signature.\n     */ get s() {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(parseInt((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _s).substring(0, 3)) < 8, \"non-canonical s; use ._s\", \"s\", (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _s));\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _s);\n    }\n    set s(_value) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataLength)(_value) === 32, \"invalid s\", \"value\", _value);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_4__._)(this, _s, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(_value));\n    }\n    /**\n     *  Return the s value, unchecked for EIP-2 compliance.\n     *\n     *  This should generally not be used and is for situations where\n     *  a non-canonical S value might be relevant, such as Frontier blocks\n     *  that were mined prior to EIP-2 or invalid Authorization List\n     *  signatures.\n     */ get _s() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _s);\n    }\n    /**\n     *  Returns true if the Signature is valid for [[link-eip-2]] signatures.\n     */ isValid() {\n        const s = BigInt((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _s));\n        return s <= BN_N_2;\n    }\n    /**\n     *  The ``v`` value for a signature.\n     *\n     *  Since a given ``x`` value for ``r`` has two possible values for\n     *  its correspondin ``y``, the ``v`` indicates which of the two ``y``\n     *  values to use.\n     *\n     *  It is normalized to the values ``27`` or ``28`` for legacy\n     *  purposes.\n     */ get v() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _v);\n    }\n    set v(value) {\n        const v = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(value, \"value\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(v === 27 || v === 28, \"invalid v\", \"v\", value);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_4__._)(this, _v, v);\n    }\n    /**\n     *  The EIP-155 ``v`` for legacy transactions. For non-legacy\n     *  transactions, this value is ``null``.\n     */ get networkV() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _networkV);\n    }\n    /**\n     *  The chain ID for EIP-155 legacy transactions. For non-legacy\n     *  transactions, this value is ``null``.\n     */ get legacyChainId() {\n        const v = this.networkV;\n        if (v == null) {\n            return null;\n        }\n        return Signature.getChainId(v);\n    }\n    /**\n     *  The ``yParity`` for the signature.\n     *\n     *  See ``v`` for more details on how this value is used.\n     */ get yParity() {\n        return this.v === 27 ? 0 : 1;\n    }\n    /**\n     *  The [[link-eip-2098]] compact representation of the ``yParity``\n     *  and ``s`` compacted into a single ``bytes32``.\n     */ get yParityAndS() {\n        // The EIP-2098 compact representation\n        const yParityAndS = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(this.s);\n        if (this.yParity) {\n            yParityAndS[0] |= 0x80;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(yParityAndS);\n    }\n    /**\n     *  The [[link-eip-2098]] compact representation.\n     */ get compactSerialized() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n            this.r,\n            this.yParityAndS\n        ]);\n    }\n    /**\n     *  The serialized representation.\n     */ get serialized() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n            this.r,\n            this.s,\n            this.yParity ? \"0x1c\" : \"0x1b\"\n        ]);\n    }\n    /**\n     *  Returns the canonical signature.\n     *\n     *  This is only necessary when dealing with legacy transaction which\n     *  did not enforce canonical S values (i.e. [[link-eip-2]]. Most\n     *  developers should never require this.\n     */ getCanonical() {\n        if (this.isValid()) {\n            return this;\n        }\n        // Compute the canonical signature; s' = N - s, v = !v\n        const s = BN_N - BigInt(this._s);\n        const v = 55 - this.v;\n        const result = new Signature(_guard, this.r, toUint256(s), v);\n        // Populate the networkV if necessary\n        if (this.networkV) {\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_4__._)(result, _networkV, this.networkV);\n        }\n        return result;\n    }\n    /**\n     *  Returns a new identical [[Signature]].\n     */ clone() {\n        const clone = new Signature(_guard, this.r, this._s, this.v);\n        if (this.networkV) {\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_4__._)(clone, _networkV, this.networkV);\n        }\n        return clone;\n    }\n    /**\n     *  Returns a representation that is compatible with ``JSON.stringify``.\n     */ toJSON() {\n        const networkV = this.networkV;\n        return {\n            _type: \"signature\",\n            networkV: networkV != null ? networkV.toString() : null,\n            r: this.r,\n            s: this._s,\n            v: this.v\n        };\n    }\n    [_inspect]() {\n        return this.toString();\n    }\n    toString() {\n        if (this.isValid()) {\n            return \"Signature { r: \".concat(this.r, \", s: \").concat(this._s, \", v: \").concat(this.v, \" }\");\n        }\n        return \"Signature { r: \".concat(this.r, \", s: \").concat(this._s, \", v: \").concat(this.v, \", valid: false }\");\n    }\n    /**\n     *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.\n     *\n     *  @example:\n     *    Signature.getChainId(45)\n     *    //_result:\n     *\n     *    Signature.getChainId(46)\n     *    //_result:\n     */ static getChainId(v) {\n        const bv = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(v, \"v\");\n        // The v is not an EIP-155 v, so it is the unspecified chain ID\n        if (bv == BN_27 || bv == BN_28) {\n            return BN_0;\n        }\n        // Bad value for an EIP-155 v\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(bv >= BN_35, \"invalid EIP-155 v\", \"v\", v);\n        return (bv - BN_35) / BN_2;\n    }\n    /**\n     *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.\n     *\n     *  Legacy transactions which use [[link-eip-155]] hijack the ``v``\n     *  property to include the chain ID.\n     *\n     *  @example:\n     *    Signature.getChainIdV(5, 27)\n     *    //_result:\n     *\n     *    Signature.getChainIdV(5, 28)\n     *    //_result:\n     *\n     */ static getChainIdV(chainId, v) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(chainId) * BN_2 + BigInt(35 + v - 27);\n    }\n    /**\n     *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,\n     *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.\n     *\n     *  @example:\n     *    // The values 0 and 1 imply v is actually yParity\n     *    Signature.getNormalizedV(0)\n     *    //_result:\n     *\n     *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)\n     *    Signature.getNormalizedV(27)\n     *    //_result:\n     *\n     *    // Legacy EIP-155 transaction (i.e. >= 35)\n     *    Signature.getNormalizedV(46)\n     *    //_result:\n     *\n     *    // Invalid values throw\n     *    Signature.getNormalizedV(5)\n     *    //_error:\n     */ static getNormalizedV(v) {\n        const bv = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(v);\n        if (bv === BN_0 || bv === BN_27) {\n            return 27;\n        }\n        if (bv === BN_1 || bv === BN_28) {\n            return 28;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(bv >= BN_35, \"invalid v\", \"v\", v);\n        // Otherwise, EIP-155 v means odd is 27 and even is 28\n        return bv & BN_1 ? 27 : 28;\n    }\n    /**\n     *  Creates a new [[Signature]].\n     *\n     *  If no %%sig%% is provided, a new [[Signature]] is created\n     *  with default values.\n     *\n     *  If %%sig%% is a string, it is parsed.\n     */ static from(sig) {\n        function assertError(check, message) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(check, message, \"signature\", sig);\n        }\n        ;\n        if (sig == null) {\n            return new Signature(_guard, _constants_index_js__WEBPACK_IMPORTED_MODULE_5__.ZeroHash, _constants_index_js__WEBPACK_IMPORTED_MODULE_5__.ZeroHash, 27);\n        }\n        if (typeof sig === \"string\") {\n            const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(sig, \"signature\");\n            if (bytes.length === 64) {\n                const r = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(0, 32));\n                const s = bytes.slice(32, 64);\n                const v = s[0] & 0x80 ? 28 : 27;\n                s[0] &= 0x7f;\n                return new Signature(_guard, r, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(s), v);\n            }\n            if (bytes.length === 65) {\n                const r = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(0, 32));\n                const s = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(32, 64));\n                const v = Signature.getNormalizedV(bytes[64]);\n                return new Signature(_guard, r, s, v);\n            }\n            assertError(false, \"invalid raw signature length\");\n        }\n        if (sig instanceof Signature) {\n            return sig.clone();\n        }\n        // Get r\n        const _r = sig.r;\n        assertError(_r != null, \"missing r\");\n        const r = toUint256(_r);\n        // Get s; by any means necessary (we check consistency below)\n        const s = function(s, yParityAndS) {\n            if (s != null) {\n                return toUint256(s);\n            }\n            if (yParityAndS != null) {\n                assertError((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(yParityAndS, 32), \"invalid yParityAndS\");\n                const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(yParityAndS);\n                bytes[0] &= 0x7f;\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes);\n            }\n            assertError(false, \"missing s\");\n        }(sig.s, sig.yParityAndS);\n        // Get v; by any means necessary (we check consistency below)\n        const { networkV, v } = function(_v, yParityAndS, yParity) {\n            if (_v != null) {\n                const v = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(_v);\n                return {\n                    networkV: v >= BN_35 ? v : undefined,\n                    v: Signature.getNormalizedV(v)\n                };\n            }\n            if (yParityAndS != null) {\n                assertError((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(yParityAndS, 32), \"invalid yParityAndS\");\n                return {\n                    v: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(yParityAndS)[0] & 0x80 ? 28 : 27\n                };\n            }\n            if (yParity != null) {\n                switch((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(yParity, \"sig.yParity\")){\n                    case 0:\n                        return {\n                            v: 27\n                        };\n                    case 1:\n                        return {\n                            v: 28\n                        };\n                }\n                assertError(false, \"invalid yParity\");\n            }\n            assertError(false, \"missing v\");\n        }(sig.v, sig.yParityAndS, sig.yParity);\n        const result = new Signature(_guard, r, s, v);\n        if (networkV) {\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_4__._)(result, _networkV, networkV);\n        }\n        // If multiple of v, yParity, yParityAndS we given, check they match\n        assertError(sig.yParity == null || (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(sig.yParity, \"sig.yParity\") === result.yParity, \"yParity mismatch\");\n        assertError(sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS, \"yParityAndS mismatch\");\n        return result;\n    }\n    /**\n     *  @private\n     */ constructor(guard, r, s, v){\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_6__._)(this, _r, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_6__._)(this, _s, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_6__._)(this, _v, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_6__._)(this, _networkV, {\n            writable: true,\n            value: void 0\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertPrivate)(guard, _guard, \"Signature\");\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_4__._)(this, _r, r);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_4__._)(this, _s, s);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_4__._)(this, _v, v);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_4__._)(this, _networkV, null);\n    }\n} //# sourceMappingURL=signature.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8vc2lnbmF0dXJlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQWlEO0FBQ29IO0FBQ3JLLFlBQVk7QUFDWixNQUFNWSxPQUFPQyxPQUFPO0FBQ3BCLE1BQU1DLE9BQU9ELE9BQU87QUFDcEIsTUFBTUUsT0FBT0YsT0FBTztBQUNwQixNQUFNRyxRQUFRSCxPQUFPO0FBQ3JCLE1BQU1JLFFBQVFKLE9BQU87QUFDckIsTUFBTUssUUFBUUwsT0FBTztBQUNyQixNQUFNTSxPQUFPTixPQUFPO0FBQ3BCLE1BQU1PLFNBQVNELE9BQU9KLE1BQU0sa0RBQWtEO0FBQzlFLE1BQU1NLFVBQVVDLE9BQU9DLEdBQUcsQ0FBQztBQUMzQixNQUFNQyxTQUFTLENBQUM7QUFDaEIsU0FBU0MsVUFBVUMsS0FBSztJQUNwQixPQUFPakIsNkRBQVlBLENBQUNGLDBEQUFTQSxDQUFDbUIsUUFBUTtBQUMxQztJQVFJLGtDQUNBLGtDQUNBLGtDQUNBO0lBMkpDTCxXQUFBQTtBQXJLTDs7Ozs7Q0FLQyxHQUNNLE1BQU1NO0lBS1Q7Ozs7O0tBS0MsR0FDRCxJQUFJQyxJQUFJO1FBQUUsT0FBTyw0RUFBSSxFQUFFQTtJQUFHO0lBQzFCLElBQUlBLEVBQUVGLEtBQUssRUFBRTtRQUNUaEIsK0RBQWNBLENBQUNSLDJEQUFVQSxDQUFDd0IsV0FBVyxJQUFJLGFBQWEsU0FBU0E7c0ZBQ3pERSxJQUFJdEIsd0RBQU9BLENBQUNvQjtJQUN0QjtJQUNBOztLQUVDLEdBQ0QsSUFBSUcsSUFBSTtRQUNKbkIsK0RBQWNBLENBQUNvQixTQUFTLDRFQUFJLEVBQUVELElBQUVFLFNBQVMsQ0FBQyxHQUFHLE1BQU0sR0FBRyw0QkFBNEIsS0FBSyw0RUFBSSxFQUFFRjtRQUM3RixPQUFPLDRFQUFJLEVBQUVBO0lBQ2pCO0lBQ0EsSUFBSUEsRUFBRUcsTUFBTSxFQUFFO1FBQ1Z0QiwrREFBY0EsQ0FBQ1Is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LFdBQVcsTUFBTTtnQkFDakIsT0FBUWxDLDBEQUFTQSxDQUFDa0MsU0FBUztvQkFDdkIsS0FBSzt3QkFBRyxPQUFPOzRCQUFFSixHQUFHO3dCQUFHO29CQUN2QixLQUFLO3dCQUFHLE9BQU87NEJBQUVBLEdBQUc7d0JBQUc7Z0JBQzNCO2dCQUNBb0IsWUFBWSxPQUFPO1lBQ3ZCO1lBQ0FBLFlBQVksT0FBTztRQUN2QixFQUFHRCxJQUFJbkIsQ0FBQyxFQUFFbUIsSUFBSWQsV0FBVyxFQUFFYyxJQUFJZixPQUFPO1FBQ3RDLE1BQU1LLFNBQVMsSUFBSWpCLFVBQVVILFFBQVFJLEdBQUdDLEdBQUdNO1FBQzNDLElBQUlDLFVBQVU7b0ZBQ1ZRLFFBQVFSLFdBQVdBO1FBQ3ZCO1FBQ0Esb0VBQW9FO1FBQ3BFbUIsWUFBWUQsSUFBSWYsT0FBTyxJQUFJLFFBQVFsQywwREFBU0EsQ0FBQ2lELElBQUlmLE9BQU8sRUFBRSxtQkFBbUJLLE9BQU9MLE9BQU8sRUFBRTtRQUM3RmdCLFlBQVlELElBQUlkLFdBQVcsSUFBSSxRQUFRYyxJQUFJZCxXQUFXLEtBQUtJLE9BQU9KLFdBQVcsRUFBRTtRQUMvRSxPQUFPSTtJQUNYO0lBdE5BOztLQUVDLEdBQ0RvQixZQUFZQyxLQUFLLEVBQUVyQyxDQUFDLEVBQUVDLENBQUMsRUFBRU0sQ0FBQyxDQUFFO1FBN0c1Qjs7bUJBQUE7O1FBQ0E7O21CQUFBOztRQUNBOzttQkFBQTs7UUFDQTs7bUJBQUE7O1FBMkdJeEIsOERBQWFBLENBQUNzRCxPQUFPekMsUUFBUTtzRkFDdkJJLElBQUlBO3NGQUNKQyxJQUFJQTtzRkFDSk0sSUFBSUE7c0ZBQ0pDLFdBQVc7SUFDckI7QUE4TUosRUFDQSxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NyeXB0by9zaWduYXR1cmUuanM/YzAxNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBaZXJvSGFzaCB9IGZyb20gXCIuLi9jb25zdGFudHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGNvbmNhdCwgZGF0YUxlbmd0aCwgZ2V0QmlnSW50LCBnZXRCeXRlcywgZ2V0TnVtYmVyLCBoZXhsaWZ5LCB0b0JlQXJyYXksIGlzSGV4U3RyaW5nLCB6ZXJvUGFkVmFsdWUsIGFzc2VydEFyZ3VtZW50LCBhc3NlcnRQcml2YXRlIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG4vLyBDb25zdGFudHNcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5jb25zdCBCTl8xID0gQmlnSW50KDEpO1xuY29uc3QgQk5fMiA9IEJpZ0ludCgyKTtcbmNvbnN0IEJOXzI3ID0gQmlnSW50KDI3KTtcbmNvbnN0IEJOXzI4ID0gQmlnSW50KDI4KTtcbmNvbnN0IEJOXzM1ID0gQmlnSW50KDM1KTtcbmNvbnN0IEJOX04gPSBCaWdJbnQoXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDFcIik7XG5jb25zdCBCTl9OXzIgPSBCTl9OIC8gQk5fMjsgLy8gTXVzdCBiZSBpbnRlZ2VyIChmbG9vcikgZGl2aXNpb247IGRvIE5PVCBzaGlmdHNcbmNvbnN0IGluc3BlY3QgPSBTeW1ib2wuZm9yKFwibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b21cIik7XG5jb25zdCBfZ3VhcmQgPSB7fTtcbmZ1bmN0aW9uIHRvVWludDI1Nih2YWx1ZSkge1xuICAgIHJldHVybiB6ZXJvUGFkVmFsdWUodG9CZUFycmF5KHZhbHVlKSwgMzIpO1xufVxuLyoqXG4gKiAgQSBTaWduYXR1cmUgIEBUT0RPXG4gKlxuICpcbiAqICBAX2RvY2xvYzogYXBpL2NyeXB0bzpTaWduaW5nXG4gKi9cbmV4cG9ydCBjbGFzcyBTaWduYXR1cmUge1xuICAgICNyO1xuICAgICNzO1xuICAgICN2O1xuICAgICNuZXR3b3JrVjtcbiAgICAvKipcbiAgICAgKiAgVGhlIGBgcmBgIHZhbHVlIGZvciBhIHNpZ25hdHVyZS5cbiAgICAgKlxuICAgICAqICBUaGlzIHJlcHJlc2VudHMgdGhlIGBgeGBgIGNvb3JkaW5hdGUgb2YgYSBcInJlZmVyZW5jZVwiIG9yXG4gICAgICogIGNoYWxsZW5nZSBwb2ludCwgZnJvbSB3aGljaCB0aGUgYGB5YGAgY2FuIGJlIGNvbXB1dGVkLlxuICAgICAqL1xuICAgIGdldCByKCkgeyByZXR1cm4gdGhpcy4jcjsgfVxuICAgIHNldCByKHZhbHVlKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGRhdGFMZW5ndGgodmFsdWUpID09PSAzMiwgXCJpbnZhbGlkIHJcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuI3IgPSBoZXhsaWZ5KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBgYHNgYCB2YWx1ZSBmb3IgYSBzaWduYXR1cmUuXG4gICAgICovXG4gICAgZ2V0IHMoKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHBhcnNlSW50KHRoaXMuI3Muc3Vic3RyaW5nKDAsIDMpKSA8IDgsIFwibm9uLWNhbm9uaWNhbCBzOyB1c2UgLl9zXCIsIFwic1wiLCB0aGlzLiNzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3M7XG4gICAgfVxuICAgIHNldCBzKF92YWx1ZSkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhTGVuZ3RoKF92YWx1ZSkgPT09IDMyLCBcImludmFsaWQgc1wiLCBcInZhbHVlXCIsIF92YWx1ZSk7XG4gICAgICAgIHRoaXMuI3MgPSBoZXhsaWZ5KF92YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHMgdmFsdWUsIHVuY2hlY2tlZCBmb3IgRUlQLTIgY29tcGxpYW5jZS5cbiAgICAgKlxuICAgICAqICBUaGlzIHNob3VsZCBnZW5lcmFsbHkgbm90IGJlIHVzZWQgYW5kIGlzIGZvciBzaXR1YXRpb25zIHdoZXJlXG4gICAgICogIGEgbm9uLWNhbm9uaWNhbCBTIHZhbHVlIG1pZ2h0IGJlIHJlbGV2YW50LCBzdWNoIGFzIEZyb250aWVyIGJsb2Nrc1xuICAgICAqICB0aGF0IHdlcmUgbWluZWQgcHJpb3IgdG8gRUlQLTIgb3IgaW52YWxpZCBBdXRob3JpemF0aW9uIExpc3RcbiAgICAgKiAgc2lnbmF0dXJlcy5cbiAgICAgKi9cbiAgICBnZXQgX3MoKSB7IHJldHVybiB0aGlzLiNzOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGUgU2lnbmF0dXJlIGlzIHZhbGlkIGZvciBbW2xpbmstZWlwLTJdXSBzaWduYXR1cmVzLlxuICAgICAqL1xuICAgIGlzVmFsaWQoKSB7XG4gICAgICAgIGNvbnN0IHMgPSBCaWdJbnQodGhpcy4jcyk7XG4gICAgICAgIHJldHVybiAocyA8PSBCTl9OXzIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGBgdmBgIHZhbHVlIGZvciBhIHNpZ25hdHVyZS5cbiAgICAgKlxuICAgICAqICBTaW5jZSBhIGdpdmVuIGBgeGBgIHZhbHVlIGZvciBgYHJgYCBoYXMgdHdvIHBvc3NpYmxlIHZhbHVlcyBmb3JcbiAgICAgKiAgaXRzIGNvcnJlc3BvbmRpbiBgYHlgYCwgdGhlIGBgdmBgIGluZGljYXRlcyB3aGljaCBvZiB0aGUgdHdvIGBgeWBgXG4gICAgICogIHZhbHVlcyB0byB1c2UuXG4gICAgICpcbiAgICAgKiAgSXQgaXMgbm9ybWFsaXplZCB0byB0aGUgdmFsdWVzIGBgMjdgYCBvciBgYDI4YGAgZm9yIGxlZ2FjeVxuICAgICAqICBwdXJwb3Nlcy5cbiAgICAgKi9cbiAgICBnZXQgdigpIHsgcmV0dXJuIHRoaXMuI3Y7IH1cbiAgICBzZXQgdih2YWx1ZSkge1xuICAgICAgICBjb25zdCB2ID0gZ2V0TnVtYmVyKHZhbHVlLCBcInZhbHVlXCIpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudCh2ID09PSAyNyB8fCB2ID09PSAyOCwgXCJpbnZhbGlkIHZcIiwgXCJ2XCIsIHZhbHVlKTtcbiAgICAgICAgdGhpcy4jdiA9IHY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgRUlQLTE1NSBgYHZgYCBmb3IgbGVnYWN5IHRyYW5zYWN0aW9ucy4gRm9yIG5vbi1sZWdhY3lcbiAgICAgKiAgdHJhbnNhY3Rpb25zLCB0aGlzIHZhbHVlIGlzIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdldCBuZXR3b3JrVigpIHsgcmV0dXJuIHRoaXMuI25ldHdvcmtWOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBjaGFpbiBJRCBmb3IgRUlQLTE1NSBsZWdhY3kgdHJhbnNhY3Rpb25zLiBGb3Igbm9uLWxlZ2FjeVxuICAgICAqICB0cmFuc2FjdGlvbnMsIHRoaXMgdmFsdWUgaXMgYGBudWxsYGAuXG4gICAgICovXG4gICAgZ2V0IGxlZ2FjeUNoYWluSWQoKSB7XG4gICAgICAgIGNvbnN0IHYgPSB0aGlzLm5ldHdvcmtWO1xuICAgICAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU2lnbmF0dXJlLmdldENoYWluSWQodik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgYGB5UGFyaXR5YGAgZm9yIHRoZSBzaWduYXR1cmUuXG4gICAgICpcbiAgICAgKiAgU2VlIGBgdmBgIGZvciBtb3JlIGRldGFpbHMgb24gaG93IHRoaXMgdmFsdWUgaXMgdXNlZC5cbiAgICAgKi9cbiAgICBnZXQgeVBhcml0eSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnYgPT09IDI3KSA/IDAgOiAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIFtbbGluay1laXAtMjA5OF1dIGNvbXBhY3QgcmVwcmVzZW50YXRpb24gb2YgdGhlIGBgeVBhcml0eWBgXG4gICAgICogIGFuZCBgYHNgYCBjb21wYWN0ZWQgaW50byBhIHNpbmdsZSBgYGJ5dGVzMzJgYC5cbiAgICAgKi9cbiAgICBnZXQgeVBhcml0eUFuZFMoKSB7XG4gICAgICAgIC8vIFRoZSBFSVAtMjA5OCBjb21wYWN0IHJlcHJlc2VudGF0aW9uXG4gICAgICAgIGNvbnN0IHlQYXJpdHlBbmRTID0gZ2V0Qnl0ZXModGhpcy5zKTtcbiAgICAgICAgaWYgKHRoaXMueVBhcml0eSkge1xuICAgICAgICAgICAgeVBhcml0eUFuZFNbMF0gfD0gMHg4MDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGV4bGlmeSh5UGFyaXR5QW5kUyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgW1tsaW5rLWVpcC0yMDk4XV0gY29tcGFjdCByZXByZXNlbnRhdGlvbi5cbiAgICAgKi9cbiAgICBnZXQgY29tcGFjdFNlcmlhbGl6ZWQoKSB7XG4gICAgICAgIHJldHVybiBjb25jYXQoW3RoaXMuciwgdGhpcy55UGFyaXR5QW5kU10pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHNlcmlhbGl6ZWQgcmVwcmVzZW50YXRpb24uXG4gICAgICovXG4gICAgZ2V0IHNlcmlhbGl6ZWQoKSB7XG4gICAgICAgIHJldHVybiBjb25jYXQoW3RoaXMuciwgdGhpcy5zLCAodGhpcy55UGFyaXR5ID8gXCIweDFjXCIgOiBcIjB4MWJcIildKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIHIsIHMsIHYpIHtcbiAgICAgICAgYXNzZXJ0UHJpdmF0ZShndWFyZCwgX2d1YXJkLCBcIlNpZ25hdHVyZVwiKTtcbiAgICAgICAgdGhpcy4jciA9IHI7XG4gICAgICAgIHRoaXMuI3MgPSBzO1xuICAgICAgICB0aGlzLiN2ID0gdjtcbiAgICAgICAgdGhpcy4jbmV0d29ya1YgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgY2Fub25pY2FsIHNpZ25hdHVyZS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIG9ubHkgbmVjZXNzYXJ5IHdoZW4gZGVhbGluZyB3aXRoIGxlZ2FjeSB0cmFuc2FjdGlvbiB3aGljaFxuICAgICAqICBkaWQgbm90IGVuZm9yY2UgY2Fub25pY2FsIFMgdmFsdWVzIChpLmUuIFtbbGluay1laXAtMl1dLiBNb3N0XG4gICAgICogIGRldmVsb3BlcnMgc2hvdWxkIG5ldmVyIHJlcXVpcmUgdGhpcy5cbiAgICAgKi9cbiAgICBnZXRDYW5vbmljYWwoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY2Fub25pY2FsIHNpZ25hdHVyZTsgcycgPSBOIC0gcywgdiA9ICF2XG4gICAgICAgIGNvbnN0IHMgPSBCTl9OIC0gQmlnSW50KHRoaXMuX3MpO1xuICAgICAgICBjb25zdCB2ID0gKDU1IC0gdGhpcy52KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFNpZ25hdHVyZShfZ3VhcmQsIHRoaXMuciwgdG9VaW50MjU2KHMpLCB2KTtcbiAgICAgICAgLy8gUG9wdWxhdGUgdGhlIG5ldHdvcmtWIGlmIG5lY2Vzc2FyeVxuICAgICAgICBpZiAodGhpcy5uZXR3b3JrVikge1xuICAgICAgICAgICAgcmVzdWx0LiNuZXR3b3JrViA9IHRoaXMubmV0d29ya1Y7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgaWRlbnRpY2FsIFtbU2lnbmF0dXJlXV0uXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IGNsb25lID0gbmV3IFNpZ25hdHVyZShfZ3VhcmQsIHRoaXMuciwgdGhpcy5fcywgdGhpcy52KTtcbiAgICAgICAgaWYgKHRoaXMubmV0d29ya1YpIHtcbiAgICAgICAgICAgIGNsb25lLiNuZXR3b3JrViA9IHRoaXMubmV0d29ya1Y7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHJlcHJlc2VudGF0aW9uIHRoYXQgaXMgY29tcGF0aWJsZSB3aXRoIGBgSlNPTi5zdHJpbmdpZnlgYC5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IG5ldHdvcmtWID0gdGhpcy5uZXR3b3JrVjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF90eXBlOiBcInNpZ25hdHVyZVwiLFxuICAgICAgICAgICAgbmV0d29ya1Y6ICgobmV0d29ya1YgIT0gbnVsbCkgPyBuZXR3b3JrVi50b1N0cmluZygpIDogbnVsbCksXG4gICAgICAgICAgICByOiB0aGlzLnIsIHM6IHRoaXMuX3MsIHY6IHRoaXMudixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgW2luc3BlY3RdKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gYFNpZ25hdHVyZSB7IHI6ICR7dGhpcy5yfSwgczogJHt0aGlzLl9zfSwgdjogJHt0aGlzLnZ9IH1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgU2lnbmF0dXJlIHsgcjogJHt0aGlzLnJ9LCBzOiAke3RoaXMuX3N9LCB2OiAke3RoaXMudn0sIHZhbGlkOiBmYWxzZSB9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENvbXB1dGUgdGhlIGNoYWluIElEIGZyb20gdGhlIGBgdmBgIGluIGEgbGVnYWN5IEVJUC0xNTUgdHJhbnNhY3Rpb25zLlxuICAgICAqXG4gICAgICogIEBleGFtcGxlOlxuICAgICAqICAgIFNpZ25hdHVyZS5nZXRDaGFpbklkKDQ1KVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIFNpZ25hdHVyZS5nZXRDaGFpbklkKDQ2KVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Q2hhaW5JZCh2KSB7XG4gICAgICAgIGNvbnN0IGJ2ID0gZ2V0QmlnSW50KHYsIFwidlwiKTtcbiAgICAgICAgLy8gVGhlIHYgaXMgbm90IGFuIEVJUC0xNTUgdiwgc28gaXQgaXMgdGhlIHVuc3BlY2lmaWVkIGNoYWluIElEXG4gICAgICAgIGlmICgoYnYgPT0gQk5fMjcpIHx8IChidiA9PSBCTl8yOCkpIHtcbiAgICAgICAgICAgIHJldHVybiBCTl8wO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJhZCB2YWx1ZSBmb3IgYW4gRUlQLTE1NSB2XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGJ2ID49IEJOXzM1LCBcImludmFsaWQgRUlQLTE1NSB2XCIsIFwidlwiLCB2KTtcbiAgICAgICAgcmV0dXJuIChidiAtIEJOXzM1KSAvIEJOXzI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDb21wdXRlIHRoZSBgYHZgYCBmb3IgYSBjaGFpbiBJRCBmb3IgYSBsZWdhY3kgRUlQLTE1NSB0cmFuc2FjdGlvbnMuXG4gICAgICpcbiAgICAgKiAgTGVnYWN5IHRyYW5zYWN0aW9ucyB3aGljaCB1c2UgW1tsaW5rLWVpcC0xNTVdXSBoaWphY2sgdGhlIGBgdmBgXG4gICAgICogIHByb3BlcnR5IHRvIGluY2x1ZGUgdGhlIGNoYWluIElELlxuICAgICAqXG4gICAgICogIEBleGFtcGxlOlxuICAgICAqICAgIFNpZ25hdHVyZS5nZXRDaGFpbklkVig1LCAyNylcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICBTaWduYXR1cmUuZ2V0Q2hhaW5JZFYoNSwgMjgpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICovXG4gICAgc3RhdGljIGdldENoYWluSWRWKGNoYWluSWQsIHYpIHtcbiAgICAgICAgcmV0dXJuIChnZXRCaWdJbnQoY2hhaW5JZCkgKiBCTl8yKSArIEJpZ0ludCgzNSArIHYgLSAyNyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDb21wdXRlIHRoZSBub3JtYWxpemVkIGxlZ2FjeSB0cmFuc2FjdGlvbiBgYHZgYCBmcm9tIGEgYGB5UGFyaXJ0eWBgLFxuICAgICAqICBhIGxlZ2FjeSB0cmFuc2FjdGlvbiBgYHZgYCBvciBhIGxlZ2FjeSBbW2xpbmstZWlwLTE1NV1dIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIEBleGFtcGxlOlxuICAgICAqICAgIC8vIFRoZSB2YWx1ZXMgMCBhbmQgMSBpbXBseSB2IGlzIGFjdHVhbGx5IHlQYXJpdHlcbiAgICAgKiAgICBTaWduYXR1cmUuZ2V0Tm9ybWFsaXplZFYoMClcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICAvLyBMZWdhY3kgbm9uLUVJUC0xNTU5IHRyYW5zYWN0aW9uIChpLmUuIDI3IG9yIDI4KVxuICAgICAqICAgIFNpZ25hdHVyZS5nZXROb3JtYWxpemVkVigyNylcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICAvLyBMZWdhY3kgRUlQLTE1NSB0cmFuc2FjdGlvbiAoaS5lLiA+PSAzNSlcbiAgICAgKiAgICBTaWduYXR1cmUuZ2V0Tm9ybWFsaXplZFYoNDYpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgLy8gSW52YWxpZCB2YWx1ZXMgdGhyb3dcbiAgICAgKiAgICBTaWduYXR1cmUuZ2V0Tm9ybWFsaXplZFYoNSlcbiAgICAgKiAgICAvL19lcnJvcjpcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Tm9ybWFsaXplZFYodikge1xuICAgICAgICBjb25zdCBidiA9IGdldEJpZ0ludCh2KTtcbiAgICAgICAgaWYgKGJ2ID09PSBCTl8wIHx8IGJ2ID09PSBCTl8yNykge1xuICAgICAgICAgICAgcmV0dXJuIDI3O1xuICAgICAgICB9XG4gICAgICAgIGlmIChidiA9PT0gQk5fMSB8fCBidiA9PT0gQk5fMjgpIHtcbiAgICAgICAgICAgIHJldHVybiAyODtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChidiA+PSBCTl8zNSwgXCJpbnZhbGlkIHZcIiwgXCJ2XCIsIHYpO1xuICAgICAgICAvLyBPdGhlcndpc2UsIEVJUC0xNTUgdiBtZWFucyBvZGQgaXMgMjcgYW5kIGV2ZW4gaXMgMjhcbiAgICAgICAgcmV0dXJuIChidiAmIEJOXzEpID8gMjcgOiAyODtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgW1tTaWduYXR1cmVdXS5cbiAgICAgKlxuICAgICAqICBJZiBubyAlJXNpZyUlIGlzIHByb3ZpZGVkLCBhIG5ldyBbW1NpZ25hdHVyZV1dIGlzIGNyZWF0ZWRcbiAgICAgKiAgd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAgICAgKlxuICAgICAqICBJZiAlJXNpZyUlIGlzIGEgc3RyaW5nLCBpdCBpcyBwYXJzZWQuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20oc2lnKSB7XG4gICAgICAgIGZ1bmN0aW9uIGFzc2VydEVycm9yKGNoZWNrLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChjaGVjaywgbWVzc2FnZSwgXCJzaWduYXR1cmVcIiwgc2lnKTtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIGlmIChzaWcgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUoX2d1YXJkLCBaZXJvSGFzaCwgWmVyb0hhc2gsIDI3KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChzaWcpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKHNpZywgXCJzaWduYXR1cmVcIik7XG4gICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSA2NCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBoZXhsaWZ5KGJ5dGVzLnNsaWNlKDAsIDMyKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IGJ5dGVzLnNsaWNlKDMyLCA2NCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdiA9IChzWzBdICYgMHg4MCkgPyAyOCA6IDI3O1xuICAgICAgICAgICAgICAgIHNbMF0gJj0gMHg3ZjtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShfZ3VhcmQsIHIsIGhleGxpZnkocyksIHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gNjUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByID0gaGV4bGlmeShieXRlcy5zbGljZSgwLCAzMikpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBoZXhsaWZ5KGJ5dGVzLnNsaWNlKDMyLCA2NCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBTaWduYXR1cmUuZ2V0Tm9ybWFsaXplZFYoYnl0ZXNbNjRdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShfZ3VhcmQsIHIsIHMsIHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0RXJyb3IoZmFsc2UsIFwiaW52YWxpZCByYXcgc2lnbmF0dXJlIGxlbmd0aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2lnIGluc3RhbmNlb2YgU2lnbmF0dXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gc2lnLmNsb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IHJcbiAgICAgICAgY29uc3QgX3IgPSBzaWcucjtcbiAgICAgICAgYXNzZXJ0RXJyb3IoX3IgIT0gbnVsbCwgXCJtaXNzaW5nIHJcIik7XG4gICAgICAgIGNvbnN0IHIgPSB0b1VpbnQyNTYoX3IpO1xuICAgICAgICAvLyBHZXQgczsgYnkgYW55IG1lYW5zIG5lY2Vzc2FyeSAod2UgY2hlY2sgY29uc2lzdGVuY3kgYmVsb3cpXG4gICAgICAgIGNvbnN0IHMgPSAoZnVuY3Rpb24gKHMsIHlQYXJpdHlBbmRTKSB7XG4gICAgICAgICAgICBpZiAocyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvVWludDI1NihzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5UGFyaXR5QW5kUyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0RXJyb3IoaXNIZXhTdHJpbmcoeVBhcml0eUFuZFMsIDMyKSwgXCJpbnZhbGlkIHlQYXJpdHlBbmRTXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoeVBhcml0eUFuZFMpO1xuICAgICAgICAgICAgICAgIGJ5dGVzWzBdICY9IDB4N2Y7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkoYnl0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0RXJyb3IoZmFsc2UsIFwibWlzc2luZyBzXCIpO1xuICAgICAgICB9KShzaWcucywgc2lnLnlQYXJpdHlBbmRTKTtcbiAgICAgICAgLy8gR2V0IHY7IGJ5IGFueSBtZWFucyBuZWNlc3NhcnkgKHdlIGNoZWNrIGNvbnNpc3RlbmN5IGJlbG93KVxuICAgICAgICBjb25zdCB7IG5ldHdvcmtWLCB2IH0gPSAoZnVuY3Rpb24gKF92LCB5UGFyaXR5QW5kUywgeVBhcml0eSkge1xuICAgICAgICAgICAgaWYgKF92ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gZ2V0QmlnSW50KF92KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuZXR3b3JrVjogKCh2ID49IEJOXzM1KSA/IHYgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgICAgICB2OiBTaWduYXR1cmUuZ2V0Tm9ybWFsaXplZFYodilcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHlQYXJpdHlBbmRTICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRFcnJvcihpc0hleFN0cmluZyh5UGFyaXR5QW5kUywgMzIpLCBcImludmFsaWQgeVBhcml0eUFuZFNcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdjogKChnZXRCeXRlcyh5UGFyaXR5QW5kUylbMF0gJiAweDgwKSA/IDI4IDogMjcpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeVBhcml0eSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChnZXROdW1iZXIoeVBhcml0eSwgXCJzaWcueVBhcml0eVwiKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiB7IHY6IDI3IH07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIHsgdjogMjggfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXNzZXJ0RXJyb3IoZmFsc2UsIFwiaW52YWxpZCB5UGFyaXR5XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0RXJyb3IoZmFsc2UsIFwibWlzc2luZyB2XCIpO1xuICAgICAgICB9KShzaWcudiwgc2lnLnlQYXJpdHlBbmRTLCBzaWcueVBhcml0eSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTaWduYXR1cmUoX2d1YXJkLCByLCBzLCB2KTtcbiAgICAgICAgaWYgKG5ldHdvcmtWKSB7XG4gICAgICAgICAgICByZXN1bHQuI25ldHdvcmtWID0gbmV0d29ya1Y7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbXVsdGlwbGUgb2YgdiwgeVBhcml0eSwgeVBhcml0eUFuZFMgd2UgZ2l2ZW4sIGNoZWNrIHRoZXkgbWF0Y2hcbiAgICAgICAgYXNzZXJ0RXJyb3Ioc2lnLnlQYXJpdHkgPT0gbnVsbCB8fCBnZXROdW1iZXIoc2lnLnlQYXJpdHksIFwic2lnLnlQYXJpdHlcIikgPT09IHJlc3VsdC55UGFyaXR5LCBcInlQYXJpdHkgbWlzbWF0Y2hcIik7XG4gICAgICAgIGFzc2VydEVycm9yKHNpZy55UGFyaXR5QW5kUyA9PSBudWxsIHx8IHNpZy55UGFyaXR5QW5kUyA9PT0gcmVzdWx0LnlQYXJpdHlBbmRTLCBcInlQYXJpdHlBbmRTIG1pc21hdGNoXCIpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ25hdHVyZS5qcy5tYXAiXSwibmFtZXMiOlsiWmVyb0hhc2giLCJjb25jYXQiLCJkYXRhTGVuZ3RoIiwiZ2V0QmlnSW50IiwiZ2V0Qnl0ZXMiLCJnZXROdW1iZXIiLCJoZXhsaWZ5IiwidG9CZUFycmF5IiwiaXNIZXhTdHJpbmciLCJ6ZXJvUGFkVmFsdWUiLCJhc3NlcnRBcmd1bWVudCIsImFzc2VydFByaXZhdGUiLCJCTl8wIiwiQmlnSW50IiwiQk5fMSIsIkJOXzIiLCJCTl8yNyIsIkJOXzI4IiwiQk5fMzUiLCJCTl9OIiwiQk5fTl8yIiwiaW5zcGVjdCIsIlN5bWJvbCIsImZvciIsIl9ndWFyZCIsInRvVWludDI1NiIsInZhbHVlIiwiU2lnbmF0dXJlIiwiciIsInMiLCJwYXJzZUludCIsInN1YnN0cmluZyIsIl92YWx1ZSIsIl9zIiwiaXNWYWxpZCIsInYiLCJuZXR3b3JrViIsImxlZ2FjeUNoYWluSWQiLCJnZXRDaGFpbklkIiwieVBhcml0eSIsInlQYXJpdHlBbmRTIiwiY29tcGFjdFNlcmlhbGl6ZWQiLCJzZXJpYWxpemVkIiwiZ2V0Q2Fub25pY2FsIiwicmVzdWx0IiwiY2xvbmUiLCJ0b0pTT04iLCJfdHlwZSIsInRvU3RyaW5nIiwiYnYiLCJnZXRDaGFpbklkViIsImNoYWluSWQiLCJnZXROb3JtYWxpemVkViIsImZyb20iLCJzaWciLCJhc3NlcnRFcnJvciIsImNoZWNrIiwibWVzc2FnZSIsImJ5dGVzIiwibGVuZ3RoIiwic2xpY2UiLCJfciIsIl92IiwidW5kZWZpbmVkIiwiY29uc3RydWN0b3IiLCJndWFyZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/crypto/signature.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/crypto/signing-key.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/crypto/signing-key.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SigningKey: function() { return /* binding */ SigningKey; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_get */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_get.js\");\n/* harmony import */ var _swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_init */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_init.js\");\n/* harmony import */ var _swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_set */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_set.js\");\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _signature_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./signature.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/crypto/signature.js\");\n/**\n *  Add details about signing here.\n *\n *  @_subsection: api/crypto:Signing  [about-signing]\n */ \n\n\n\n\n\nvar _privateKey = /*#__PURE__*/ new WeakMap();\n/**\n *  A **SigningKey** provides high-level access to the elliptic curve\n *  cryptography (ECC) operations and key management.\n */ class SigningKey {\n    /**\n     *  The private key.\n     */ get privateKey() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _privateKey);\n    }\n    /**\n     *  The uncompressed public key.\n     *\n     * This will always begin with the prefix ``0x04`` and be 132\n     * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).\n     */ get publicKey() {\n        return SigningKey.computePublicKey((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _privateKey));\n    }\n    /**\n     *  The compressed public key.\n     *\n     *  This will always begin with either the prefix ``0x02`` or ``0x03``\n     *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal\n     *  nibbles)\n     */ get compressedPublicKey() {\n        return SigningKey.computePublicKey((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _privateKey), true);\n    }\n    /**\n     *  Return the signature of the signed %%digest%%.\n     */ sign(digest) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.dataLength)(digest) === 32, \"invalid digest length\", \"digest\", digest);\n        const sig = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_3__.secp256k1.sign((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)(digest), (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _privateKey)), {\n            lowS: true\n        });\n        return _signature_js__WEBPACK_IMPORTED_MODULE_4__.Signature.from({\n            r: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.toBeHex)(sig.r, 32),\n            s: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.toBeHex)(sig.s, 32),\n            v: sig.recovery ? 0x1c : 0x1b\n        });\n    }\n    /**\n     *  Returns the [[link-wiki-ecdh]] shared secret between this\n     *  private key and the %%other%% key.\n     *\n     *  The %%other%% key may be any type of key, a raw public key,\n     *  a compressed/uncompressed pubic key or aprivate key.\n     *\n     *  Best practice is usually to use a cryptographic hash on the\n     *  returned value before using it as a symetric secret.\n     *\n     *  @example:\n     *    sign1 = new SigningKey(id(\"some-secret-1\"))\n     *    sign2 = new SigningKey(id(\"some-secret-2\"))\n     *\n     *    // Notice that privA.computeSharedSecret(pubB)...\n     *    sign1.computeSharedSecret(sign2.publicKey)\n     *    //_result:\n     *\n     *    // ...is equal to privB.computeSharedSecret(pubA).\n     *    sign2.computeSharedSecret(sign1.publicKey)\n     *    //_result:\n     */ computeSharedSecret(other) {\n        const pubKey = SigningKey.computePublicKey(other);\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_3__.secp256k1.getSharedSecret((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _privateKey)), (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(pubKey), false));\n    }\n    /**\n     *  Compute the public key for %%key%%, optionally %%compressed%%.\n     *\n     *  The %%key%% may be any type of key, a raw public key, a\n     *  compressed/uncompressed public key or private key.\n     *\n     *  @example:\n     *    sign = new SigningKey(id(\"some-secret\"));\n     *\n     *    // Compute the uncompressed public key for a private key\n     *    SigningKey.computePublicKey(sign.privateKey)\n     *    //_result:\n     *\n     *    // Compute the compressed public key for a private key\n     *    SigningKey.computePublicKey(sign.privateKey, true)\n     *    //_result:\n     *\n     *    // Compute the uncompressed public key\n     *    SigningKey.computePublicKey(sign.publicKey, false);\n     *    //_result:\n     *\n     *    // Compute the Compressed a public key\n     *    SigningKey.computePublicKey(sign.publicKey, true);\n     *    //_result:\n     */ static computePublicKey(key, compressed) {\n        let bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(key, \"key\");\n        // private key\n        if (bytes.length === 32) {\n            const pubKey = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_3__.secp256k1.getPublicKey(bytes, !!compressed);\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)(pubKey);\n        }\n        // raw public key; use uncompressed key with 0x04 prefix\n        if (bytes.length === 64) {\n            const pub = new Uint8Array(65);\n            pub[0] = 0x04;\n            pub.set(bytes, 1);\n            bytes = pub;\n        }\n        const point = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_3__.secp256k1.ProjectivePoint.fromHex(bytes);\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)(point.toRawBytes(compressed));\n    }\n    /**\n     *  Returns the public key for the private key which produced the\n     *  %%signature%% for the given %%digest%%.\n     *\n     *  @example:\n     *    key = new SigningKey(id(\"some-secret\"))\n     *    digest = id(\"hello world\")\n     *    sig = key.sign(digest)\n     *\n     *    // Notice the signer public key...\n     *    key.publicKey\n     *    //_result:\n     *\n     *    // ...is equal to the recovered public key\n     *    SigningKey.recoverPublicKey(digest, sig)\n     *    //_result:\n     *\n     */ static recoverPublicKey(digest, signature) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.dataLength)(digest) === 32, \"invalid digest length\", \"digest\", digest);\n        const sig = _signature_js__WEBPACK_IMPORTED_MODULE_4__.Signature.from(signature);\n        let secpSig = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_3__.secp256k1.Signature.fromCompact((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.concat)([\n            sig.r,\n            sig.s\n        ])));\n        secpSig = secpSig.addRecoveryBit(sig.yParity);\n        const pubKey = secpSig.recoverPublicKey((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)(digest));\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(pubKey != null, \"invalid signature for digest\", \"signature\", signature);\n        return \"0x\" + pubKey.toHex(false);\n    }\n    /**\n     *  Returns the point resulting from adding the ellipic curve points\n     *  %%p0%% and %%p1%%.\n     *\n     *  This is not a common function most developers should require, but\n     *  can be useful for certain privacy-specific techniques.\n     *\n     *  For example, it is used by [[HDNodeWallet]] to compute child\n     *  addresses from parent public keys and chain codes.\n     */ static addPoints(p0, p1, compressed) {\n        const pub0 = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_3__.secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p0).substring(2));\n        const pub1 = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_3__.secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p1).substring(2));\n        return \"0x\" + pub0.add(pub1).toHex(!!compressed);\n    }\n    /**\n     *  Creates a new **SigningKey** for %%privateKey%%.\n     */ constructor(privateKey){\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_6__._)(this, _privateKey, {\n            writable: true,\n            value: void 0\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.dataLength)(privateKey) === 32, \"invalid private key\", \"privateKey\", \"[REDACTED]\");\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_7__._)(this, _privateKey, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)(privateKey));\n    }\n} //# sourceMappingURL=signing-key.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8vc2lnbmluZy1rZXkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Q0FJQzs7O0FBQ21EO0FBQzZEO0FBQ3RFO0lBTXZDO0FBTEo7OztDQUdDLEdBQ00sTUFBTVM7SUFTVDs7S0FFQyxHQUNELElBQUlDLGFBQWE7UUFBRSxPQUFPLDRFQUFJLEVBQUVBO0lBQVk7SUFDNUM7Ozs7O0tBS0MsR0FDRCxJQUFJQyxZQUFZO1FBQUUsT0FBT0YsV0FBV0csZ0JBQWdCLENBQUMsNEVBQUksRUFBRUY7SUFBYTtJQUN4RTs7Ozs7O0tBTUMsR0FDRCxJQUFJRyxzQkFBc0I7UUFBRSxPQUFPSixXQUFXRyxnQkFBZ0IsQ0FBQyw0RUFBSSxFQUFFRixjQUFZO0lBQU87SUFDeEY7O0tBRUMsR0FDREksS0FBS0MsTUFBTSxFQUFFO1FBQ1RSLCtEQUFjQSxDQUFDTCwyREFBVUEsQ0FBQ2EsWUFBWSxJQUFJLHlCQUF5QixVQUFVQTtRQUM3RSxNQUFNQyxNQUFNaEIsOERBQVNBLENBQUNjLElBQUksQ0FBQ1YsNkRBQVlBLENBQUNXLFNBQVNYLDZEQUFZQSxDQUFDQSx1RUFBQUEsQ0FBQSxJQUFJLEVBQUVNLGVBQWE7WUFDN0VPLE1BQU07UUFDVjtRQUNBLE9BQU9ULG9EQUFTQSxDQUFDVSxJQUFJLENBQUM7WUFDbEJDLEdBQUdiLHdEQUFPQSxDQUFDVSxJQUFJRyxDQUFDLEVBQUU7WUFDbEJDLEdBQUdkLHdEQUFPQSxDQUFDVSxJQUFJSSxDQUFDLEVBQUU7WUFDbEJDLEdBQUlMLElBQUlNLFFBQVEsR0FBRyxPQUFPO1FBQzlCO0lBQ0o7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBcUJDLEdBQ0RDLG9CQUFvQkMsS0FBSyxFQUFFO1FBQ3ZCLE1BQU1DLFNBQVNoQixXQUFXRyxnQkFBZ0IsQ0FBQ1k7UUFDM0MsT0FBT25CLHdEQUFPQSxDQUFDTCw4REFBU0EsQ0FBQzBCLGVBQWUsQ0FBQ3RCLDZEQUFZQSxDQUFDQSx1RUFBQUEsQ0FBQSxJQUFJLEVBQUVNLGVBQWFQLHlEQUFRQSxDQUFDc0IsU0FBUztJQUMvRjtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0F3QkMsR0FDRCxPQUFPYixpQkFBaUJlLEdBQUcsRUFBRUMsVUFBVSxFQUFFO1FBQ3JDLElBQUlDLFFBQVExQix5REFBUUEsQ0FBQ3dCLEtBQUs7UUFDMUIsY0FBYztRQUNkLElBQUlFLE1BQU1DLE1BQU0sS0FBSyxJQUFJO1lBQ3JCLE1BQU1MLFNBQVN6Qiw4REFBU0EsQ0FBQytCLFlBQVksQ0FBQ0YsT0FBTyxDQUFDLENBQUNEO1lBQy9DLE9BQU92Qix3REFBT0EsQ0FBQ29CO1FBQ25CO1FBQ0Esd0RBQXdEO1FBQ3hELElBQUlJLE1BQU1DLE1BQU0sS0FBSyxJQUFJO1lBQ3JCLE1BQU1FLE1BQU0sSUFBSUMsV0FBVztZQUMzQkQsR0FBRyxDQUFDLEVBQUUsR0FBRztZQUNUQSxJQUFJRSxHQUFHLENBQUNMLE9BQU87WUFDZkEsUUFBUUc7UUFDWjtRQUNBLE1BQU1HLFFBQVFuQyw4REFBU0EsQ0FBQ29DLGVBQWUsQ0FBQ0MsT0FBTyxDQUFDUjtRQUNoRCxPQUFPeEIsd0RBQU9BLENBQUM4QixNQUFNRyxVQUFVLENBQUNWO0lBQ3BDO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBaUJDLEdBQ0QsT0FBT1csaUJBQWlCeEIsTUFBTSxFQUFFeUIsU0FBUyxFQUFFO1FBQ3ZDakMsK0RBQWNBLENBQUNMLDJEQUFVQSxDQUFDYSxZQUFZLElBQUkseUJBQXlCLFVBQVVBO1FBQzdFLE1BQU1DLE1BQU1SLG9EQUFTQSxDQUFDVSxJQUFJLENBQUNzQjtRQUMzQixJQUFJQyxVQUFVekMsOERBQVNBLENBQUNRLFNBQVMsQ0FBQ2tDLFdBQVcsQ0FBQ3RDLDZEQUFZQSxDQUFDSCx1REFBTUEsQ0FBQztZQUFDZSxJQUFJRyxDQUFDO1lBQUVILElBQUlJLENBQUM7U0FBQztRQUNoRnFCLFVBQVVBLFFBQVFFLGNBQWMsQ0FBQzNCLElBQUk0QixPQUFPO1FBQzVDLE1BQU1uQixTQUFTZ0IsUUFBUUYsZ0JBQWdCLENBQUNuQyw2REFBWUEsQ0FBQ1c7UUFDckRSLCtEQUFjQSxDQUFDa0IsVUFBVSxNQUFNLGdDQUFnQyxhQUFhZTtRQUM1RSxPQUFPLE9BQU9mLE9BQU9vQixLQUFLLENBQUM7SUFDL0I7SUFDQTs7Ozs7Ozs7O0tBU0MsR0FDRCxPQUFPQyxVQUFVQyxFQUFFLEVBQUVDLEVBQUUsRUFBRXBCLFVBQVUsRUFBRTtRQUNqQyxNQUFNcUIsT0FBT2pELDhEQUFTQSxDQUFDb0MsZUFBZSxDQUFDQyxPQUFPLENBQUM1QixXQUFXRyxnQkFBZ0IsQ0FBQ21DLElBQUlHLFNBQVMsQ0FBQztRQUN6RixNQUFNQyxPQUFPbkQsOERBQVNBLENBQUNvQyxlQUFlLENBQUNDLE9BQU8sQ0FBQzVCLFdBQVdHLGdCQUFnQixDQUFDb0MsSUFBSUUsU0FBUyxDQUFDO1FBQ3pGLE9BQU8sT0FBT0QsS0FBS0csR0FBRyxDQUFDRCxNQUFNTixLQUFLLENBQUMsQ0FBQyxDQUFDakI7SUFDekM7SUFySkE7O0tBRUMsR0FDRHlCLFlBQVkzQyxVQUFVLENBQUU7UUFKeEI7O21CQUFBOztRQUtJSCwrREFBY0EsQ0FBQ0wsMkRBQVVBLENBQUNRLGdCQUFnQixJQUFJLHVCQUF1QixjQUFjO3NGQUM3RUEsYUFBYUwsd0RBQU9BLENBQUNLO0lBQy9CO0FBZ0pKLEVBQ0EsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8vc2lnbmluZy1rZXkuanM/NDhlZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBBZGQgZGV0YWlscyBhYm91dCBzaWduaW5nIGhlcmUuXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL2NyeXB0bzpTaWduaW5nICBbYWJvdXQtc2lnbmluZ11cbiAqL1xuaW1wb3J0IHsgc2VjcDI1NmsxIH0gZnJvbSBcIkBub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxXCI7XG5pbXBvcnQgeyBjb25jYXQsIGRhdGFMZW5ndGgsIGdldEJ5dGVzLCBnZXRCeXRlc0NvcHksIGhleGxpZnksIHRvQmVIZXgsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tIFwiLi9zaWduYXR1cmUuanNcIjtcbi8qKlxuICogIEEgKipTaWduaW5nS2V5KiogcHJvdmlkZXMgaGlnaC1sZXZlbCBhY2Nlc3MgdG8gdGhlIGVsbGlwdGljIGN1cnZlXG4gKiAgY3J5cHRvZ3JhcGh5IChFQ0MpIG9wZXJhdGlvbnMgYW5kIGtleSBtYW5hZ2VtZW50LlxuICovXG5leHBvcnQgY2xhc3MgU2lnbmluZ0tleSB7XG4gICAgI3ByaXZhdGVLZXk7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipTaWduaW5nS2V5KiogZm9yICUlcHJpdmF0ZUtleSUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByaXZhdGVLZXkpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZGF0YUxlbmd0aChwcml2YXRlS2V5KSA9PT0gMzIsIFwiaW52YWxpZCBwcml2YXRlIGtleVwiLCBcInByaXZhdGVLZXlcIiwgXCJbUkVEQUNURURdXCIpO1xuICAgICAgICB0aGlzLiNwcml2YXRlS2V5ID0gaGV4bGlmeShwcml2YXRlS2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBwcml2YXRlIGtleS5cbiAgICAgKi9cbiAgICBnZXQgcHJpdmF0ZUtleSgpIHsgcmV0dXJuIHRoaXMuI3ByaXZhdGVLZXk7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHVuY29tcHJlc3NlZCBwdWJsaWMga2V5LlxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIGFsd2F5cyBiZWdpbiB3aXRoIHRoZSBwcmVmaXggYGAweDA0YGAgYW5kIGJlIDEzMlxuICAgICAqIGNoYXJhY3RlcnMgbG9uZyAodGhlIGBgMHhgYCBwcmVmaXggYW5kIDEzMCBoZXhhZGVjaW1hbCBuaWJibGVzKS5cbiAgICAgKi9cbiAgICBnZXQgcHVibGljS2V5KCkgeyByZXR1cm4gU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHRoaXMuI3ByaXZhdGVLZXkpOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBjb21wcmVzc2VkIHB1YmxpYyBrZXkuXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIGFsd2F5cyBiZWdpbiB3aXRoIGVpdGhlciB0aGUgcHJlZml4IGBgMHgwMmBgIG9yIGBgMHgwM2BgXG4gICAgICogIGFuZCBiZSA2OCBjaGFyYWN0ZXJzIGxvbmcgKHRoZSBgYDB4YGAgcHJlZml4IGFuZCAzMyBoZXhhZGVjaW1hbFxuICAgICAqICBuaWJibGVzKVxuICAgICAqL1xuICAgIGdldCBjb21wcmVzc2VkUHVibGljS2V5KCkgeyByZXR1cm4gU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHRoaXMuI3ByaXZhdGVLZXksIHRydWUpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgc2lnbmF0dXJlIG9mIHRoZSBzaWduZWQgJSVkaWdlc3QlJS5cbiAgICAgKi9cbiAgICBzaWduKGRpZ2VzdCkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhTGVuZ3RoKGRpZ2VzdCkgPT09IDMyLCBcImludmFsaWQgZGlnZXN0IGxlbmd0aFwiLCBcImRpZ2VzdFwiLCBkaWdlc3QpO1xuICAgICAgICBjb25zdCBzaWcgPSBzZWNwMjU2azEuc2lnbihnZXRCeXRlc0NvcHkoZGlnZXN0KSwgZ2V0Qnl0ZXNDb3B5KHRoaXMuI3ByaXZhdGVLZXkpLCB7XG4gICAgICAgICAgICBsb3dTOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gU2lnbmF0dXJlLmZyb20oe1xuICAgICAgICAgICAgcjogdG9CZUhleChzaWcuciwgMzIpLFxuICAgICAgICAgICAgczogdG9CZUhleChzaWcucywgMzIpLFxuICAgICAgICAgICAgdjogKHNpZy5yZWNvdmVyeSA/IDB4MWMgOiAweDFiKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIFtbbGluay13aWtpLWVjZGhdXSBzaGFyZWQgc2VjcmV0IGJldHdlZW4gdGhpc1xuICAgICAqICBwcml2YXRlIGtleSBhbmQgdGhlICUlb3RoZXIlJSBrZXkuXG4gICAgICpcbiAgICAgKiAgVGhlICUlb3RoZXIlJSBrZXkgbWF5IGJlIGFueSB0eXBlIG9mIGtleSwgYSByYXcgcHVibGljIGtleSxcbiAgICAgKiAgYSBjb21wcmVzc2VkL3VuY29tcHJlc3NlZCBwdWJpYyBrZXkgb3IgYXByaXZhdGUga2V5LlxuICAgICAqXG4gICAgICogIEJlc3QgcHJhY3RpY2UgaXMgdXN1YWxseSB0byB1c2UgYSBjcnlwdG9ncmFwaGljIGhhc2ggb24gdGhlXG4gICAgICogIHJldHVybmVkIHZhbHVlIGJlZm9yZSB1c2luZyBpdCBhcyBhIHN5bWV0cmljIHNlY3JldC5cbiAgICAgKlxuICAgICAqICBAZXhhbXBsZTpcbiAgICAgKiAgICBzaWduMSA9IG5ldyBTaWduaW5nS2V5KGlkKFwic29tZS1zZWNyZXQtMVwiKSlcbiAgICAgKiAgICBzaWduMiA9IG5ldyBTaWduaW5nS2V5KGlkKFwic29tZS1zZWNyZXQtMlwiKSlcbiAgICAgKlxuICAgICAqICAgIC8vIE5vdGljZSB0aGF0IHByaXZBLmNvbXB1dGVTaGFyZWRTZWNyZXQocHViQikuLi5cbiAgICAgKiAgICBzaWduMS5jb21wdXRlU2hhcmVkU2VjcmV0KHNpZ24yLnB1YmxpY0tleSlcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICAvLyAuLi5pcyBlcXVhbCB0byBwcml2Qi5jb21wdXRlU2hhcmVkU2VjcmV0KHB1YkEpLlxuICAgICAqICAgIHNpZ24yLmNvbXB1dGVTaGFyZWRTZWNyZXQoc2lnbjEucHVibGljS2V5KVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKi9cbiAgICBjb21wdXRlU2hhcmVkU2VjcmV0KG90aGVyKSB7XG4gICAgICAgIGNvbnN0IHB1YktleSA9IFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleShvdGhlcik7XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KHNlY3AyNTZrMS5nZXRTaGFyZWRTZWNyZXQoZ2V0Qnl0ZXNDb3B5KHRoaXMuI3ByaXZhdGVLZXkpLCBnZXRCeXRlcyhwdWJLZXkpLCBmYWxzZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ29tcHV0ZSB0aGUgcHVibGljIGtleSBmb3IgJSVrZXklJSwgb3B0aW9uYWxseSAlJWNvbXByZXNzZWQlJS5cbiAgICAgKlxuICAgICAqICBUaGUgJSVrZXklJSBtYXkgYmUgYW55IHR5cGUgb2Yga2V5LCBhIHJhdyBwdWJsaWMga2V5LCBhXG4gICAgICogIGNvbXByZXNzZWQvdW5jb21wcmVzc2VkIHB1YmxpYyBrZXkgb3IgcHJpdmF0ZSBrZXkuXG4gICAgICpcbiAgICAgKiAgQGV4YW1wbGU6XG4gICAgICogICAgc2lnbiA9IG5ldyBTaWduaW5nS2V5KGlkKFwic29tZS1zZWNyZXRcIikpO1xuICAgICAqXG4gICAgICogICAgLy8gQ29tcHV0ZSB0aGUgdW5jb21wcmVzc2VkIHB1YmxpYyBrZXkgZm9yIGEgcHJpdmF0ZSBrZXlcbiAgICAgKiAgICBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkoc2lnbi5wcml2YXRlS2V5KVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIC8vIENvbXB1dGUgdGhlIGNvbXByZXNzZWQgcHVibGljIGtleSBmb3IgYSBwcml2YXRlIGtleVxuICAgICAqICAgIFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleShzaWduLnByaXZhdGVLZXksIHRydWUpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgLy8gQ29tcHV0ZSB0aGUgdW5jb21wcmVzc2VkIHB1YmxpYyBrZXlcbiAgICAgKiAgICBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkoc2lnbi5wdWJsaWNLZXksIGZhbHNlKTtcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICAvLyBDb21wdXRlIHRoZSBDb21wcmVzc2VkIGEgcHVibGljIGtleVxuICAgICAqICAgIFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleShzaWduLnB1YmxpY0tleSwgdHJ1ZSk7XG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqL1xuICAgIHN0YXRpYyBjb21wdXRlUHVibGljS2V5KGtleSwgY29tcHJlc3NlZCkge1xuICAgICAgICBsZXQgYnl0ZXMgPSBnZXRCeXRlcyhrZXksIFwia2V5XCIpO1xuICAgICAgICAvLyBwcml2YXRlIGtleVxuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSAzMikge1xuICAgICAgICAgICAgY29uc3QgcHViS2V5ID0gc2VjcDI1NmsxLmdldFB1YmxpY0tleShieXRlcywgISFjb21wcmVzc2VkKTtcbiAgICAgICAgICAgIHJldHVybiBoZXhsaWZ5KHB1YktleSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmF3IHB1YmxpYyBrZXk7IHVzZSB1bmNvbXByZXNzZWQga2V5IHdpdGggMHgwNCBwcmVmaXhcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gNjQpIHtcbiAgICAgICAgICAgIGNvbnN0IHB1YiA9IG5ldyBVaW50OEFycmF5KDY1KTtcbiAgICAgICAgICAgIHB1YlswXSA9IDB4MDQ7XG4gICAgICAgICAgICBwdWIuc2V0KGJ5dGVzLCAxKTtcbiAgICAgICAgICAgIGJ5dGVzID0gcHViO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvaW50ID0gc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludC5mcm9tSGV4KGJ5dGVzKTtcbiAgICAgICAgcmV0dXJuIGhleGxpZnkocG9pbnQudG9SYXdCeXRlcyhjb21wcmVzc2VkKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBwdWJsaWMga2V5IGZvciB0aGUgcHJpdmF0ZSBrZXkgd2hpY2ggcHJvZHVjZWQgdGhlXG4gICAgICogICUlc2lnbmF0dXJlJSUgZm9yIHRoZSBnaXZlbiAlJWRpZ2VzdCUlLlxuICAgICAqXG4gICAgICogIEBleGFtcGxlOlxuICAgICAqICAgIGtleSA9IG5ldyBTaWduaW5nS2V5KGlkKFwic29tZS1zZWNyZXRcIikpXG4gICAgICogICAgZGlnZXN0ID0gaWQoXCJoZWxsbyB3b3JsZFwiKVxuICAgICAqICAgIHNpZyA9IGtleS5zaWduKGRpZ2VzdClcbiAgICAgKlxuICAgICAqICAgIC8vIE5vdGljZSB0aGUgc2lnbmVyIHB1YmxpYyBrZXkuLi5cbiAgICAgKiAgICBrZXkucHVibGljS2V5XG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgLy8gLi4uaXMgZXF1YWwgdG8gdGhlIHJlY292ZXJlZCBwdWJsaWMga2V5XG4gICAgICogICAgU2lnbmluZ0tleS5yZWNvdmVyUHVibGljS2V5KGRpZ2VzdCwgc2lnKVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqL1xuICAgIHN0YXRpYyByZWNvdmVyUHVibGljS2V5KGRpZ2VzdCwgc2lnbmF0dXJlKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGRhdGFMZW5ndGgoZGlnZXN0KSA9PT0gMzIsIFwiaW52YWxpZCBkaWdlc3QgbGVuZ3RoXCIsIFwiZGlnZXN0XCIsIGRpZ2VzdCk7XG4gICAgICAgIGNvbnN0IHNpZyA9IFNpZ25hdHVyZS5mcm9tKHNpZ25hdHVyZSk7XG4gICAgICAgIGxldCBzZWNwU2lnID0gc2VjcDI1NmsxLlNpZ25hdHVyZS5mcm9tQ29tcGFjdChnZXRCeXRlc0NvcHkoY29uY2F0KFtzaWcuciwgc2lnLnNdKSkpO1xuICAgICAgICBzZWNwU2lnID0gc2VjcFNpZy5hZGRSZWNvdmVyeUJpdChzaWcueVBhcml0eSk7XG4gICAgICAgIGNvbnN0IHB1YktleSA9IHNlY3BTaWcucmVjb3ZlclB1YmxpY0tleShnZXRCeXRlc0NvcHkoZGlnZXN0KSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHB1YktleSAhPSBudWxsLCBcImludmFsaWQgc2lnbmF0dXJlIGZvciBkaWdlc3RcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgcmV0dXJuIFwiMHhcIiArIHB1YktleS50b0hleChmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBwb2ludCByZXN1bHRpbmcgZnJvbSBhZGRpbmcgdGhlIGVsbGlwaWMgY3VydmUgcG9pbnRzXG4gICAgICogICUlcDAlJSBhbmQgJSVwMSUlLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgbm90IGEgY29tbW9uIGZ1bmN0aW9uIG1vc3QgZGV2ZWxvcGVycyBzaG91bGQgcmVxdWlyZSwgYnV0XG4gICAgICogIGNhbiBiZSB1c2VmdWwgZm9yIGNlcnRhaW4gcHJpdmFjeS1zcGVjaWZpYyB0ZWNobmlxdWVzLlxuICAgICAqXG4gICAgICogIEZvciBleGFtcGxlLCBpdCBpcyB1c2VkIGJ5IFtbSEROb2RlV2FsbGV0XV0gdG8gY29tcHV0ZSBjaGlsZFxuICAgICAqICBhZGRyZXNzZXMgZnJvbSBwYXJlbnQgcHVibGljIGtleXMgYW5kIGNoYWluIGNvZGVzLlxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRQb2ludHMocDAsIHAxLCBjb21wcmVzc2VkKSB7XG4gICAgICAgIGNvbnN0IHB1YjAgPSBzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LmZyb21IZXgoU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHAwKS5zdWJzdHJpbmcoMikpO1xuICAgICAgICBjb25zdCBwdWIxID0gc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludC5mcm9tSGV4KFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleShwMSkuc3Vic3RyaW5nKDIpKTtcbiAgICAgICAgcmV0dXJuIFwiMHhcIiArIHB1YjAuYWRkKHB1YjEpLnRvSGV4KCEhY29tcHJlc3NlZCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lnbmluZy1rZXkuanMubWFwIl0sIm5hbWVzIjpbInNlY3AyNTZrMSIsImNvbmNhdCIsImRhdGFMZW5ndGgiLCJnZXRCeXRlcyIsImdldEJ5dGVzQ29weSIsImhleGxpZnkiLCJ0b0JlSGV4IiwiYXNzZXJ0QXJndW1lbnQiLCJTaWduYXR1cmUiLCJTaWduaW5nS2V5IiwicHJpdmF0ZUtleSIsInB1YmxpY0tleSIsImNvbXB1dGVQdWJsaWNLZXkiLCJjb21wcmVzc2VkUHVibGljS2V5Iiwic2lnbiIsImRpZ2VzdCIsInNpZyIsImxvd1MiLCJmcm9tIiwiciIsInMiLCJ2IiwicmVjb3ZlcnkiLCJjb21wdXRlU2hhcmVkU2VjcmV0Iiwib3RoZXIiLCJwdWJLZXkiLCJnZXRTaGFyZWRTZWNyZXQiLCJrZXkiLCJjb21wcmVzc2VkIiwiYnl0ZXMiLCJsZW5ndGgiLCJnZXRQdWJsaWNLZXkiLCJwdWIiLCJVaW50OEFycmF5Iiwic2V0IiwicG9pbnQiLCJQcm9qZWN0aXZlUG9pbnQiLCJmcm9tSGV4IiwidG9SYXdCeXRlcyIsInJlY292ZXJQdWJsaWNLZXkiLCJzaWduYXR1cmUiLCJzZWNwU2lnIiwiZnJvbUNvbXBhY3QiLCJhZGRSZWNvdmVyeUJpdCIsInlQYXJpdHkiLCJ0b0hleCIsImFkZFBvaW50cyIsInAwIiwicDEiLCJwdWIwIiwic3Vic3RyaW5nIiwicHViMSIsImFkZCIsImNvbnN0cnVjdG9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/crypto/signing-key.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/hash/id.js":
/*!************************************************!*\
  !*** ./node_modules/ethers/lib.esm/hash/id.js ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   id: function() { return /* binding */ id; }\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../crypto/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n\n\n/**\n *  A simple hashing function which operates on UTF-8 strings to\n *  compute an 32-byte identifier.\n *\n *  This simply computes the [UTF-8 bytes](toUtf8Bytes) and computes\n *  the [[keccak256]].\n *\n *  @example:\n *    id(\"hello world\")\n *    //_result:\n */ function id(value) {\n    return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_0__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toUtf8Bytes)(value));\n} //# sourceMappingURL=id.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9oYXNoL2lkLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUErQztBQUNDO0FBQ2hEOzs7Ozs7Ozs7O0NBVUMsR0FDTSxTQUFTRSxHQUFHQyxLQUFLO0lBQ3BCLE9BQU9ILDJEQUFTQSxDQUFDQyw0REFBV0EsQ0FBQ0U7QUFDakMsRUFDQSw4QkFBOEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2hhc2gvaWQuanM/NTQ1MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG5pbXBvcnQgeyB0b1V0ZjhCeXRlcyB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuLyoqXG4gKiAgQSBzaW1wbGUgaGFzaGluZyBmdW5jdGlvbiB3aGljaCBvcGVyYXRlcyBvbiBVVEYtOCBzdHJpbmdzIHRvXG4gKiAgY29tcHV0ZSBhbiAzMi1ieXRlIGlkZW50aWZpZXIuXG4gKlxuICogIFRoaXMgc2ltcGx5IGNvbXB1dGVzIHRoZSBbVVRGLTggYnl0ZXNdKHRvVXRmOEJ5dGVzKSBhbmQgY29tcHV0ZXNcbiAqICB0aGUgW1trZWNjYWsyNTZdXS5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICBpZChcImhlbGxvIHdvcmxkXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZCh2YWx1ZSkge1xuICAgIHJldHVybiBrZWNjYWsyNTYodG9VdGY4Qnl0ZXModmFsdWUpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlkLmpzLm1hcCJdLCJuYW1lcyI6WyJrZWNjYWsyNTYiLCJ0b1V0ZjhCeXRlcyIsImlkIiwidmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/hash/id.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/hash/namehash.js":
/*!******************************************************!*\
  !*** ./node_modules/ethers/lib.esm/hash/namehash.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dnsEncode: function() { return /* binding */ dnsEncode; },\n/* harmony export */   ensNormalize: function() { return /* binding */ ensNormalize; },\n/* harmony export */   isValidName: function() { return /* binding */ isValidName; },\n/* harmony export */   namehash: function() { return /* binding */ namehash; }\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../crypto/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _adraffy_ens_normalize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @adraffy/ens-normalize */ \"(app-pages-browser)/./node_modules/@adraffy/ens-normalize/dist/index.mjs\");\n\n\n\nconst Zeros = new Uint8Array(32);\nZeros.fill(0);\nfunction checkComponent(comp) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(comp.length !== 0, \"invalid ENS name; empty component\", \"comp\", comp);\n    return comp;\n}\nfunction ensNameSplit(name) {\n    const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.toUtf8Bytes)(ensNormalize(name));\n    const comps = [];\n    if (name.length === 0) {\n        return comps;\n    }\n    let last = 0;\n    for(let i = 0; i < bytes.length; i++){\n        const d = bytes[i];\n        // A separator (i.e. \".\"); copy this component\n        if (d === 0x2e) {\n            comps.push(checkComponent(bytes.slice(last, i)));\n            last = i + 1;\n        }\n    }\n    // There was a stray separator at the end of the name\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(last < bytes.length, \"invalid ENS name; empty component\", \"name\", name);\n    comps.push(checkComponent(bytes.slice(last)));\n    return comps;\n}\n/**\n *  Returns the ENS %%name%% normalized.\n */ function ensNormalize(name) {\n    try {\n        if (name.length === 0) {\n            throw new Error(\"empty label\");\n        }\n        return (0,_adraffy_ens_normalize__WEBPACK_IMPORTED_MODULE_0__.ens_normalize)(name);\n    } catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid ENS name (\".concat(error.message, \")\"), \"name\", name);\n    }\n}\n/**\n *  Returns ``true`` if %%name%% is a valid ENS name.\n */ function isValidName(name) {\n    try {\n        return ensNameSplit(name).length !== 0;\n    } catch (error) {}\n    return false;\n}\n/**\n *  Returns the [[link-namehash]] for %%name%%.\n */ function namehash(name) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(typeof name === \"string\", \"invalid ENS name; not a string\", \"name\", name);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(name.length, \"invalid ENS name (empty label)\", \"name\", name);\n    let result = Zeros;\n    const comps = ensNameSplit(name);\n    while(comps.length){\n        result = (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.concat)([\n            result,\n            (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.keccak256)(comps.pop())\n        ]));\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.hexlify)(result);\n}\n/**\n *  Returns the DNS encoded %%name%%.\n *\n *  This is used for various parts of ENS name resolution, such\n *  as the wildcard resolution.\n */ function dnsEncode(name, _maxLength) {\n    const length = _maxLength != null ? _maxLength : 63;\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(length <= 255, \"DNS encoded label cannot exceed 255\", \"length\", length);\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.hexlify)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.concat)(ensNameSplit(name).map((comp)=>{\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(comp.length <= length, \"label \".concat(JSON.stringify(name), \" exceeds \").concat(length, \" bytes\"), \"name\", name);\n        const bytes = new Uint8Array(comp.length + 1);\n        bytes.set(comp, 1);\n        bytes[0] = bytes.length - 1;\n        return bytes;\n    }))) + \"00\";\n} //# sourceMappingURL=namehash.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9oYXNoL25hbWVoYXNoLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUErQztBQUNrQztBQUMxQjtBQUN2RCxNQUFNTSxRQUFRLElBQUlDLFdBQVc7QUFDN0JELE1BQU1FLElBQUksQ0FBQztBQUNYLFNBQVNDLGVBQWVDLElBQUk7SUFDeEJQLCtEQUFjQSxDQUFDTyxLQUFLQyxNQUFNLEtBQUssR0FBRyxxQ0FBcUMsUUFBUUQ7SUFDL0UsT0FBT0E7QUFDWDtBQUNBLFNBQVNFLGFBQWFDLElBQUk7SUFDdEIsTUFBTUMsUUFBUVYsNERBQVdBLENBQUNXLGFBQWFGO0lBQ3ZDLE1BQU1HLFFBQVEsRUFBRTtJQUNoQixJQUFJSCxLQUFLRixNQUFNLEtBQUssR0FBRztRQUNuQixPQUFPSztJQUNYO0lBQ0EsSUFBSUMsT0FBTztJQUNYLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJSixNQUFNSCxNQUFNLEVBQUVPLElBQUs7UUFDbkMsTUFBTUMsSUFBSUwsS0FBSyxDQUFDSSxFQUFFO1FBQ2xCLDhDQUE4QztRQUM5QyxJQUFJQyxNQUFNLE1BQU07WUFDWkgsTUFBTUksSUFBSSxDQUFDWCxlQUFlSyxNQUFNTyxLQUFLLENBQUNKLE1BQU1DO1lBQzVDRCxPQUFPQyxJQUFJO1FBQ2Y7SUFDSjtJQUNBLHFEQUFxRDtJQUNyRGYsK0RBQWNBLENBQUNjLE9BQU9ILE1BQU1ILE1BQU0sRUFBRSxxQ0FBcUMsUUFBUUU7SUFDakZHLE1BQU1JLElBQUksQ0FBQ1gsZUFBZUssTUFBTU8sS0FBSyxDQUFDSjtJQUN0QyxPQUFPRDtBQUNYO0FBQ0E7O0NBRUMsR0FDTSxTQUFTRCxhQUFhRixJQUFJO0lBQzdCLElBQUk7UUFDQSxJQUFJQSxLQUFLRixNQUFNLEtBQUssR0FBRztZQUNuQixNQUFNLElBQUlXLE1BQU07UUFDcEI7UUFDQSxPQUFPakIscUVBQWFBLENBQUNRO0lBQ3pCLEVBQ0EsT0FBT1UsT0FBTztRQUNWcEIsK0RBQWNBLENBQUMsT0FBTyxxQkFBbUMsT0FBZG9CLE1BQU1DLE9BQU8sRUFBQyxNQUFJLFFBQVFYO0lBQ3pFO0FBQ0o7QUFDQTs7Q0FFQyxHQUNNLFNBQVNZLFlBQVlaLElBQUk7SUFDNUIsSUFBSTtRQUNBLE9BQVFELGFBQWFDLE1BQU1GLE1BQU0sS0FBSztJQUMxQyxFQUNBLE9BQU9ZLE9BQU8sQ0FBRTtJQUNoQixPQUFPO0FBQ1g7QUFDQTs7Q0FFQyxHQUNNLFNBQVNHLFNBQVNiLElBQUk7SUFDekJWLCtEQUFjQSxDQUFDLE9BQVFVLFNBQVUsVUFBVSxrQ0FBa0MsUUFBUUE7SUFDckZWLCtEQUFjQSxDQUFDVSxLQUFLRixNQUFNLEVBQUcsa0NBQWlDLFFBQVFFO0lBQ3RFLElBQUljLFNBQVNyQjtJQUNiLE1BQU1VLFFBQVFKLGFBQWFDO0lBQzNCLE1BQU9HLE1BQU1MLE1BQU0sQ0FBRTtRQUNqQmdCLFNBQVMzQiwyREFBU0EsQ0FBQ0MsdURBQU1BLENBQUM7WUFBQzBCO1lBQVEzQiwyREFBU0EsQ0FBRWdCLE1BQU1ZLEdBQUc7U0FBSztJQUNoRTtJQUNBLE9BQU8xQix3REFBT0EsQ0FBQ3lCO0FBQ25CO0FBQ0E7Ozs7O0NBS0MsR0FDTSxTQUFTRSxVQUFVaEIsSUFBSSxFQUFFaUIsVUFBVTtJQUN0QyxNQUFNbkIsU0FBUyxjQUFlLE9BQVFtQixhQUFhO0lBQ25EM0IsK0RBQWNBLENBQUNRLFVBQVUsS0FBSyx1Q0FBdUMsVUFBVUE7SUFDL0UsT0FBT1Qsd0RBQU9BLENBQUNELHVEQUFNQSxDQUFDVyxhQUFhQyxNQUFNa0IsR0FBRyxDQUFDLENBQUNyQjtRQUMxQ1AsK0RBQWNBLENBQUNPLEtBQUtDLE1BQU0sSUFBSUEsUUFBUSxTQUF5Q0EsT0FBaENxQixLQUFLQyxTQUFTLENBQUNwQixPQUFNLGFBQWtCLE9BQVBGLFFBQU8sV0FBUyxRQUFRRTtRQUN2RyxNQUFNQyxRQUFRLElBQUlQLFdBQVdHLEtBQUtDLE1BQU0sR0FBRztRQUMzQ0csTUFBTW9CLEdBQUcsQ0FBQ3hCLE1BQU07UUFDaEJJLEtBQUssQ0FBQyxFQUFFLEdBQUdBLE1BQU1ILE1BQU0sR0FBRztRQUMxQixPQUFPRztJQUNYLE9BQU87QUFDWCxFQUNBLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vaGFzaC9uYW1laGFzaC5qcz9lNTA4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbmltcG9ydCB7IGNvbmNhdCwgaGV4bGlmeSwgYXNzZXJ0QXJndW1lbnQsIHRvVXRmOEJ5dGVzIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBlbnNfbm9ybWFsaXplIH0gZnJvbSBcIkBhZHJhZmZ5L2Vucy1ub3JtYWxpemVcIjtcbmNvbnN0IFplcm9zID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuWmVyb3MuZmlsbCgwKTtcbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50KGNvbXApIHtcbiAgICBhc3NlcnRBcmd1bWVudChjb21wLmxlbmd0aCAhPT0gMCwgXCJpbnZhbGlkIEVOUyBuYW1lOyBlbXB0eSBjb21wb25lbnRcIiwgXCJjb21wXCIsIGNvbXApO1xuICAgIHJldHVybiBjb21wO1xufVxuZnVuY3Rpb24gZW5zTmFtZVNwbGl0KG5hbWUpIHtcbiAgICBjb25zdCBieXRlcyA9IHRvVXRmOEJ5dGVzKGVuc05vcm1hbGl6ZShuYW1lKSk7XG4gICAgY29uc3QgY29tcHMgPSBbXTtcbiAgICBpZiAobmFtZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGNvbXBzO1xuICAgIH1cbiAgICBsZXQgbGFzdCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBkID0gYnl0ZXNbaV07XG4gICAgICAgIC8vIEEgc2VwYXJhdG9yIChpLmUuIFwiLlwiKTsgY29weSB0aGlzIGNvbXBvbmVudFxuICAgICAgICBpZiAoZCA9PT0gMHgyZSkge1xuICAgICAgICAgICAgY29tcHMucHVzaChjaGVja0NvbXBvbmVudChieXRlcy5zbGljZShsYXN0LCBpKSkpO1xuICAgICAgICAgICAgbGFzdCA9IGkgKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRoZXJlIHdhcyBhIHN0cmF5IHNlcGFyYXRvciBhdCB0aGUgZW5kIG9mIHRoZSBuYW1lXG4gICAgYXNzZXJ0QXJndW1lbnQobGFzdCA8IGJ5dGVzLmxlbmd0aCwgXCJpbnZhbGlkIEVOUyBuYW1lOyBlbXB0eSBjb21wb25lbnRcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgIGNvbXBzLnB1c2goY2hlY2tDb21wb25lbnQoYnl0ZXMuc2xpY2UobGFzdCkpKTtcbiAgICByZXR1cm4gY29tcHM7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSBFTlMgJSVuYW1lJSUgbm9ybWFsaXplZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuc05vcm1hbGl6ZShuYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKG5hbWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbXB0eSBsYWJlbFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5zX25vcm1hbGl6ZShuYW1lKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgaW52YWxpZCBFTlMgbmFtZSAoJHtlcnJvci5tZXNzYWdlfSlgLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgfVxufVxuLyoqXG4gKiAgUmV0dXJucyBgYHRydWVgYCBpZiAlJW5hbWUlJSBpcyBhIHZhbGlkIEVOUyBuYW1lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZE5hbWUobmFtZSkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAoZW5zTmFtZVNwbGl0KG5hbWUpLmxlbmd0aCAhPT0gMCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgW1tsaW5rLW5hbWVoYXNoXV0gZm9yICUlbmFtZSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbmFtZWhhc2gobmFtZSkge1xuICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAobmFtZSkgPT09IFwic3RyaW5nXCIsIFwiaW52YWxpZCBFTlMgbmFtZTsgbm90IGEgc3RyaW5nXCIsIFwibmFtZVwiLCBuYW1lKTtcbiAgICBhc3NlcnRBcmd1bWVudChuYW1lLmxlbmd0aCwgYGludmFsaWQgRU5TIG5hbWUgKGVtcHR5IGxhYmVsKWAsIFwibmFtZVwiLCBuYW1lKTtcbiAgICBsZXQgcmVzdWx0ID0gWmVyb3M7XG4gICAgY29uc3QgY29tcHMgPSBlbnNOYW1lU3BsaXQobmFtZSk7XG4gICAgd2hpbGUgKGNvbXBzLmxlbmd0aCkge1xuICAgICAgICByZXN1bHQgPSBrZWNjYWsyNTYoY29uY2F0KFtyZXN1bHQsIGtlY2NhazI1NigoY29tcHMucG9wKCkpKV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleGxpZnkocmVzdWx0KTtcbn1cbi8qKlxuICogIFJldHVybnMgdGhlIEROUyBlbmNvZGVkICUlbmFtZSUlLlxuICpcbiAqICBUaGlzIGlzIHVzZWQgZm9yIHZhcmlvdXMgcGFydHMgb2YgRU5TIG5hbWUgcmVzb2x1dGlvbiwgc3VjaFxuICogIGFzIHRoZSB3aWxkY2FyZCByZXNvbHV0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZG5zRW5jb2RlKG5hbWUsIF9tYXhMZW5ndGgpIHtcbiAgICBjb25zdCBsZW5ndGggPSAoX21heExlbmd0aCAhPSBudWxsKSA/IF9tYXhMZW5ndGggOiA2MztcbiAgICBhc3NlcnRBcmd1bWVudChsZW5ndGggPD0gMjU1LCBcIkROUyBlbmNvZGVkIGxhYmVsIGNhbm5vdCBleGNlZWQgMjU1XCIsIFwibGVuZ3RoXCIsIGxlbmd0aCk7XG4gICAgcmV0dXJuIGhleGxpZnkoY29uY2F0KGVuc05hbWVTcGxpdChuYW1lKS5tYXAoKGNvbXApID0+IHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoY29tcC5sZW5ndGggPD0gbGVuZ3RoLCBgbGFiZWwgJHtKU09OLnN0cmluZ2lmeShuYW1lKX0gZXhjZWVkcyAke2xlbmd0aH0gYnl0ZXNgLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoY29tcC5sZW5ndGggKyAxKTtcbiAgICAgICAgYnl0ZXMuc2V0KGNvbXAsIDEpO1xuICAgICAgICBieXRlc1swXSA9IGJ5dGVzLmxlbmd0aCAtIDE7XG4gICAgICAgIHJldHVybiBieXRlcztcbiAgICB9KSkpICsgXCIwMFwiO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmFtZWhhc2guanMubWFwIl0sIm5hbWVzIjpbImtlY2NhazI1NiIsImNvbmNhdCIsImhleGxpZnkiLCJhc3NlcnRBcmd1bWVudCIsInRvVXRmOEJ5dGVzIiwiZW5zX25vcm1hbGl6ZSIsIlplcm9zIiwiVWludDhBcnJheSIsImZpbGwiLCJjaGVja0NvbXBvbmVudCIsImNvbXAiLCJsZW5ndGgiLCJlbnNOYW1lU3BsaXQiLCJuYW1lIiwiYnl0ZXMiLCJlbnNOb3JtYWxpemUiLCJjb21wcyIsImxhc3QiLCJpIiwiZCIsInB1c2giLCJzbGljZSIsIkVycm9yIiwiZXJyb3IiLCJtZXNzYWdlIiwiaXNWYWxpZE5hbWUiLCJuYW1laGFzaCIsInJlc3VsdCIsInBvcCIsImRuc0VuY29kZSIsIl9tYXhMZW5ndGgiLCJtYXAiLCJKU09OIiwic3RyaW5naWZ5Iiwic2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/hash/namehash.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/hash/typed-data.js":
/*!********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/hash/typed-data.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TypedDataEncoder: function() { return /* binding */ TypedDataEncoder; },\n/* harmony export */   verifyTypedData: function() { return /* binding */ verifyTypedData; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_get */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_get.js\");\n/* harmony import */ var _swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_init */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_init.js\");\n/* harmony import */ var _swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_set */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_set.js\");\n/* harmony import */ var _swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @swc/helpers/_/_class_private_method_get */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_method_get.js\");\n/* harmony import */ var _swc_helpers_class_private_method_init__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @swc/helpers/_/_class_private_method_init */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_method_init.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../address/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../crypto/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../transaction/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/transaction/address.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _id_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./id.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/hash/id.js\");\n//import { TypedDataDomain, TypedDataField } from \"@ethersproject/providerabstract-signer\";\n\n\n\n\n\n\n\n\n\n\nconst padding = new Uint8Array(32);\npadding.fill(0);\nconst BN__1 = BigInt(-1);\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_MAX_UINT256 = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n;\n;\nfunction hexPadRight(value) {\n    const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(value);\n    const padOffset = bytes.length % 32;\n    if (padOffset) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n            bytes,\n            padding.slice(padOffset)\n        ]);\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes);\n}\nconst hexTrue = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toBeHex)(BN_1, 32);\nconst hexFalse = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toBeHex)(BN_0, 32);\nconst domainFieldTypes = {\n    name: \"string\",\n    version: \"string\",\n    chainId: \"uint256\",\n    verifyingContract: \"address\",\n    salt: \"bytes32\"\n};\nconst domainFieldNames = [\n    \"name\",\n    \"version\",\n    \"chainId\",\n    \"verifyingContract\",\n    \"salt\"\n];\nfunction checkString(key) {\n    return function(value) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(typeof value === \"string\", \"invalid domain value for \".concat(JSON.stringify(key)), \"domain.\".concat(key), value);\n        return value;\n    };\n}\nconst domainChecks = {\n    name: checkString(\"name\"),\n    version: checkString(\"version\"),\n    chainId: function(_value) {\n        const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(_value, \"domain.chainId\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(value >= 0, \"invalid chain ID\", \"domain.chainId\", _value);\n        if (Number.isSafeInteger(value)) {\n            return Number(value);\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toQuantity)(value);\n    },\n    verifyingContract: function(value) {\n        try {\n            return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_3__.getAddress)(value).toLowerCase();\n        } catch (error) {}\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, 'invalid domain value \"verifyingContract\"', \"domain.verifyingContract\", value);\n    },\n    salt: function(value) {\n        const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(value, \"domain.salt\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(bytes.length === 32, 'invalid domain value \"salt\"', \"domain.salt\", value);\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes);\n    }\n};\nfunction getBaseEncoder(type) {\n    // intXX and uintXX\n    {\n        const match = type.match(/^(u?)int(\\d+)$/);\n        if (match) {\n            const signed = match[1] === \"\";\n            const width = parseInt(match[2]);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(width % 8 === 0 && width !== 0 && width <= 256 && match[2] === String(width), \"invalid numeric width\", \"type\", type);\n            const boundsUpper = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.mask)(BN_MAX_UINT256, signed ? width - 1 : width);\n            const boundsLower = signed ? (boundsUpper + BN_1) * BN__1 : BN_0;\n            return function(_value) {\n                const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(_value, \"value\");\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(value >= boundsLower && value <= boundsUpper, \"value out-of-bounds for \".concat(type), \"value\", value);\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toBeHex)(signed ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toTwos)(value, 256) : value, 32);\n            };\n        }\n    }\n    // bytesXX\n    {\n        const match = type.match(/^bytes(\\d+)$/);\n        if (match) {\n            const width = parseInt(match[1]);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(width !== 0 && width <= 32 && match[1] === String(width), \"invalid bytes width\", \"type\", type);\n            return function(value) {\n                const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(value);\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(bytes.length === width, \"invalid length for \".concat(type), \"value\", value);\n                return hexPadRight(value);\n            };\n        }\n    }\n    switch(type){\n        case \"address\":\n            return function(value) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)((0,_address_index_js__WEBPACK_IMPORTED_MODULE_3__.getAddress)(value), 32);\n            };\n        case \"bool\":\n            return function(value) {\n                return !value ? hexFalse : hexTrue;\n            };\n        case \"bytes\":\n            return function(value) {\n                return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_4__.keccak256)(value);\n            };\n        case \"string\":\n            return function(value) {\n                return (0,_id_js__WEBPACK_IMPORTED_MODULE_5__.id)(value);\n            };\n    }\n    return null;\n}\nfunction encodeType(name, fields) {\n    return \"\".concat(name, \"(\").concat(fields.map((param)=>{\n        let { name, type } = param;\n        return type + \" \" + name;\n    }).join(\",\"), \")\");\n}\n// foo[][3] => { base: \"foo\", index: \"[][3]\", array: {\n//     base: \"foo\", prefix: \"foo[]\", count: 3 } }\nfunction splitArray(type) {\n    const match = type.match(/^([^\\x5b]*)((\\x5b\\d*\\x5d)*)(\\x5b(\\d*)\\x5d)$/);\n    if (match) {\n        return {\n            base: match[1],\n            index: match[2] + match[4],\n            array: {\n                base: match[1],\n                prefix: match[1] + match[2],\n                count: match[5] ? parseInt(match[5]) : -1\n            }\n        };\n    }\n    return {\n        base: type\n    };\n}\nvar _types = /*#__PURE__*/ new WeakMap(), _fullTypes = /*#__PURE__*/ new WeakMap(), _encoderCache = /*#__PURE__*/ new WeakMap(), _getEncoder = /*#__PURE__*/ new WeakSet();\n/**\n *  A **TypedDataEncode** prepares and encodes [[link-eip-712]] payloads\n *  for signed typed data.\n *\n *  This is useful for those that wish to compute various components of a\n *  typed data hash, primary types, or sub-components, but generally the\n *  higher level [[Signer-signTypedData]] is more useful.\n */ class TypedDataEncoder {\n    /**\n     *  The types.\n     */ get types() {\n        return JSON.parse((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_6__._)(this, _types));\n    }\n    /**\n     *  Returnthe encoder for the specific %%type%%.\n     */ getEncoder(type) {\n        let encoder = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_6__._)(this, _encoderCache).get(type);\n        if (!encoder) {\n            encoder = (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_7__._)(this, _getEncoder, getEncoder).call(this, type);\n            (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_6__._)(this, _encoderCache).set(type, encoder);\n        }\n        return encoder;\n    }\n    /**\n     *  Return the full type for %%name%%.\n     */ encodeType(name) {\n        const result = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_6__._)(this, _fullTypes).get(name);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(result, \"unknown type: \".concat(JSON.stringify(name)), \"name\", name);\n        return result;\n    }\n    /**\n     *  Return the encoded %%value%% for the %%type%%.\n     */ encodeData(type, value) {\n        return this.getEncoder(type)(value);\n    }\n    /**\n     *  Returns the hash of %%value%% for the type of %%name%%.\n     */ hashStruct(name, value) {\n        return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_4__.keccak256)(this.encodeData(name, value));\n    }\n    /**\n     *  Return the fulled encoded %%value%% for the [[types]].\n     */ encode(value) {\n        return this.encodeData(this.primaryType, value);\n    }\n    /**\n     *  Return the hash of the fully encoded %%value%% for the [[types]].\n     */ hash(value) {\n        return this.hashStruct(this.primaryType, value);\n    }\n    /**\n     *  @_ignore:\n     */ _visit(type, value, callback) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return callback(type, value);\n            }\n        }\n        // Array\n        const array = splitArray(type).array;\n        if (array) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(array.count === -1 || array.count === value.length, \"array length mismatch; expected length \".concat(array.count), \"value\", value);\n            return value.map((v)=>this._visit(array.prefix, v, callback));\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            return fields.reduce((accum, param)=>{\n                let { name, type } = param;\n                accum[name] = this._visit(type, value[name], callback);\n                return accum;\n            }, {});\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, \"unknown type: \".concat(type), \"type\", type);\n    }\n    /**\n     *  Call %%calback%% for each value in %%value%%, passing the type and\n     *  component within %%value%%.\n     *\n     *  This is useful for replacing addresses or other transformation that\n     *  may be desired on each component, based on its type.\n     */ visit(value, callback) {\n        return this._visit(this.primaryType, value, callback);\n    }\n    /**\n     *  Create a new **TypedDataEncoder** for %%types%%.\n     */ static from(types) {\n        return new TypedDataEncoder(types);\n    }\n    /**\n     *  Return the primary type for %%types%%.\n     */ static getPrimaryType(types) {\n        return TypedDataEncoder.from(types).primaryType;\n    }\n    /**\n     *  Return the hashed struct for %%value%% using %%types%% and %%name%%.\n     */ static hashStruct(name, types, value) {\n        return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n    /**\n     *  Return the domain hash for %%domain%%.\n     */ static hashDomain(domain) {\n        const domainFields = [];\n        for(const name in domain){\n            if (domain[name] == null) {\n                continue;\n            }\n            const type = domainFieldTypes[name];\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(type, \"invalid typed-data domain key: \".concat(JSON.stringify(name)), \"domain\", domain);\n            domainFields.push({\n                name,\n                type\n            });\n        }\n        domainFields.sort((a, b)=>{\n            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n        });\n        return TypedDataEncoder.hashStruct(\"EIP712Domain\", {\n            EIP712Domain: domainFields\n        }, domain);\n    }\n    /**\n     *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.\n     */ static encode(domain, types, value) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n            \"0x1901\",\n            TypedDataEncoder.hashDomain(domain),\n            TypedDataEncoder.from(types).hash(value)\n        ]);\n    }\n    /**\n     *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.\n     */ static hash(domain, types, value) {\n        return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_4__.keccak256)(TypedDataEncoder.encode(domain, types, value));\n    }\n    // Replaces all address types with ENS names with their looked up address\n    /**\n     * Resolves to the value from resolving all addresses in %%value%% for\n     * %%types%% and the %%domain%%.\n     */ static async resolveNames(domain, types, value, resolveName) {\n        // Make a copy to isolate it from the object passed in\n        domain = Object.assign({}, domain);\n        // Allow passing null to ignore value\n        for(const key in domain){\n            if (domain[key] == null) {\n                delete domain[key];\n            }\n        }\n        // Look up all ENS names\n        const ensCache = {};\n        // Do we need to look up the domain's verifyingContract?\n        if (domain.verifyingContract && !(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(domain.verifyingContract, 20)) {\n            ensCache[domain.verifyingContract] = \"0x\";\n        }\n        // We are going to use the encoder to visit all the base values\n        const encoder = TypedDataEncoder.from(types);\n        // Get a list of all the addresses\n        encoder.visit(value, (type, value)=>{\n            if (type === \"address\" && !(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(value, 20)) {\n                ensCache[value] = \"0x\";\n            }\n            return value;\n        });\n        // Lookup each name\n        for(const name in ensCache){\n            ensCache[name] = await resolveName(name);\n        }\n        // Replace the domain verifyingContract if needed\n        if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n            domain.verifyingContract = ensCache[domain.verifyingContract];\n        }\n        // Replace all ENS names with their address\n        value = encoder.visit(value, (type, value)=>{\n            if (type === \"address\" && ensCache[value]) {\n                return ensCache[value];\n            }\n            return value;\n        });\n        return {\n            domain,\n            value\n        };\n    }\n    /**\n     *  Returns the JSON-encoded payload expected by nodes which implement\n     *  the JSON-RPC [[link-eip-712]] method.\n     */ static getPayload(domain, types, value) {\n        // Validate the domain fields\n        TypedDataEncoder.hashDomain(domain);\n        // Derive the EIP712Domain Struct reference type\n        const domainValues = {};\n        const domainTypes = [];\n        domainFieldNames.forEach((name)=>{\n            const value = domain[name];\n            if (value == null) {\n                return;\n            }\n            domainValues[name] = domainChecks[name](value);\n            domainTypes.push({\n                name,\n                type: domainFieldTypes[name]\n            });\n        });\n        const encoder = TypedDataEncoder.from(types);\n        // Get the normalized types\n        types = encoder.types;\n        const typesWithDomain = Object.assign({}, types);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(typesWithDomain.EIP712Domain == null, \"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n        typesWithDomain.EIP712Domain = domainTypes;\n        // Validate the data structures and types\n        encoder.encode(value);\n        return {\n            types: typesWithDomain,\n            domain: domainValues,\n            primaryType: encoder.primaryType,\n            message: encoder.visit(value, (type, value)=>{\n                // bytes\n                if (type.match(/^bytes(\\d*)/)) {\n                    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(value));\n                }\n                // uint or int\n                if (type.match(/^u?int/)) {\n                    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(value).toString();\n                }\n                switch(type){\n                    case \"address\":\n                        return value.toLowerCase();\n                    case \"bool\":\n                        return !!value;\n                    case \"string\":\n                        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(typeof value === \"string\", \"invalid string\", \"value\", value);\n                        return value;\n                }\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, \"unsupported type\", \"type\", type);\n            })\n        };\n    }\n    /**\n     *  Create a new **TypedDataEncoder** for %%types%%.\n     *\n     *  This performs all necessary checking that types are valid and\n     *  do not violate the [[link-eip-712]] structural constraints as\n     *  well as computes the [[primaryType]].\n     */ constructor(_types1){\n        (0,_swc_helpers_class_private_method_init__WEBPACK_IMPORTED_MODULE_8__._)(this, _getEncoder);\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_9__._)(this, _types, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_9__._)(this, _fullTypes, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_9__._)(this, _encoderCache, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_10__._)(this, _fullTypes, new Map());\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_10__._)(this, _encoderCache, new Map());\n        // Link struct types to their direct child structs\n        const links = new Map();\n        // Link structs to structs which contain them as a child\n        const parents = new Map();\n        // Link all subtypes within a given struct\n        const subtypes = new Map();\n        const types = {};\n        Object.keys(_types1).forEach((type)=>{\n            types[type] = _types1[type].map((param)=>{\n                let { name, type } = param;\n                // Normalize the base type (unless name conflict)\n                let { base, index } = splitArray(type);\n                if (base === \"int\" && !_types1[\"int\"]) {\n                    base = \"int256\";\n                }\n                if (base === \"uint\" && !_types1[\"uint\"]) {\n                    base = \"uint256\";\n                }\n                return {\n                    name,\n                    type: base + (index || \"\")\n                };\n            });\n            links.set(type, new Set());\n            parents.set(type, []);\n            subtypes.set(type, new Set());\n        });\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_10__._)(this, _types, JSON.stringify(types));\n        for(const name in types){\n            const uniqueNames = new Set();\n            for (const field of types[name]){\n                // Check each field has a unique name\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(!uniqueNames.has(field.name), \"duplicate variable name \".concat(JSON.stringify(field.name), \" in \").concat(JSON.stringify(name)), \"types\", _types1);\n                uniqueNames.add(field.name);\n                // Get the base type (drop any array specifiers)\n                const baseType = splitArray(field.type).base;\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(baseType !== name, \"circular type reference to \".concat(JSON.stringify(baseType)), \"types\", _types1);\n                // Is this a base encoding type?\n                const encoder = getBaseEncoder(baseType);\n                if (encoder) {\n                    continue;\n                }\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(parents.has(baseType), \"unknown type \".concat(JSON.stringify(baseType)), \"types\", _types1);\n                // Add linkage\n                parents.get(baseType).push(name);\n                links.get(name).add(baseType);\n            }\n        }\n        // Deduce the primary type\n        const primaryTypes = Array.from(parents.keys()).filter((n)=>parents.get(n).length === 0);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(primaryTypes.length !== 0, \"missing primary type\", \"types\", _types1);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(primaryTypes.length === 1, \"ambiguous primary types or unused types: \".concat(primaryTypes.map((t)=>JSON.stringify(t)).join(\", \")), \"types\", _types1);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_11__.defineProperties)(this, {\n            primaryType: primaryTypes[0]\n        });\n        // Check for circular type references\n        function checkCircular(type, found) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(!found.has(type), \"circular type reference to \".concat(JSON.stringify(type)), \"types\", _types1);\n            found.add(type);\n            for (const child of links.get(type)){\n                if (!parents.has(child)) {\n                    continue;\n                }\n                // Recursively check children\n                checkCircular(child, found);\n                // Mark all ancestors as having this decendant\n                for (const subtype of found){\n                    subtypes.get(subtype).add(child);\n                }\n            }\n            found.delete(type);\n        }\n        checkCircular(this.primaryType, new Set());\n        // Compute each fully describe type\n        for (const [name, set] of subtypes){\n            const st = Array.from(set);\n            st.sort();\n            (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_6__._)(this, _fullTypes).set(name, encodeType(name, types[name]) + st.map((t)=>encodeType(t, types[t])).join(\"\"));\n        }\n    }\n}\nfunction getEncoder(type) {\n    // Basic encoder type (address, bool, uint256, etc)\n    {\n        const encoder = getBaseEncoder(type);\n        if (encoder) {\n            return encoder;\n        }\n    }\n    // Array\n    const array = splitArray(type).array;\n    if (array) {\n        const subtype = array.prefix;\n        const subEncoder = this.getEncoder(subtype);\n        return (value)=>{\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(array.count === -1 || array.count === value.length, \"array length mismatch; expected length \".concat(array.count), \"value\", value);\n            let result = value.map(subEncoder);\n            if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_6__._)(this, _fullTypes).has(subtype)) {\n                result = result.map(_crypto_index_js__WEBPACK_IMPORTED_MODULE_4__.keccak256);\n            }\n            return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_4__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)(result));\n        };\n    }\n    // Struct\n    const fields = this.types[type];\n    if (fields) {\n        const encodedType = (0,_id_js__WEBPACK_IMPORTED_MODULE_5__.id)((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_6__._)(this, _fullTypes).get(type));\n        return (value)=>{\n            const values = fields.map((param)=>{\n                let { name, type } = param;\n                const result = this.getEncoder(type)(value[name]);\n                if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_6__._)(this, _fullTypes).has(type)) {\n                    return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_4__.keccak256)(result);\n                }\n                return result;\n            });\n            values.unshift(encodedType);\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)(values);\n        };\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, \"unknown type: \".concat(type), \"type\", type);\n}\n/**\n *  Compute the address used to sign the typed data for the %%signature%%.\n */ function verifyTypedData(domain, types, value, signature) {\n    return (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_12__.recoverAddress)(TypedDataEncoder.hash(domain, types, value), signature);\n} //# sourceMappingURL=typed-data.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9oYXNoL3R5cGVkLWRhdGEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsMkZBQTJGOzs7Ozs7QUFDMUM7QUFDRjtBQUNVO0FBQ2dIO0FBQzVJO0FBQzdCLE1BQU1nQixVQUFVLElBQUlDLFdBQVc7QUFDL0JELFFBQVFFLElBQUksQ0FBQztBQUNiLE1BQU1DLFFBQVFDLE9BQU8sQ0FBQztBQUN0QixNQUFNQyxPQUFPRCxPQUFPO0FBQ3BCLE1BQU1FLE9BQU9GLE9BQU87QUFDcEIsTUFBTUcsaUJBQWlCSCxPQUFPOzs7QUFHOUIsU0FBU0ksWUFBWUMsS0FBSztJQUN0QixNQUFNQyxRQUFRcEIseURBQVFBLENBQUNtQjtJQUN2QixNQUFNRSxZQUFZRCxNQUFNRSxNQUFNLEdBQUc7SUFDakMsSUFBSUQsV0FBVztRQUNYLE9BQU94Qix1REFBTUEsQ0FBQztZQUFDdUI7WUFBT1YsUUFBUWEsS0FBSyxDQUFDRjtTQUFXO0lBQ25EO0lBQ0EsT0FBT3BCLHdEQUFPQSxDQUFDbUI7QUFDbkI7QUFDQSxNQUFNSSxVQUFVcEIsd0RBQU9BLENBQUNZLE1BQU07QUFDOUIsTUFBTVMsV0FBV3JCLHdEQUFPQSxDQUFDVyxNQUFNO0FBQy9CLE1BQU1XLG1CQUFtQjtJQUNyQkMsTUFBTTtJQUNOQyxTQUFTO0lBQ1RDLFNBQVM7SUFDVEMsbUJBQW1CO0lBQ25CQyxNQUFNO0FBQ1Y7QUFDQSxNQUFNQyxtQkFBbUI7SUFDckI7SUFBUTtJQUFXO0lBQVc7SUFBcUI7Q0FDdEQ7QUFDRCxTQUFTQyxZQUFZQyxHQUFHO0lBQ3BCLE9BQU8sU0FBVWYsS0FBSztRQUNsQlgsK0RBQWNBLENBQUMsT0FBUVcsVUFBVyxVQUFVLDRCQUFnRCxPQUFwQmdCLEtBQUtDLFNBQVMsQ0FBQ0YsT0FBUSxVQUFjLE9BQUpBLE1BQU9mO1FBQ2hILE9BQU9BO0lBQ1g7QUFDSjtBQUNBLE1BQU1rQixlQUFl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UixNQUFNOEUsY0FBYzFILDBDQUFFQSxDQUFDLDRFQUFJLEVBQUU4RCxZQUFVSCxHQUFHLENBQUN4QjtRQUMzQyxPQUFPLENBQUN6QjtZQUNKLE1BQU1pSCxTQUFTL0UsT0FBT0MsR0FBRyxDQUFDO29CQUFDLEVBQUUzQixJQUFJLEVBQUVpQixJQUFJLEVBQUU7Z0JBQ3JDLE1BQU0wQixTQUFTLElBQUksQ0FBQ0wsVUFBVSxDQUFDckIsTUFBTXpCLEtBQUssQ0FBQ1EsS0FBSztnQkFDaEQsSUFBSSw0RUFBSSxFQUFFNEMsWUFBVTZDLEdBQUcsQ0FBQ3hFLE9BQU87b0JBQzNCLE9BQU9qRCwyREFBU0EsQ0FBQzJFO2dCQUNyQjtnQkFDQSxPQUFPQTtZQUNYO1lBQ0E4RCxPQUFPQyxPQUFPLENBQUNGO1lBQ2YsT0FBT3RJLHVEQUFNQSxDQUFDdUk7UUFDbEI7SUFDSjtJQUNBNUgsK0RBQWNBLENBQUMsT0FBTyxpQkFBc0IsT0FBTG9DLE9BQVEsUUFBUUE7QUFDM0Q7QUE2Tko7O0NBRUMsR0FDTSxTQUFTMEYsZ0JBQWdCaEQsTUFBTSxFQUFFdkIsS0FBSyxFQUFFNUMsS0FBSyxFQUFFb0gsU0FBUztJQUMzRCxPQUFPM0ksc0VBQWNBLENBQUNrRSxpQkFBaUJjLElBQUksQ0FBQ1UsUUFBUXZCLE9BQU81QyxRQUFRb0g7QUFDdkUsRUFDQSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2hhc2gvdHlwZWQtZGF0YS5qcz8yMWU5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vaW1wb3J0IHsgVHlwZWREYXRhRG9tYWluLCBUeXBlZERhdGFGaWVsZCB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm92aWRlcmFic3RyYWN0LXNpZ25lclwiO1xuaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG5pbXBvcnQgeyByZWNvdmVyQWRkcmVzcyB9IGZyb20gXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY29uY2F0LCBkZWZpbmVQcm9wZXJ0aWVzLCBnZXRCaWdJbnQsIGdldEJ5dGVzLCBoZXhsaWZ5LCBpc0hleFN0cmluZywgbWFzaywgdG9CZUhleCwgdG9RdWFudGl0eSwgdG9Ud29zLCB6ZXJvUGFkVmFsdWUsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBpZCB9IGZyb20gXCIuL2lkLmpzXCI7XG5jb25zdCBwYWRkaW5nID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xucGFkZGluZy5maWxsKDApO1xuY29uc3QgQk5fXzEgPSBCaWdJbnQoLTEpO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmNvbnN0IEJOXzEgPSBCaWdJbnQoMSk7XG5jb25zdCBCTl9NQVhfVUlOVDI1NiA9IEJpZ0ludChcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlwiKTtcbjtcbjtcbmZ1bmN0aW9uIGhleFBhZFJpZ2h0KHZhbHVlKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyh2YWx1ZSk7XG4gICAgY29uc3QgcGFkT2Zmc2V0ID0gYnl0ZXMubGVuZ3RoICUgMzI7XG4gICAgaWYgKHBhZE9mZnNldCkge1xuICAgICAgICByZXR1cm4gY29uY2F0KFtieXRlcywgcGFkZGluZy5zbGljZShwYWRPZmZzZXQpXSk7XG4gICAgfVxuICAgIHJldHVybiBoZXhsaWZ5KGJ5dGVzKTtcbn1cbmNvbnN0IGhleFRydWUgPSB0b0JlSGV4KEJOXzEsIDMyKTtcbmNvbnN0IGhleEZhbHNlID0gdG9CZUhleChCTl8wLCAzMik7XG5jb25zdCBkb21haW5GaWVsZFR5cGVzID0ge1xuICAgIG5hbWU6IFwic3RyaW5nXCIsXG4gICAgdmVyc2lvbjogXCJzdHJpbmdcIixcbiAgICBjaGFpbklkOiBcInVpbnQyNTZcIixcbiAgICB2ZXJpZnlpbmdDb250cmFjdDogXCJhZGRyZXNzXCIsXG4gICAgc2FsdDogXCJieXRlczMyXCJcbn07XG5jb25zdCBkb21haW5GaWVsZE5hbWVzID0gW1xuICAgIFwibmFtZVwiLCBcInZlcnNpb25cIiwgXCJjaGFpbklkXCIsIFwidmVyaWZ5aW5nQ29udHJhY3RcIiwgXCJzYWx0XCJcbl07XG5mdW5jdGlvbiBjaGVja1N0cmluZyhrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiLCBgaW52YWxpZCBkb21haW4gdmFsdWUgZm9yICR7SlNPTi5zdHJpbmdpZnkoa2V5KX1gLCBgZG9tYWluLiR7a2V5fWAsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG59XG5jb25zdCBkb21haW5DaGVja3MgPSB7XG4gICAgbmFtZTogY2hlY2tTdHJpbmcoXCJuYW1lXCIpLFxuICAgIHZlcnNpb246IGNoZWNrU3RyaW5nKFwidmVyc2lvblwiKSxcbiAgICBjaGFpbklkOiBmdW5jdGlvbiAoX3ZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0QmlnSW50KF92YWx1ZSwgXCJkb21haW4uY2hhaW5JZFwiKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodmFsdWUgPj0gMCwgXCJpbnZhbGlkIGNoYWluIElEXCIsIFwiZG9tYWluLmNoYWluSWRcIiwgX3ZhbHVlKTtcbiAgICAgICAgaWYgKE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvUXVhbnRpdHkodmFsdWUpO1xuICAgIH0sXG4gICAgdmVyaWZ5aW5nQ29udHJhY3Q6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEFkZHJlc3ModmFsdWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBpbnZhbGlkIGRvbWFpbiB2YWx1ZSBcInZlcmlmeWluZ0NvbnRyYWN0XCJgLCBcImRvbWFpbi52ZXJpZnlpbmdDb250cmFjdFwiLCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzYWx0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyh2YWx1ZSwgXCJkb21haW4uc2FsdFwiKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoYnl0ZXMubGVuZ3RoID09PSAzMiwgYGludmFsaWQgZG9tYWluIHZhbHVlIFwic2FsdFwiYCwgXCJkb21haW4uc2FsdFwiLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KGJ5dGVzKTtcbiAgICB9XG59O1xuZnVuY3Rpb24gZ2V0QmFzZUVuY29kZXIodHlwZSkge1xuICAgIC8vIGludFhYIGFuZCB1aW50WFhcbiAgICB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaCgvXih1PylpbnQoXFxkKykkLyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgY29uc3Qgc2lnbmVkID0gKG1hdGNoWzFdID09PSBcIlwiKTtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gcGFyc2VJbnQobWF0Y2hbMl0pO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQod2lkdGggJSA4ID09PSAwICYmIHdpZHRoICE9PSAwICYmIHdpZHRoIDw9IDI1NiAmJiBtYXRjaFsyXSA9PT0gU3RyaW5nKHdpZHRoKSwgXCJpbnZhbGlkIG51bWVyaWMgd2lkdGhcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgICAgICAgICAgY29uc3QgYm91bmRzVXBwZXIgPSBtYXNrKEJOX01BWF9VSU5UMjU2LCBzaWduZWQgPyAod2lkdGggLSAxKSA6IHdpZHRoKTtcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kc0xvd2VyID0gc2lnbmVkID8gKChib3VuZHNVcHBlciArIEJOXzEpICogQk5fXzEpIDogQk5fMDtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoX3ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBnZXRCaWdJbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlID49IGJvdW5kc0xvd2VyICYmIHZhbHVlIDw9IGJvdW5kc1VwcGVyLCBgdmFsdWUgb3V0LW9mLWJvdW5kcyBmb3IgJHt0eXBlfWAsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b0JlSGV4KHNpZ25lZCA/IHRvVHdvcyh2YWx1ZSwgMjU2KSA6IHZhbHVlLCAzMik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGJ5dGVzWFhcbiAgICB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaCgvXmJ5dGVzKFxcZCspJC8pO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gcGFyc2VJbnQobWF0Y2hbMV0pO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQod2lkdGggIT09IDAgJiYgd2lkdGggPD0gMzIgJiYgbWF0Y2hbMV0gPT09IFN0cmluZyh3aWR0aCksIFwiaW52YWxpZCBieXRlcyB3aWR0aFwiLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoYnl0ZXMubGVuZ3RoID09PSB3aWR0aCwgYGludmFsaWQgbGVuZ3RoIGZvciAke3R5cGV9YCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhleFBhZFJpZ2h0KHZhbHVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJhZGRyZXNzXCI6IHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB6ZXJvUGFkVmFsdWUoZ2V0QWRkcmVzcyh2YWx1ZSksIDMyKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcImJvb2xcIjogcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICgoIXZhbHVlKSA/IGhleEZhbHNlIDogaGV4VHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJieXRlc1wiOiByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4ga2VjY2FrMjU2KHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOiByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQodmFsdWUpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGVuY29kZVR5cGUobmFtZSwgZmllbGRzKSB7XG4gICAgcmV0dXJuIGAke25hbWV9KCR7ZmllbGRzLm1hcCgoeyBuYW1lLCB0eXBlIH0pID0+ICh0eXBlICsgXCIgXCIgKyBuYW1lKSkuam9pbihcIixcIil9KWA7XG59XG4vLyBmb29bXVszXSA9PiB7IGJhc2U6IFwiZm9vXCIsIGluZGV4OiBcIltdWzNdXCIsIGFycmF5OiB7XG4vLyAgICAgYmFzZTogXCJmb29cIiwgcHJlZml4OiBcImZvb1tdXCIsIGNvdW50OiAzIH0gfVxuZnVuY3Rpb24gc3BsaXRBcnJheSh0eXBlKSB7XG4gICAgY29uc3QgbWF0Y2ggPSB0eXBlLm1hdGNoKC9eKFteXFx4NWJdKikoKFxceDViXFxkKlxceDVkKSopKFxceDViKFxcZCopXFx4NWQpJC8pO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYmFzZTogbWF0Y2hbMV0sXG4gICAgICAgICAgICBpbmRleDogKG1hdGNoWzJdICsgbWF0Y2hbNF0pLFxuICAgICAgICAgICAgYXJyYXk6IHtcbiAgICAgICAgICAgICAgICBiYXNlOiBtYXRjaFsxXSxcbiAgICAgICAgICAgICAgICBwcmVmaXg6IChtYXRjaFsxXSArIG1hdGNoWzJdKSxcbiAgICAgICAgICAgICAgICBjb3VudDogKG1hdGNoWzVdID8gcGFyc2VJbnQobWF0Y2hbNV0pIDogLTEpLFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4geyBiYXNlOiB0eXBlIH07XG59XG4vKipcbiAqICBBICoqVHlwZWREYXRhRW5jb2RlKiogcHJlcGFyZXMgYW5kIGVuY29kZXMgW1tsaW5rLWVpcC03MTJdXSBwYXlsb2Fkc1xuICogIGZvciBzaWduZWQgdHlwZWQgZGF0YS5cbiAqXG4gKiAgVGhpcyBpcyB1c2VmdWwgZm9yIHRob3NlIHRoYXQgd2lzaCB0byBjb21wdXRlIHZhcmlvdXMgY29tcG9uZW50cyBvZiBhXG4gKiAgdHlwZWQgZGF0YSBoYXNoLCBwcmltYXJ5IHR5cGVzLCBvciBzdWItY29tcG9uZW50cywgYnV0IGdlbmVyYWxseSB0aGVcbiAqICBoaWdoZXIgbGV2ZWwgW1tTaWduZXItc2lnblR5cGVkRGF0YV1dIGlzIG1vcmUgdXNlZnVsLlxuICovXG5leHBvcnQgY2xhc3MgVHlwZWREYXRhRW5jb2RlciB7XG4gICAgLyoqXG4gICAgICogIFRoZSBwcmltYXJ5IHR5cGUgZm9yIHRoZSBzdHJ1Y3R1cmVkIFtbdHlwZXNdXS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIGRlcml2ZWQgYXV0b21hdGljYWxseSBmcm9tIHRoZSBbW3R5cGVzXV0sIHNpbmNlIG5vXG4gICAgICogIHJlY3Vyc2lvbiBpcyBwb3NzaWJsZSwgb25jZSB0aGUgREFHIGZvciB0aGUgdHlwZXMgaXMgY29uc3R1cmN0ZWRcbiAgICAgKiAgaW50ZXJuYWxseSwgdGhlIHByaW1hcnkgdHlwZSBtdXN0IGJlIHRoZSBvbmx5IHJlbWFpbmluZyB0eXBlIHdpdGhcbiAgICAgKiAgbm8gcGFyZW50IG5vZGVzLlxuICAgICAqL1xuICAgIHByaW1hcnlUeXBlO1xuICAgICN0eXBlcztcbiAgICAvKipcbiAgICAgKiAgVGhlIHR5cGVzLlxuICAgICAqL1xuICAgIGdldCB0eXBlcygpIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGhpcy4jdHlwZXMpO1xuICAgIH1cbiAgICAjZnVsbFR5cGVzO1xuICAgICNlbmNvZGVyQ2FjaGU7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKlR5cGVkRGF0YUVuY29kZXIqKiBmb3IgJSV0eXBlcyUlLlxuICAgICAqXG4gICAgICogIFRoaXMgcGVyZm9ybXMgYWxsIG5lY2Vzc2FyeSBjaGVja2luZyB0aGF0IHR5cGVzIGFyZSB2YWxpZCBhbmRcbiAgICAgKiAgZG8gbm90IHZpb2xhdGUgdGhlIFtbbGluay1laXAtNzEyXV0gc3RydWN0dXJhbCBjb25zdHJhaW50cyBhc1xuICAgICAqICB3ZWxsIGFzIGNvbXB1dGVzIHRoZSBbW3ByaW1hcnlUeXBlXV0uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoX3R5cGVzKSB7XG4gICAgICAgIHRoaXMuI2Z1bGxUeXBlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jZW5jb2RlckNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBMaW5rIHN0cnVjdCB0eXBlcyB0byB0aGVpciBkaXJlY3QgY2hpbGQgc3RydWN0c1xuICAgICAgICBjb25zdCBsaW5rcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gTGluayBzdHJ1Y3RzIHRvIHN0cnVjdHMgd2hpY2ggY29udGFpbiB0aGVtIGFzIGEgY2hpbGRcbiAgICAgICAgY29uc3QgcGFyZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gTGluayBhbGwgc3VidHlwZXMgd2l0aGluIGEgZ2l2ZW4gc3RydWN0XG4gICAgICAgIGNvbnN0IHN1YnR5cGVzID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCB0eXBlcyA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhfdHlwZXMpLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICAgICAgICAgIHR5cGVzW3R5cGVdID0gX3R5cGVzW3R5cGVdLm1hcCgoeyBuYW1lLCB0eXBlIH0pID0+IHtcbiAgICAgICAgICAgICAgICAvLyBOb3JtYWxpemUgdGhlIGJhc2UgdHlwZSAodW5sZXNzIG5hbWUgY29uZmxpY3QpXG4gICAgICAgICAgICAgICAgbGV0IHsgYmFzZSwgaW5kZXggfSA9IHNwbGl0QXJyYXkodHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGJhc2UgPT09IFwiaW50XCIgJiYgIV90eXBlc1tcImludFwiXSkge1xuICAgICAgICAgICAgICAgICAgICBiYXNlID0gXCJpbnQyNTZcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJhc2UgPT09IFwidWludFwiICYmICFfdHlwZXNbXCJ1aW50XCJdKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2UgPSBcInVpbnQyNTZcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbmFtZSwgdHlwZTogKGJhc2UgKyAoaW5kZXggfHwgXCJcIikpIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxpbmtzLnNldCh0eXBlLCBuZXcgU2V0KCkpO1xuICAgICAgICAgICAgcGFyZW50cy5zZXQodHlwZSwgW10pO1xuICAgICAgICAgICAgc3VidHlwZXMuc2V0KHR5cGUsIG5ldyBTZXQoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiN0eXBlcyA9IEpTT04uc3RyaW5naWZ5KHR5cGVzKTtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIHR5cGVzKSB7XG4gICAgICAgICAgICBjb25zdCB1bmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgdHlwZXNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBlYWNoIGZpZWxkIGhhcyBhIHVuaXF1ZSBuYW1lXG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoIXVuaXF1ZU5hbWVzLmhhcyhmaWVsZC5uYW1lKSwgYGR1cGxpY2F0ZSB2YXJpYWJsZSBuYW1lICR7SlNPTi5zdHJpbmdpZnkoZmllbGQubmFtZSl9IGluICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9YCwgXCJ0eXBlc1wiLCBfdHlwZXMpO1xuICAgICAgICAgICAgICAgIHVuaXF1ZU5hbWVzLmFkZChmaWVsZC5uYW1lKTtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGJhc2UgdHlwZSAoZHJvcCBhbnkgYXJyYXkgc3BlY2lmaWVycylcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlVHlwZSA9IHNwbGl0QXJyYXkoZmllbGQudHlwZSkuYmFzZTtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChiYXNlVHlwZSAhPT0gbmFtZSwgYGNpcmN1bGFyIHR5cGUgcmVmZXJlbmNlIHRvICR7SlNPTi5zdHJpbmdpZnkoYmFzZVR5cGUpfWAsIFwidHlwZXNcIiwgX3R5cGVzKTtcbiAgICAgICAgICAgICAgICAvLyBJcyB0aGlzIGEgYmFzZSBlbmNvZGluZyB0eXBlP1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBnZXRCYXNlRW5jb2RlcihiYXNlVHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGVuY29kZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHBhcmVudHMuaGFzKGJhc2VUeXBlKSwgYHVua25vd24gdHlwZSAke0pTT04uc3RyaW5naWZ5KGJhc2VUeXBlKX1gLCBcInR5cGVzXCIsIF90eXBlcyk7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGxpbmthZ2VcbiAgICAgICAgICAgICAgICBwYXJlbnRzLmdldChiYXNlVHlwZSkucHVzaChuYW1lKTtcbiAgICAgICAgICAgICAgICBsaW5rcy5nZXQobmFtZSkuYWRkKGJhc2VUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBEZWR1Y2UgdGhlIHByaW1hcnkgdHlwZVxuICAgICAgICBjb25zdCBwcmltYXJ5VHlwZXMgPSBBcnJheS5mcm9tKHBhcmVudHMua2V5cygpKS5maWx0ZXIoKG4pID0+IChwYXJlbnRzLmdldChuKS5sZW5ndGggPT09IDApKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQocHJpbWFyeVR5cGVzLmxlbmd0aCAhPT0gMCwgXCJtaXNzaW5nIHByaW1hcnkgdHlwZVwiLCBcInR5cGVzXCIsIF90eXBlcyk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHByaW1hcnlUeXBlcy5sZW5ndGggPT09IDEsIGBhbWJpZ3VvdXMgcHJpbWFyeSB0eXBlcyBvciB1bnVzZWQgdHlwZXM6ICR7cHJpbWFyeVR5cGVzLm1hcCgodCkgPT4gKEpTT04uc3RyaW5naWZ5KHQpKSkuam9pbihcIiwgXCIpfWAsIFwidHlwZXNcIiwgX3R5cGVzKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHByaW1hcnlUeXBlOiBwcmltYXJ5VHlwZXNbMF0gfSk7XG4gICAgICAgIC8vIENoZWNrIGZvciBjaXJjdWxhciB0eXBlIHJlZmVyZW5jZXNcbiAgICAgICAgZnVuY3Rpb24gY2hlY2tDaXJjdWxhcih0eXBlLCBmb3VuZCkge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoIWZvdW5kLmhhcyh0eXBlKSwgYGNpcmN1bGFyIHR5cGUgcmVmZXJlbmNlIHRvICR7SlNPTi5zdHJpbmdpZnkodHlwZSl9YCwgXCJ0eXBlc1wiLCBfdHlwZXMpO1xuICAgICAgICAgICAgZm91bmQuYWRkKHR5cGUpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBsaW5rcy5nZXQodHlwZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmVudHMuaGFzKGNoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgY2hlY2sgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICBjaGVja0NpcmN1bGFyKGNoaWxkLCBmb3VuZCk7XG4gICAgICAgICAgICAgICAgLy8gTWFyayBhbGwgYW5jZXN0b3JzIGFzIGhhdmluZyB0aGlzIGRlY2VuZGFudFxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc3VidHlwZSBvZiBmb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlcy5nZXQoc3VidHlwZSkuYWRkKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3VuZC5kZWxldGUodHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tDaXJjdWxhcih0aGlzLnByaW1hcnlUeXBlLCBuZXcgU2V0KCkpO1xuICAgICAgICAvLyBDb21wdXRlIGVhY2ggZnVsbHkgZGVzY3JpYmUgdHlwZVxuICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBzZXRdIG9mIHN1YnR5cGVzKSB7XG4gICAgICAgICAgICBjb25zdCBzdCA9IEFycmF5LmZyb20oc2V0KTtcbiAgICAgICAgICAgIHN0LnNvcnQoKTtcbiAgICAgICAgICAgIHRoaXMuI2Z1bGxUeXBlcy5zZXQobmFtZSwgZW5jb2RlVHlwZShuYW1lLCB0eXBlc1tuYW1lXSkgKyBzdC5tYXAoKHQpID0+IGVuY29kZVR5cGUodCwgdHlwZXNbdF0pKS5qb2luKFwiXCIpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJudGhlIGVuY29kZXIgZm9yIHRoZSBzcGVjaWZpYyAlJXR5cGUlJS5cbiAgICAgKi9cbiAgICBnZXRFbmNvZGVyKHR5cGUpIHtcbiAgICAgICAgbGV0IGVuY29kZXIgPSB0aGlzLiNlbmNvZGVyQ2FjaGUuZ2V0KHR5cGUpO1xuICAgICAgICBpZiAoIWVuY29kZXIpIHtcbiAgICAgICAgICAgIGVuY29kZXIgPSB0aGlzLiNnZXRFbmNvZGVyKHR5cGUpO1xuICAgICAgICAgICAgdGhpcy4jZW5jb2RlckNhY2hlLnNldCh0eXBlLCBlbmNvZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5jb2RlcjtcbiAgICB9XG4gICAgI2dldEVuY29kZXIodHlwZSkge1xuICAgICAgICAvLyBCYXNpYyBlbmNvZGVyIHR5cGUgKGFkZHJlc3MsIGJvb2wsIHVpbnQyNTYsIGV0YylcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlciA9IGdldEJhc2VFbmNvZGVyKHR5cGUpO1xuICAgICAgICAgICAgaWYgKGVuY29kZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5jb2RlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBcnJheVxuICAgICAgICBjb25zdCBhcnJheSA9IHNwbGl0QXJyYXkodHlwZSkuYXJyYXk7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgICAgY29uc3Qgc3VidHlwZSA9IGFycmF5LnByZWZpeDtcbiAgICAgICAgICAgIGNvbnN0IHN1YkVuY29kZXIgPSB0aGlzLmdldEVuY29kZXIoc3VidHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoYXJyYXkuY291bnQgPT09IC0xIHx8IGFycmF5LmNvdW50ID09PSB2YWx1ZS5sZW5ndGgsIGBhcnJheSBsZW5ndGggbWlzbWF0Y2g7IGV4cGVjdGVkIGxlbmd0aCAke2FycmF5LmNvdW50fWAsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSB2YWx1ZS5tYXAoc3ViRW5jb2Rlcik7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI2Z1bGxUeXBlcy5oYXMoc3VidHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm1hcChrZWNjYWsyNTYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ga2VjY2FrMjU2KGNvbmNhdChyZXN1bHQpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RydWN0XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMudHlwZXNbdHlwZV07XG4gICAgICAgIGlmIChmaWVsZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZWRUeXBlID0gaWQodGhpcy4jZnVsbFR5cGVzLmdldCh0eXBlKSk7XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gZmllbGRzLm1hcCgoeyBuYW1lLCB0eXBlIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5nZXRFbmNvZGVyKHR5cGUpKHZhbHVlW25hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuI2Z1bGxUeXBlcy5oYXModHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZWNjYWsyNTYocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhbHVlcy51bnNoaWZ0KGVuY29kZWRUeXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uY2F0KHZhbHVlcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgdW5rbm93biB0eXBlOiAke3R5cGV9YCwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBmdWxsIHR5cGUgZm9yICUlbmFtZSUlLlxuICAgICAqL1xuICAgIGVuY29kZVR5cGUobmFtZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNmdWxsVHlwZXMuZ2V0KG5hbWUpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChyZXN1bHQsIGB1bmtub3duIHR5cGU6ICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9YCwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBlbmNvZGVkICUldmFsdWUlJSBmb3IgdGhlICUldHlwZSUlLlxuICAgICAqL1xuICAgIGVuY29kZURhdGEodHlwZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RW5jb2Rlcih0eXBlKSh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBoYXNoIG9mICUldmFsdWUlJSBmb3IgdGhlIHR5cGUgb2YgJSVuYW1lJSUuXG4gICAgICovXG4gICAgaGFzaFN0cnVjdChuYW1lLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4ga2VjY2FrMjU2KHRoaXMuZW5jb2RlRGF0YShuYW1lLCB2YWx1ZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBmdWxsZWQgZW5jb2RlZCAlJXZhbHVlJSUgZm9yIHRoZSBbW3R5cGVzXV0uXG4gICAgICovXG4gICAgZW5jb2RlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuY29kZURhdGEodGhpcy5wcmltYXJ5VHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBoYXNoIG9mIHRoZSBmdWxseSBlbmNvZGVkICUldmFsdWUlJSBmb3IgdGhlIFtbdHlwZXNdXS5cbiAgICAgKi9cbiAgICBoYXNoKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc2hTdHJ1Y3QodGhpcy5wcmltYXJ5VHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgX3Zpc2l0KHR5cGUsIHZhbHVlLCBjYWxsYmFjaykge1xuICAgICAgICAvLyBCYXNpYyBlbmNvZGVyIHR5cGUgKGFkZHJlc3MsIGJvb2wsIHVpbnQyNTYsIGV0YylcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlciA9IGdldEJhc2VFbmNvZGVyKHR5cGUpO1xuICAgICAgICAgICAgaWYgKGVuY29kZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sodHlwZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFycmF5XG4gICAgICAgIGNvbnN0IGFycmF5ID0gc3BsaXRBcnJheSh0eXBlKS5hcnJheTtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChhcnJheS5jb3VudCA9PT0gLTEgfHwgYXJyYXkuY291bnQgPT09IHZhbHVlLmxlbmd0aCwgYGFycmF5IGxlbmd0aCBtaXNtYXRjaDsgZXhwZWN0ZWQgbGVuZ3RoICR7YXJyYXkuY291bnR9YCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKCh2KSA9PiB0aGlzLl92aXNpdChhcnJheS5wcmVmaXgsIHYsIGNhbGxiYWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RydWN0XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMudHlwZXNbdHlwZV07XG4gICAgICAgIGlmIChmaWVsZHMpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWVsZHMucmVkdWNlKChhY2N1bSwgeyBuYW1lLCB0eXBlIH0pID0+IHtcbiAgICAgICAgICAgICAgICBhY2N1bVtuYW1lXSA9IHRoaXMuX3Zpc2l0KHR5cGUsIHZhbHVlW25hbWVdLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgdW5rbm93biB0eXBlOiAke3R5cGV9YCwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ2FsbCAlJWNhbGJhY2slJSBmb3IgZWFjaCB2YWx1ZSBpbiAlJXZhbHVlJSUsIHBhc3NpbmcgdGhlIHR5cGUgYW5kXG4gICAgICogIGNvbXBvbmVudCB3aXRoaW4gJSV2YWx1ZSUlLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgdXNlZnVsIGZvciByZXBsYWNpbmcgYWRkcmVzc2VzIG9yIG90aGVyIHRyYW5zZm9ybWF0aW9uIHRoYXRcbiAgICAgKiAgbWF5IGJlIGRlc2lyZWQgb24gZWFjaCBjb21wb25lbnQsIGJhc2VkIG9uIGl0cyB0eXBlLlxuICAgICAqL1xuICAgIHZpc2l0KHZhbHVlLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaXQodGhpcy5wcmltYXJ5VHlwZSwgdmFsdWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKlR5cGVkRGF0YUVuY29kZXIqKiBmb3IgJSV0eXBlcyUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKHR5cGVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZWREYXRhRW5jb2Rlcih0eXBlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHByaW1hcnkgdHlwZSBmb3IgJSV0eXBlcyUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRQcmltYXJ5VHlwZSh0eXBlcykge1xuICAgICAgICByZXR1cm4gVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKS5wcmltYXJ5VHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgaGFzaGVkIHN0cnVjdCBmb3IgJSV2YWx1ZSUlIHVzaW5nICUldHlwZXMlJSBhbmQgJSVuYW1lJSUuXG4gICAgICovXG4gICAgc3RhdGljIGhhc2hTdHJ1Y3QobmFtZSwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBUeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpLmhhc2hTdHJ1Y3QobmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBkb21haW4gaGFzaCBmb3IgJSVkb21haW4lJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaGFzaERvbWFpbihkb21haW4pIHtcbiAgICAgICAgY29uc3QgZG9tYWluRmllbGRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBkb21haW4pIHtcbiAgICAgICAgICAgIGlmIChkb21haW5bbmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHlwZSA9IGRvbWFpbkZpZWxkVHlwZXNbbmFtZV07XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlLCBgaW52YWxpZCB0eXBlZC1kYXRhIGRvbWFpbiBrZXk6ICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9YCwgXCJkb21haW5cIiwgZG9tYWluKTtcbiAgICAgICAgICAgIGRvbWFpbkZpZWxkcy5wdXNoKHsgbmFtZSwgdHlwZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBkb21haW5GaWVsZHMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGRvbWFpbkZpZWxkTmFtZXMuaW5kZXhPZihhLm5hbWUpIC0gZG9tYWluRmllbGROYW1lcy5pbmRleE9mKGIubmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gVHlwZWREYXRhRW5jb2Rlci5oYXNoU3RydWN0KFwiRUlQNzEyRG9tYWluXCIsIHsgRUlQNzEyRG9tYWluOiBkb21haW5GaWVsZHMgfSwgZG9tYWluKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgZnVsbHkgZW5jb2RlZCBbW2xpbmstZWlwLTcxMl1dICUldmFsdWUlJSBmb3IgJSV0eXBlcyUlIHdpdGggJSVkb21haW4lJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZW5jb2RlKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjb25jYXQoW1xuICAgICAgICAgICAgXCIweDE5MDFcIixcbiAgICAgICAgICAgIFR5cGVkRGF0YUVuY29kZXIuaGFzaERvbWFpbihkb21haW4pLFxuICAgICAgICAgICAgVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKS5oYXNoKHZhbHVlKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgaGFzaCBvZiB0aGUgZnVsbHkgZW5jb2RlZCBbW2xpbmstZWlwLTcxMl1dICUldmFsdWUlJSBmb3IgJSV0eXBlcyUlIHdpdGggJSVkb21haW4lJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaGFzaChkb21haW4sIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4ga2VjY2FrMjU2KFR5cGVkRGF0YUVuY29kZXIuZW5jb2RlKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSk7XG4gICAgfVxuICAgIC8vIFJlcGxhY2VzIGFsbCBhZGRyZXNzIHR5cGVzIHdpdGggRU5TIG5hbWVzIHdpdGggdGhlaXIgbG9va2VkIHVwIGFkZHJlc3NcbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyB0byB0aGUgdmFsdWUgZnJvbSByZXNvbHZpbmcgYWxsIGFkZHJlc3NlcyBpbiAlJXZhbHVlJSUgZm9yXG4gICAgICogJSV0eXBlcyUlIGFuZCB0aGUgJSVkb21haW4lJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgcmVzb2x2ZU5hbWVzKGRvbWFpbiwgdHlwZXMsIHZhbHVlLCByZXNvbHZlTmFtZSkge1xuICAgICAgICAvLyBNYWtlIGEgY29weSB0byBpc29sYXRlIGl0IGZyb20gdGhlIG9iamVjdCBwYXNzZWQgaW5cbiAgICAgICAgZG9tYWluID0gT2JqZWN0LmFzc2lnbih7fSwgZG9tYWluKTtcbiAgICAgICAgLy8gQWxsb3cgcGFzc2luZyBudWxsIHRvIGlnbm9yZSB2YWx1ZVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkb21haW4pIHtcbiAgICAgICAgICAgIGlmIChkb21haW5ba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGRvbWFpbltrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIExvb2sgdXAgYWxsIEVOUyBuYW1lc1xuICAgICAgICBjb25zdCBlbnNDYWNoZSA9IHt9O1xuICAgICAgICAvLyBEbyB3ZSBuZWVkIHRvIGxvb2sgdXAgdGhlIGRvbWFpbidzIHZlcmlmeWluZ0NvbnRyYWN0P1xuICAgICAgICBpZiAoZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0ICYmICFpc0hleFN0cmluZyhkb21haW4udmVyaWZ5aW5nQ29udHJhY3QsIDIwKSkge1xuICAgICAgICAgICAgZW5zQ2FjaGVbZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0XSA9IFwiMHhcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBhcmUgZ29pbmcgdG8gdXNlIHRoZSBlbmNvZGVyIHRvIHZpc2l0IGFsbCB0aGUgYmFzZSB2YWx1ZXNcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IFR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcyk7XG4gICAgICAgIC8vIEdldCBhIGxpc3Qgb2YgYWxsIHRoZSBhZGRyZXNzZXNcbiAgICAgICAgZW5jb2Rlci52aXNpdCh2YWx1ZSwgKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJhZGRyZXNzXCIgJiYgIWlzSGV4U3RyaW5nKHZhbHVlLCAyMCkpIHtcbiAgICAgICAgICAgICAgICBlbnNDYWNoZVt2YWx1ZV0gPSBcIjB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBMb29rdXAgZWFjaCBuYW1lXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBlbnNDYWNoZSkge1xuICAgICAgICAgICAgZW5zQ2FjaGVbbmFtZV0gPSBhd2FpdCByZXNvbHZlTmFtZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXBsYWNlIHRoZSBkb21haW4gdmVyaWZ5aW5nQ29udHJhY3QgaWYgbmVlZGVkXG4gICAgICAgIGlmIChkb21haW4udmVyaWZ5aW5nQ29udHJhY3QgJiYgZW5zQ2FjaGVbZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0XSkge1xuICAgICAgICAgICAgZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0ID0gZW5zQ2FjaGVbZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0XTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXBsYWNlIGFsbCBFTlMgbmFtZXMgd2l0aCB0aGVpciBhZGRyZXNzXG4gICAgICAgIHZhbHVlID0gZW5jb2Rlci52aXNpdCh2YWx1ZSwgKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJhZGRyZXNzXCIgJiYgZW5zQ2FjaGVbdmFsdWVdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuc0NhY2hlW3ZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IGRvbWFpbiwgdmFsdWUgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIEpTT04tZW5jb2RlZCBwYXlsb2FkIGV4cGVjdGVkIGJ5IG5vZGVzIHdoaWNoIGltcGxlbWVudFxuICAgICAqICB0aGUgSlNPTi1SUEMgW1tsaW5rLWVpcC03MTJdXSBtZXRob2QuXG4gICAgICovXG4gICAgc3RhdGljIGdldFBheWxvYWQoZG9tYWluLCB0eXBlcywgdmFsdWUpIHtcbiAgICAgICAgLy8gVmFsaWRhdGUgdGhlIGRvbWFpbiBmaWVsZHNcbiAgICAgICAgVHlwZWREYXRhRW5jb2Rlci5oYXNoRG9tYWluKGRvbWFpbik7XG4gICAgICAgIC8vIERlcml2ZSB0aGUgRUlQNzEyRG9tYWluIFN0cnVjdCByZWZlcmVuY2UgdHlwZVxuICAgICAgICBjb25zdCBkb21haW5WYWx1ZXMgPSB7fTtcbiAgICAgICAgY29uc3QgZG9tYWluVHlwZXMgPSBbXTtcbiAgICAgICAgZG9tYWluRmllbGROYW1lcy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRvbWFpbltuYW1lXTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9tYWluVmFsdWVzW25hbWVdID0gZG9tYWluQ2hlY2tzW25hbWVdKHZhbHVlKTtcbiAgICAgICAgICAgIGRvbWFpblR5cGVzLnB1c2goeyBuYW1lLCB0eXBlOiBkb21haW5GaWVsZFR5cGVzW25hbWVdIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IFR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcyk7XG4gICAgICAgIC8vIEdldCB0aGUgbm9ybWFsaXplZCB0eXBlc1xuICAgICAgICB0eXBlcyA9IGVuY29kZXIudHlwZXM7XG4gICAgICAgIGNvbnN0IHR5cGVzV2l0aERvbWFpbiA9IE9iamVjdC5hc3NpZ24oe30sIHR5cGVzKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZXNXaXRoRG9tYWluLkVJUDcxMkRvbWFpbiA9PSBudWxsLCBcInR5cGVzIG11c3Qgbm90IGNvbnRhaW4gRUlQNzEyRG9tYWluIHR5cGVcIiwgXCJ0eXBlcy5FSVA3MTJEb21haW5cIiwgdHlwZXMpO1xuICAgICAgICB0eXBlc1dpdGhEb21haW4uRUlQNzEyRG9tYWluID0gZG9tYWluVHlwZXM7XG4gICAgICAgIC8vIFZhbGlkYXRlIHRoZSBkYXRhIHN0cnVjdHVyZXMgYW5kIHR5cGVzXG4gICAgICAgIGVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGVzOiB0eXBlc1dpdGhEb21haW4sXG4gICAgICAgICAgICBkb21haW46IGRvbWFpblZhbHVlcyxcbiAgICAgICAgICAgIHByaW1hcnlUeXBlOiBlbmNvZGVyLnByaW1hcnlUeXBlLFxuICAgICAgICAgICAgbWVzc2FnZTogZW5jb2Rlci52aXNpdCh2YWx1ZSwgKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gYnl0ZXNcbiAgICAgICAgICAgICAgICBpZiAodHlwZS5tYXRjaCgvXmJ5dGVzKFxcZCopLykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkoZ2V0Qnl0ZXModmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdWludCBvciBpbnRcbiAgICAgICAgICAgICAgICBpZiAodHlwZS5tYXRjaCgvXnU/aW50LykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEJpZ0ludCh2YWx1ZSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhZGRyZXNzXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJvb2xcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhIXZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiwgXCJpbnZhbGlkIHN0cmluZ1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgdHlwZVwiLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuICogIENvbXB1dGUgdGhlIGFkZHJlc3MgdXNlZCB0byBzaWduIHRoZSB0eXBlZCBkYXRhIGZvciB0aGUgJSVzaWduYXR1cmUlJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeVR5cGVkRGF0YShkb21haW4sIHR5cGVzLCB2YWx1ZSwgc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIHJlY292ZXJBZGRyZXNzKFR5cGVkRGF0YUVuY29kZXIuaGFzaChkb21haW4sIHR5cGVzLCB2YWx1ZSksIHNpZ25hdHVyZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlZC1kYXRhLmpzLm1hcCJdLCJuYW1lcyI6WyJnZXRBZGRyZXNzIiwia2VjY2FrMjU2IiwicmVjb3ZlckFkZHJlc3MiLCJjb25jYXQiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZ2V0QmlnSW50IiwiZ2V0Qnl0ZXMiLCJoZXhsaWZ5IiwiaXNIZXhTdHJpbmciLCJtYXNrIiwidG9CZUhleCIsInRvUXVhbnRpdHkiLCJ0b1R3b3MiLCJ6ZXJvUGFkVmFsdWUiLCJhc3NlcnRBcmd1bWVudCIsImlkIiwicGFkZGluZyIsIlVpbnQ4QXJyYXkiLCJmaWxsIiwiQk5fXzEiLCJCaWdJbnQiLCJCTl8wIiwiQk5fMSIsIkJOX01BWF9VSU5UMjU2IiwiaGV4UGFkUmlnaHQiLCJ2YWx1ZSIsImJ5dGVzIiwicGFkT2Zmc2V0IiwibGVuZ3RoIiwic2xpY2UiLCJoZXhUcnVlIiwiaGV4RmFsc2UiLCJkb21haW5GaWVsZFR5cGVzIiwibmFtZSIsInZlcnNpb24iLCJjaGFpbklkIiwidmVyaWZ5aW5nQ29udHJhY3QiLCJzYWx0IiwiZG9tYWluRmllbGROYW1lcyIsImNoZWNrU3RyaW5nIiwia2V5IiwiSlNPTiIsInN0cmluZ2lmeSIsImRvbWFpbkNoZWNrcyIsIl92YWx1ZSIsIk51bWJlciIsImlzU2FmZUludGVnZXIiLCJ0b0xvd2VyQ2FzZSIsImVycm9yIiwiZ2V0QmFzZUVuY29kZXIiLCJ0eXBlIiwibWF0Y2giLCJzaWduZWQiLCJ3aWR0aCIsInBhcnNlSW50IiwiU3RyaW5nIiwiYm91bmRzVXBwZXIiLCJib3VuZHNMb3dlciIsImVuY29kZVR5cGUiLCJmaWVsZHMiLCJtYXAiLCJqb2luIiwic3BsaXRBcnJheSIsImJhc2UiLCJpbmRleCIsImFycmF5IiwicHJlZml4IiwiY291bnQiLCJUeXBlZERhdGFFbmNvZGVyIiwidHlwZXMiLCJwYXJzZSIsImdldEVuY29kZXIiLCJlbmNvZGVyIiwiZW5jb2RlckNhY2hlIiwiZ2V0Iiwic2V0IiwicmVzdWx0IiwiZnVsbFR5cGVzIiwiZW5jb2RlRGF0YSIsImhhc2hTdHJ1Y3QiLCJlbmNvZGUiLCJwcmltYXJ5VHlwZSIsImhhc2giLCJfdmlzaXQiLCJjYWxsYmFjayIsInYiLCJyZWR1Y2UiLCJhY2N1bSIsInZpc2l0IiwiZnJvbSIsImdldFByaW1hcnlUeXBlIiwiaGFzaERvbWFpbiIsImRvbWFpbiIsImRvbWFpbkZpZWxkcyIsInB1c2giLCJzb3J0IiwiYSIsImIiLCJpbmRleE9mIiwiRUlQNzEyRG9tYWluIiwicmVzb2x2ZU5hbWVzIiwicmVzb2x2ZU5hbWUiLCJPYmplY3QiLCJhc3NpZ24iLCJlbnNDYWNoZSIsImdldFBheWxvYWQiLCJkb21haW5WYWx1ZXMiLCJkb21haW5UeXBlcyIsImZvckVhY2giLCJ0eXBlc1dpdGhEb21haW4iLCJtZXNzYWdlIiwidG9TdHJpbmciLCJjb25zdHJ1Y3RvciIsIl90eXBlcyIsIk1hcCIsImxpbmtzIiwicGFyZW50cyIsInN1YnR5cGVzIiwia2V5cyIsIlNldCIsInVuaXF1ZU5hbWVzIiwiZmllbGQiLCJoYXMiLCJhZGQiLCJiYXNlVHlwZSIsInByaW1hcnlUeXBlcyIsIkFycmF5IiwiZmlsdGVyIiwibiIsInQiLCJjaGVja0NpcmN1bGFyIiwiZm91bmQiLCJjaGlsZCIsInN1YnR5cGUiLCJkZWxldGUiLCJzdCIsInN1YkVuY29kZXIiLCJlbmNvZGVkVHlwZSIsInZhbHVlcyIsInVuc2hpZnQiLCJ2ZXJpZnlUeXBlZERhdGEiLCJzaWduYXR1cmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/hash/typed-data.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/providers/abstract-provider.js":
/*!********************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/abstract-provider.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractProvider: function() { return /* binding */ AbstractProvider; },\n/* harmony export */   UnmanagedSubscriber: function() { return /* binding */ UnmanagedSubscriber; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_get */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_get.js\");\n/* harmony import */ var _swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_init */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_init.js\");\n/* harmony import */ var _swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_set */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_set.js\");\n/* harmony import */ var _swc_helpers_class_private_field_update__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_update */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_update.js\");\n/* harmony import */ var _swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @swc/helpers/_/_class_private_method_get */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_method_get.js\");\n/* harmony import */ var _swc_helpers_class_private_method_init__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @swc/helpers/_/_class_private_method_init */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_method_init.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../address/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/address/checks.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../address/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _constants_index_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../constants/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/constants/addresses.js\");\n/* harmony import */ var _contract_index_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../contract/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/contract/contract.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../hash/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/hash/namehash.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../transaction/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/transaction/transaction.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/fetch.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/events.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var _ens_resolver_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./ens-resolver.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/providers/ens-resolver.js\");\n/* harmony import */ var _format_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./format.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/providers/format.js\");\n/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./network.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/providers/network.js\");\n/* harmony import */ var _provider_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./provider.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/providers/provider.js\");\n/* harmony import */ var _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./subscriber-polling.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/providers/subscriber-polling.js\");\n/**\n *  The available providers should suffice for most developers purposes,\n *  but the [[AbstractProvider]] class has many features which enable\n *  sub-classing it for specific purposes.\n *\n *  @_section: api/providers/abstract-provider: Subclassing Provider  [abstract-provider]\n */ // @TODO\n// Event coalescence\n//   When we register an event with an async value (e.g. address is a Signer\n//   or ENS name), we need to add it immeidately for the Event API, but also\n//   need time to resolve the address. Upon resolving the address, we need to\n//   migrate the listener to the static event. We also need to maintain a map\n//   of Signer/ENS name to address so we can sync respond to listenerCount.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// Constants\nconst BN_2 = BigInt(2);\nconst MAX_CCIP_REDIRECTS = 10;\nfunction isPromise(value) {\n    return value && typeof value.then === \"function\";\n}\nfunction getTag(prefix, value) {\n    return prefix + \":\" + JSON.stringify(value, (k, v)=>{\n        if (v == null) {\n            return \"null\";\n        }\n        if (typeof v === \"bigint\") {\n            return \"bigint:\".concat(v.toString());\n        }\n        if (typeof v === \"string\") {\n            return v.toLowerCase();\n        }\n        // Sort object keys\n        if (typeof v === \"object\" && !Array.isArray(v)) {\n            const keys = Object.keys(v);\n            keys.sort();\n            return keys.reduce((accum, key)=>{\n                accum[key] = v[key];\n                return accum;\n            }, {});\n        }\n        return v;\n    });\n}\n/**\n *  An **UnmanagedSubscriber** is useful for events which do not require\n *  any additional management, such as ``\"debug\"`` which only requires\n *  emit in synchronous event loop triggered calls.\n */ class UnmanagedSubscriber {\n    start() {}\n    stop() {}\n    pause(dropWhilePaused) {}\n    resume() {}\n    /**\n     *  Create a new UnmanagedSubscriber with %%name%%.\n     */ constructor(name){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            name\n        });\n    }\n}\nfunction copy(value) {\n    return JSON.parse(JSON.stringify(value));\n}\nfunction concisify(items) {\n    items = Array.from(new Set(items).values());\n    items.sort();\n    return items;\n}\nasync function getSubscription(_event, provider) {\n    if (_event == null) {\n        throw new Error(\"invalid event\");\n    }\n    // Normalize topic array info an EventFilter\n    if (Array.isArray(_event)) {\n        _event = {\n            topics: _event\n        };\n    }\n    if (typeof _event === \"string\") {\n        switch(_event){\n            case \"block\":\n            case \"debug\":\n            case \"error\":\n            case \"finalized\":\n            case \"network\":\n            case \"pending\":\n            case \"safe\":\n                {\n                    return {\n                        type: _event,\n                        tag: _event\n                    };\n                }\n        }\n    }\n    if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(_event, 32)) {\n        const hash = _event.toLowerCase();\n        return {\n            type: \"transaction\",\n            tag: getTag(\"tx\", {\n                hash\n            }),\n            hash\n        };\n    }\n    if (_event.orphan) {\n        const event = _event;\n        // @TODO: Should lowercase and whatnot things here instead of copy...\n        return {\n            type: \"orphan\",\n            tag: getTag(\"orphan\", event),\n            filter: copy(event)\n        };\n    }\n    if (_event.address || _event.topics) {\n        const event = _event;\n        const filter = {\n            topics: (event.topics || []).map((t)=>{\n                if (t == null) {\n                    return null;\n                }\n                if (Array.isArray(t)) {\n                    return concisify(t.map((t)=>t.toLowerCase()));\n                }\n                return t.toLowerCase();\n            })\n        };\n        if (event.address) {\n            const addresses = [];\n            const promises = [];\n            const addAddress = (addr)=>{\n                if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(addr)) {\n                    addresses.push(addr);\n                } else {\n                    promises.push((async ()=>{\n                        addresses.push(await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(addr, provider));\n                    })());\n                }\n            };\n            if (Array.isArray(event.address)) {\n                event.address.forEach(addAddress);\n            } else {\n                addAddress(event.address);\n            }\n            if (promises.length) {\n                await Promise.all(promises);\n            }\n            filter.address = concisify(addresses.map((a)=>a.toLowerCase()));\n        }\n        return {\n            filter,\n            tag: getTag(\"event\", filter),\n            type: \"event\"\n        };\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"unknown ProviderEvent\", \"event\", _event);\n}\nfunction getTime() {\n    return new Date().getTime();\n}\nconst defaultOptions = {\n    cacheTimeout: 250,\n    pollingInterval: 4000\n};\nvar _subs = /*#__PURE__*/ new WeakMap(), _plugins = /*#__PURE__*/ new WeakMap(), // null=unpaused, true=paused+dropWhilePaused, false=paused\n_pausedState = /*#__PURE__*/ new WeakMap(), _destroyed = /*#__PURE__*/ new WeakMap(), _networkPromise = /*#__PURE__*/ new WeakMap(), _anyNetwork = /*#__PURE__*/ new WeakMap(), _performCache = /*#__PURE__*/ new WeakMap(), // The most recent block number if running an event or -1 if no \"block\" event\n_lastBlockNumber = /*#__PURE__*/ new WeakMap(), _nextTimer = /*#__PURE__*/ new WeakMap(), _timers = /*#__PURE__*/ new WeakMap(), _disableCcipRead = /*#__PURE__*/ new WeakMap(), _options = /*#__PURE__*/ new WeakMap(), _perform = /*#__PURE__*/ new WeakSet(), _call = /*#__PURE__*/ new WeakSet(), _checkNetwork = /*#__PURE__*/ new WeakSet(), _getAccountValue = /*#__PURE__*/ new WeakSet(), _getBlock = /*#__PURE__*/ new WeakSet(), _hasSub = /*#__PURE__*/ new WeakSet(), _getSub = /*#__PURE__*/ new WeakSet();\n/**\n *  An **AbstractProvider** provides a base class for other sub-classes to\n *  implement the [[Provider]] API by normalizing input arguments and\n *  formatting output results as well as tracking events for consistent\n *  behaviour on an eventually-consistent network.\n */ class AbstractProvider {\n    get pollingInterval() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _options).pollingInterval;\n    }\n    /**\n     *  Returns ``this``, to allow an **AbstractProvider** to implement\n     *  the [[ContractRunner]] interface.\n     */ get provider() {\n        return this;\n    }\n    /**\n     *  Returns all the registered plug-ins.\n     */ get plugins() {\n        return Array.from((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _plugins).values());\n    }\n    /**\n     *  Attach a new plug-in.\n     */ attachPlugin(plugin) {\n        if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _plugins).get(plugin.name)) {\n            throw new Error(\"cannot replace existing plugin: \".concat(plugin.name, \" \"));\n        }\n        (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _plugins).set(plugin.name, plugin.connect(this));\n        return this;\n    }\n    /**\n     *  Get a plugin by name.\n     */ getPlugin(name) {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _plugins).get(name) || null;\n    }\n    /**\n     *  Prevent any CCIP-read operation, regardless of whether requested\n     *  in a [[call]] using ``enableCcipRead``.\n     */ get disableCcipRead() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _disableCcipRead);\n    }\n    set disableCcipRead(value) {\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _disableCcipRead, !!value);\n    }\n    /**\n     *  Resolves to the data for executing the CCIP-read operations.\n     */ async ccipReadFetch(tx, calldata, urls) {\n        if (this.disableCcipRead || urls.length === 0 || tx.to == null) {\n            return null;\n        }\n        const sender = tx.to.toLowerCase();\n        const data = calldata.toLowerCase();\n        const errorMessages = [];\n        for(let i = 0; i < urls.length; i++){\n            const url = urls[i];\n            // URL expansion\n            const href = url.replace(\"{sender}\", sender).replace(\"{data}\", data);\n            // If no {data} is present, use POST; otherwise GET\n            //const json: string | null = (url.indexOf(\"{data}\") >= 0) ? null: JSON.stringify({ data, sender });\n            //const result = await fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {\n            //    value.status = response.statusCode;\n            //    return value;\n            //});\n            const request = new _utils_index_js__WEBPACK_IMPORTED_MODULE_6__.FetchRequest(href);\n            if (url.indexOf(\"{data}\") === -1) {\n                request.body = {\n                    data,\n                    sender\n                };\n            }\n            this.emit(\"debug\", {\n                action: \"sendCcipReadFetchRequest\",\n                request,\n                index: i,\n                urls\n            });\n            let errorMessage = \"unknown error\";\n            // Fetch the resource...\n            let resp;\n            try {\n                resp = await request.send();\n            } catch (error) {\n                // ...low-level fetch error (missing host, bad SSL, etc.),\n                // so try next URL\n                errorMessages.push(error.message);\n                this.emit(\"debug\", {\n                    action: \"receiveCcipReadFetchError\",\n                    request,\n                    result: {\n                        error\n                    }\n                });\n                continue;\n            }\n            try {\n                const result = resp.bodyJson;\n                if (result.data) {\n                    this.emit(\"debug\", {\n                        action: \"receiveCcipReadFetchResult\",\n                        request,\n                        result\n                    });\n                    return result.data;\n                }\n                if (result.message) {\n                    errorMessage = result.message;\n                }\n                this.emit(\"debug\", {\n                    action: \"receiveCcipReadFetchError\",\n                    request,\n                    result\n                });\n            } catch (error) {}\n            // 4xx indicates the result is not present; stop\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(resp.statusCode < 400 || resp.statusCode >= 500, \"response not found during CCIP fetch: \".concat(errorMessage), \"OFFCHAIN_FAULT\", {\n                reason: \"404_MISSING_RESOURCE\",\n                transaction: tx,\n                info: {\n                    url,\n                    errorMessage\n                }\n            });\n            // 5xx indicates server issue; try the next url\n            errorMessages.push(errorMessage);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"error encountered during CCIP fetch: \".concat(errorMessages.map((m)=>JSON.stringify(m)).join(\", \")), \"OFFCHAIN_FAULT\", {\n            reason: \"500_SERVER_ERROR\",\n            transaction: tx,\n            info: {\n                urls,\n                errorMessages\n            }\n        });\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a block before\n     *  returning it, to add additional properties or an alternate\n     *  sub-class of [[Block]].\n     */ _wrapBlock(value, network) {\n        return new _provider_js__WEBPACK_IMPORTED_MODULE_7__.Block((0,_format_js__WEBPACK_IMPORTED_MODULE_8__.formatBlock)(value), this);\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a log before\n     *  returning it, to add additional properties or an alternate\n     *  sub-class of [[Log]].\n     */ _wrapLog(value, network) {\n        return new _provider_js__WEBPACK_IMPORTED_MODULE_7__.Log((0,_format_js__WEBPACK_IMPORTED_MODULE_8__.formatLog)(value), this);\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a transaction\n     *  receipt before returning it, to add additional properties or an\n     *  alternate sub-class of [[TransactionReceipt]].\n     */ _wrapTransactionReceipt(value, network) {\n        return new _provider_js__WEBPACK_IMPORTED_MODULE_7__.TransactionReceipt((0,_format_js__WEBPACK_IMPORTED_MODULE_8__.formatTransactionReceipt)(value), this);\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a transaction\n     *  response before returning it, to add additional properties or an\n     *  alternate sub-class of [[TransactionResponse]].\n     */ _wrapTransactionResponse(tx, network) {\n        return new _provider_js__WEBPACK_IMPORTED_MODULE_7__.TransactionResponse((0,_format_js__WEBPACK_IMPORTED_MODULE_8__.formatTransactionResponse)(tx), this);\n    }\n    /**\n     *  Resolves to the Network, forcing a network detection using whatever\n     *  technique the sub-class requires.\n     *\n     *  Sub-classes **must** override this.\n     */ _detectNetwork() {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"sub-classes must implement this\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"_detectNetwork\"\n        });\n    }\n    /**\n     *  Sub-classes should use this to perform all built-in operations. All\n     *  methods sanitizes and normalizes the values passed into this.\n     *\n     *  Sub-classes **must** override this.\n     */ async _perform(req) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"unsupported method: \".concat(req.method), \"UNSUPPORTED_OPERATION\", {\n            operation: req.method,\n            info: req\n        });\n    }\n    // State\n    async getBlockNumber() {\n        const blockNumber = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.getNumber)(await (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _perform, perform).call(this, {\n            method: \"getBlockNumber\"\n        }), \"%response\");\n        if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _lastBlockNumber) >= 0) {\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _lastBlockNumber, blockNumber);\n        }\n        return blockNumber;\n    }\n    /**\n     *  Returns or resolves to the address for %%address%%, resolving ENS\n     *  names and [[Addressable]] objects and returning if already an\n     *  address.\n     */ _getAddress(address) {\n        return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(address, this);\n    }\n    /**\n     *  Returns or resolves to a valid block tag for %%blockTag%%, resolving\n     *  negative values and returning if already a valid block tag.\n     */ _getBlockTag(blockTag) {\n        if (blockTag == null) {\n            return \"latest\";\n        }\n        switch(blockTag){\n            case \"earliest\":\n                return \"0x0\";\n            case \"finalized\":\n            case \"latest\":\n            case \"pending\":\n            case \"safe\":\n                return blockTag;\n        }\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(blockTag)) {\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(blockTag, 32)) {\n                return blockTag;\n            }\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.toQuantity)(blockTag);\n        }\n        if (typeof blockTag === \"bigint\") {\n            blockTag = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.getNumber)(blockTag, \"blockTag\");\n        }\n        if (typeof blockTag === \"number\") {\n            if (blockTag >= 0) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.toQuantity)(blockTag);\n            }\n            if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _lastBlockNumber) >= 0) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.toQuantity)((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _lastBlockNumber) + blockTag);\n            }\n            return this.getBlockNumber().then((b)=>(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.toQuantity)(b + blockTag));\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"invalid blockTag\", \"blockTag\", blockTag);\n    }\n    /**\n     *  Returns or resolves to a filter for %%filter%%, resolving any ENS\n     *  names or [[Addressable]] object and returning if already a valid\n     *  filter.\n     */ _getFilter(filter) {\n        // Create a canonical representation of the topics\n        const topics = (filter.topics || []).map((t)=>{\n            if (t == null) {\n                return null;\n            }\n            if (Array.isArray(t)) {\n                return concisify(t.map((t)=>t.toLowerCase()));\n            }\n            return t.toLowerCase();\n        });\n        const blockHash = \"blockHash\" in filter ? filter.blockHash : undefined;\n        const resolve = (_address, fromBlock, toBlock)=>{\n            let address = undefined;\n            switch(_address.length){\n                case 0:\n                    break;\n                case 1:\n                    address = _address[0];\n                    break;\n                default:\n                    _address.sort();\n                    address = _address;\n            }\n            if (blockHash) {\n                if (fromBlock != null || toBlock != null) {\n                    throw new Error(\"invalid filter\");\n                }\n            }\n            const filter = {};\n            if (address) {\n                filter.address = address;\n            }\n            if (topics.length) {\n                filter.topics = topics;\n            }\n            if (fromBlock) {\n                filter.fromBlock = fromBlock;\n            }\n            if (toBlock) {\n                filter.toBlock = toBlock;\n            }\n            if (blockHash) {\n                filter.blockHash = blockHash;\n            }\n            return filter;\n        };\n        // Addresses could be async (ENS names or Addressables)\n        let address = [];\n        if (filter.address) {\n            if (Array.isArray(filter.address)) {\n                for (const addr of filter.address){\n                    address.push(this._getAddress(addr));\n                }\n            } else {\n                address.push(this._getAddress(filter.address));\n            }\n        }\n        let fromBlock = undefined;\n        if (\"fromBlock\" in filter) {\n            fromBlock = this._getBlockTag(filter.fromBlock);\n        }\n        let toBlock = undefined;\n        if (\"toBlock\" in filter) {\n            toBlock = this._getBlockTag(filter.toBlock);\n        }\n        if (address.filter((a)=>typeof a !== \"string\").length || fromBlock != null && typeof fromBlock !== \"string\" || toBlock != null && typeof toBlock !== \"string\") {\n            return Promise.all([\n                Promise.all(address),\n                fromBlock,\n                toBlock\n            ]).then((result)=>{\n                return resolve(result[0], result[1], result[2]);\n            });\n        }\n        return resolve(address, fromBlock, toBlock);\n    }\n    /**\n     *  Returns or resolves to a transaction for %%request%%, resolving\n     *  any ENS names or [[Addressable]] and returning if already a valid\n     *  transaction.\n     */ _getTransactionRequest(_request) {\n        const request = (0,_provider_js__WEBPACK_IMPORTED_MODULE_7__.copyRequest)(_request);\n        const promises = [];\n        [\n            \"to\",\n            \"from\"\n        ].forEach((key)=>{\n            if (request[key] == null) {\n                return;\n            }\n            const addr = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(request[key], this);\n            if (isPromise(addr)) {\n                promises.push(async function() {\n                    request[key] = await addr;\n                }());\n            } else {\n                request[key] = addr;\n            }\n        });\n        if (request.blockTag != null) {\n            const blockTag = this._getBlockTag(request.blockTag);\n            if (isPromise(blockTag)) {\n                promises.push(async function() {\n                    request.blockTag = await blockTag;\n                }());\n            } else {\n                request.blockTag = blockTag;\n            }\n        }\n        if (promises.length) {\n            return async function() {\n                await Promise.all(promises);\n                return request;\n            }();\n        }\n        return request;\n    }\n    async getNetwork() {\n        // No explicit network was set and this is our first time\n        if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _networkPromise) == null) {\n            // Detect the current network (shared with all calls)\n            const detectNetwork = (async ()=>{\n                try {\n                    const network = await this._detectNetwork();\n                    this.emit(\"network\", network, null);\n                    return network;\n                } catch (error) {\n                    if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _networkPromise) === detectNetwork) {\n                        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _networkPromise, null);\n                    }\n                    throw error;\n                }\n            })();\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _networkPromise, detectNetwork);\n            return (await detectNetwork).clone();\n        }\n        const networkPromise = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _networkPromise);\n        const [expected, actual] = await Promise.all([\n            networkPromise,\n            this._detectNetwork() // The actual connected network\n        ]);\n        if (expected.chainId !== actual.chainId) {\n            if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _anyNetwork)) {\n                // The \"any\" network can change, so notify listeners\n                this.emit(\"network\", actual, expected);\n                // Update the network if something else hasn't already changed it\n                if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _networkPromise) === networkPromise) {\n                    (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _networkPromise, Promise.resolve(actual));\n                }\n            } else {\n                // Otherwise, we do not allow changes to the underlying network\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"network changed: \".concat(expected.chainId, \" => \").concat(actual.chainId, \" \"), \"NETWORK_ERROR\", {\n                    event: \"changed\"\n                });\n            }\n        }\n        return expected.clone();\n    }\n    async getFeeData() {\n        const network = await this.getNetwork();\n        const getFeeDataFunc = async ()=>{\n            const { _block, gasPrice, priorityFee } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n                _block: (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _getBlock, getBlock).call(this, \"latest\", false),\n                gasPrice: (async ()=>{\n                    try {\n                        const value = await (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _perform, perform).call(this, {\n                            method: \"getGasPrice\"\n                        });\n                        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.getBigInt)(value, \"%response\");\n                    } catch (error) {}\n                    return null;\n                })(),\n                priorityFee: (async ()=>{\n                    try {\n                        const value = await (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _perform, perform).call(this, {\n                            method: \"getPriorityFee\"\n                        });\n                        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.getBigInt)(value, \"%response\");\n                    } catch (error) {}\n                    return null;\n                })()\n            });\n            let maxFeePerGas = null;\n            let maxPriorityFeePerGas = null;\n            // These are the recommended EIP-1559 heuristics for fee data\n            const block = this._wrapBlock(_block, network);\n            if (block && block.baseFeePerGas) {\n                maxPriorityFeePerGas = priorityFee != null ? priorityFee : BigInt(\"1000000000\");\n                maxFeePerGas = block.baseFeePerGas * BN_2 + maxPriorityFeePerGas;\n            }\n            return new _provider_js__WEBPACK_IMPORTED_MODULE_7__.FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas);\n        };\n        // Check for a FeeDataNetWorkPlugin\n        const plugin = network.getPlugin(\"org.ethers.plugins.network.FetchUrlFeeDataPlugin\");\n        if (plugin) {\n            const req = new _utils_index_js__WEBPACK_IMPORTED_MODULE_6__.FetchRequest(plugin.url);\n            const feeData = await plugin.processFunc(getFeeDataFunc, this, req);\n            return new _provider_js__WEBPACK_IMPORTED_MODULE_7__.FeeData(feeData.gasPrice, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas);\n        }\n        return await getFeeDataFunc();\n    }\n    async estimateGas(_tx) {\n        let tx = this._getTransactionRequest(_tx);\n        if (isPromise(tx)) {\n            tx = await tx;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.getBigInt)(await (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _perform, perform).call(this, {\n            method: \"estimateGas\",\n            transaction: tx\n        }), \"%response\");\n    }\n    async call(_tx) {\n        const { tx, blockTag } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            tx: this._getTransactionRequest(_tx),\n            blockTag: this._getBlockTag(_tx.blockTag)\n        });\n        return await (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _checkNetwork, checkNetwork).call(this, (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _call, call).call(this, tx, blockTag, _tx.enableCcipRead ? 0 : -1));\n    }\n    async getBalance(address, blockTag) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.getBigInt)(await (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _getAccountValue, getAccountValue).call(this, {\n            method: \"getBalance\"\n        }, address, blockTag), \"%response\");\n    }\n    async getTransactionCount(address, blockTag) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.getNumber)(await (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _getAccountValue, getAccountValue).call(this, {\n            method: \"getTransactionCount\"\n        }, address, blockTag), \"%response\");\n    }\n    async getCode(address, blockTag) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(await (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _getAccountValue, getAccountValue).call(this, {\n            method: \"getCode\"\n        }, address, blockTag));\n    }\n    async getStorage(address, _position, blockTag) {\n        const position = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.getBigInt)(_position, \"position\");\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(await (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _getAccountValue, getAccountValue).call(this, {\n            method: \"getStorage\",\n            position\n        }, address, blockTag));\n    }\n    // Write\n    async broadcastTransaction(signedTx) {\n        const { blockNumber, hash, network } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            blockNumber: this.getBlockNumber(),\n            hash: this._perform({\n                method: \"broadcastTransaction\",\n                signedTransaction: signedTx\n            }),\n            network: this.getNetwork()\n        });\n        const tx = _transaction_index_js__WEBPACK_IMPORTED_MODULE_11__.Transaction.from(signedTx);\n        if (tx.hash !== hash) {\n            throw new Error(\"@TODO: the returned hash did not match\");\n        }\n        return this._wrapTransactionResponse(tx, network).replaceableTransaction(blockNumber);\n    }\n    // Queries\n    async getBlock(block, prefetchTxs) {\n        const { network, params } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            network: this.getNetwork(),\n            params: (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _getBlock, getBlock).call(this, block, !!prefetchTxs)\n        });\n        if (params == null) {\n            return null;\n        }\n        return this._wrapBlock(params, network);\n    }\n    async getTransaction(hash) {\n        const { network, params } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            network: this.getNetwork(),\n            params: (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _perform, perform).call(this, {\n                method: \"getTransaction\",\n                hash\n            })\n        });\n        if (params == null) {\n            return null;\n        }\n        return this._wrapTransactionResponse(params, network);\n    }\n    async getTransactionReceipt(hash) {\n        const { network, params } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            network: this.getNetwork(),\n            params: (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _perform, perform).call(this, {\n                method: \"getTransactionReceipt\",\n                hash\n            })\n        });\n        if (params == null) {\n            return null;\n        }\n        // Some backends did not backfill the effectiveGasPrice into old transactions\n        // in the receipt, so we look it up manually and inject it.\n        if (params.gasPrice == null && params.effectiveGasPrice == null) {\n            const tx = await (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _perform, perform).call(this, {\n                method: \"getTransaction\",\n                hash\n            });\n            if (tx == null) {\n                throw new Error(\"report this; could not find tx or effectiveGasPrice\");\n            }\n            params.effectiveGasPrice = tx.gasPrice;\n        }\n        return this._wrapTransactionReceipt(params, network);\n    }\n    async getTransactionResult(hash) {\n        const { result } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            network: this.getNetwork(),\n            result: (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _perform, perform).call(this, {\n                method: \"getTransactionResult\",\n                hash\n            })\n        });\n        if (result == null) {\n            return null;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(result);\n    }\n    // Bloom-filter Queries\n    async getLogs(_filter) {\n        let filter = this._getFilter(_filter);\n        if (isPromise(filter)) {\n            filter = await filter;\n        }\n        const { network, params } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            network: this.getNetwork(),\n            params: (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _perform, perform).call(this, {\n                method: \"getLogs\",\n                filter\n            })\n        });\n        return params.map((p)=>this._wrapLog(p, network));\n    }\n    // ENS\n    _getProvider(chainId) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"provider cannot connect to target network\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"_getProvider()\"\n        });\n    }\n    async getResolver(name) {\n        return await _ens_resolver_js__WEBPACK_IMPORTED_MODULE_12__.EnsResolver.fromName(this, name);\n    }\n    async getAvatar(name) {\n        const resolver = await this.getResolver(name);\n        if (resolver) {\n            return await resolver.getAvatar();\n        }\n        return null;\n    }\n    async resolveName(name) {\n        const resolver = await this.getResolver(name);\n        if (resolver) {\n            return await resolver.getAddress();\n        }\n        return null;\n    }\n    async lookupAddress(address) {\n        address = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_13__.getAddress)(address);\n        const node = (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_14__.namehash)(address.substring(2).toLowerCase() + \".addr.reverse\");\n        try {\n            const ensAddr = await _ens_resolver_js__WEBPACK_IMPORTED_MODULE_12__.EnsResolver.getEnsAddress(this);\n            const ensContract = new _contract_index_js__WEBPACK_IMPORTED_MODULE_15__.Contract(ensAddr, [\n                \"function resolver(bytes32) view returns (address)\"\n            ], this);\n            const resolver = await ensContract.resolver(node);\n            if (resolver == null || resolver === _constants_index_js__WEBPACK_IMPORTED_MODULE_16__.ZeroAddress) {\n                return null;\n            }\n            const resolverContract = new _contract_index_js__WEBPACK_IMPORTED_MODULE_15__.Contract(resolver, [\n                \"function name(bytes32) view returns (string)\"\n            ], this);\n            const name = await resolverContract.name(node);\n            // Failed forward resolution\n            const check = await this.resolveName(name);\n            if (check !== address) {\n                return null;\n            }\n            return name;\n        } catch (error) {\n            // No data was returned from the resolver\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isError)(error, \"BAD_DATA\") && error.value === \"0x\") {\n                return null;\n            }\n            // Something reerted\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isError)(error, \"CALL_EXCEPTION\")) {\n                return null;\n            }\n            throw error;\n        }\n        return null;\n    }\n    async waitForTransaction(hash, _confirms, timeout) {\n        const confirms = _confirms != null ? _confirms : 1;\n        if (confirms === 0) {\n            return this.getTransactionReceipt(hash);\n        }\n        return new Promise(async (resolve, reject)=>{\n            let timer = null;\n            const listener = async (blockNumber)=>{\n                try {\n                    const receipt = await this.getTransactionReceipt(hash);\n                    if (receipt != null) {\n                        if (blockNumber - receipt.blockNumber + 1 >= confirms) {\n                            resolve(receipt);\n                            //this.off(\"block\", listener);\n                            if (timer) {\n                                clearTimeout(timer);\n                                timer = null;\n                            }\n                            return;\n                        }\n                    }\n                } catch (error) {\n                    console.log(\"EEE\", error);\n                }\n                this.once(\"block\", listener);\n            };\n            if (timeout != null) {\n                timer = setTimeout(()=>{\n                    if (timer == null) {\n                        return;\n                    }\n                    timer = null;\n                    this.off(\"block\", listener);\n                    reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"timeout\", \"TIMEOUT\", {\n                        reason: \"timeout\"\n                    }));\n                }, timeout);\n            }\n            listener(await this.getBlockNumber());\n        });\n    }\n    async waitForBlock(blockTag) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"not implemented yet\", \"NOT_IMPLEMENTED\", {\n            operation: \"waitForBlock\"\n        });\n    }\n    /**\n     *  Clear a timer created using the [[_setTimeout]] method.\n     */ _clearTimeout(timerId) {\n        const timer = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _timers).get(timerId);\n        if (!timer) {\n            return;\n        }\n        if (timer.timer) {\n            clearTimeout(timer.timer);\n        }\n        (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _timers).delete(timerId);\n    }\n    /**\n     *  Create a timer that will execute %%func%% after at least %%timeout%%\n     *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute\n     *  in the next event loop.\n     *\n     *  [Pausing](AbstractProvider-paused) the provider will pause any\n     *  associated timers.\n     */ _setTimeout(_func, timeout) {\n        if (timeout == null) {\n            timeout = 0;\n        }\n        const timerId = (0,_swc_helpers_class_private_field_update__WEBPACK_IMPORTED_MODULE_17__._)(this, _nextTimer).value++;\n        const func = ()=>{\n            (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _timers).delete(timerId);\n            _func();\n        };\n        if (this.paused) {\n            (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _timers).set(timerId, {\n                timer: null,\n                func,\n                time: timeout\n            });\n        } else {\n            const timer = setTimeout(func, timeout);\n            (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _timers).set(timerId, {\n                timer,\n                func,\n                time: getTime()\n            });\n        }\n        return timerId;\n    }\n    /**\n     *  Perform %%func%% on each subscriber.\n     */ _forEachSubscriber(func) {\n        for (const sub of (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _subs).values()){\n            func(sub.subscriber);\n        }\n    }\n    /**\n     *  Sub-classes may override this to customize subscription\n     *  implementations.\n     */ _getSubscriber(sub) {\n        switch(sub.type){\n            case \"debug\":\n            case \"error\":\n            case \"network\":\n                return new UnmanagedSubscriber(sub.type);\n            case \"block\":\n                {\n                    const subscriber = new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_18__.PollingBlockSubscriber(this);\n                    subscriber.pollingInterval = this.pollingInterval;\n                    return subscriber;\n                }\n            case \"safe\":\n            case \"finalized\":\n                return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_18__.PollingBlockTagSubscriber(this, sub.type);\n            case \"event\":\n                return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_18__.PollingEventSubscriber(this, sub.filter);\n            case \"transaction\":\n                return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_18__.PollingTransactionSubscriber(this, sub.hash);\n            case \"orphan\":\n                return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_18__.PollingOrphanSubscriber(this, sub.filter);\n        }\n        throw new Error(\"unsupported event: \".concat(sub.type));\n    }\n    /**\n     *  If a [[Subscriber]] fails and needs to replace itself, this\n     *  method may be used.\n     *\n     *  For example, this is used for providers when using the\n     *  ``eth_getFilterChanges`` method, which can return null if state\n     *  filters are not supported by the backend, allowing the Subscriber\n     *  to swap in a [[PollingEventSubscriber]].\n     */ _recoverSubscriber(oldSub, newSub) {\n        for (const sub of (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _subs).values()){\n            if (sub.subscriber === oldSub) {\n                if (sub.started) {\n                    sub.subscriber.stop();\n                }\n                sub.subscriber = newSub;\n                if (sub.started) {\n                    newSub.start();\n                }\n                if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _pausedState) != null) {\n                    newSub.pause((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _pausedState));\n                }\n                break;\n            }\n        }\n    }\n    async on(event, listener) {\n        const sub = await (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _getSub, getSub).call(this, event);\n        sub.listeners.push({\n            listener,\n            once: false\n        });\n        if (!sub.started) {\n            sub.subscriber.start();\n            sub.started = true;\n            if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _pausedState) != null) {\n                sub.subscriber.pause((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _pausedState));\n            }\n        }\n        return this;\n    }\n    async once(event, listener) {\n        const sub = await (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _getSub, getSub).call(this, event);\n        sub.listeners.push({\n            listener,\n            once: true\n        });\n        if (!sub.started) {\n            sub.subscriber.start();\n            sub.started = true;\n            if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _pausedState) != null) {\n                sub.subscriber.pause((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _pausedState));\n            }\n        }\n        return this;\n    }\n    async emit(event) {\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        const sub = await (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _hasSub, hasSub).call(this, event, args);\n        // If there is not subscription or if a recent emit removed\n        // the last of them (which also deleted the sub) do nothing\n        if (!sub || sub.listeners.length === 0) {\n            return false;\n        }\n        ;\n        const count = sub.listeners.length;\n        sub.listeners = sub.listeners.filter((param)=>{\n            let { listener, once } = param;\n            const payload = new _utils_index_js__WEBPACK_IMPORTED_MODULE_19__.EventPayload(this, once ? null : listener, event);\n            try {\n                listener.call(this, ...args, payload);\n            } catch (error) {}\n            return !once;\n        });\n        if (sub.listeners.length === 0) {\n            if (sub.started) {\n                sub.subscriber.stop();\n            }\n            (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _subs).delete(sub.tag);\n        }\n        return count > 0;\n    }\n    async listenerCount(event) {\n        if (event) {\n            const sub = await (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _hasSub, hasSub).call(this, event);\n            if (!sub) {\n                return 0;\n            }\n            return sub.listeners.length;\n        }\n        let total = 0;\n        for (const { listeners } of (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _subs).values()){\n            total += listeners.length;\n        }\n        return total;\n    }\n    async listeners(event) {\n        if (event) {\n            const sub = await (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _hasSub, hasSub).call(this, event);\n            if (!sub) {\n                return [];\n            }\n            return sub.listeners.map((param)=>{\n                let { listener } = param;\n                return listener;\n            });\n        }\n        let result = [];\n        for (const { listeners } of (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _subs).values()){\n            result = result.concat(listeners.map((param)=>{\n                let { listener } = param;\n                return listener;\n            }));\n        }\n        return result;\n    }\n    async off(event, listener) {\n        const sub = await (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _hasSub, hasSub).call(this, event);\n        if (!sub) {\n            return this;\n        }\n        if (listener) {\n            const index = sub.listeners.map((param)=>{\n                let { listener } = param;\n                return listener;\n            }).indexOf(listener);\n            if (index >= 0) {\n                sub.listeners.splice(index, 1);\n            }\n        }\n        if (!listener || sub.listeners.length === 0) {\n            if (sub.started) {\n                sub.subscriber.stop();\n            }\n            (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _subs).delete(sub.tag);\n        }\n        return this;\n    }\n    async removeAllListeners(event) {\n        if (event) {\n            const { tag, started, subscriber } = await (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _getSub, getSub).call(this, event);\n            if (started) {\n                subscriber.stop();\n            }\n            (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _subs).delete(tag);\n        } else {\n            for (const [tag, { started, subscriber }] of (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _subs)){\n                if (started) {\n                    subscriber.stop();\n                }\n                (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _subs).delete(tag);\n            }\n        }\n        return this;\n    }\n    // Alias for \"on\"\n    async addListener(event, listener) {\n        return await this.on(event, listener);\n    }\n    // Alias for \"off\"\n    async removeListener(event, listener) {\n        return this.off(event, listener);\n    }\n    /**\n     *  If this provider has been destroyed using the [[destroy]] method.\n     *\n     *  Once destroyed, all resources are reclaimed, internal event loops\n     *  and timers are cleaned up and no further requests may be sent to\n     *  the provider.\n     */ get destroyed() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _destroyed);\n    }\n    /**\n     *  Sub-classes may use this to shutdown any sockets or release their\n     *  resources and reject any pending requests.\n     *\n     *  Sub-classes **must** call ``super.destroy()``.\n     */ destroy() {\n        // Stop all listeners\n        this.removeAllListeners();\n        // Shut down all tiemrs\n        for (const timerId of (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _timers).keys()){\n            this._clearTimeout(timerId);\n        }\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _destroyed, true);\n    }\n    /**\n     *  Whether the provider is currently paused.\n     *\n     *  A paused provider will not emit any events, and generally should\n     *  not make any requests to the network, but that is up to sub-classes\n     *  to manage.\n     *\n     *  Setting ``paused = true`` is identical to calling ``.pause(false)``,\n     *  which will buffer any events that occur while paused until the\n     *  provider is unpaused.\n     */ get paused() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _pausedState) != null;\n    }\n    set paused(pause) {\n        if (!!pause === this.paused) {\n            return;\n        }\n        if (this.paused) {\n            this.resume();\n        } else {\n            this.pause(false);\n        }\n    }\n    /**\n     *  Pause the provider. If %%dropWhilePaused%%, any events that occur\n     *  while paused are dropped, otherwise all events will be emitted once\n     *  the provider is unpaused.\n     */ pause(dropWhilePaused) {\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _lastBlockNumber, -1);\n        if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _pausedState) != null) {\n            if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _pausedState) == !!dropWhilePaused) {\n                return;\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"cannot change pause type; resume first\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"pause\"\n            });\n        }\n        this._forEachSubscriber((s)=>s.pause(dropWhilePaused));\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _pausedState, !!dropWhilePaused);\n        for (const timer of (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _timers).values()){\n            // Clear the timer\n            if (timer.timer) {\n                clearTimeout(timer.timer);\n            }\n            // Remaining time needed for when we become unpaused\n            timer.time = getTime() - timer.time;\n        }\n    }\n    /**\n     *  Resume the provider.\n     */ resume() {\n        if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _pausedState) == null) {\n            return;\n        }\n        this._forEachSubscriber((s)=>s.resume());\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _pausedState, null);\n        for (const timer of (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _timers).values()){\n            // Remaining time when we were paused\n            let timeout = timer.time;\n            if (timeout < 0) {\n                timeout = 0;\n            }\n            // Start time (in cause paused, so we con compute remaininf time)\n            timer.time = getTime();\n            // Start the timer\n            setTimeout(timer.func, timeout);\n        }\n    }\n    /**\n     *  Create a new **AbstractProvider** connected to %%network%%, or\n     *  use the various network detection capabilities to discover the\n     *  [[Network]] if necessary.\n     */ constructor(_network, options){\n        // Shares multiple identical requests made during the same 250ms\n        (0,_swc_helpers_class_private_method_init__WEBPACK_IMPORTED_MODULE_20__._)(this, _perform);\n        (0,_swc_helpers_class_private_method_init__WEBPACK_IMPORTED_MODULE_20__._)(this, _call);\n        (0,_swc_helpers_class_private_method_init__WEBPACK_IMPORTED_MODULE_20__._)(this, _checkNetwork);\n        // Account\n        (0,_swc_helpers_class_private_method_init__WEBPACK_IMPORTED_MODULE_20__._)(this, _getAccountValue);\n        (0,_swc_helpers_class_private_method_init__WEBPACK_IMPORTED_MODULE_20__._)(this, _getBlock);\n        (0,_swc_helpers_class_private_method_init__WEBPACK_IMPORTED_MODULE_20__._)(this, _hasSub);\n        (0,_swc_helpers_class_private_method_init__WEBPACK_IMPORTED_MODULE_20__._)(this, _getSub);\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_21__._)(this, _subs, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_21__._)(this, _plugins, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_21__._)(this, _pausedState, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_21__._)(this, _destroyed, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_21__._)(this, _networkPromise, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_21__._)(this, _anyNetwork, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_21__._)(this, _performCache, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_21__._)(this, _lastBlockNumber, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_21__._)(this, _nextTimer, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_21__._)(this, _timers, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_21__._)(this, _disableCcipRead, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_21__._)(this, _options, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _options, Object.assign({}, defaultOptions, options || {}));\n        if (_network === \"any\") {\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _anyNetwork, true);\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _networkPromise, null);\n        } else if (_network) {\n            const network = _network_js__WEBPACK_IMPORTED_MODULE_22__.Network.from(_network);\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _anyNetwork, false);\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _networkPromise, Promise.resolve(network));\n            setTimeout(()=>{\n                this.emit(\"network\", network, null);\n            }, 0);\n        } else {\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _anyNetwork, false);\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _networkPromise, null);\n        }\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _lastBlockNumber, -1);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _performCache, new Map());\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _subs, new Map());\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _plugins, new Map());\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _pausedState, null);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _destroyed, false);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _nextTimer, 1);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _timers, new Map());\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _disableCcipRead, false);\n    }\n}\nasync function perform(req) {\n    const timeout = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _options).cacheTimeout;\n    // Caching disabled\n    if (timeout < 0) {\n        return await this._perform(req);\n    }\n    // Create a tag\n    const tag = getTag(req.method, req);\n    let perform = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _performCache).get(tag);\n    if (!perform) {\n        perform = this._perform(req);\n        (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _performCache).set(tag, perform);\n        setTimeout(()=>{\n            if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _performCache).get(tag) === perform) {\n                (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _performCache).delete(tag);\n            }\n        }, timeout);\n    }\n    return await perform;\n}\nasync function call(tx, blockTag, attempt) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(attempt < MAX_CCIP_REDIRECTS, \"CCIP read exceeded maximum redirections\", \"OFFCHAIN_FAULT\", {\n        reason: \"TOO_MANY_REDIRECTS\",\n        transaction: Object.assign({}, tx, {\n            blockTag,\n            enableCcipRead: true\n        })\n    });\n    // This came in as a PerformActionTransaction, so to/from are safe; we can cast\n    const transaction = (0,_provider_js__WEBPACK_IMPORTED_MODULE_7__.copyRequest)(tx);\n    try {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(await this._perform({\n            method: \"call\",\n            transaction,\n            blockTag\n        }));\n    } catch (error) {\n        // CCIP Read OffchainLookup\n        if (!this.disableCcipRead && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isCallException)(error) && error.data && attempt >= 0 && blockTag === \"latest\" && transaction.to != null && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(error.data, 0, 4) === \"0x556f1830\") {\n            const data = error.data;\n            const txSender = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(transaction.to, this);\n            // Parse the CCIP Read Arguments\n            let ccipArgs;\n            try {\n                ccipArgs = parseOffchainLookup((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(error.data, 4));\n            } catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, error.message, \"OFFCHAIN_FAULT\", {\n                    reason: \"BAD_DATA\",\n                    transaction,\n                    info: {\n                        data\n                    }\n                });\n            }\n            // Check the sender of the OffchainLookup matches the transaction\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(), \"CCIP Read sender mismatch\", \"CALL_EXCEPTION\", {\n                action: \"call\",\n                data,\n                reason: \"OffchainLookup\",\n                transaction: transaction,\n                invocation: null,\n                revert: {\n                    signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                    name: \"OffchainLookup\",\n                    args: ccipArgs.errorArgs\n                }\n            });\n            const ccipResult = await this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(ccipResult != null, \"CCIP Read failed to fetch data\", \"OFFCHAIN_FAULT\", {\n                reason: \"FETCH_FAILED\",\n                transaction,\n                info: {\n                    data: error.data,\n                    errorArgs: ccipArgs.errorArgs\n                }\n            });\n            const tx = {\n                to: txSender,\n                data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.concat)([\n                    ccipArgs.selector,\n                    encodeBytes([\n                        ccipResult,\n                        ccipArgs.extraData\n                    ])\n                ])\n            };\n            this.emit(\"debug\", {\n                action: \"sendCcipReadCall\",\n                transaction: tx\n            });\n            try {\n                const result = await (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _call, call).call(this, tx, blockTag, attempt + 1);\n                this.emit(\"debug\", {\n                    action: \"receiveCcipReadCallResult\",\n                    transaction: Object.assign({}, tx),\n                    result\n                });\n                return result;\n            } catch (error) {\n                this.emit(\"debug\", {\n                    action: \"receiveCcipReadCallError\",\n                    transaction: Object.assign({}, tx),\n                    error\n                });\n                throw error;\n            }\n        }\n        throw error;\n    }\n}\nasync function checkNetwork(promise) {\n    const { value } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n        network: this.getNetwork(),\n        value: promise\n    });\n    return value;\n}\nasync function getAccountValue(request, _address, _blockTag) {\n    let address = this._getAddress(_address);\n    let blockTag = this._getBlockTag(_blockTag);\n    if (typeof address !== \"string\" || typeof blockTag !== \"string\") {\n        [address, blockTag] = await Promise.all([\n            address,\n            blockTag\n        ]);\n    }\n    return await (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _checkNetwork, checkNetwork).call(this, (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _perform, perform).call(this, Object.assign(request, {\n        address,\n        blockTag\n    })));\n}\nasync function getBlock(block, includeTransactions) {\n    // @TODO: Add CustomBlockPlugin check\n    if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(block, 32)) {\n        return await (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _perform, perform).call(this, {\n            method: \"getBlock\",\n            blockHash: block,\n            includeTransactions\n        });\n    }\n    let blockTag = this._getBlockTag(block);\n    if (typeof blockTag !== \"string\") {\n        blockTag = await blockTag;\n    }\n    return await (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _perform, perform).call(this, {\n        method: \"getBlock\",\n        blockTag,\n        includeTransactions\n    });\n}\nasync function hasSub(event, emitArgs) {\n    let sub = await getSubscription(event, this);\n    // This is a log that is removing an existing log; we actually want\n    // to emit an orphan event for the removed log\n    if (sub.type === \"event\" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true) {\n        sub = await getSubscription({\n            orphan: \"drop-log\",\n            log: emitArgs[0]\n        }, this);\n    }\n    return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _subs).get(sub.tag) || null;\n}\nasync function getSub(event) {\n    const subscription = await getSubscription(event, this);\n    // Prevent tampering with our tag in any subclass' _getSubscriber\n    const tag = subscription.tag;\n    let sub = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _subs).get(tag);\n    if (!sub) {\n        const subscriber = this._getSubscriber(subscription);\n        const addressableMap = new WeakMap();\n        const nameMap = new Map();\n        sub = {\n            subscriber,\n            tag,\n            addressableMap,\n            nameMap,\n            started: false,\n            listeners: []\n        };\n        (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _subs).set(tag, sub);\n    }\n    return sub;\n}\nfunction _parseString(result, start) {\n    try {\n        const bytes = _parseBytes(result, start);\n        if (bytes) {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_23__.toUtf8String)(bytes);\n        }\n    } catch (error) {}\n    return null;\n}\nfunction _parseBytes(result, start) {\n    if (result === \"0x\") {\n        return null;\n    }\n    try {\n        const offset = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.getNumber)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(result, start, start + 32));\n        const length = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.getNumber)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(result, offset, offset + 32));\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(result, offset + 32, offset + 32 + length);\n    } catch (error) {}\n    return null;\n}\nfunction numPad(value) {\n    const result = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.toBeArray)(value);\n    if (result.length > 32) {\n        throw new Error(\"internal; should not happen\");\n    }\n    const padded = new Uint8Array(32);\n    padded.set(result, 32 - result.length);\n    return padded;\n}\nfunction bytesPad(value) {\n    if (value.length % 32 === 0) {\n        return value;\n    }\n    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);\n    result.set(value);\n    return result;\n}\nconst empty = new Uint8Array([]);\n// ABI Encodes a series of (bytes, bytes, ...)\nfunction encodeBytes(datas) {\n    const result = [];\n    let byteCount = 0;\n    // Add place-holders for pointers as we add items\n    for(let i = 0; i < datas.length; i++){\n        result.push(empty);\n        byteCount += 32;\n    }\n    for(let i = 0; i < datas.length; i++){\n        const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(datas[i]);\n        // Update the bytes offset\n        result[i] = numPad(byteCount);\n        // The length and padded value of data\n        result.push(numPad(data.length));\n        result.push(bytesPad(data));\n        byteCount += 32 + Math.ceil(data.length / 32) * 32;\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.concat)(result);\n}\nconst zeros = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\nfunction parseOffchainLookup(data) {\n    const result = {\n        sender: \"\",\n        urls: [],\n        calldata: \"\",\n        selector: \"\",\n        extraData: \"\",\n        errorArgs: []\n    };\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataLength)(data) >= 5 * 32, \"insufficient OffchainLookup data\", \"OFFCHAIN_FAULT\", {\n        reason: \"insufficient OffchainLookup data\"\n    });\n    const sender = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, 0, 32);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(sender, 0, 12) === (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(zeros, 0, 12), \"corrupt OffchainLookup sender\", \"OFFCHAIN_FAULT\", {\n        reason: \"corrupt OffchainLookup sender\"\n    });\n    result.sender = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(sender, 12);\n    // Read the URLs from the response\n    try {\n        const urls = [];\n        const urlsOffset = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.getNumber)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, 32, 64));\n        const urlsLength = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.getNumber)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, urlsOffset, urlsOffset + 32));\n        const urlsData = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, urlsOffset + 32);\n        for(let u = 0; u < urlsLength; u++){\n            const url = _parseString(urlsData, u * 32);\n            if (url == null) {\n                throw new Error(\"abort\");\n            }\n            urls.push(url);\n        }\n        result.urls = urls;\n    } catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"corrupt OffchainLookup urls\", \"OFFCHAIN_FAULT\", {\n            reason: \"corrupt OffchainLookup urls\"\n        });\n    }\n    // Get the CCIP calldata to forward\n    try {\n        const calldata = _parseBytes(data, 64);\n        if (calldata == null) {\n            throw new Error(\"abort\");\n        }\n        result.calldata = calldata;\n    } catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"corrupt OffchainLookup calldata\", \"OFFCHAIN_FAULT\", {\n            reason: \"corrupt OffchainLookup calldata\"\n        });\n    }\n    // Get the callbackSelector (bytes4)\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, 100, 128) === (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(zeros, 0, 28), \"corrupt OffchainLookup callbaackSelector\", \"OFFCHAIN_FAULT\", {\n        reason: \"corrupt OffchainLookup callbaackSelector\"\n    });\n    result.selector = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, 96, 100);\n    // Get the extra data to send back to the contract as context\n    try {\n        const extraData = _parseBytes(data, 128);\n        if (extraData == null) {\n            throw new Error(\"abort\");\n        }\n        result.extraData = extraData;\n    } catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"corrupt OffchainLookup extraData\", \"OFFCHAIN_FAULT\", {\n            reason: \"corrupt OffchainLookup extraData\"\n        });\n    }\n    result.errorArgs = \"sender,urls,calldata,selector,extraData\".split(/,/).map((k)=>result[k]);\n    return result;\n} //# sourceMappingURL=abstract-provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7O0NBTUMsR0FDRCxRQUFRO0FBQ1Isb0JBQW9CO0FBQ3BCLDRFQUE0RTtBQUM1RSw0RUFBNEU7QUFDNUUsNkVBQTZFO0FBQzdFLDZFQUE2RTtBQUM3RSwyRUFBMkU7Ozs7Ozs7QUFDVjtBQUNiO0FBQ0o7QUFDSjtBQUNVO0FBQ3FPO0FBQzNPO0FBQzBEO0FBQ25FO0FBQ21FO0FBQ2lFO0FBQzNLLFlBQVk7QUFDWixNQUFNMkMsT0FBT0MsT0FBTztBQUNwQixNQUFNQyxxQkFBcUI7QUFDM0IsU0FBU0MsVUFBVUMsS0FBSztJQUNwQixPQUFRQSxTQUFTLE9BQVFBLE1BQU1DLElBQUksS0FBTTtBQUM3QztBQUNBLFNBQVNDLE9BQU9DLE1BQU0sRUFBRUgsS0FBSztJQUN6QixPQUFPRyxTQUFTLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQ0wsT0FBTyxDQUFDTSxHQUFHQztRQUM1QyxJQUFJQSxLQUFLLE1BQU07WUFDWCxPQUFPO1FBQ1g7UUFDQSxJQUFJLE9BQVFBLE1BQU8sVUFBVTtZQUN6QixPQUFPLFVBQXVCLE9BQWJBLEVBQUVDLFFBQVE7UUFDL0I7UUFDQSxJQUFJLE9BQVFELE1BQU8sVUFBVTtZQUN6QixPQUFPQSxFQUFFRSxXQUFXO1FBQ3hCO1FBQ0EsbUJBQW1CO1FBQ25CLElBQUksT0FBUUYsTUFBTyxZQUFZLENBQUNHLE1BQU1DLE9BQU8sQ0FBQ0osSUFBSTtZQUM5QyxNQUFNSyxPQUFPQyxPQUFPRCxJQUFJLENBQUNMO1lBQ3pCSyxLQUFLRSxJQUFJO1lBQ1QsT0FBT0YsS0FBS0csTUFBTSxDQUFDLENBQUNDLE9BQU9DO2dCQUN2QkQsS0FBSyxDQUFDQyxJQUFJLEdBQUdWLENBQUMsQ0FBQ1UsSUFBSTtnQkFDbkIsT0FBT0Q7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QUFHQTtJQUNsQixFQUNBLE9BQU9rQixPQUFPO1FBQ1YzSCx1REFBTUEsQ0FBQyxPQUFPLCtCQUErQixrQkFBa0I7WUFDM0RnSSxRQUFRO1FBQ1o7SUFDSjtJQUNBLG1DQUFtQztJQUNuQyxJQUFJO1FBQ0EsTUFBTXhCLFdBQVdpTSxZQUFZN0wsTUFBTTtRQUNuQyxJQUFJSixZQUFZLE1BQU07WUFDbEIsTUFBTSxJQUFJdEMsTUFBTTtRQUNwQjtRQUNBMkQsT0FBT3JCLFFBQVEsR0FBR0E7SUFDdEIsRUFDQSxPQUFPbUIsT0FBTztRQUNWM0gsdURBQU1BLENBQUMsT0FBTyxtQ0FBbUMsa0JBQWtCO1lBQy9EZ0ksUUFBUTtRQUNaO0lBQ0o7SUFDQSxvQ0FBb0M7SUFDcENoSSx1REFBTUEsQ0FBQ1QsMERBQVNBLENBQUNxSCxNQUFNLEtBQUssU0FBU3JILDBEQUFTQSxDQUFDNlQsT0FBTyxHQUFHLEtBQUssNENBQTRDLGtCQUFrQjtRQUN4SHBMLFFBQVE7SUFDWjtJQUNBSCxPQUFPOEosUUFBUSxHQUFHcFMsMERBQVNBLENBQUNxSCxNQUFNLElBQUk7SUFDdEMsNkRBQTZEO0lBQzdELElBQUk7UUFDQSxNQUFNaUwsWUFBWVksWUFBWTdMLE1BQU07UUFDcEMsSUFBSWlMLGFBQWEsTUFBTTtZQUNuQixNQUFNLElBQUkzTixNQUFNO1FBQ3BCO1FBQ0EyRCxPQUFPZ0ssU0FBUyxHQUFHQTtJQUN2QixFQUNBLE9BQU9sSyxPQUFPO1FBQ1YzSCx1REFBTUEsQ0FBQyxPQUFPLG9DQUFvQyxrQkFBa0I7WUFDaEVnSSxRQUFRO1FBQ1o7SUFDSjtJQUNBSCxPQUFPNEosU0FBUyxHQUFHLDBDQUEwQ2dDLEtBQUssQ0FBQyxLQUFLOU8sR0FBRyxDQUFDLENBQUN2QyxJQUFNeUYsTUFBTSxDQUFDekYsRUFBRTtJQUM1RixPQUFPeUY7QUFDWCxFQUNBLDZDQUE2QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyLmpzPzFlYTkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgVGhlIGF2YWlsYWJsZSBwcm92aWRlcnMgc2hvdWxkIHN1ZmZpY2UgZm9yIG1vc3QgZGV2ZWxvcGVycyBwdXJwb3NlcyxcbiAqICBidXQgdGhlIFtbQWJzdHJhY3RQcm92aWRlcl1dIGNsYXNzIGhhcyBtYW55IGZlYXR1cmVzIHdoaWNoIGVuYWJsZVxuICogIHN1Yi1jbGFzc2luZyBpdCBmb3Igc3BlY2lmaWMgcHVycG9zZXMuXG4gKlxuICogIEBfc2VjdGlvbjogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlcjogU3ViY2xhc3NpbmcgUHJvdmlkZXIgIFthYnN0cmFjdC1wcm92aWRlcl1cbiAqL1xuLy8gQFRPRE9cbi8vIEV2ZW50IGNvYWxlc2NlbmNlXG4vLyAgIFdoZW4gd2UgcmVnaXN0ZXIgYW4gZXZlbnQgd2l0aCBhbiBhc3luYyB2YWx1ZSAoZS5nLiBhZGRyZXNzIGlzIGEgU2lnbmVyXG4vLyAgIG9yIEVOUyBuYW1lKSwgd2UgbmVlZCB0byBhZGQgaXQgaW1tZWlkYXRlbHkgZm9yIHRoZSBFdmVudCBBUEksIGJ1dCBhbHNvXG4vLyAgIG5lZWQgdGltZSB0byByZXNvbHZlIHRoZSBhZGRyZXNzLiBVcG9uIHJlc29sdmluZyB0aGUgYWRkcmVzcywgd2UgbmVlZCB0b1xuLy8gICBtaWdyYXRlIHRoZSBsaXN0ZW5lciB0byB0aGUgc3RhdGljIGV2ZW50LiBXZSBhbHNvIG5lZWQgdG8gbWFpbnRhaW4gYSBtYXBcbi8vICAgb2YgU2lnbmVyL0VOUyBuYW1lIHRvIGFkZHJlc3Mgc28gd2UgY2FuIHN5bmMgcmVzcG9uZCB0byBsaXN0ZW5lckNvdW50LlxuaW1wb3J0IHsgZ2V0QWRkcmVzcywgcmVzb2x2ZUFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgWmVyb0FkZHJlc3MgfSBmcm9tIFwiLi4vY29uc3RhbnRzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBDb250cmFjdCB9IGZyb20gXCIuLi9jb250cmFjdC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgbmFtZWhhc2ggfSBmcm9tIFwiLi4vaGFzaC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcbmltcG9ydCB7IGNvbmNhdCwgZGF0YUxlbmd0aCwgZGF0YVNsaWNlLCBoZXhsaWZ5LCBpc0hleFN0cmluZywgZ2V0QmlnSW50LCBnZXRCeXRlcywgZ2V0TnVtYmVyLCBpc0NhbGxFeGNlcHRpb24sIGlzRXJyb3IsIG1ha2VFcnJvciwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCwgRmV0Y2hSZXF1ZXN0LCB0b0JlQXJyYXksIHRvUXVhbnRpdHksIGRlZmluZVByb3BlcnRpZXMsIEV2ZW50UGF5bG9hZCwgcmVzb2x2ZVByb3BlcnRpZXMsIHRvVXRmOFN0cmluZyB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgRW5zUmVzb2x2ZXIgfSBmcm9tIFwiLi9lbnMtcmVzb2x2ZXIuanNcIjtcbmltcG9ydCB7IGZvcm1hdEJsb2NrLCBmb3JtYXRMb2csIGZvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdCwgZm9ybWF0VHJhbnNhY3Rpb25SZXNwb25zZSB9IGZyb20gXCIuL2Zvcm1hdC5qc1wiO1xuaW1wb3J0IHsgTmV0d29yayB9IGZyb20gXCIuL25ldHdvcmsuanNcIjtcbmltcG9ydCB7IGNvcHlSZXF1ZXN0LCBCbG9jaywgRmVlRGF0YSwgTG9nLCBUcmFuc2FjdGlvblJlY2VpcHQsIFRyYW5zYWN0aW9uUmVzcG9uc2UgfSBmcm9tIFwiLi9wcm92aWRlci5qc1wiO1xuaW1wb3J0IHsgUG9sbGluZ0Jsb2NrU3Vic2NyaWJlciwgUG9sbGluZ0Jsb2NrVGFnU3Vic2NyaWJlciwgUG9sbGluZ0V2ZW50U3Vic2NyaWJlciwgUG9sbGluZ09ycGhhblN1YnNjcmliZXIsIFBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXIgfSBmcm9tIFwiLi9zdWJzY3JpYmVyLXBvbGxpbmcuanNcIjtcbi8vIENvbnN0YW50c1xuY29uc3QgQk5fMiA9IEJpZ0ludCgyKTtcbmNvbnN0IE1BWF9DQ0lQX1JFRElSRUNUUyA9IDEwO1xuZnVuY3Rpb24gaXNQcm9taXNlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLnRoZW4pID09PSBcImZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gZ2V0VGFnKHByZWZpeCwgdmFsdWUpIHtcbiAgICByZXR1cm4gcHJlZml4ICsgXCI6XCIgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgKGssIHYpID0+IHtcbiAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHYpID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gYGJpZ2ludDoke3YudG9TdHJpbmcoKX1gO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHYpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvcnQgb2JqZWN0IGtleXNcbiAgICAgICAgaWYgKHR5cGVvZiAodikgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2KTtcbiAgICAgICAgICAgIGtleXMuc29ydCgpO1xuICAgICAgICAgICAgcmV0dXJuIGtleXMucmVkdWNlKChhY2N1bSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgYWNjdW1ba2V5XSA9IHZba2V5XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfSk7XG59XG4vKipcbiAqICBBbiAqKlVubWFuYWdlZFN1YnNjcmliZXIqKiBpcyB1c2VmdWwgZm9yIGV2ZW50cyB3aGljaCBkbyBub3QgcmVxdWlyZVxuICogIGFueSBhZGRpdGlvbmFsIG1hbmFnZW1lbnQsIHN1Y2ggYXMgYGBcImRlYnVnXCJgYCB3aGljaCBvbmx5IHJlcXVpcmVzXG4gKiAgZW1pdCBpbiBzeW5jaHJvbm91cyBldmVudCBsb29wIHRyaWdnZXJlZCBjYWxscy5cbiAqL1xuZXhwb3J0IGNsYXNzIFVubWFuYWdlZFN1YnNjcmliZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBmb2YgdGhlIGV2ZW50LlxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyBVbm1hbmFnZWRTdWJzY3JpYmVyIHdpdGggJSVuYW1lJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSkgeyBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgbmFtZSB9KTsgfVxuICAgIHN0YXJ0KCkgeyB9XG4gICAgc3RvcCgpIHsgfVxuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkgeyB9XG4gICAgcmVzdW1lKCkgeyB9XG59XG5mdW5jdGlvbiBjb3B5KHZhbHVlKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGNvbmNpc2lmeShpdGVtcykge1xuICAgIGl0ZW1zID0gQXJyYXkuZnJvbSgobmV3IFNldChpdGVtcykpLnZhbHVlcygpKTtcbiAgICBpdGVtcy5zb3J0KCk7XG4gICAgcmV0dXJuIGl0ZW1zO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0U3Vic2NyaXB0aW9uKF9ldmVudCwgcHJvdmlkZXIpIHtcbiAgICBpZiAoX2V2ZW50ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBldmVudFwiKTtcbiAgICB9XG4gICAgLy8gTm9ybWFsaXplIHRvcGljIGFycmF5IGluZm8gYW4gRXZlbnRGaWx0ZXJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShfZXZlbnQpKSB7XG4gICAgICAgIF9ldmVudCA9IHsgdG9waWNzOiBfZXZlbnQgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAoX2V2ZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBzd2l0Y2ggKF9ldmVudCkge1xuICAgICAgICAgICAgY2FzZSBcImJsb2NrXCI6XG4gICAgICAgICAgICBjYXNlIFwiZGVidWdcIjpcbiAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgY2FzZSBcImZpbmFsaXplZFwiOlxuICAgICAgICAgICAgY2FzZSBcIm5ldHdvcmtcIjpcbiAgICAgICAgICAgIGNhc2UgXCJwZW5kaW5nXCI6XG4gICAgICAgICAgICBjYXNlIFwic2FmZVwiOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogX2V2ZW50LCB0YWc6IF9ldmVudCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc0hleFN0cmluZyhfZXZlbnQsIDMyKSkge1xuICAgICAgICBjb25zdCBoYXNoID0gX2V2ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwidHJhbnNhY3Rpb25cIiwgdGFnOiBnZXRUYWcoXCJ0eFwiLCB7IGhhc2ggfSksIGhhc2ggfTtcbiAgICB9XG4gICAgaWYgKF9ldmVudC5vcnBoYW4pIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBfZXZlbnQ7XG4gICAgICAgIC8vIEBUT0RPOiBTaG91bGQgbG93ZXJjYXNlIGFuZCB3aGF0bm90IHRoaW5ncyBoZXJlIGluc3RlYWQgb2YgY29weS4uLlxuICAgICAgICByZXR1cm4geyB0eXBlOiBcIm9ycGhhblwiLCB0YWc6IGdldFRhZyhcIm9ycGhhblwiLCBldmVudCksIGZpbHRlcjogY29weShldmVudCkgfTtcbiAgICB9XG4gICAgaWYgKChfZXZlbnQuYWRkcmVzcyB8fCBfZXZlbnQudG9waWNzKSkge1xuICAgICAgICBjb25zdCBldmVudCA9IF9ldmVudDtcbiAgICAgICAgY29uc3QgZmlsdGVyID0ge1xuICAgICAgICAgICAgdG9waWNzOiAoKGV2ZW50LnRvcGljcyB8fCBbXSkubWFwKCh0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbmNpc2lmeSh0Lm1hcCgodCkgPT4gdC50b0xvd2VyQ2FzZSgpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGV2ZW50LmFkZHJlc3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3NlcyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGFkZEFkZHJlc3MgPSAoYWRkcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpc0hleFN0cmluZyhhZGRyKSkge1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzZXMucHVzaChhZGRyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3Nlcy5wdXNoKGF3YWl0IHJlc29sdmVBZGRyZXNzKGFkZHIsIHByb3ZpZGVyKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudC5hZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgIGV2ZW50LmFkZHJlc3MuZm9yRWFjaChhZGRBZGRyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZEFkZHJlc3MoZXZlbnQuYWRkcmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsdGVyLmFkZHJlc3MgPSBjb25jaXNpZnkoYWRkcmVzc2VzLm1hcCgoYSkgPT4gYS50b0xvd2VyQ2FzZSgpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZmlsdGVyLCB0YWc6IGdldFRhZyhcImV2ZW50XCIsIGZpbHRlciksIHR5cGU6IFwiZXZlbnRcIiB9O1xuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bmtub3duIFByb3ZpZGVyRXZlbnRcIiwgXCJldmVudFwiLCBfZXZlbnQpO1xufVxuZnVuY3Rpb24gZ2V0VGltZSgpIHsgcmV0dXJuIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7IH1cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIGNhY2hlVGltZW91dDogMjUwLFxuICAgIHBvbGxpbmdJbnRlcnZhbDogNDAwMFxufTtcbi8qKlxuICogIEFuICoqQWJzdHJhY3RQcm92aWRlcioqIHByb3ZpZGVzIGEgYmFzZSBjbGFzcyBmb3Igb3RoZXIgc3ViLWNsYXNzZXMgdG9cbiAqICBpbXBsZW1lbnQgdGhlIFtbUHJvdmlkZXJdXSBBUEkgYnkgbm9ybWFsaXppbmcgaW5wdXQgYXJndW1lbnRzIGFuZFxuICogIGZvcm1hdHRpbmcgb3V0cHV0IHJlc3VsdHMgYXMgd2VsbCBhcyB0cmFja2luZyBldmVudHMgZm9yIGNvbnNpc3RlbnRcbiAqICBiZWhhdmlvdXIgb24gYW4gZXZlbnR1YWxseS1jb25zaXN0ZW50IG5ldHdvcmsuXG4gKi9cbmV4cG9ydCBjbGFzcyBBYnN0cmFjdFByb3ZpZGVyIHtcbiAgICAjc3VicztcbiAgICAjcGx1Z2lucztcbiAgICAvLyBudWxsPXVucGF1c2VkLCB0cnVlPXBhdXNlZCtkcm9wV2hpbGVQYXVzZWQsIGZhbHNlPXBhdXNlZFxuICAgICNwYXVzZWRTdGF0ZTtcbiAgICAjZGVzdHJveWVkO1xuICAgICNuZXR3b3JrUHJvbWlzZTtcbiAgICAjYW55TmV0d29yaztcbiAgICAjcGVyZm9ybUNhY2hlO1xuICAgIC8vIFRoZSBtb3N0IHJlY2VudCBibG9jayBudW1iZXIgaWYgcnVubmluZyBhbiBldmVudCBvciAtMSBpZiBubyBcImJsb2NrXCIgZXZlbnRcbiAgICAjbGFzdEJsb2NrTnVtYmVyO1xuICAgICNuZXh0VGltZXI7XG4gICAgI3RpbWVycztcbiAgICAjZGlzYWJsZUNjaXBSZWFkO1xuICAgICNvcHRpb25zO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipBYnN0cmFjdFByb3ZpZGVyKiogY29ubmVjdGVkIHRvICUlbmV0d29yayUlLCBvclxuICAgICAqICB1c2UgdGhlIHZhcmlvdXMgbmV0d29yayBkZXRlY3Rpb24gY2FwYWJpbGl0aWVzIHRvIGRpc2NvdmVyIHRoZVxuICAgICAqICBbW05ldHdvcmtdXSBpZiBuZWNlc3NhcnkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoX25ldHdvcmssIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy4jb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zIHx8IHt9KTtcbiAgICAgICAgaWYgKF9uZXR3b3JrID09PSBcImFueVwiKSB7XG4gICAgICAgICAgICB0aGlzLiNhbnlOZXR3b3JrID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuI25ldHdvcmtQcm9taXNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChfbmV0d29yaykge1xuICAgICAgICAgICAgY29uc3QgbmV0d29yayA9IE5ldHdvcmsuZnJvbShfbmV0d29yayk7XG4gICAgICAgICAgICB0aGlzLiNhbnlOZXR3b3JrID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLiNuZXR3b3JrUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShuZXR3b3JrKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4geyB0aGlzLmVtaXQoXCJuZXR3b3JrXCIsIG5ldHdvcmssIG51bGwpOyB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI2FueU5ldHdvcmsgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuI25ldHdvcmtQcm9taXNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNsYXN0QmxvY2tOdW1iZXIgPSAtMTtcbiAgICAgICAgdGhpcy4jcGVyZm9ybUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLiNzdWJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLiNwbHVnaW5zID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLiNwYXVzZWRTdGF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuI2Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNuZXh0VGltZXIgPSAxO1xuICAgICAgICB0aGlzLiN0aW1lcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuI2Rpc2FibGVDY2lwUmVhZCA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgcG9sbGluZ0ludGVydmFsKCkgeyByZXR1cm4gdGhpcy4jb3B0aW9ucy5wb2xsaW5nSW50ZXJ2YWw7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRoaXNgYCwgdG8gYWxsb3cgYW4gKipBYnN0cmFjdFByb3ZpZGVyKiogdG8gaW1wbGVtZW50XG4gICAgICogIHRoZSBbW0NvbnRyYWN0UnVubmVyXV0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGdldCBwcm92aWRlcigpIHsgcmV0dXJuIHRoaXM7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhbGwgdGhlIHJlZ2lzdGVyZWQgcGx1Zy1pbnMuXG4gICAgICovXG4gICAgZ2V0IHBsdWdpbnMoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuI3BsdWdpbnMudmFsdWVzKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQXR0YWNoIGEgbmV3IHBsdWctaW4uXG4gICAgICovXG4gICAgYXR0YWNoUGx1Z2luKHBsdWdpbikge1xuICAgICAgICBpZiAodGhpcy4jcGx1Z2lucy5nZXQocGx1Z2luLm5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZXBsYWNlIGV4aXN0aW5nIHBsdWdpbjogJHtwbHVnaW4ubmFtZX0gYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcGx1Z2lucy5zZXQocGx1Z2luLm5hbWUsIHBsdWdpbi5jb25uZWN0KHRoaXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgYSBwbHVnaW4gYnkgbmFtZS5cbiAgICAgKi9cbiAgICBnZXRQbHVnaW4obmFtZSkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI3BsdWdpbnMuZ2V0KG5hbWUpKSB8fCBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUHJldmVudCBhbnkgQ0NJUC1yZWFkIG9wZXJhdGlvbiwgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHJlcXVlc3RlZFxuICAgICAqICBpbiBhIFtbY2FsbF1dIHVzaW5nIGBgZW5hYmxlQ2NpcFJlYWRgYC5cbiAgICAgKi9cbiAgICBnZXQgZGlzYWJsZUNjaXBSZWFkKCkgeyByZXR1cm4gdGhpcy4jZGlzYWJsZUNjaXBSZWFkOyB9XG4gICAgc2V0IGRpc2FibGVDY2lwUmVhZCh2YWx1ZSkgeyB0aGlzLiNkaXNhYmxlQ2NpcFJlYWQgPSAhIXZhbHVlOyB9XG4gICAgLy8gU2hhcmVzIG11bHRpcGxlIGlkZW50aWNhbCByZXF1ZXN0cyBtYWRlIGR1cmluZyB0aGUgc2FtZSAyNTBtc1xuICAgIGFzeW5jICNwZXJmb3JtKHJlcSkge1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gdGhpcy4jb3B0aW9ucy5jYWNoZVRpbWVvdXQ7XG4gICAgICAgIC8vIENhY2hpbmcgZGlzYWJsZWRcbiAgICAgICAgaWYgKHRpbWVvdXQgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fcGVyZm9ybShyZXEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhIHRhZ1xuICAgICAgICBjb25zdCB0YWcgPSBnZXRUYWcocmVxLm1ldGhvZCwgcmVxKTtcbiAgICAgICAgbGV0IHBlcmZvcm0gPSB0aGlzLiNwZXJmb3JtQ2FjaGUuZ2V0KHRhZyk7XG4gICAgICAgIGlmICghcGVyZm9ybSkge1xuICAgICAgICAgICAgcGVyZm9ybSA9IHRoaXMuX3BlcmZvcm0ocmVxKTtcbiAgICAgICAgICAgIHRoaXMuI3BlcmZvcm1DYWNoZS5zZXQodGFnLCBwZXJmb3JtKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNwZXJmb3JtQ2FjaGUuZ2V0KHRhZykgPT09IHBlcmZvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jcGVyZm9ybUNhY2hlLmRlbGV0ZSh0YWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCBwZXJmb3JtO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGRhdGEgZm9yIGV4ZWN1dGluZyB0aGUgQ0NJUC1yZWFkIG9wZXJhdGlvbnMuXG4gICAgICovXG4gICAgYXN5bmMgY2NpcFJlYWRGZXRjaCh0eCwgY2FsbGRhdGEsIHVybHMpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZUNjaXBSZWFkIHx8IHVybHMubGVuZ3RoID09PSAwIHx8IHR4LnRvID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlbmRlciA9IHR4LnRvLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBjYWxsZGF0YS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdXJscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gdXJsc1tpXTtcbiAgICAgICAgICAgIC8vIFVSTCBleHBhbnNpb25cbiAgICAgICAgICAgIGNvbnN0IGhyZWYgPSB1cmwucmVwbGFjZShcIntzZW5kZXJ9XCIsIHNlbmRlcikucmVwbGFjZShcIntkYXRhfVwiLCBkYXRhKTtcbiAgICAgICAgICAgIC8vIElmIG5vIHtkYXRhfSBpcyBwcmVzZW50LCB1c2UgUE9TVDsgb3RoZXJ3aXNlIEdFVFxuICAgICAgICAgICAgLy9jb25zdCBqc29uOiBzdHJpbmcgfCBudWxsID0gKHVybC5pbmRleE9mKFwie2RhdGF9XCIpID49IDApID8gbnVsbDogSlNPTi5zdHJpbmdpZnkoeyBkYXRhLCBzZW5kZXIgfSk7XG4gICAgICAgICAgICAvL2NvbnN0IHJlc3VsdCA9IGF3YWl0IGZldGNoSnNvbih7IHVybDogaHJlZiwgZXJyb3JQYXNzVGhyb3VnaDogdHJ1ZSB9LCBqc29uLCAodmFsdWUsIHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAvLyAgICB2YWx1ZS5zdGF0dXMgPSByZXNwb25zZS5zdGF0dXNDb2RlO1xuICAgICAgICAgICAgLy8gICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgLy99KTtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgRmV0Y2hSZXF1ZXN0KGhyZWYpO1xuICAgICAgICAgICAgaWYgKHVybC5pbmRleE9mKFwie2RhdGF9XCIpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QuYm9keSA9IHsgZGF0YSwgc2VuZGVyIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJzZW5kQ2NpcFJlYWRGZXRjaFJlcXVlc3RcIiwgcmVxdWVzdCwgaW5kZXg6IGksIHVybHMgfSk7XG4gICAgICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gXCJ1bmtub3duIGVycm9yXCI7XG4gICAgICAgICAgICAvLyBGZXRjaCB0aGUgcmVzb3VyY2UuLi5cbiAgICAgICAgICAgIGxldCByZXNwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXNwID0gYXdhaXQgcmVxdWVzdC5zZW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyAuLi5sb3ctbGV2ZWwgZmV0Y2ggZXJyb3IgKG1pc3NpbmcgaG9zdCwgYmFkIFNTTCwgZXRjLiksXG4gICAgICAgICAgICAgICAgLy8gc28gdHJ5IG5leHQgVVJMXG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlcy5wdXNoKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVDY2lwUmVhZEZldGNoRXJyb3JcIiwgcmVxdWVzdCwgcmVzdWx0OiB7IGVycm9yIH0gfSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc3AuYm9keUpzb247XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVDY2lwUmVhZEZldGNoUmVzdWx0XCIsIHJlcXVlc3QsIHJlc3VsdCB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gcmVzdWx0Lm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVDY2lwUmVhZEZldGNoRXJyb3JcIiwgcmVxdWVzdCwgcmVzdWx0IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIC8vIDR4eCBpbmRpY2F0ZXMgdGhlIHJlc3VsdCBpcyBub3QgcHJlc2VudDsgc3RvcFxuICAgICAgICAgICAgYXNzZXJ0KHJlc3Auc3RhdHVzQ29kZSA8IDQwMCB8fCByZXNwLnN0YXR1c0NvZGUgPj0gNTAwLCBgcmVzcG9uc2Ugbm90IGZvdW5kIGR1cmluZyBDQ0lQIGZldGNoOiAke2Vycm9yTWVzc2FnZX1gLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHsgcmVhc29uOiBcIjQwNF9NSVNTSU5HX1JFU09VUkNFXCIsIHRyYW5zYWN0aW9uOiB0eCwgaW5mbzogeyB1cmwsIGVycm9yTWVzc2FnZSB9IH0pO1xuICAgICAgICAgICAgLy8gNXh4IGluZGljYXRlcyBzZXJ2ZXIgaXNzdWU7IHRyeSB0aGUgbmV4dCB1cmxcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZXMucHVzaChlcnJvck1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydChmYWxzZSwgYGVycm9yIGVuY291bnRlcmVkIGR1cmluZyBDQ0lQIGZldGNoOiAke2Vycm9yTWVzc2FnZXMubWFwKChtKSA9PiBKU09OLnN0cmluZ2lmeShtKSkuam9pbihcIiwgXCIpfWAsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xuICAgICAgICAgICAgcmVhc29uOiBcIjUwMF9TRVJWRVJfRVJST1JcIixcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0eCwgaW5mbzogeyB1cmxzLCBlcnJvck1lc3NhZ2VzIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQcm92aWRlcyB0aGUgb3Bwb3J0dW5pdHkgZm9yIGEgc3ViLWNsYXNzIHRvIHdyYXAgYSBibG9jayBiZWZvcmVcbiAgICAgKiAgcmV0dXJuaW5nIGl0LCB0byBhZGQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIG9yIGFuIGFsdGVybmF0ZVxuICAgICAqICBzdWItY2xhc3Mgb2YgW1tCbG9ja11dLlxuICAgICAqL1xuICAgIF93cmFwQmxvY2sodmFsdWUsIG5ldHdvcmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9jayhmb3JtYXRCbG9jayh2YWx1ZSksIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUHJvdmlkZXMgdGhlIG9wcG9ydHVuaXR5IGZvciBhIHN1Yi1jbGFzcyB0byB3cmFwIGEgbG9nIGJlZm9yZVxuICAgICAqICByZXR1cm5pbmcgaXQsIHRvIGFkZCBhZGRpdGlvbmFsIHByb3BlcnRpZXMgb3IgYW4gYWx0ZXJuYXRlXG4gICAgICogIHN1Yi1jbGFzcyBvZiBbW0xvZ11dLlxuICAgICAqL1xuICAgIF93cmFwTG9nKHZhbHVlLCBuZXR3b3JrKSB7XG4gICAgICAgIHJldHVybiBuZXcgTG9nKGZvcm1hdExvZyh2YWx1ZSksIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUHJvdmlkZXMgdGhlIG9wcG9ydHVuaXR5IGZvciBhIHN1Yi1jbGFzcyB0byB3cmFwIGEgdHJhbnNhY3Rpb25cbiAgICAgKiAgcmVjZWlwdCBiZWZvcmUgcmV0dXJuaW5nIGl0LCB0byBhZGQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIG9yIGFuXG4gICAgICogIGFsdGVybmF0ZSBzdWItY2xhc3Mgb2YgW1tUcmFuc2FjdGlvblJlY2VpcHRdXS5cbiAgICAgKi9cbiAgICBfd3JhcFRyYW5zYWN0aW9uUmVjZWlwdCh2YWx1ZSwgbmV0d29yaykge1xuICAgICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uUmVjZWlwdChmb3JtYXRUcmFuc2FjdGlvblJlY2VpcHQodmFsdWUpLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFByb3ZpZGVzIHRoZSBvcHBvcnR1bml0eSBmb3IgYSBzdWItY2xhc3MgdG8gd3JhcCBhIHRyYW5zYWN0aW9uXG4gICAgICogIHJlc3BvbnNlIGJlZm9yZSByZXR1cm5pbmcgaXQsIHRvIGFkZCBhZGRpdGlvbmFsIHByb3BlcnRpZXMgb3IgYW5cbiAgICAgKiAgYWx0ZXJuYXRlIHN1Yi1jbGFzcyBvZiBbW1RyYW5zYWN0aW9uUmVzcG9uc2VdXS5cbiAgICAgKi9cbiAgICBfd3JhcFRyYW5zYWN0aW9uUmVzcG9uc2UodHgsIG5ldHdvcmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvblJlc3BvbnNlKGZvcm1hdFRyYW5zYWN0aW9uUmVzcG9uc2UodHgpLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBOZXR3b3JrLCBmb3JjaW5nIGEgbmV0d29yayBkZXRlY3Rpb24gdXNpbmcgd2hhdGV2ZXJcbiAgICAgKiAgdGVjaG5pcXVlIHRoZSBzdWItY2xhc3MgcmVxdWlyZXMuXG4gICAgICpcbiAgICAgKiAgU3ViLWNsYXNzZXMgKiptdXN0Kiogb3ZlcnJpZGUgdGhpcy5cbiAgICAgKi9cbiAgICBfZGV0ZWN0TmV0d29yaygpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInN1Yi1jbGFzc2VzIG11c3QgaW1wbGVtZW50IHRoaXNcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcIl9kZXRlY3ROZXR3b3JrXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTdWItY2xhc3NlcyBzaG91bGQgdXNlIHRoaXMgdG8gcGVyZm9ybSBhbGwgYnVpbHQtaW4gb3BlcmF0aW9ucy4gQWxsXG4gICAgICogIG1ldGhvZHMgc2FuaXRpemVzIGFuZCBub3JtYWxpemVzIHRoZSB2YWx1ZXMgcGFzc2VkIGludG8gdGhpcy5cbiAgICAgKlxuICAgICAqICBTdWItY2xhc3NlcyAqKm11c3QqKiBvdmVycmlkZSB0aGlzLlxuICAgICAqL1xuICAgIGFzeW5jIF9wZXJmb3JtKHJlcSkge1xuICAgICAgICBhc3NlcnQoZmFsc2UsIGB1bnN1cHBvcnRlZCBtZXRob2Q6ICR7cmVxLm1ldGhvZH1gLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IHJlcS5tZXRob2QsXG4gICAgICAgICAgICBpbmZvOiByZXFcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFN0YXRlXG4gICAgYXN5bmMgZ2V0QmxvY2tOdW1iZXIoKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gZ2V0TnVtYmVyKGF3YWl0IHRoaXMuI3BlcmZvcm0oeyBtZXRob2Q6IFwiZ2V0QmxvY2tOdW1iZXJcIiB9KSwgXCIlcmVzcG9uc2VcIik7XG4gICAgICAgIGlmICh0aGlzLiNsYXN0QmxvY2tOdW1iZXIgPj0gMCkge1xuICAgICAgICAgICAgdGhpcy4jbGFzdEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJsb2NrTnVtYmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBvciByZXNvbHZlcyB0byB0aGUgYWRkcmVzcyBmb3IgJSVhZGRyZXNzJSUsIHJlc29sdmluZyBFTlNcbiAgICAgKiAgbmFtZXMgYW5kIFtbQWRkcmVzc2FibGVdXSBvYmplY3RzIGFuZCByZXR1cm5pbmcgaWYgYWxyZWFkeSBhblxuICAgICAqICBhZGRyZXNzLlxuICAgICAqL1xuICAgIF9nZXRBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVBZGRyZXNzKGFkZHJlc3MsIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBvciByZXNvbHZlcyB0byBhIHZhbGlkIGJsb2NrIHRhZyBmb3IgJSVibG9ja1RhZyUlLCByZXNvbHZpbmdcbiAgICAgKiAgbmVnYXRpdmUgdmFsdWVzIGFuZCByZXR1cm5pbmcgaWYgYWxyZWFkeSBhIHZhbGlkIGJsb2NrIHRhZy5cbiAgICAgKi9cbiAgICBfZ2V0QmxvY2tUYWcoYmxvY2tUYWcpIHtcbiAgICAgICAgaWYgKGJsb2NrVGFnID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBcImxhdGVzdFwiO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoYmxvY2tUYWcpIHtcbiAgICAgICAgICAgIGNhc2UgXCJlYXJsaWVzdFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcIjB4MFwiO1xuICAgICAgICAgICAgY2FzZSBcImZpbmFsaXplZFwiOlxuICAgICAgICAgICAgY2FzZSBcImxhdGVzdFwiOlxuICAgICAgICAgICAgY2FzZSBcInBlbmRpbmdcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzYWZlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJsb2NrVGFnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0hleFN0cmluZyhibG9ja1RhZykpIHtcbiAgICAgICAgICAgIGlmIChpc0hleFN0cmluZyhibG9ja1RhZywgMzIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJsb2NrVGFnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRvUXVhbnRpdHkoYmxvY2tUYWcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKGJsb2NrVGFnKSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgICAgYmxvY2tUYWcgPSBnZXROdW1iZXIoYmxvY2tUYWcsIFwiYmxvY2tUYWdcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAoYmxvY2tUYWcpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBpZiAoYmxvY2tUYWcgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b1F1YW50aXR5KGJsb2NrVGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLiNsYXN0QmxvY2tOdW1iZXIgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b1F1YW50aXR5KHRoaXMuI2xhc3RCbG9ja051bWJlciArIGJsb2NrVGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEJsb2NrTnVtYmVyKCkudGhlbigoYikgPT4gdG9RdWFudGl0eShiICsgYmxvY2tUYWcpKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIGJsb2NrVGFnXCIsIFwiYmxvY2tUYWdcIiwgYmxvY2tUYWcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBvciByZXNvbHZlcyB0byBhIGZpbHRlciBmb3IgJSVmaWx0ZXIlJSwgcmVzb2x2aW5nIGFueSBFTlNcbiAgICAgKiAgbmFtZXMgb3IgW1tBZGRyZXNzYWJsZV1dIG9iamVjdCBhbmQgcmV0dXJuaW5nIGlmIGFscmVhZHkgYSB2YWxpZFxuICAgICAqICBmaWx0ZXIuXG4gICAgICovXG4gICAgX2dldEZpbHRlcihmaWx0ZXIpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgY2Fub25pY2FsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0b3BpY3NcbiAgICAgICAgY29uc3QgdG9waWNzID0gKGZpbHRlci50b3BpY3MgfHwgW10pLm1hcCgodCkgPT4ge1xuICAgICAgICAgICAgaWYgKHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uY2lzaWZ5KHQubWFwKCh0KSA9PiB0LnRvTG93ZXJDYXNlKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBibG9ja0hhc2ggPSAoXCJibG9ja0hhc2hcIiBpbiBmaWx0ZXIpID8gZmlsdGVyLmJsb2NrSGFzaCA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgcmVzb2x2ZSA9IChfYWRkcmVzcywgZnJvbUJsb2NrLCB0b0Jsb2NrKSA9PiB7XG4gICAgICAgICAgICBsZXQgYWRkcmVzcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHN3aXRjaCAoX2FkZHJlc3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgPSBfYWRkcmVzc1swXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgX2FkZHJlc3Muc29ydCgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzID0gX2FkZHJlc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmxvY2tIYXNoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZyb21CbG9jayAhPSBudWxsIHx8IHRvQmxvY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZpbHRlclwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXIgPSB7fTtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyLmFkZHJlc3MgPSBhZGRyZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvcGljcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIudG9waWNzID0gdG9waWNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZyb21CbG9jaykge1xuICAgICAgICAgICAgICAgIGZpbHRlci5mcm9tQmxvY2sgPSBmcm9tQmxvY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9CbG9jaykge1xuICAgICAgICAgICAgICAgIGZpbHRlci50b0Jsb2NrID0gdG9CbG9jaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChibG9ja0hhc2gpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIuYmxvY2tIYXNoID0gYmxvY2tIYXNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcjtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQWRkcmVzc2VzIGNvdWxkIGJlIGFzeW5jIChFTlMgbmFtZXMgb3IgQWRkcmVzc2FibGVzKVxuICAgICAgICBsZXQgYWRkcmVzcyA9IFtdO1xuICAgICAgICBpZiAoZmlsdGVyLmFkZHJlc3MpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpbHRlci5hZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYWRkciBvZiBmaWx0ZXIuYWRkcmVzcykge1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLnB1c2godGhpcy5fZ2V0QWRkcmVzcyhhZGRyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzcy5wdXNoKHRoaXMuX2dldEFkZHJlc3MoZmlsdGVyLmFkZHJlc3MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgZnJvbUJsb2NrID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoXCJmcm9tQmxvY2tcIiBpbiBmaWx0ZXIpIHtcbiAgICAgICAgICAgIGZyb21CbG9jayA9IHRoaXMuX2dldEJsb2NrVGFnKGZpbHRlci5mcm9tQmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b0Jsb2NrID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoXCJ0b0Jsb2NrXCIgaW4gZmlsdGVyKSB7XG4gICAgICAgICAgICB0b0Jsb2NrID0gdGhpcy5fZ2V0QmxvY2tUYWcoZmlsdGVyLnRvQmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZGRyZXNzLmZpbHRlcigoYSkgPT4gKHR5cGVvZiAoYSkgIT09IFwic3RyaW5nXCIpKS5sZW5ndGggfHxcbiAgICAgICAgICAgIChmcm9tQmxvY2sgIT0gbnVsbCAmJiB0eXBlb2YgKGZyb21CbG9jaykgIT09IFwic3RyaW5nXCIpIHx8XG4gICAgICAgICAgICAodG9CbG9jayAhPSBudWxsICYmIHR5cGVvZiAodG9CbG9jaykgIT09IFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1Byb21pc2UuYWxsKGFkZHJlc3MpLCBmcm9tQmxvY2ssIHRvQmxvY2tdKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXN1bHRbMF0sIHJlc3VsdFsxXSwgcmVzdWx0WzJdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlKGFkZHJlc3MsIGZyb21CbG9jaywgdG9CbG9jayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIG9yIHJlc29sdmVzIHRvIGEgdHJhbnNhY3Rpb24gZm9yICUlcmVxdWVzdCUlLCByZXNvbHZpbmdcbiAgICAgKiAgYW55IEVOUyBuYW1lcyBvciBbW0FkZHJlc3NhYmxlXV0gYW5kIHJldHVybmluZyBpZiBhbHJlYWR5IGEgdmFsaWRcbiAgICAgKiAgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgX2dldFRyYW5zYWN0aW9uUmVxdWVzdChfcmVxdWVzdCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gY29weVJlcXVlc3QoX3JlcXVlc3QpO1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICBbXCJ0b1wiLCBcImZyb21cIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhZGRyID0gcmVzb2x2ZUFkZHJlc3MocmVxdWVzdFtrZXldLCB0aGlzKTtcbiAgICAgICAgICAgIGlmIChpc1Byb21pc2UoYWRkcikpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKChhc3luYyBmdW5jdGlvbiAoKSB7IHJlcXVlc3Rba2V5XSA9IGF3YWl0IGFkZHI7IH0pKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdFtrZXldID0gYWRkcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZXF1ZXN0LmJsb2NrVGFnICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrVGFnID0gdGhpcy5fZ2V0QmxvY2tUYWcocmVxdWVzdC5ibG9ja1RhZyk7XG4gICAgICAgICAgICBpZiAoaXNQcm9taXNlKGJsb2NrVGFnKSkge1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jIGZ1bmN0aW9uICgpIHsgcmVxdWVzdC5ibG9ja1RhZyA9IGF3YWl0IGJsb2NrVGFnOyB9KSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QuYmxvY2tUYWcgPSBibG9ja1RhZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gKGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH1cbiAgICBhc3luYyBnZXROZXR3b3JrKCkge1xuICAgICAgICAvLyBObyBleHBsaWNpdCBuZXR3b3JrIHdhcyBzZXQgYW5kIHRoaXMgaXMgb3VyIGZpcnN0IHRpbWVcbiAgICAgICAgaWYgKHRoaXMuI25ldHdvcmtQcm9taXNlID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIERldGVjdCB0aGUgY3VycmVudCBuZXR3b3JrIChzaGFyZWQgd2l0aCBhbGwgY2FsbHMpXG4gICAgICAgICAgICBjb25zdCBkZXRlY3ROZXR3b3JrID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgdGhpcy5fZGV0ZWN0TmV0d29yaygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJuZXR3b3JrXCIsIG5ldHdvcmssIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV0d29yaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiNuZXR3b3JrUHJvbWlzZSA9PT0gZGV0ZWN0TmV0d29yaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jbmV0d29ya1Byb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICB0aGlzLiNuZXR3b3JrUHJvbWlzZSA9IGRldGVjdE5ldHdvcms7XG4gICAgICAgICAgICByZXR1cm4gKGF3YWl0IGRldGVjdE5ldHdvcmspLmNsb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV0d29ya1Byb21pc2UgPSB0aGlzLiNuZXR3b3JrUHJvbWlzZTtcbiAgICAgICAgY29uc3QgW2V4cGVjdGVkLCBhY3R1YWxdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgbmV0d29ya1Byb21pc2UsXG4gICAgICAgICAgICB0aGlzLl9kZXRlY3ROZXR3b3JrKCkgLy8gVGhlIGFjdHVhbCBjb25uZWN0ZWQgbmV0d29ya1xuICAgICAgICBdKTtcbiAgICAgICAgaWYgKGV4cGVjdGVkLmNoYWluSWQgIT09IGFjdHVhbC5jaGFpbklkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jYW55TmV0d29yaykge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBcImFueVwiIG5ldHdvcmsgY2FuIGNoYW5nZSwgc28gbm90aWZ5IGxpc3RlbmVyc1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcIm5ldHdvcmtcIiwgYWN0dWFsLCBleHBlY3RlZCk7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBuZXR3b3JrIGlmIHNvbWV0aGluZyBlbHNlIGhhc24ndCBhbHJlYWR5IGNoYW5nZWQgaXRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jbmV0d29ya1Byb21pc2UgPT09IG5ldHdvcmtQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI25ldHdvcmtQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGFjdHVhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBkbyBub3QgYWxsb3cgY2hhbmdlcyB0byB0aGUgdW5kZXJseWluZyBuZXR3b3JrXG4gICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBgbmV0d29yayBjaGFuZ2VkOiAke2V4cGVjdGVkLmNoYWluSWR9ID0+ICR7YWN0dWFsLmNoYWluSWR9IGAsIFwiTkVUV09SS19FUlJPUlwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBcImNoYW5nZWRcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHBlY3RlZC5jbG9uZSgpO1xuICAgIH1cbiAgICBhc3luYyBnZXRGZWVEYXRhKCkge1xuICAgICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgIGNvbnN0IGdldEZlZURhdGFGdW5jID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBfYmxvY2ssIGdhc1ByaWNlLCBwcmlvcml0eUZlZSB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgICAgIF9ibG9jazogdGhpcy4jZ2V0QmxvY2soXCJsYXRlc3RcIiwgZmFsc2UpLFxuICAgICAgICAgICAgICAgIGdhc1ByaWNlOiAoKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRHYXNQcmljZVwiIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEJpZ0ludCh2YWx1ZSwgXCIlcmVzcG9uc2VcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfSkoKSksXG4gICAgICAgICAgICAgICAgcHJpb3JpdHlGZWU6ICgoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldFByaW9yaXR5RmVlXCIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QmlnSW50KHZhbHVlLCBcIiVyZXNwb25zZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9KSgpKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgbWF4RmVlUGVyR2FzID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBtYXhQcmlvcml0eUZlZVBlckdhcyA9IG51bGw7XG4gICAgICAgICAgICAvLyBUaGVzZSBhcmUgdGhlIHJlY29tbWVuZGVkIEVJUC0xNTU5IGhldXJpc3RpY3MgZm9yIGZlZSBkYXRhXG4gICAgICAgICAgICBjb25zdCBibG9jayA9IHRoaXMuX3dyYXBCbG9jayhfYmxvY2ssIG5ldHdvcmspO1xuICAgICAgICAgICAgaWYgKGJsb2NrICYmIGJsb2NrLmJhc2VGZWVQZXJHYXMpIHtcbiAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhcyA9IChwcmlvcml0eUZlZSAhPSBudWxsKSA/IHByaW9yaXR5RmVlIDogQmlnSW50KFwiMTAwMDAwMDAwMFwiKTtcbiAgICAgICAgICAgICAgICBtYXhGZWVQZXJHYXMgPSAoYmxvY2suYmFzZUZlZVBlckdhcyAqIEJOXzIpICsgbWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZlZURhdGEoZ2FzUHJpY2UsIG1heEZlZVBlckdhcywgbWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBDaGVjayBmb3IgYSBGZWVEYXRhTmV0V29ya1BsdWdpblxuICAgICAgICBjb25zdCBwbHVnaW4gPSBuZXR3b3JrLmdldFBsdWdpbihcIm9yZy5ldGhlcnMucGx1Z2lucy5uZXR3b3JrLkZldGNoVXJsRmVlRGF0YVBsdWdpblwiKTtcbiAgICAgICAgaWYgKHBsdWdpbikge1xuICAgICAgICAgICAgY29uc3QgcmVxID0gbmV3IEZldGNoUmVxdWVzdChwbHVnaW4udXJsKTtcbiAgICAgICAgICAgIGNvbnN0IGZlZURhdGEgPSBhd2FpdCBwbHVnaW4ucHJvY2Vzc0Z1bmMoZ2V0RmVlRGF0YUZ1bmMsIHRoaXMsIHJlcSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZlZURhdGEoZmVlRGF0YS5nYXNQcmljZSwgZmVlRGF0YS5tYXhGZWVQZXJHYXMsIGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCBnZXRGZWVEYXRhRnVuYygpO1xuICAgIH1cbiAgICBhc3luYyBlc3RpbWF0ZUdhcyhfdHgpIHtcbiAgICAgICAgbGV0IHR4ID0gdGhpcy5fZ2V0VHJhbnNhY3Rpb25SZXF1ZXN0KF90eCk7XG4gICAgICAgIGlmIChpc1Byb21pc2UodHgpKSB7XG4gICAgICAgICAgICB0eCA9IGF3YWl0IHR4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRCaWdJbnQoYXdhaXQgdGhpcy4jcGVyZm9ybSh7XG4gICAgICAgICAgICBtZXRob2Q6IFwiZXN0aW1hdGVHYXNcIiwgdHJhbnNhY3Rpb246IHR4XG4gICAgICAgIH0pLCBcIiVyZXNwb25zZVwiKTtcbiAgICB9XG4gICAgYXN5bmMgI2NhbGwodHgsIGJsb2NrVGFnLCBhdHRlbXB0KSB7XG4gICAgICAgIGFzc2VydChhdHRlbXB0IDwgTUFYX0NDSVBfUkVESVJFQ1RTLCBcIkNDSVAgcmVhZCBleGNlZWRlZCBtYXhpbXVtIHJlZGlyZWN0aW9uc1wiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIHJlYXNvbjogXCJUT09fTUFOWV9SRURJUkVDVFNcIixcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiBPYmplY3QuYXNzaWduKHt9LCB0eCwgeyBibG9ja1RhZywgZW5hYmxlQ2NpcFJlYWQ6IHRydWUgfSlcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRoaXMgY2FtZSBpbiBhcyBhIFBlcmZvcm1BY3Rpb25UcmFuc2FjdGlvbiwgc28gdG8vZnJvbSBhcmUgc2FmZTsgd2UgY2FuIGNhc3RcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBjb3B5UmVxdWVzdCh0eCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gaGV4bGlmeShhd2FpdCB0aGlzLl9wZXJmb3JtKHsgbWV0aG9kOiBcImNhbGxcIiwgdHJhbnNhY3Rpb24sIGJsb2NrVGFnIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIENDSVAgUmVhZCBPZmZjaGFpbkxvb2t1cFxuICAgICAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVDY2lwUmVhZCAmJiBpc0NhbGxFeGNlcHRpb24oZXJyb3IpICYmIGVycm9yLmRhdGEgJiYgYXR0ZW1wdCA+PSAwICYmIGJsb2NrVGFnID09PSBcImxhdGVzdFwiICYmIHRyYW5zYWN0aW9uLnRvICE9IG51bGwgJiYgZGF0YVNsaWNlKGVycm9yLmRhdGEsIDAsIDQpID09PSBcIjB4NTU2ZjE4MzBcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBlcnJvci5kYXRhO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR4U2VuZGVyID0gYXdhaXQgcmVzb2x2ZUFkZHJlc3ModHJhbnNhY3Rpb24udG8sIHRoaXMpO1xuICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBDQ0lQIFJlYWQgQXJndW1lbnRzXG4gICAgICAgICAgICAgICAgbGV0IGNjaXBBcmdzO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNjaXBBcmdzID0gcGFyc2VPZmZjaGFpbkxvb2t1cChkYXRhU2xpY2UoZXJyb3IuZGF0YSwgNCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBlcnJvci5tZXNzYWdlLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogXCJCQURfREFUQVwiLCB0cmFuc2FjdGlvbiwgaW5mbzogeyBkYXRhIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoZSBzZW5kZXIgb2YgdGhlIE9mZmNoYWluTG9va3VwIG1hdGNoZXMgdGhlIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgYXNzZXJ0KGNjaXBBcmdzLnNlbmRlci50b0xvd2VyQ2FzZSgpID09PSB0eFNlbmRlci50b0xvd2VyQ2FzZSgpLCBcIkNDSVAgUmVhZCBzZW5kZXIgbWlzbWF0Y2hcIiwgXCJDQUxMX0VYQ0VQVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJjYWxsXCIsXG4gICAgICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogXCJPZmZjaGFpbkxvb2t1cFwiLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIGludm9jYXRpb246IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHJldmVydDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBcIk9mZmNoYWluTG9va3VwKGFkZHJlc3Msc3RyaW5nW10sYnl0ZXMsYnl0ZXM0LGJ5dGVzKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJPZmZjaGFpbkxvb2t1cFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogY2NpcEFyZ3MuZXJyb3JBcmdzXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBjY2lwUmVzdWx0ID0gYXdhaXQgdGhpcy5jY2lwUmVhZEZldGNoKHRyYW5zYWN0aW9uLCBjY2lwQXJncy5jYWxsZGF0YSwgY2NpcEFyZ3MudXJscyk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KGNjaXBSZXN1bHQgIT0gbnVsbCwgXCJDQ0lQIFJlYWQgZmFpbGVkIHRvIGZldGNoIGRhdGFcIiwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogXCJGRVRDSF9GQUlMRURcIiwgdHJhbnNhY3Rpb24sIGluZm86IHsgZGF0YTogZXJyb3IuZGF0YSwgZXJyb3JBcmdzOiBjY2lwQXJncy5lcnJvckFyZ3MgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR4ID0ge1xuICAgICAgICAgICAgICAgICAgICB0bzogdHhTZW5kZXIsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGNvbmNhdChbY2NpcEFyZ3Muc2VsZWN0b3IsIGVuY29kZUJ5dGVzKFtjY2lwUmVzdWx0LCBjY2lwQXJncy5leHRyYURhdGFdKV0pXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJzZW5kQ2NpcFJlYWRDYWxsXCIsIHRyYW5zYWN0aW9uOiB0eCB9KTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNjYWxsKHR4LCBibG9ja1RhZywgYXR0ZW1wdCArIDEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlQ2NpcFJlYWRDYWxsUmVzdWx0XCIsIHRyYW5zYWN0aW9uOiBPYmplY3QuYXNzaWduKHt9LCB0eCksIHJlc3VsdCB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVDY2lwUmVhZENhbGxFcnJvclwiLCB0cmFuc2FjdGlvbjogT2JqZWN0LmFzc2lnbih7fSwgdHgpLCBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgI2NoZWNrTmV0d29yayhwcm9taXNlKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIG5ldHdvcms6IHRoaXMuZ2V0TmV0d29yaygpLFxuICAgICAgICAgICAgdmFsdWU6IHByb21pc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgYXN5bmMgY2FsbChfdHgpIHtcbiAgICAgICAgY29uc3QgeyB0eCwgYmxvY2tUYWcgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIHR4OiB0aGlzLl9nZXRUcmFuc2FjdGlvblJlcXVlc3QoX3R4KSxcbiAgICAgICAgICAgIGJsb2NrVGFnOiB0aGlzLl9nZXRCbG9ja1RhZyhfdHguYmxvY2tUYWcpXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jY2hlY2tOZXR3b3JrKHRoaXMuI2NhbGwodHgsIGJsb2NrVGFnLCBfdHguZW5hYmxlQ2NpcFJlYWQgPyAwIDogLTEpKTtcbiAgICB9XG4gICAgLy8gQWNjb3VudFxuICAgIGFzeW5jICNnZXRBY2NvdW50VmFsdWUocmVxdWVzdCwgX2FkZHJlc3MsIF9ibG9ja1RhZykge1xuICAgICAgICBsZXQgYWRkcmVzcyA9IHRoaXMuX2dldEFkZHJlc3MoX2FkZHJlc3MpO1xuICAgICAgICBsZXQgYmxvY2tUYWcgPSB0aGlzLl9nZXRCbG9ja1RhZyhfYmxvY2tUYWcpO1xuICAgICAgICBpZiAodHlwZW9mIChhZGRyZXNzKSAhPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgKGJsb2NrVGFnKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgW2FkZHJlc3MsIGJsb2NrVGFnXSA9IGF3YWl0IFByb21pc2UuYWxsKFthZGRyZXNzLCBibG9ja1RhZ10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNjaGVja05ldHdvcmsodGhpcy4jcGVyZm9ybShPYmplY3QuYXNzaWduKHJlcXVlc3QsIHsgYWRkcmVzcywgYmxvY2tUYWcgfSkpKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0QmFsYW5jZShhZGRyZXNzLCBibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gZ2V0QmlnSW50KGF3YWl0IHRoaXMuI2dldEFjY291bnRWYWx1ZSh7IG1ldGhvZDogXCJnZXRCYWxhbmNlXCIgfSwgYWRkcmVzcywgYmxvY2tUYWcpLCBcIiVyZXNwb25zZVwiKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25Db3VudChhZGRyZXNzLCBibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gZ2V0TnVtYmVyKGF3YWl0IHRoaXMuI2dldEFjY291bnRWYWx1ZSh7IG1ldGhvZDogXCJnZXRUcmFuc2FjdGlvbkNvdW50XCIgfSwgYWRkcmVzcywgYmxvY2tUYWcpLCBcIiVyZXNwb25zZVwiKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Q29kZShhZGRyZXNzLCBibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gaGV4bGlmeShhd2FpdCB0aGlzLiNnZXRBY2NvdW50VmFsdWUoeyBtZXRob2Q6IFwiZ2V0Q29kZVwiIH0sIGFkZHJlc3MsIGJsb2NrVGFnKSk7XG4gICAgfVxuICAgIGFzeW5jIGdldFN0b3JhZ2UoYWRkcmVzcywgX3Bvc2l0aW9uLCBibG9ja1RhZykge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGdldEJpZ0ludChfcG9zaXRpb24sIFwicG9zaXRpb25cIik7XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KGF3YWl0IHRoaXMuI2dldEFjY291bnRWYWx1ZSh7IG1ldGhvZDogXCJnZXRTdG9yYWdlXCIsIHBvc2l0aW9uIH0sIGFkZHJlc3MsIGJsb2NrVGFnKSk7XG4gICAgfVxuICAgIC8vIFdyaXRlXG4gICAgYXN5bmMgYnJvYWRjYXN0VHJhbnNhY3Rpb24oc2lnbmVkVHgpIHtcbiAgICAgICAgY29uc3QgeyBibG9ja051bWJlciwgaGFzaCwgbmV0d29yayB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IHRoaXMuZ2V0QmxvY2tOdW1iZXIoKSxcbiAgICAgICAgICAgIGhhc2g6IHRoaXMuX3BlcmZvcm0oe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJicm9hZGNhc3RUcmFuc2FjdGlvblwiLFxuICAgICAgICAgICAgICAgIHNpZ25lZFRyYW5zYWN0aW9uOiBzaWduZWRUeFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdHggPSBUcmFuc2FjdGlvbi5mcm9tKHNpZ25lZFR4KTtcbiAgICAgICAgaWYgKHR4Lmhhc2ggIT09IGhhc2gpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBUT0RPOiB0aGUgcmV0dXJuZWQgaGFzaCBkaWQgbm90IG1hdGNoXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93cmFwVHJhbnNhY3Rpb25SZXNwb25zZSh0eCwgbmV0d29yaykucmVwbGFjZWFibGVUcmFuc2FjdGlvbihibG9ja051bWJlcik7XG4gICAgfVxuICAgIGFzeW5jICNnZXRCbG9jayhibG9jaywgaW5jbHVkZVRyYW5zYWN0aW9ucykge1xuICAgICAgICAvLyBAVE9ETzogQWRkIEN1c3RvbUJsb2NrUGx1Z2luIGNoZWNrXG4gICAgICAgIGlmIChpc0hleFN0cmluZyhibG9jaywgMzIpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jcGVyZm9ybSh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcImdldEJsb2NrXCIsIGJsb2NrSGFzaDogYmxvY2ssIGluY2x1ZGVUcmFuc2FjdGlvbnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBibG9ja1RhZyA9IHRoaXMuX2dldEJsb2NrVGFnKGJsb2NrKTtcbiAgICAgICAgaWYgKHR5cGVvZiAoYmxvY2tUYWcpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBibG9ja1RhZyA9IGF3YWl0IGJsb2NrVGFnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNwZXJmb3JtKHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJnZXRCbG9ja1wiLCBibG9ja1RhZywgaW5jbHVkZVRyYW5zYWN0aW9uc1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gUXVlcmllc1xuICAgIGFzeW5jIGdldEJsb2NrKGJsb2NrLCBwcmVmZXRjaFR4cykge1xuICAgICAgICBjb25zdCB7IG5ldHdvcmssIHBhcmFtcyB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgbmV0d29yazogdGhpcy5nZXROZXR3b3JrKCksXG4gICAgICAgICAgICBwYXJhbXM6IHRoaXMuI2dldEJsb2NrKGJsb2NrLCAhIXByZWZldGNoVHhzKVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHBhcmFtcyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fd3JhcEJsb2NrKHBhcmFtcywgbmV0d29yayk7XG4gICAgfVxuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKGhhc2gpIHtcbiAgICAgICAgY29uc3QgeyBuZXR3b3JrLCBwYXJhbXMgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIG5ldHdvcms6IHRoaXMuZ2V0TmV0d29yaygpLFxuICAgICAgICAgICAgcGFyYW1zOiB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldFRyYW5zYWN0aW9uXCIsIGhhc2ggfSlcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwYXJhbXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyYXBUcmFuc2FjdGlvblJlc3BvbnNlKHBhcmFtcywgbmV0d29yayk7XG4gICAgfVxuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uUmVjZWlwdChoYXNoKSB7XG4gICAgICAgIGNvbnN0IHsgbmV0d29yaywgcGFyYW1zIH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcbiAgICAgICAgICAgIHBhcmFtczogdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIiwgaGFzaCB9KVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHBhcmFtcyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb21lIGJhY2tlbmRzIGRpZCBub3QgYmFja2ZpbGwgdGhlIGVmZmVjdGl2ZUdhc1ByaWNlIGludG8gb2xkIHRyYW5zYWN0aW9uc1xuICAgICAgICAvLyBpbiB0aGUgcmVjZWlwdCwgc28gd2UgbG9vayBpdCB1cCBtYW51YWxseSBhbmQgaW5qZWN0IGl0LlxuICAgICAgICBpZiAocGFyYW1zLmdhc1ByaWNlID09IG51bGwgJiYgcGFyYW1zLmVmZmVjdGl2ZUdhc1ByaWNlID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRUcmFuc2FjdGlvblwiLCBoYXNoIH0pO1xuICAgICAgICAgICAgaWYgKHR4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZXBvcnQgdGhpczsgY291bGQgbm90IGZpbmQgdHggb3IgZWZmZWN0aXZlR2FzUHJpY2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJhbXMuZWZmZWN0aXZlR2FzUHJpY2UgPSB0eC5nYXNQcmljZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fd3JhcFRyYW5zYWN0aW9uUmVjZWlwdChwYXJhbXMsIG5ldHdvcmspO1xuICAgIH1cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvblJlc3VsdChoYXNoKSB7XG4gICAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcbiAgICAgICAgICAgIHJlc3VsdDogdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRUcmFuc2FjdGlvblJlc3VsdFwiLCBoYXNoIH0pXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KHJlc3VsdCk7XG4gICAgfVxuICAgIC8vIEJsb29tLWZpbHRlciBRdWVyaWVzXG4gICAgYXN5bmMgZ2V0TG9ncyhfZmlsdGVyKSB7XG4gICAgICAgIGxldCBmaWx0ZXIgPSB0aGlzLl9nZXRGaWx0ZXIoX2ZpbHRlcik7XG4gICAgICAgIGlmIChpc1Byb21pc2UoZmlsdGVyKSkge1xuICAgICAgICAgICAgZmlsdGVyID0gYXdhaXQgZmlsdGVyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbmV0d29yaywgcGFyYW1zIH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcbiAgICAgICAgICAgIHBhcmFtczogdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRMb2dzXCIsIGZpbHRlciB9KVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5tYXAoKHApID0+IHRoaXMuX3dyYXBMb2cocCwgbmV0d29yaykpO1xuICAgIH1cbiAgICAvLyBFTlNcbiAgICBfZ2V0UHJvdmlkZXIoY2hhaW5JZCkge1xuICAgICAgICBhc3NlcnQoZmFsc2UsIFwicHJvdmlkZXIgY2Fubm90IGNvbm5lY3QgdG8gdGFyZ2V0IG5ldHdvcmtcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcIl9nZXRQcm92aWRlcigpXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGdldFJlc29sdmVyKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IEVuc1Jlc29sdmVyLmZyb21OYW1lKHRoaXMsIG5hbWUpO1xuICAgIH1cbiAgICBhc3luYyBnZXRBdmF0YXIobmFtZSkge1xuICAgICAgICBjb25zdCByZXNvbHZlciA9IGF3YWl0IHRoaXMuZ2V0UmVzb2x2ZXIobmFtZSk7XG4gICAgICAgIGlmIChyZXNvbHZlcikge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJlc29sdmVyLmdldEF2YXRhcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhc3luYyByZXNvbHZlTmFtZShuYW1lKSB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVyID0gYXdhaXQgdGhpcy5nZXRSZXNvbHZlcihuYW1lKTtcbiAgICAgICAgaWYgKHJlc29sdmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcmVzb2x2ZXIuZ2V0QWRkcmVzcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhc3luYyBsb29rdXBBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICAgICAgYWRkcmVzcyA9IGdldEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuYW1laGFzaChhZGRyZXNzLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpICsgXCIuYWRkci5yZXZlcnNlXCIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZW5zQWRkciA9IGF3YWl0IEVuc1Jlc29sdmVyLmdldEVuc0FkZHJlc3ModGhpcyk7XG4gICAgICAgICAgICBjb25zdCBlbnNDb250cmFjdCA9IG5ldyBDb250cmFjdChlbnNBZGRyLCBbXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvbiByZXNvbHZlcihieXRlczMyKSB2aWV3IHJldHVybnMgKGFkZHJlc3MpXCJcbiAgICAgICAgICAgIF0sIHRoaXMpO1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBhd2FpdCBlbnNDb250cmFjdC5yZXNvbHZlcihub2RlKTtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlciA9PSBudWxsIHx8IHJlc29sdmVyID09PSBaZXJvQWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXJDb250cmFjdCA9IG5ldyBDb250cmFjdChyZXNvbHZlciwgW1xuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gbmFtZShieXRlczMyKSB2aWV3IHJldHVybnMgKHN0cmluZylcIlxuICAgICAgICAgICAgXSwgdGhpcyk7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gYXdhaXQgcmVzb2x2ZXJDb250cmFjdC5uYW1lKG5vZGUpO1xuICAgICAgICAgICAgLy8gRmFpbGVkIGZvcndhcmQgcmVzb2x1dGlvblxuICAgICAgICAgICAgY29uc3QgY2hlY2sgPSBhd2FpdCB0aGlzLnJlc29sdmVOYW1lKG5hbWUpO1xuICAgICAgICAgICAgaWYgKGNoZWNrICE9PSBhZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIE5vIGRhdGEgd2FzIHJldHVybmVkIGZyb20gdGhlIHJlc29sdmVyXG4gICAgICAgICAgICBpZiAoaXNFcnJvcihlcnJvciwgXCJCQURfREFUQVwiKSAmJiBlcnJvci52YWx1ZSA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTb21ldGhpbmcgcmVlcnRlZFxuICAgICAgICAgICAgaWYgKGlzRXJyb3IoZXJyb3IsIFwiQ0FMTF9FWENFUFRJT05cIikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhc3luYyB3YWl0Rm9yVHJhbnNhY3Rpb24oaGFzaCwgX2NvbmZpcm1zLCB0aW1lb3V0KSB7XG4gICAgICAgIGNvbnN0IGNvbmZpcm1zID0gKF9jb25maXJtcyAhPSBudWxsKSA/IF9jb25maXJtcyA6IDE7XG4gICAgICAgIGlmIChjb25maXJtcyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGhhc2gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsZXQgdGltZXIgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXIgPSAoYXN5bmMgKGJsb2NrTnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHRoaXMuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGhhc2gpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjZWlwdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgLSByZWNlaXB0LmJsb2NrTnVtYmVyICsgMSA+PSBjb25maXJtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVjZWlwdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90aGlzLm9mZihcImJsb2NrXCIsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRUVFXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5vbmNlKFwiYmxvY2tcIiwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGltZW91dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2ZmKFwiYmxvY2tcIiwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobWFrZUVycm9yKFwidGltZW91dFwiLCBcIlRJTUVPVVRcIiwgeyByZWFzb246IFwidGltZW91dFwiIH0pKTtcbiAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3RlbmVyKGF3YWl0IHRoaXMuZ2V0QmxvY2tOdW1iZXIoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyB3YWl0Rm9yQmxvY2soYmxvY2tUYWcpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcIm5vdCBpbXBsZW1lbnRlZCB5ZXRcIiwgXCJOT1RfSU1QTEVNRU5URURcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcIndhaXRGb3JCbG9ja1wiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ2xlYXIgYSB0aW1lciBjcmVhdGVkIHVzaW5nIHRoZSBbW19zZXRUaW1lb3V0XV0gbWV0aG9kLlxuICAgICAqL1xuICAgIF9jbGVhclRpbWVvdXQodGltZXJJZCkge1xuICAgICAgICBjb25zdCB0aW1lciA9IHRoaXMuI3RpbWVycy5nZXQodGltZXJJZCk7XG4gICAgICAgIGlmICghdGltZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZXIudGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lci50aW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jdGltZXJzLmRlbGV0ZSh0aW1lcklkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIHRpbWVyIHRoYXQgd2lsbCBleGVjdXRlICUlZnVuYyUlIGFmdGVyIGF0IGxlYXN0ICUldGltZW91dCUlXG4gICAgICogIChpbiBtcykuIElmICUldGltZW91dCUlIGlzIHVuc3BlY2lmaWVkLCB0aGVuICUlZnVuYyUlIHdpbGwgZXhlY3V0ZVxuICAgICAqICBpbiB0aGUgbmV4dCBldmVudCBsb29wLlxuICAgICAqXG4gICAgICogIFtQYXVzaW5nXShBYnN0cmFjdFByb3ZpZGVyLXBhdXNlZCkgdGhlIHByb3ZpZGVyIHdpbGwgcGF1c2UgYW55XG4gICAgICogIGFzc29jaWF0ZWQgdGltZXJzLlxuICAgICAqL1xuICAgIF9zZXRUaW1lb3V0KF9mdW5jLCB0aW1lb3V0KSB7XG4gICAgICAgIGlmICh0aW1lb3V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRpbWVvdXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbWVySWQgPSB0aGlzLiNuZXh0VGltZXIrKztcbiAgICAgICAgY29uc3QgZnVuYyA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuI3RpbWVycy5kZWxldGUodGltZXJJZCk7XG4gICAgICAgICAgICBfZnVuYygpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5wYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuI3RpbWVycy5zZXQodGltZXJJZCwgeyB0aW1lcjogbnVsbCwgZnVuYywgdGltZTogdGltZW91dCB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dChmdW5jLCB0aW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMuI3RpbWVycy5zZXQodGltZXJJZCwgeyB0aW1lciwgZnVuYywgdGltZTogZ2V0VGltZSgpIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aW1lcklkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUGVyZm9ybSAlJWZ1bmMlJSBvbiBlYWNoIHN1YnNjcmliZXIuXG4gICAgICovXG4gICAgX2ZvckVhY2hTdWJzY3JpYmVyKGZ1bmMpIHtcbiAgICAgICAgZm9yIChjb25zdCBzdWIgb2YgdGhpcy4jc3Vicy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgZnVuYyhzdWIuc3Vic2NyaWJlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzIG1heSBvdmVycmlkZSB0aGlzIHRvIGN1c3RvbWl6ZSBzdWJzY3JpcHRpb25cbiAgICAgKiAgaW1wbGVtZW50YXRpb25zLlxuICAgICAqL1xuICAgIF9nZXRTdWJzY3JpYmVyKHN1Yikge1xuICAgICAgICBzd2l0Y2ggKHN1Yi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiZGVidWdcIjpcbiAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgY2FzZSBcIm5ldHdvcmtcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVubWFuYWdlZFN1YnNjcmliZXIoc3ViLnR5cGUpO1xuICAgICAgICAgICAgY2FzZSBcImJsb2NrXCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJzY3JpYmVyID0gbmV3IFBvbGxpbmdCbG9ja1N1YnNjcmliZXIodGhpcyk7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5wb2xsaW5nSW50ZXJ2YWwgPSB0aGlzLnBvbGxpbmdJbnRlcnZhbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzYWZlXCI6XG4gICAgICAgICAgICBjYXNlIFwiZmluYWxpemVkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nQmxvY2tUYWdTdWJzY3JpYmVyKHRoaXMsIHN1Yi50eXBlKTtcbiAgICAgICAgICAgIGNhc2UgXCJldmVudFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9sbGluZ0V2ZW50U3Vic2NyaWJlcih0aGlzLCBzdWIuZmlsdGVyKTtcbiAgICAgICAgICAgIGNhc2UgXCJ0cmFuc2FjdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9sbGluZ1RyYW5zYWN0aW9uU3Vic2NyaWJlcih0aGlzLCBzdWIuaGFzaCk7XG4gICAgICAgICAgICBjYXNlIFwib3JwaGFuXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nT3JwaGFuU3Vic2NyaWJlcih0aGlzLCBzdWIuZmlsdGVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGV2ZW50OiAke3N1Yi50eXBlfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSWYgYSBbW1N1YnNjcmliZXJdXSBmYWlscyBhbmQgbmVlZHMgdG8gcmVwbGFjZSBpdHNlbGYsIHRoaXNcbiAgICAgKiAgbWV0aG9kIG1heSBiZSB1c2VkLlxuICAgICAqXG4gICAgICogIEZvciBleGFtcGxlLCB0aGlzIGlzIHVzZWQgZm9yIHByb3ZpZGVycyB3aGVuIHVzaW5nIHRoZVxuICAgICAqICBgYGV0aF9nZXRGaWx0ZXJDaGFuZ2VzYGAgbWV0aG9kLCB3aGljaCBjYW4gcmV0dXJuIG51bGwgaWYgc3RhdGVcbiAgICAgKiAgZmlsdGVycyBhcmUgbm90IHN1cHBvcnRlZCBieSB0aGUgYmFja2VuZCwgYWxsb3dpbmcgdGhlIFN1YnNjcmliZXJcbiAgICAgKiAgdG8gc3dhcCBpbiBhIFtbUG9sbGluZ0V2ZW50U3Vic2NyaWJlcl1dLlxuICAgICAqL1xuICAgIF9yZWNvdmVyU3Vic2NyaWJlcihvbGRTdWIsIG5ld1N1Yikge1xuICAgICAgICBmb3IgKGNvbnN0IHN1YiBvZiB0aGlzLiNzdWJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBpZiAoc3ViLnN1YnNjcmliZXIgPT09IG9sZFN1Yikge1xuICAgICAgICAgICAgICAgIGlmIChzdWIuc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBzdWIuc3Vic2NyaWJlci5zdG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyID0gbmV3U3ViO1xuICAgICAgICAgICAgICAgIGlmIChzdWIuc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdTdWIuc3RhcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI3BhdXNlZFN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3ViLnBhdXNlKHRoaXMuI3BhdXNlZFN0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgI2hhc1N1YihldmVudCwgZW1pdEFyZ3MpIHtcbiAgICAgICAgbGV0IHN1YiA9IGF3YWl0IGdldFN1YnNjcmlwdGlvbihldmVudCwgdGhpcyk7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBsb2cgdGhhdCBpcyByZW1vdmluZyBhbiBleGlzdGluZyBsb2c7IHdlIGFjdHVhbGx5IHdhbnRcbiAgICAgICAgLy8gdG8gZW1pdCBhbiBvcnBoYW4gZXZlbnQgZm9yIHRoZSByZW1vdmVkIGxvZ1xuICAgICAgICBpZiAoc3ViLnR5cGUgPT09IFwiZXZlbnRcIiAmJiBlbWl0QXJncyAmJiBlbWl0QXJncy5sZW5ndGggPiAwICYmIGVtaXRBcmdzWzBdLnJlbW92ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHN1YiA9IGF3YWl0IGdldFN1YnNjcmlwdGlvbih7IG9ycGhhbjogXCJkcm9wLWxvZ1wiLCBsb2c6IGVtaXRBcmdzWzBdIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiNzdWJzLmdldChzdWIudGFnKSB8fCBudWxsO1xuICAgIH1cbiAgICBhc3luYyAjZ2V0U3ViKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGF3YWl0IGdldFN1YnNjcmlwdGlvbihldmVudCwgdGhpcyk7XG4gICAgICAgIC8vIFByZXZlbnQgdGFtcGVyaW5nIHdpdGggb3VyIHRhZyBpbiBhbnkgc3ViY2xhc3MnIF9nZXRTdWJzY3JpYmVyXG4gICAgICAgIGNvbnN0IHRhZyA9IHN1YnNjcmlwdGlvbi50YWc7XG4gICAgICAgIGxldCBzdWIgPSB0aGlzLiNzdWJzLmdldCh0YWcpO1xuICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaWJlciA9IHRoaXMuX2dldFN1YnNjcmliZXIoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3NhYmxlTWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBzdWIgPSB7IHN1YnNjcmliZXIsIHRhZywgYWRkcmVzc2FibGVNYXAsIG5hbWVNYXAsIHN0YXJ0ZWQ6IGZhbHNlLCBsaXN0ZW5lcnM6IFtdIH07XG4gICAgICAgICAgICB0aGlzLiNzdWJzLnNldCh0YWcsIHN1Yik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YjtcbiAgICB9XG4gICAgYXN5bmMgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuI2dldFN1YihldmVudCk7XG4gICAgICAgIHN1Yi5saXN0ZW5lcnMucHVzaCh7IGxpc3RlbmVyLCBvbmNlOiBmYWxzZSB9KTtcbiAgICAgICAgaWYgKCFzdWIuc3RhcnRlZCkge1xuICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIuc3RhcnQoKTtcbiAgICAgICAgICAgIHN1Yi5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLiNwYXVzZWRTdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIucGF1c2UodGhpcy4jcGF1c2VkU3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhc3luYyBvbmNlKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCB0aGlzLiNnZXRTdWIoZXZlbnQpO1xuICAgICAgICBzdWIubGlzdGVuZXJzLnB1c2goeyBsaXN0ZW5lciwgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgaWYgKCFzdWIuc3RhcnRlZCkge1xuICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIuc3RhcnQoKTtcbiAgICAgICAgICAgIHN1Yi5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLiNwYXVzZWRTdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIucGF1c2UodGhpcy4jcGF1c2VkU3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhc3luYyBlbWl0KGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuI2hhc1N1YihldmVudCwgYXJncyk7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vdCBzdWJzY3JpcHRpb24gb3IgaWYgYSByZWNlbnQgZW1pdCByZW1vdmVkXG4gICAgICAgIC8vIHRoZSBsYXN0IG9mIHRoZW0gKHdoaWNoIGFsc28gZGVsZXRlZCB0aGUgc3ViKSBkbyBub3RoaW5nXG4gICAgICAgIGlmICghc3ViIHx8IHN1Yi5saXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICBjb25zdCBjb3VudCA9IHN1Yi5saXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICBzdWIubGlzdGVuZXJzID0gc3ViLmxpc3RlbmVycy5maWx0ZXIoKHsgbGlzdGVuZXIsIG9uY2UgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IG5ldyBFdmVudFBheWxvYWQodGhpcywgKG9uY2UgPyBudWxsIDogbGlzdGVuZXIpLCBldmVudCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgLi4uYXJncywgcGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgcmV0dXJuICFvbmNlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHN1Yi5saXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoc3ViLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICBzdWIuc3Vic2NyaWJlci5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNzdWJzLmRlbGV0ZShzdWIudGFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGNvdW50ID4gMCk7XG4gICAgfVxuICAgIGFzeW5jIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCB0aGlzLiNoYXNTdWIoZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFzdWIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdWIubGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG90YWwgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHsgbGlzdGVuZXJzIH0gb2YgdGhpcy4jc3Vicy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgdG90YWwgKz0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgfVxuICAgIGFzeW5jIGxpc3RlbmVycyhldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuI2hhc1N1YihldmVudCk7XG4gICAgICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdWIubGlzdGVuZXJzLm1hcCgoeyBsaXN0ZW5lciB9KSA9PiBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHsgbGlzdGVuZXJzIH0gb2YgdGhpcy4jc3Vicy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChsaXN0ZW5lcnMubWFwKCh7IGxpc3RlbmVyIH0pID0+IGxpc3RlbmVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgb2ZmKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCB0aGlzLiNoYXNTdWIoZXZlbnQpO1xuICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHN1Yi5saXN0ZW5lcnMubWFwKCh7IGxpc3RlbmVyIH0pID0+IGxpc3RlbmVyKS5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgc3ViLmxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbGlzdGVuZXIgfHwgc3ViLmxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmIChzdWIuc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI3N1YnMuZGVsZXRlKHN1Yi50YWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhc3luYyByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCB7IHRhZywgc3RhcnRlZCwgc3Vic2NyaWJlciB9ID0gYXdhaXQgdGhpcy4jZ2V0U3ViKGV2ZW50KTtcbiAgICAgICAgICAgIGlmIChzdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNzdWJzLmRlbGV0ZSh0YWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbdGFnLCB7IHN0YXJ0ZWQsIHN1YnNjcmliZXIgfV0gb2YgdGhpcy4jc3Vicykge1xuICAgICAgICAgICAgICAgIGlmIChzdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuc3RvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLiNzdWJzLmRlbGV0ZSh0YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBBbGlhcyBmb3IgXCJvblwiXG4gICAgYXN5bmMgYWRkTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8vIEFsaWFzIGZvciBcIm9mZlwiXG4gICAgYXN5bmMgcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9mZihldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSWYgdGhpcyBwcm92aWRlciBoYXMgYmVlbiBkZXN0cm95ZWQgdXNpbmcgdGhlIFtbZGVzdHJveV1dIG1ldGhvZC5cbiAgICAgKlxuICAgICAqICBPbmNlIGRlc3Ryb3llZCwgYWxsIHJlc291cmNlcyBhcmUgcmVjbGFpbWVkLCBpbnRlcm5hbCBldmVudCBsb29wc1xuICAgICAqICBhbmQgdGltZXJzIGFyZSBjbGVhbmVkIHVwIGFuZCBubyBmdXJ0aGVyIHJlcXVlc3RzIG1heSBiZSBzZW50IHRvXG4gICAgICogIHRoZSBwcm92aWRlci5cbiAgICAgKi9cbiAgICBnZXQgZGVzdHJveWVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZGVzdHJveWVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU3ViLWNsYXNzZXMgbWF5IHVzZSB0aGlzIHRvIHNodXRkb3duIGFueSBzb2NrZXRzIG9yIHJlbGVhc2UgdGhlaXJcbiAgICAgKiAgcmVzb3VyY2VzIGFuZCByZWplY3QgYW55IHBlbmRpbmcgcmVxdWVzdHMuXG4gICAgICpcbiAgICAgKiAgU3ViLWNsYXNzZXMgKiptdXN0KiogY2FsbCBgYHN1cGVyLmRlc3Ryb3koKWBgLlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIC8vIFN0b3AgYWxsIGxpc3RlbmVyc1xuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAvLyBTaHV0IGRvd24gYWxsIHRpZW1yc1xuICAgICAgICBmb3IgKGNvbnN0IHRpbWVySWQgb2YgdGhpcy4jdGltZXJzLmtleXMoKSkge1xuICAgICAgICAgICAgdGhpcy5fY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBXaGV0aGVyIHRoZSBwcm92aWRlciBpcyBjdXJyZW50bHkgcGF1c2VkLlxuICAgICAqXG4gICAgICogIEEgcGF1c2VkIHByb3ZpZGVyIHdpbGwgbm90IGVtaXQgYW55IGV2ZW50cywgYW5kIGdlbmVyYWxseSBzaG91bGRcbiAgICAgKiAgbm90IG1ha2UgYW55IHJlcXVlc3RzIHRvIHRoZSBuZXR3b3JrLCBidXQgdGhhdCBpcyB1cCB0byBzdWItY2xhc3Nlc1xuICAgICAqICB0byBtYW5hZ2UuXG4gICAgICpcbiAgICAgKiAgU2V0dGluZyBgYHBhdXNlZCA9IHRydWVgYCBpcyBpZGVudGljYWwgdG8gY2FsbGluZyBgYC5wYXVzZShmYWxzZSlgYCxcbiAgICAgKiAgd2hpY2ggd2lsbCBidWZmZXIgYW55IGV2ZW50cyB0aGF0IG9jY3VyIHdoaWxlIHBhdXNlZCB1bnRpbCB0aGVcbiAgICAgKiAgcHJvdmlkZXIgaXMgdW5wYXVzZWQuXG4gICAgICovXG4gICAgZ2V0IHBhdXNlZCgpIHsgcmV0dXJuICh0aGlzLiNwYXVzZWRTdGF0ZSAhPSBudWxsKTsgfVxuICAgIHNldCBwYXVzZWQocGF1c2UpIHtcbiAgICAgICAgaWYgKCEhcGF1c2UgPT09IHRoaXMucGF1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3VtZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYXVzZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFBhdXNlIHRoZSBwcm92aWRlci4gSWYgJSVkcm9wV2hpbGVQYXVzZWQlJSwgYW55IGV2ZW50cyB0aGF0IG9jY3VyXG4gICAgICogIHdoaWxlIHBhdXNlZCBhcmUgZHJvcHBlZCwgb3RoZXJ3aXNlIGFsbCBldmVudHMgd2lsbCBiZSBlbWl0dGVkIG9uY2VcbiAgICAgKiAgdGhlIHByb3ZpZGVyIGlzIHVucGF1c2VkLlxuICAgICAqL1xuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICB0aGlzLiNsYXN0QmxvY2tOdW1iZXIgPSAtMTtcbiAgICAgICAgaWYgKHRoaXMuI3BhdXNlZFN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNwYXVzZWRTdGF0ZSA9PSAhIWRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJjYW5ub3QgY2hhbmdlIHBhdXNlIHR5cGU7IHJlc3VtZSBmaXJzdFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInBhdXNlXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ZvckVhY2hTdWJzY3JpYmVyKChzKSA9PiBzLnBhdXNlKGRyb3BXaGlsZVBhdXNlZCkpO1xuICAgICAgICB0aGlzLiNwYXVzZWRTdGF0ZSA9ICEhZHJvcFdoaWxlUGF1c2VkO1xuICAgICAgICBmb3IgKGNvbnN0IHRpbWVyIG9mIHRoaXMuI3RpbWVycy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIHRpbWVyXG4gICAgICAgICAgICBpZiAodGltZXIudGltZXIpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIudGltZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtYWluaW5nIHRpbWUgbmVlZGVkIGZvciB3aGVuIHdlIGJlY29tZSB1bnBhdXNlZFxuICAgICAgICAgICAgdGltZXIudGltZSA9IGdldFRpbWUoKSAtIHRpbWVyLnRpbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc3VtZSB0aGUgcHJvdmlkZXIuXG4gICAgICovXG4gICAgcmVzdW1lKCkge1xuICAgICAgICBpZiAodGhpcy4jcGF1c2VkU3RhdGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ZvckVhY2hTdWJzY3JpYmVyKChzKSA9PiBzLnJlc3VtZSgpKTtcbiAgICAgICAgdGhpcy4jcGF1c2VkU3RhdGUgPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IHRpbWVyIG9mIHRoaXMuI3RpbWVycy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgLy8gUmVtYWluaW5nIHRpbWUgd2hlbiB3ZSB3ZXJlIHBhdXNlZFxuICAgICAgICAgICAgbGV0IHRpbWVvdXQgPSB0aW1lci50aW1lO1xuICAgICAgICAgICAgaWYgKHRpbWVvdXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdGFydCB0aW1lIChpbiBjYXVzZSBwYXVzZWQsIHNvIHdlIGNvbiBjb21wdXRlIHJlbWFpbmluZiB0aW1lKVxuICAgICAgICAgICAgdGltZXIudGltZSA9IGdldFRpbWUoKTtcbiAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSB0aW1lclxuICAgICAgICAgICAgc2V0VGltZW91dCh0aW1lci5mdW5jLCB0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIF9wYXJzZVN0cmluZyhyZXN1bHQsIHN0YXJ0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBfcGFyc2VCeXRlcyhyZXN1bHQsIHN0YXJ0KTtcbiAgICAgICAgaWYgKGJ5dGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9VdGY4U3RyaW5nKGJ5dGVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gX3BhcnNlQnl0ZXMocmVzdWx0LCBzdGFydCkge1xuICAgIGlmIChyZXN1bHQgPT09IFwiMHhcIikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gZ2V0TnVtYmVyKGRhdGFTbGljZShyZXN1bHQsIHN0YXJ0LCBzdGFydCArIDMyKSk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGdldE51bWJlcihkYXRhU2xpY2UocmVzdWx0LCBvZmZzZXQsIG9mZnNldCArIDMyKSk7XG4gICAgICAgIHJldHVybiBkYXRhU2xpY2UocmVzdWx0LCBvZmZzZXQgKyAzMiwgb2Zmc2V0ICsgMzIgKyBsZW5ndGgpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gbnVtUGFkKHZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdG9CZUFycmF5KHZhbHVlKTtcbiAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludGVybmFsOyBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICB9XG4gICAgY29uc3QgcGFkZGVkID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICAgIHBhZGRlZC5zZXQocmVzdWx0LCAzMiAtIHJlc3VsdC5sZW5ndGgpO1xuICAgIHJldHVybiBwYWRkZWQ7XG59XG5mdW5jdGlvbiBieXRlc1BhZCh2YWx1ZSkge1xuICAgIGlmICgodmFsdWUubGVuZ3RoICUgMzIpID09PSAwKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKHZhbHVlLmxlbmd0aCAvIDMyKSAqIDMyKTtcbiAgICByZXN1bHQuc2V0KHZhbHVlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgZW1wdHkgPSBuZXcgVWludDhBcnJheShbXSk7XG4vLyBBQkkgRW5jb2RlcyBhIHNlcmllcyBvZiAoYnl0ZXMsIGJ5dGVzLCAuLi4pXG5mdW5jdGlvbiBlbmNvZGVCeXRlcyhkYXRhcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBieXRlQ291bnQgPSAwO1xuICAgIC8vIEFkZCBwbGFjZS1ob2xkZXJzIGZvciBwb2ludGVycyBhcyB3ZSBhZGQgaXRlbXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGVtcHR5KTtcbiAgICAgICAgYnl0ZUNvdW50ICs9IDMyO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBnZXRCeXRlcyhkYXRhc1tpXSk7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgYnl0ZXMgb2Zmc2V0XG4gICAgICAgIHJlc3VsdFtpXSA9IG51bVBhZChieXRlQ291bnQpO1xuICAgICAgICAvLyBUaGUgbGVuZ3RoIGFuZCBwYWRkZWQgdmFsdWUgb2YgZGF0YVxuICAgICAgICByZXN1bHQucHVzaChudW1QYWQoZGF0YS5sZW5ndGgpKTtcbiAgICAgICAgcmVzdWx0LnB1c2goYnl0ZXNQYWQoZGF0YSkpO1xuICAgICAgICBieXRlQ291bnQgKz0gMzIgKyBNYXRoLmNlaWwoZGF0YS5sZW5ndGggLyAzMikgKiAzMjtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmNhdChyZXN1bHQpO1xufVxuY29uc3QgemVyb3MgPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuZnVuY3Rpb24gcGFyc2VPZmZjaGFpbkxvb2t1cChkYXRhKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBzZW5kZXI6IFwiXCIsIHVybHM6IFtdLCBjYWxsZGF0YTogXCJcIiwgc2VsZWN0b3I6IFwiXCIsIGV4dHJhRGF0YTogXCJcIiwgZXJyb3JBcmdzOiBbXVxuICAgIH07XG4gICAgYXNzZXJ0KGRhdGFMZW5ndGgoZGF0YSkgPj0gNSAqIDMyLCBcImluc3VmZmljaWVudCBPZmZjaGFpbkxvb2t1cCBkYXRhXCIsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xuICAgICAgICByZWFzb246IFwiaW5zdWZmaWNpZW50IE9mZmNoYWluTG9va3VwIGRhdGFcIlxuICAgIH0pO1xuICAgIGNvbnN0IHNlbmRlciA9IGRhdGFTbGljZShkYXRhLCAwLCAzMik7XG4gICAgYXNzZXJ0KGRhdGFTbGljZShzZW5kZXIsIDAsIDEyKSA9PT0gZGF0YVNsaWNlKHplcm9zLCAwLCAxMiksIFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCBzZW5kZXJcIiwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgIHJlYXNvbjogXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIHNlbmRlclwiXG4gICAgfSk7XG4gICAgcmVzdWx0LnNlbmRlciA9IGRhdGFTbGljZShzZW5kZXIsIDEyKTtcbiAgICAvLyBSZWFkIHRoZSBVUkxzIGZyb20gdGhlIHJlc3BvbnNlXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdXJscyA9IFtdO1xuICAgICAgICBjb25zdCB1cmxzT2Zmc2V0ID0gZ2V0TnVtYmVyKGRhdGFTbGljZShkYXRhLCAzMiwgNjQpKTtcbiAgICAgICAgY29uc3QgdXJsc0xlbmd0aCA9IGdldE51bWJlcihkYXRhU2xpY2UoZGF0YSwgdXJsc09mZnNldCwgdXJsc09mZnNldCArIDMyKSk7XG4gICAgICAgIGNvbnN0IHVybHNEYXRhID0gZGF0YVNsaWNlKGRhdGEsIHVybHNPZmZzZXQgKyAzMik7XG4gICAgICAgIGZvciAobGV0IHUgPSAwOyB1IDwgdXJsc0xlbmd0aDsgdSsrKSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBfcGFyc2VTdHJpbmcodXJsc0RhdGEsIHUgKiAzMik7XG4gICAgICAgICAgICBpZiAodXJsID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhYm9ydFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVybHMucHVzaCh1cmwpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC51cmxzID0gdXJscztcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIHVybHNcIiwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgICAgICByZWFzb246IFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCB1cmxzXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgQ0NJUCBjYWxsZGF0YSB0byBmb3J3YXJkXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY2FsbGRhdGEgPSBfcGFyc2VCeXRlcyhkYXRhLCA2NCk7XG4gICAgICAgIGlmIChjYWxsZGF0YSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhYm9ydFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuY2FsbGRhdGEgPSBjYWxsZGF0YTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIGNhbGxkYXRhXCIsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xuICAgICAgICAgICAgcmVhc29uOiBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgY2FsbGRhdGFcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gR2V0IHRoZSBjYWxsYmFja1NlbGVjdG9yIChieXRlczQpXG4gICAgYXNzZXJ0KGRhdGFTbGljZShkYXRhLCAxMDAsIDEyOCkgPT09IGRhdGFTbGljZSh6ZXJvcywgMCwgMjgpLCBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgY2FsbGJhYWNrU2VsZWN0b3JcIiwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgIHJlYXNvbjogXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIGNhbGxiYWFja1NlbGVjdG9yXCJcbiAgICB9KTtcbiAgICByZXN1bHQuc2VsZWN0b3IgPSBkYXRhU2xpY2UoZGF0YSwgOTYsIDEwMCk7XG4gICAgLy8gR2V0IHRoZSBleHRyYSBkYXRhIHRvIHNlbmQgYmFjayB0byB0aGUgY29udHJhY3QgYXMgY29udGV4dFxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGV4dHJhRGF0YSA9IF9wYXJzZUJ5dGVzKGRhdGEsIDEyOCk7XG4gICAgICAgIGlmIChleHRyYURhdGEgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWJvcnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LmV4dHJhRGF0YSA9IGV4dHJhRGF0YTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIGV4dHJhRGF0YVwiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIHJlYXNvbjogXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIGV4dHJhRGF0YVwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXN1bHQuZXJyb3JBcmdzID0gXCJzZW5kZXIsdXJscyxjYWxsZGF0YSxzZWxlY3RvcixleHRyYURhdGFcIi5zcGxpdCgvLC8pLm1hcCgoaykgPT4gcmVzdWx0W2tdKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWJzdHJhY3QtcHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbImdldEFkZHJlc3MiLCJyZXNvbHZlQWRkcmVzcyIsIlplcm9BZGRyZXNzIiwiQ29udHJhY3QiLCJuYW1laGFzaCIsIlRyYW5zYWN0aW9uIiwiY29uY2F0IiwiZGF0YUxlbmd0aCIsImRhdGFTbGljZSIsImhleGxpZnkiLCJpc0hleFN0cmluZyIsImdldEJpZ0ludCIsImdldEJ5dGVzIiwiZ2V0TnVtYmVyIiwiaXNDYWxsRXhjZXB0aW9uIiwiaXNFcnJvciIsIm1ha2VFcnJvciIsImFzc2VydCIsImFzc2VydEFyZ3VtZW50IiwiRmV0Y2hSZXF1ZXN0IiwidG9CZUFycmF5IiwidG9RdWFudGl0eSIsImRlZmluZVByb3BlcnRpZXMiLCJFdmVudFBheWxvYWQiLCJyZXNvbHZlUHJvcGVydGllcyIsInRvVXRmOFN0cmluZyIsIkVuc1Jlc29sdmVyIiwiZm9ybWF0QmxvY2siLCJmb3JtYXRMb2ciLCJmb3JtYXRUcmFuc2FjdGlvblJlY2VpcHQiLCJmb3JtYXRUcmFuc2FjdGlvblJlc3BvbnNlIiwiTmV0d29yayIsImNvcHlSZXF1ZXN0IiwiQmxvY2siLCJGZWVEYXRhIiwiTG9nIiwiVHJhbnNhY3Rpb25SZWNlaXB0IiwiVHJhbnNhY3Rpb25SZXNwb25zZSIsIlBvbGxpbmdCbG9ja1N1YnNjcmliZXIiLCJQb2xsaW5nQmxvY2tUYWdTdWJzY3JpYmVyIiwiUG9sbGluZ0V2ZW50U3Vic2NyaWJlciIsIlBvbGxpbmdPcnBoYW5TdWJzY3JpYmVyIiwiUG9sbGluZ1RyYW5zYWN0aW9uU3Vic2NyaWJlciIsIkJOXzIiLCJCaWdJbnQiLCJNQVhfQ0NJUF9SRURJUkVDVFMiLCJpc1Byb21pc2UiLCJ2YWx1ZSIsInRoZW4iLCJnZXRUYWciLCJwcmVmaXgiLCJKU09OIiwic3RyaW5naWZ5IiwiayIsInYiLCJ0b1N0cmluZyIsInRvTG93ZXJDYXNlIiwiQXJyYXkiLCJpc0FycmF5Iiwia2V5cyIsIk9iamVjdCIsInNvcnQiLCJyZWR1Y2UiLCJhY2N1bSIsImtleSIsIlVubWFuYWdlZFN1YnNjcmliZXIiLCJzdGFydCIsInN0b3AiLCJwYXVzZSIsImRyb3BXaGlsZVBhdXNlZCIsInJlc3VtZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsImNvcHkiLCJwYXJzZSIsImNvbmNpc2lmeSIsIml0ZW1zIiwiZnJvbSIsIlNldCIsInZhbHVlcyIsImdldFN1YnNjcmlwdGlvbiIsIl9ldmVudCIsInByb3ZpZGVyIiwiRXJyb3IiLCJ0b3BpY3MiLCJ0eXBlIiwidGFnIiwiaGFzaCIsIm9ycGhhbiIsImV2ZW50IiwiZmlsdGVyIiwiYWRkcmVzcyIsIm1hcCIsInQiLCJhZGRyZXNzZXMiLCJwcm9taXNlcyIsImFkZEFkZHJlc3MiLCJhZGRyIiwicHVzaCIsImZvckVhY2giLCJsZW5ndGgiLCJQcm9taXNlIiwiYWxsIiwiYSIsImdldFRpbWUiLCJEYXRlIiwiZGVmYXVsdE9wdGlvbnMiLCJjYWNoZVRpbWVvdXQiLCJwb2xsaW5nSW50ZXJ2YWwiLCJBYnN0cmFjdFByb3ZpZGVyIiwib3B0aW9ucyIsInBsdWdpbnMiLCJhdHRhY2hQbHVnaW4iLCJwbHVnaW4iLCJnZXQiLCJzZXQiLCJjb25uZWN0IiwiZ2V0UGx1Z2luIiwiZGlzYWJsZUNjaXBSZWFkIiwiY2NpcFJlYWRGZXRjaCIsInR4IiwiY2FsbGRhdGEiLCJ1cmxzIiwidG8iLCJzZW5kZXIiLCJkYXRhIiwiZXJyb3JNZXNzYWdlcyIsImkiLCJ1cmwiLCJocmVmIiwicmVwbGFjZSIsInJlcXVlc3QiLCJpbmRleE9mIiwiYm9keSIsImVtaXQiLCJhY3Rpb24iLCJpbmRleCIsImVycm9yTWVzc2FnZSIsInJlc3AiLCJzZW5kIiwiZXJyb3IiLCJtZXNzYWdlIiwicmVzdWx0IiwiYm9keUpzb24iLCJzdGF0dXNDb2RlIiwicmVhc29uIiwidHJhbnNhY3Rpb24iLCJpbmZvIiwibSIsImpvaW4iLCJfd3JhcEJsb2NrIiwibmV0d29yayIsIl93cmFwTG9nIiwiX3dyYXBUcmFuc2FjdGlvblJlY2VpcHQiLCJfd3JhcFRyYW5zYWN0aW9uUmVzcG9uc2UiLCJfZGV0ZWN0TmV0d29yayIsIm9wZXJhdGlvbiIsIl9wZXJmb3JtIiwicmVxIiwibWV0aG9kIiwiZ2V0QmxvY2tOdW1iZXIiLCJibG9ja051bWJlciIsInBlcmZvcm0iLCJsYXN0QmxvY2tOdW1iZXIiLCJfZ2V0QWRkcmVzcyIsIl9nZXRCbG9ja1RhZyIsImJsb2NrVGFnIiwiYiIsIl9nZXRGaWx0ZXIiLCJibG9ja0hhc2giLCJ1bmRlZmluZWQiLCJyZXNvbHZlIiwiX2FkZHJlc3MiLCJmcm9tQmxvY2siLCJ0b0Jsb2NrIiwiX2dldFRyYW5zYWN0aW9uUmVxdWVzdCIsIl9yZXF1ZXN0IiwiZ2V0TmV0d29yayIsIm5ldHdvcmtQcm9taXNlIiwiZGV0ZWN0TmV0d29yayIsImNsb25lIiwiZXhwZWN0ZWQiLCJhY3R1YWwiLCJjaGFpbklkIiwiYW55TmV0d29yayIsImdldEZlZURhdGEiLCJnZXRGZWVEYXRhRnVuYyIsIl9ibG9jayIsImdhc1ByaWNlIiwicHJpb3JpdHlGZWUiLCJnZXRCbG9jayIsIm1heEZlZVBlckdhcyIsIm1heFByaW9yaXR5RmVlUGVyR2FzIiwiYmxvY2siLCJiYXNlRmVlUGVyR2FzIiwiZmVlRGF0YSIsInByb2Nlc3NGdW5jIiwiZXN0aW1hdGVHYXMiLCJfdHgiLCJjYWxsIiwiY2hlY2tOZXR3b3JrIiwiZW5hYmxlQ2NpcFJlYWQiLCJnZXRCYWxhbmNlIiwiZ2V0QWNjb3VudFZhbHVlIiwiZ2V0VHJhbnNhY3Rpb25Db3VudCIsImdldENvZGUiLCJnZXRTdG9yYWdlIiwiX3Bvc2l0aW9uIiwicG9zaXRpb24iLCJicm9hZGNhc3RUcmFuc2FjdGlvbiIsInNpZ25lZFR4Iiwic2lnbmVkVHJhbnNhY3Rpb24iLCJyZXBsYWNlYWJsZVRyYW5zYWN0aW9uIiwicHJlZmV0Y2hUeHMiLCJwYXJhbXMiLCJnZXRUcmFuc2FjdGlvbiIsImdldFRyYW5zYWN0aW9uUmVjZWlwdCIsImVmZmVjdGl2ZUdhc1ByaWNlIiwiZ2V0VHJhbnNhY3Rpb25SZXN1bHQiLCJnZXRMb2dzIiwiX2ZpbHRlciIsInAiLCJfZ2V0UHJvdmlkZXIiLCJnZXRSZXNvbHZlciIsImZyb21OYW1lIiwiZ2V0QXZhdGFyIiwicmVzb2x2ZXIiLCJyZXNvbHZlTmFtZSIsImxvb2t1cEFkZHJlc3MiLCJub2RlIiwic3Vic3RyaW5nIiwiZW5zQWRkciIsImdldEVuc0FkZHJlc3MiLCJlbnNDb250cmFjdCIsInJlc29sdmVyQ29udHJhY3QiLCJjaGVjayIsIndhaXRGb3JUcmFuc2FjdGlvbiIsIl9jb25maXJtcyIsInRpbWVvdXQiLCJjb25maXJtcyIsInJlamVjdCIsInRpbWVyIiwibGlzdGVuZXIiLCJyZWNlaXB0IiwiY2xlYXJUaW1lb3V0IiwiY29uc29sZSIsImxvZyIsIm9uY2UiLCJzZXRUaW1lb3V0Iiwib2ZmIiwid2FpdEZvckJsb2NrIiwiX2NsZWFyVGltZW91dCIsInRpbWVySWQiLCJ0aW1lcnMiLCJkZWxldGUiLCJfc2V0VGltZW91dCIsIl9mdW5jIiwibmV4dFRpbWVyIiwiZnVuYyIsInBhdXNlZCIsInRpbWUiLCJfZm9yRWFjaFN1YnNjcmliZXIiLCJzdWIiLCJzdWJzIiwic3Vic2NyaWJlciIsIl9nZXRTdWJzY3JpYmVyIiwiX3JlY292ZXJTdWJzY3JpYmVyIiwib2xkU3ViIiwibmV3U3ViIiwic3RhcnRlZCIsInBhdXNlZFN0YXRlIiwib24iLCJnZXRTdWIiLCJsaXN0ZW5lcnMiLCJhcmdzIiwiaGFzU3ViIiwiY291bnQiLCJwYXlsb2FkIiwibGlzdGVuZXJDb3VudCIsInRvdGFsIiwic3BsaWNlIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiYWRkTGlzdGVuZXIiLCJyZW1vdmVMaXN0ZW5lciIsImRlc3Ryb3llZCIsImRlc3Ryb3kiLCJzIiwiX25ldHdvcmsiLCJhc3NpZ24iLCJwZXJmb3JtQ2FjaGUiLCJNYXAiLCJhdHRlbXB0IiwidHhTZW5kZXIiLCJjY2lwQXJncyIsInBhcnNlT2ZmY2hhaW5Mb29rdXAiLCJpbnZvY2F0aW9uIiwicmV2ZXJ0Iiwic2lnbmF0dXJlIiwiZXJyb3JBcmdzIiwiY2NpcFJlc3VsdCIsInNlbGVjdG9yIiwiZW5jb2RlQnl0ZXMiLCJleHRyYURhdGEiLCJwcm9taXNlIiwiX2Jsb2NrVGFnIiwiaW5jbHVkZVRyYW5zYWN0aW9ucyIsImVtaXRBcmdzIiwicmVtb3ZlZCIsInN1YnNjcmlwdGlvbiIsImFkZHJlc3NhYmxlTWFwIiwiV2Vha01hcCIsIm5hbWVNYXAiLCJfcGFyc2VTdHJpbmciLCJieXRlcyIsIl9wYXJzZUJ5dGVzIiwib2Zmc2V0IiwibnVtUGFkIiwicGFkZGVkIiwiVWludDhBcnJheSIsImJ5dGVzUGFkIiwiTWF0aCIsImNlaWwiLCJlbXB0eSIsImRhdGFzIiwiYnl0ZUNvdW50IiwiemVyb3MiLCJ1cmxzT2Zmc2V0IiwidXJsc0xlbmd0aCIsInVybHNEYXRhIiwidSIsInNwbGl0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/providers/abstract-provider.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/providers/abstract-signer.js":
/*!******************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/abstract-signer.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractSigner: function() { return /* binding */ AbstractSigner; },\n/* harmony export */   VoidSigner: function() { return /* binding */ VoidSigner; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @swc/helpers/_/_class_private_method_get */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_method_get.js\");\n/* harmony import */ var _swc_helpers_class_private_method_init__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @swc/helpers/_/_class_private_method_init */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_method_init.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../address/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/address/checks.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../transaction/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/transaction/transaction.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _provider_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./provider.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/providers/provider.js\");\n/**\n *  Generally the [[Wallet]] and [[JsonRpcSigner]] and their sub-classes\n *  are sufficient for most developers, but this is provided to\n *  fascilitate more complex Signers.\n *\n *  @_section: api/providers/abstract-signer: Subclassing Signer [abstract-signer]\n */ \n\n\n\n\n\nfunction checkProvider(signer, operation) {\n    if (signer.provider) {\n        return signer.provider;\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"missing provider\", \"UNSUPPORTED_OPERATION\", {\n        operation\n    });\n}\nasync function populate(signer, tx) {\n    let pop = (0,_provider_js__WEBPACK_IMPORTED_MODULE_1__.copyRequest)(tx);\n    if (pop.to != null) {\n        pop.to = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(pop.to, signer);\n    }\n    if (pop.from != null) {\n        const from = pop.from;\n        pop.from = Promise.all([\n            signer.getAddress(),\n            (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(from, signer)\n        ]).then((param)=>{\n            let [address, from] = param;\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(address.toLowerCase() === from.toLowerCase(), \"transaction from mismatch\", \"tx.from\", from);\n            return address;\n        });\n    } else {\n        pop.from = signer.getAddress();\n    }\n    return await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.resolveProperties)(pop);\n}\n/**\n *  An **AbstractSigner** includes most of teh functionality required\n *  to get a [[Signer]] working as expected, but requires a few\n *  Signer-specific methods be overridden.\n *\n */ class AbstractSigner {\n    async getNonce(blockTag) {\n        return checkProvider(this, \"getTransactionCount\").getTransactionCount(await this.getAddress(), blockTag);\n    }\n    async populateCall(tx) {\n        const pop = await populate(this, tx);\n        return pop;\n    }\n    async populateTransaction(tx) {\n        const provider = checkProvider(this, \"populateTransaction\");\n        const pop = await populate(this, tx);\n        if (pop.nonce == null) {\n            pop.nonce = await this.getNonce(\"pending\");\n        }\n        if (pop.gasLimit == null) {\n            pop.gasLimit = await this.estimateGas(pop);\n        }\n        // Populate the chain ID\n        const network = await this.provider.getNetwork();\n        if (pop.chainId != null) {\n            const chainId = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.getBigInt)(pop.chainId);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(chainId === network.chainId, \"transaction chainId mismatch\", \"tx.chainId\", tx.chainId);\n        } else {\n            pop.chainId = network.chainId;\n        }\n        // Do not allow mixing pre-eip-1559 and eip-1559 properties\n        const hasEip1559 = pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null;\n        if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"eip-1559 transaction do not support gasPrice\", \"tx\", tx);\n        } else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas\", \"tx\", tx);\n        }\n        if ((pop.type === 2 || pop.type == null) && pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null) {\n            // Fully-formed EIP-1559 transaction (skip getFeeData)\n            pop.type = 2;\n        } else if (pop.type === 0 || pop.type === 1) {\n            // Explicit Legacy or EIP-2930 transaction\n            // We need to get fee data to determine things\n            const feeData = await provider.getFeeData();\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(feeData.gasPrice != null, \"network does not support gasPrice\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"getGasPrice\"\n            });\n            // Populate missing gasPrice\n            if (pop.gasPrice == null) {\n                pop.gasPrice = feeData.gasPrice;\n            }\n        } else {\n            // We need to get fee data to determine things\n            const feeData = await provider.getFeeData();\n            if (pop.type == null) {\n                // We need to auto-detect the intended type of this transaction...\n                if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {\n                    // The network supports EIP-1559!\n                    // Upgrade transaction from null to eip-1559\n                    if (pop.authorizationList && pop.authorizationList.length) {\n                        pop.type = 4;\n                    } else {\n                        pop.type = 2;\n                    }\n                    if (pop.gasPrice != null) {\n                        // Using legacy gasPrice property on an eip-1559 network,\n                        // so use gasPrice as both fee properties\n                        const gasPrice = pop.gasPrice;\n                        delete pop.gasPrice;\n                        pop.maxFeePerGas = gasPrice;\n                        pop.maxPriorityFeePerGas = gasPrice;\n                    } else {\n                        // Populate missing fee data\n                        if (pop.maxFeePerGas == null) {\n                            pop.maxFeePerGas = feeData.maxFeePerGas;\n                        }\n                        if (pop.maxPriorityFeePerGas == null) {\n                            pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n                        }\n                    }\n                } else if (feeData.gasPrice != null) {\n                    // Network doesn't support EIP-1559...\n                    // ...but they are trying to use EIP-1559 properties\n                    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!hasEip1559, \"network does not support EIP-1559\", \"UNSUPPORTED_OPERATION\", {\n                        operation: \"populateTransaction\"\n                    });\n                    // Populate missing fee data\n                    if (pop.gasPrice == null) {\n                        pop.gasPrice = feeData.gasPrice;\n                    }\n                    // Explicitly set untyped transaction to legacy\n                    // @TODO: Maybe this shold allow type 1?\n                    pop.type = 0;\n                } else {\n                    // getFeeData has failed us.\n                    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"failed to get consistent fee data\", \"UNSUPPORTED_OPERATION\", {\n                        operation: \"signer.getFeeData\"\n                    });\n                }\n            } else if (pop.type === 2 || pop.type === 3 || pop.type === 4) {\n                // Explicitly using EIP-1559 or EIP-4844\n                // Populate missing fee data\n                if (pop.maxFeePerGas == null) {\n                    pop.maxFeePerGas = feeData.maxFeePerGas;\n                }\n                if (pop.maxPriorityFeePerGas == null) {\n                    pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n                }\n            }\n        }\n        //@TOOD: Don't await all over the place; save them up for\n        // the end for better batching\n        return await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.resolveProperties)(pop);\n    }\n    async populateAuthorization(_auth) {\n        const auth = Object.assign({}, _auth);\n        // Add a chain ID if not explicitly set to 0\n        if (auth.chainId == null) {\n            auth.chainId = (await checkProvider(this, \"getNetwork\").getNetwork()).chainId;\n        }\n        // @TODO: Take chain ID into account when populating noce?\n        if (auth.nonce == null) {\n            auth.nonce = await this.getNonce();\n        }\n        return auth;\n    }\n    async estimateGas(tx) {\n        return checkProvider(this, \"estimateGas\").estimateGas(await this.populateCall(tx));\n    }\n    async call(tx) {\n        return checkProvider(this, \"call\").call(await this.populateCall(tx));\n    }\n    async resolveName(name) {\n        const provider = checkProvider(this, \"resolveName\");\n        return await provider.resolveName(name);\n    }\n    async sendTransaction(tx) {\n        const provider = checkProvider(this, \"sendTransaction\");\n        const pop = await this.populateTransaction(tx);\n        delete pop.from;\n        const txObj = _transaction_index_js__WEBPACK_IMPORTED_MODULE_5__.Transaction.from(pop);\n        return await provider.broadcastTransaction(await this.signTransaction(txObj));\n    }\n    // @TODO: in v7 move this to be abstract\n    authorize(authorization) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"authorization not implemented for this signer\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"authorize\"\n        });\n    }\n    /**\n     *  Creates a new Signer connected to %%provider%%.\n     */ constructor(provider){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.defineProperties)(this, {\n            provider: provider || null\n        });\n    }\n}\nvar _throwUnsupported = /*#__PURE__*/ new WeakSet();\n/**\n *  A **VoidSigner** is a class designed to allow an address to be used\n *  in any API which accepts a Signer, but for which there are no\n *  credentials available to perform any actual signing.\n *\n *  This for example allow impersonating an account for the purpose of\n *  static calls or estimating gas, but does not allow sending transactions.\n */ class VoidSigner extends AbstractSigner {\n    async getAddress() {\n        return this.address;\n    }\n    connect(provider) {\n        return new VoidSigner(this.address, provider);\n    }\n    async signTransaction(tx) {\n        (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_6__._)(this, _throwUnsupported, throwUnsupported).call(this, \"transactions\", \"signTransaction\");\n    }\n    async signMessage(message) {\n        (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_6__._)(this, _throwUnsupported, throwUnsupported).call(this, \"messages\", \"signMessage\");\n    }\n    async signTypedData(domain, types, value) {\n        (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_6__._)(this, _throwUnsupported, throwUnsupported).call(this, \"typed-data\", \"signTypedData\");\n    }\n    /**\n     *  Creates a new **VoidSigner** with %%address%% attached to\n     *  %%provider%%.\n     */ constructor(address, provider){\n        super(provider);\n        (0,_swc_helpers_class_private_method_init__WEBPACK_IMPORTED_MODULE_7__._)(this, _throwUnsupported);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.defineProperties)(this, {\n            address\n        });\n    }\n} //# sourceMappingURL=abstract-signer.js.map\nfunction throwUnsupported(suffix, operation) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"VoidSigner cannot sign \".concat(suffix), \"UNSUPPORTED_OPERATION\", {\n        operation\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvYWJzdHJhY3Qtc2lnbmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7O0NBTUM7O0FBQ29EO0FBQ0M7QUFDcUQ7QUFDL0Q7QUFDNUMsU0FBU1EsY0FBY0MsTUFBTSxFQUFFQyxTQUFTO0lBQ3BDLElBQUlELE9BQU9FLFFBQVEsRUFBRTtRQUNqQixPQUFPRixPQUFPRSxRQUFRO0lBQzFCO0lBQ0FOLHVEQUFNQSxDQUFDLE9BQU8sb0JBQW9CLHlCQUF5QjtRQUFFSztJQUFVO0FBQzNFO0FBQ0EsZUFBZUUsU0FBU0gsTUFBTSxFQUFFSSxFQUFFO0lBQzlCLElBQUlDLE1BQU1QLHlEQUFXQSxDQUFDTTtJQUN0QixJQUFJQyxJQUFJQyxFQUFFLElBQUksTUFBTTtRQUNoQkQsSUFBSUMsRUFBRSxHQUFHZixpRUFBY0EsQ0FBQ2MsSUFBSUMsRUFBRSxFQUFFTjtJQUNwQztJQUNBLElBQUlLLElBQUlFLElBQUksSUFBSSxNQUFNO1FBQ2xCLE1BQU1BLE9BQU9GLElBQUlFLElBQUk7UUFDckJGLElBQUlFLElBQUksR0FBR0MsUUFBUUMsR0FBRyxDQUFDO1lBQ25CVCxPQUFPVSxVQUFVO1lBQ2pCbkIsaUVBQWNBLENBQUNnQixNQUFNUDtTQUN4QixFQUFFVyxJQUFJLENBQUM7Z0JBQUMsQ0FBQ0MsU0FBU0wsS0FBSztZQUNwQlYsK0RBQWNBLENBQUNlLFFBQVFDLFdBQVcsT0FBT04sS0FBS00sV0FBVyxJQUFJLDZCQUE2QixXQUFXTjtZQUNyRyxPQUFPSztRQUNYO0lBQ0osT0FDSztRQUNEUCxJQUFJRSxJQUFJLEdBQUdQLE9BQU9VLFVBQVU7SUFDaEM7SUFDQSxPQUFPLE1BQU1mLGtFQUFpQkEsQ0FBQ1U7QUFDbkM7QUFDQTs7Ozs7Q0FLQyxHQUNNLE1BQU1TO0lBV1QsTUFBTUMsU0FBU0MsUUFBUSxFQUFFO1FBQ3JCLE9BQU9qQixjQUFjLElB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RUFDQSwyQ0FBMkM7QUFidkMsMEJBQWtCK0MsTUFBTSxFQUFFMUQsU0FBUztJQUMvQkwsdURBQU1BLENBQUMsT0FBTywwQkFBaUMsT0FBUCtELFNBQVUseUJBQXlCO1FBQUUxRDtJQUFVO0FBQzNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvYWJzdHJhY3Qtc2lnbmVyLmpzPzk0NGEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgR2VuZXJhbGx5IHRoZSBbW1dhbGxldF1dIGFuZCBbW0pzb25ScGNTaWduZXJdXSBhbmQgdGhlaXIgc3ViLWNsYXNzZXNcbiAqICBhcmUgc3VmZmljaWVudCBmb3IgbW9zdCBkZXZlbG9wZXJzLCBidXQgdGhpcyBpcyBwcm92aWRlZCB0b1xuICogIGZhc2NpbGl0YXRlIG1vcmUgY29tcGxleCBTaWduZXJzLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS9wcm92aWRlcnMvYWJzdHJhY3Qtc2lnbmVyOiBTdWJjbGFzc2luZyBTaWduZXIgW2Fic3RyYWN0LXNpZ25lcl1cbiAqL1xuaW1wb3J0IHsgcmVzb2x2ZUFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGdldEJpZ0ludCwgcmVzb2x2ZVByb3BlcnRpZXMsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGNvcHlSZXF1ZXN0IH0gZnJvbSBcIi4vcHJvdmlkZXIuanNcIjtcbmZ1bmN0aW9uIGNoZWNrUHJvdmlkZXIoc2lnbmVyLCBvcGVyYXRpb24pIHtcbiAgICBpZiAoc2lnbmVyLnByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBzaWduZXIucHJvdmlkZXI7XG4gICAgfVxuICAgIGFzc2VydChmYWxzZSwgXCJtaXNzaW5nIHByb3ZpZGVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gcG9wdWxhdGUoc2lnbmVyLCB0eCkge1xuICAgIGxldCBwb3AgPSBjb3B5UmVxdWVzdCh0eCk7XG4gICAgaWYgKHBvcC50byAhPSBudWxsKSB7XG4gICAgICAgIHBvcC50byA9IHJlc29sdmVBZGRyZXNzKHBvcC50bywgc2lnbmVyKTtcbiAgICB9XG4gICAgaWYgKHBvcC5mcm9tICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgZnJvbSA9IHBvcC5mcm9tO1xuICAgICAgICBwb3AuZnJvbSA9IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHNpZ25lci5nZXRBZGRyZXNzKCksXG4gICAgICAgICAgICByZXNvbHZlQWRkcmVzcyhmcm9tLCBzaWduZXIpXG4gICAgICAgIF0pLnRoZW4oKFthZGRyZXNzLCBmcm9tXSkgPT4ge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoYWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSBmcm9tLnRvTG93ZXJDYXNlKCksIFwidHJhbnNhY3Rpb24gZnJvbSBtaXNtYXRjaFwiLCBcInR4LmZyb21cIiwgZnJvbSk7XG4gICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwb3AuZnJvbSA9IHNpZ25lci5nZXRBZGRyZXNzKCk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCByZXNvbHZlUHJvcGVydGllcyhwb3ApO1xufVxuLyoqXG4gKiAgQW4gKipBYnN0cmFjdFNpZ25lcioqIGluY2x1ZGVzIG1vc3Qgb2YgdGVoIGZ1bmN0aW9uYWxpdHkgcmVxdWlyZWRcbiAqICB0byBnZXQgYSBbW1NpZ25lcl1dIHdvcmtpbmcgYXMgZXhwZWN0ZWQsIGJ1dCByZXF1aXJlcyBhIGZld1xuICogIFNpZ25lci1zcGVjaWZpYyBtZXRob2RzIGJlIG92ZXJyaWRkZW4uXG4gKlxuICovXG5leHBvcnQgY2xhc3MgQWJzdHJhY3RTaWduZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgcHJvdmlkZXIgdGhpcyBzaWduZXIgaXMgY29ubmVjdGVkIHRvLlxuICAgICAqL1xuICAgIHByb3ZpZGVyO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IFNpZ25lciBjb25uZWN0ZWQgdG8gJSVwcm92aWRlciUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBwcm92aWRlcjogKHByb3ZpZGVyIHx8IG51bGwpIH0pO1xuICAgIH1cbiAgICBhc3luYyBnZXROb25jZShibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gY2hlY2tQcm92aWRlcih0aGlzLCBcImdldFRyYW5zYWN0aW9uQ291bnRcIikuZ2V0VHJhbnNhY3Rpb25Db3VudChhd2FpdCB0aGlzLmdldEFkZHJlc3MoKSwgYmxvY2tUYWcpO1xuICAgIH1cbiAgICBhc3luYyBwb3B1bGF0ZUNhbGwodHgpIHtcbiAgICAgICAgY29uc3QgcG9wID0gYXdhaXQgcG9wdWxhdGUodGhpcywgdHgpO1xuICAgICAgICByZXR1cm4gcG9wO1xuICAgIH1cbiAgICBhc3luYyBwb3B1bGF0ZVRyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gY2hlY2tQcm92aWRlcih0aGlzLCBcInBvcHVsYXRlVHJhbnNhY3Rpb25cIik7XG4gICAgICAgIGNvbnN0IHBvcCA9IGF3YWl0IHBvcHVsYXRlKHRoaXMsIHR4KTtcbiAgICAgICAgaWYgKHBvcC5ub25jZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBwb3Aubm9uY2UgPSBhd2FpdCB0aGlzLmdldE5vbmNlKFwicGVuZGluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9wLmdhc0xpbWl0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHBvcC5nYXNMaW1pdCA9IGF3YWl0IHRoaXMuZXN0aW1hdGVHYXMocG9wKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQb3B1bGF0ZSB0aGUgY2hhaW4gSURcbiAgICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0ICh0aGlzLnByb3ZpZGVyKS5nZXROZXR3b3JrKCk7XG4gICAgICAgIGlmIChwb3AuY2hhaW5JZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFpbklkID0gZ2V0QmlnSW50KHBvcC5jaGFpbklkKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGNoYWluSWQgPT09IG5ldHdvcmsuY2hhaW5JZCwgXCJ0cmFuc2FjdGlvbiBjaGFpbklkIG1pc21hdGNoXCIsIFwidHguY2hhaW5JZFwiLCB0eC5jaGFpbklkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBvcC5jaGFpbklkID0gbmV0d29yay5jaGFpbklkO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvIG5vdCBhbGxvdyBtaXhpbmcgcHJlLWVpcC0xNTU5IGFuZCBlaXAtMTU1OSBwcm9wZXJ0aWVzXG4gICAgICAgIGNvbnN0IGhhc0VpcDE1NTkgPSAocG9wLm1heEZlZVBlckdhcyAhPSBudWxsIHx8IHBvcC5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKTtcbiAgICAgICAgaWYgKHBvcC5nYXNQcmljZSAhPSBudWxsICYmIChwb3AudHlwZSA9PT0gMiB8fCBoYXNFaXAxNTU5KSkge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiZWlwLTE1NTkgdHJhbnNhY3Rpb24gZG8gbm90IHN1cHBvcnQgZ2FzUHJpY2VcIiwgXCJ0eFwiLCB0eCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHBvcC50eXBlID09PSAwIHx8IHBvcC50eXBlID09PSAxKSAmJiBoYXNFaXAxNTU5KSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJwcmUtZWlwLTE1NTkgdHJhbnNhY3Rpb24gZG8gbm90IHN1cHBvcnQgbWF4RmVlUGVyR2FzL21heFByaW9yaXR5RmVlUGVyR2FzXCIsIFwidHhcIiwgdHgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgocG9wLnR5cGUgPT09IDIgfHwgcG9wLnR5cGUgPT0gbnVsbCkgJiYgKHBvcC5tYXhGZWVQZXJHYXMgIT0gbnVsbCAmJiBwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCkpIHtcbiAgICAgICAgICAgIC8vIEZ1bGx5LWZvcm1lZCBFSVAtMTU1OSB0cmFuc2FjdGlvbiAoc2tpcCBnZXRGZWVEYXRhKVxuICAgICAgICAgICAgcG9wLnR5cGUgPSAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvcC50eXBlID09PSAwIHx8IHBvcC50eXBlID09PSAxKSB7XG4gICAgICAgICAgICAvLyBFeHBsaWNpdCBMZWdhY3kgb3IgRUlQLTI5MzAgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZ2V0IGZlZSBkYXRhIHRvIGRldGVybWluZSB0aGluZ3NcbiAgICAgICAgICAgIGNvbnN0IGZlZURhdGEgPSBhd2FpdCBwcm92aWRlci5nZXRGZWVEYXRhKCk7XG4gICAgICAgICAgICBhc3NlcnQoZmVlRGF0YS5nYXNQcmljZSAhPSBudWxsLCBcIm5ldHdvcmsgZG9lcyBub3Qgc3VwcG9ydCBnYXNQcmljZVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImdldEdhc1ByaWNlXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gUG9wdWxhdGUgbWlzc2luZyBnYXNQcmljZVxuICAgICAgICAgICAgaWYgKHBvcC5nYXNQcmljZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcG9wLmdhc1ByaWNlID0gZmVlRGF0YS5nYXNQcmljZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZ2V0IGZlZSBkYXRhIHRvIGRldGVybWluZSB0aGluZ3NcbiAgICAgICAgICAgIGNvbnN0IGZlZURhdGEgPSBhd2FpdCBwcm92aWRlci5nZXRGZWVEYXRhKCk7XG4gICAgICAgICAgICBpZiAocG9wLnR5cGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gYXV0by1kZXRlY3QgdGhlIGludGVuZGVkIHR5cGUgb2YgdGhpcyB0cmFuc2FjdGlvbi4uLlxuICAgICAgICAgICAgICAgIGlmIChmZWVEYXRhLm1heEZlZVBlckdhcyAhPSBudWxsICYmIGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbmV0d29yayBzdXBwb3J0cyBFSVAtMTU1OSFcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBncmFkZSB0cmFuc2FjdGlvbiBmcm9tIG51bGwgdG8gZWlwLTE1NTlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcC5hdXRob3JpemF0aW9uTGlzdCAmJiBwb3AuYXV0aG9yaXphdGlvbkxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3AudHlwZSA9IDQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3AudHlwZSA9IDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcC5nYXNQcmljZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2luZyBsZWdhY3kgZ2FzUHJpY2UgcHJvcGVydHkgb24gYW4gZWlwLTE1NTkgbmV0d29yayxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIHVzZSBnYXNQcmljZSBhcyBib3RoIGZlZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBnYXNQcmljZSA9IHBvcC5nYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwb3AuZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3AubWF4RmVlUGVyR2FzID0gZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBnYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3NpbmcgZmVlIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3AubWF4RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3AubWF4RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhGZWVQZXJHYXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9wLm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZlZURhdGEuZ2FzUHJpY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOZXR3b3JrIGRvZXNuJ3Qgc3VwcG9ydCBFSVAtMTU1OS4uLlxuICAgICAgICAgICAgICAgICAgICAvLyAuLi5idXQgdGhleSBhcmUgdHJ5aW5nIHRvIHVzZSBFSVAtMTU1OSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydCghaGFzRWlwMTU1OSwgXCJuZXR3b3JrIGRvZXMgbm90IHN1cHBvcnQgRUlQLTE1NTlcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInBvcHVsYXRlVHJhbnNhY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUG9wdWxhdGUgbWlzc2luZyBmZWUgZGF0YVxuICAgICAgICAgICAgICAgICAgICBpZiAocG9wLmdhc1ByaWNlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcC5nYXNQcmljZSA9IGZlZURhdGEuZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRXhwbGljaXRseSBzZXQgdW50eXBlZCB0cmFuc2FjdGlvbiB0byBsZWdhY3lcbiAgICAgICAgICAgICAgICAgICAgLy8gQFRPRE86IE1heWJlIHRoaXMgc2hvbGQgYWxsb3cgdHlwZSAxP1xuICAgICAgICAgICAgICAgICAgICBwb3AudHlwZSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBnZXRGZWVEYXRhIGhhcyBmYWlsZWQgdXMuXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJmYWlsZWQgdG8gZ2V0IGNvbnNpc3RlbnQgZmVlIGRhdGFcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNpZ25lci5nZXRGZWVEYXRhXCJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocG9wLnR5cGUgPT09IDIgfHwgcG9wLnR5cGUgPT09IDMgfHwgcG9wLnR5cGUgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAvLyBFeHBsaWNpdGx5IHVzaW5nIEVJUC0xNTU5IG9yIEVJUC00ODQ0XG4gICAgICAgICAgICAgICAgLy8gUG9wdWxhdGUgbWlzc2luZyBmZWUgZGF0YVxuICAgICAgICAgICAgICAgIGlmIChwb3AubWF4RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9wLm1heEZlZVBlckdhcyA9IGZlZURhdGEubWF4RmVlUGVyR2FzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocG9wLm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9wLm1heFByaW9yaXR5RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy9AVE9PRDogRG9uJ3QgYXdhaXQgYWxsIG92ZXIgdGhlIHBsYWNlOyBzYXZlIHRoZW0gdXAgZm9yXG4gICAgICAgIC8vIHRoZSBlbmQgZm9yIGJldHRlciBiYXRjaGluZ1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMocG9wKTtcbiAgICB9XG4gICAgYXN5bmMgcG9wdWxhdGVBdXRob3JpemF0aW9uKF9hdXRoKSB7XG4gICAgICAgIGNvbnN0IGF1dGggPSBPYmplY3QuYXNzaWduKHt9LCBfYXV0aCk7XG4gICAgICAgIC8vIEFkZCBhIGNoYWluIElEIGlmIG5vdCBleHBsaWNpdGx5IHNldCB0byAwXG4gICAgICAgIGlmIChhdXRoLmNoYWluSWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgYXV0aC5jaGFpbklkID0gKGF3YWl0IGNoZWNrUHJvdmlkZXIodGhpcywgXCJnZXROZXR3b3JrXCIpLmdldE5ldHdvcmsoKSkuY2hhaW5JZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBAVE9ETzogVGFrZSBjaGFpbiBJRCBpbnRvIGFjY291bnQgd2hlbiBwb3B1bGF0aW5nIG5vY2U/XG4gICAgICAgIGlmIChhdXRoLm5vbmNlID09IG51bGwpIHtcbiAgICAgICAgICAgIGF1dGgubm9uY2UgPSBhd2FpdCB0aGlzLmdldE5vbmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF1dGg7XG4gICAgfVxuICAgIGFzeW5jIGVzdGltYXRlR2FzKHR4KSB7XG4gICAgICAgIHJldHVybiBjaGVja1Byb3ZpZGVyKHRoaXMsIFwiZXN0aW1hdGVHYXNcIikuZXN0aW1hdGVHYXMoYXdhaXQgdGhpcy5wb3B1bGF0ZUNhbGwodHgpKTtcbiAgICB9XG4gICAgYXN5bmMgY2FsbCh0eCkge1xuICAgICAgICByZXR1cm4gY2hlY2tQcm92aWRlcih0aGlzLCBcImNhbGxcIikuY2FsbChhd2FpdCB0aGlzLnBvcHVsYXRlQ2FsbCh0eCkpO1xuICAgIH1cbiAgICBhc3luYyByZXNvbHZlTmFtZShuYW1lKSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gY2hlY2tQcm92aWRlcih0aGlzLCBcInJlc29sdmVOYW1lXCIpO1xuICAgICAgICByZXR1cm4gYXdhaXQgcHJvdmlkZXIucmVzb2x2ZU5hbWUobmFtZSk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmRUcmFuc2FjdGlvbih0eCkge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGNoZWNrUHJvdmlkZXIodGhpcywgXCJzZW5kVHJhbnNhY3Rpb25cIik7XG4gICAgICAgIGNvbnN0IHBvcCA9IGF3YWl0IHRoaXMucG9wdWxhdGVUcmFuc2FjdGlvbih0eCk7XG4gICAgICAgIGRlbGV0ZSBwb3AuZnJvbTtcbiAgICAgICAgY29uc3QgdHhPYmogPSBUcmFuc2FjdGlvbi5mcm9tKHBvcCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5icm9hZGNhc3RUcmFuc2FjdGlvbihhd2FpdCB0aGlzLnNpZ25UcmFuc2FjdGlvbih0eE9iaikpO1xuICAgIH1cbiAgICAvLyBAVE9ETzogaW4gdjcgbW92ZSB0aGlzIHRvIGJlIGFic3RyYWN0XG4gICAgYXV0aG9yaXplKGF1dGhvcml6YXRpb24pIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImF1dGhvcml6YXRpb24gbm90IGltcGxlbWVudGVkIGZvciB0aGlzIHNpZ25lclwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJhdXRob3JpemVcIiB9KTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqVm9pZFNpZ25lcioqIGlzIGEgY2xhc3MgZGVzaWduZWQgdG8gYWxsb3cgYW4gYWRkcmVzcyB0byBiZSB1c2VkXG4gKiAgaW4gYW55IEFQSSB3aGljaCBhY2NlcHRzIGEgU2lnbmVyLCBidXQgZm9yIHdoaWNoIHRoZXJlIGFyZSBub1xuICogIGNyZWRlbnRpYWxzIGF2YWlsYWJsZSB0byBwZXJmb3JtIGFueSBhY3R1YWwgc2lnbmluZy5cbiAqXG4gKiAgVGhpcyBmb3IgZXhhbXBsZSBhbGxvdyBpbXBlcnNvbmF0aW5nIGFuIGFjY291bnQgZm9yIHRoZSBwdXJwb3NlIG9mXG4gKiAgc3RhdGljIGNhbGxzIG9yIGVzdGltYXRpbmcgZ2FzLCBidXQgZG9lcyBub3QgYWxsb3cgc2VuZGluZyB0cmFuc2FjdGlvbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBWb2lkU2lnbmVyIGV4dGVuZHMgQWJzdHJhY3RTaWduZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgc2lnbmVyIGFkZHJlc3MuXG4gICAgICovXG4gICAgYWRkcmVzcztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKlZvaWRTaWduZXIqKiB3aXRoICUlYWRkcmVzcyUlIGF0dGFjaGVkIHRvXG4gICAgICogICUlcHJvdmlkZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBwcm92aWRlcikge1xuICAgICAgICBzdXBlcihwcm92aWRlcik7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBhZGRyZXNzIH0pO1xuICAgIH1cbiAgICBhc3luYyBnZXRBZGRyZXNzKCkgeyByZXR1cm4gdGhpcy5hZGRyZXNzOyB9XG4gICAgY29ubmVjdChwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gbmV3IFZvaWRTaWduZXIodGhpcy5hZGRyZXNzLCBwcm92aWRlcik7XG4gICAgfVxuICAgICN0aHJvd1Vuc3VwcG9ydGVkKHN1ZmZpeCwgb3BlcmF0aW9uKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgYFZvaWRTaWduZXIgY2Fubm90IHNpZ24gJHtzdWZmaXh9YCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb24gfSk7XG4gICAgfVxuICAgIGFzeW5jIHNpZ25UcmFuc2FjdGlvbih0eCkge1xuICAgICAgICB0aGlzLiN0aHJvd1Vuc3VwcG9ydGVkKFwidHJhbnNhY3Rpb25zXCIsIFwic2lnblRyYW5zYWN0aW9uXCIpO1xuICAgIH1cbiAgICBhc3luYyBzaWduTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuI3Rocm93VW5zdXBwb3J0ZWQoXCJtZXNzYWdlc1wiLCBcInNpZ25NZXNzYWdlXCIpO1xuICAgIH1cbiAgICBhc3luYyBzaWduVHlwZWREYXRhKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI3Rocm93VW5zdXBwb3J0ZWQoXCJ0eXBlZC1kYXRhXCIsIFwic2lnblR5cGVkRGF0YVwiKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYnN0cmFjdC1zaWduZXIuanMubWFwIl0sIm5hbWVzIjpbInJlc29sdmVBZGRyZXNzIiwiVHJhbnNhY3Rpb24iLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZ2V0QmlnSW50IiwicmVzb2x2ZVByb3BlcnRpZXMiLCJhc3NlcnQiLCJhc3NlcnRBcmd1bWVudCIsImNvcHlSZXF1ZXN0IiwiY2hlY2tQcm92aWRlciIsInNpZ25lciIsIm9wZXJhdGlvbiIsInByb3ZpZGVyIiwicG9wdWxhdGUiLCJ0eCIsInBvcCIsInRvIiwiZnJvbSIsIlByb21pc2UiLCJhbGwiLCJnZXRBZGRyZXNzIiwidGhlbiIsImFkZHJlc3MiLCJ0b0xvd2VyQ2FzZSIsIkFic3RyYWN0U2lnbmVyIiwiZ2V0Tm9uY2UiLCJibG9ja1RhZyIsImdldFRyYW5zYWN0aW9uQ291bnQiLCJwb3B1bGF0ZUNhbGwiLCJwb3B1bGF0ZVRyYW5zYWN0aW9uIiwibm9uY2UiLCJnYXNMaW1pdCIsImVzdGltYXRlR2FzIiwibmV0d29yayIsImdldE5ldHdvcmsiLCJjaGFpbklkIiwiaGFzRWlwMTU1OSIsIm1heEZlZVBlckdhcyIsIm1heFByaW9yaXR5RmVlUGVyR2FzIiwiZ2FzUHJpY2UiLCJ0eXBlIiwiZmVlRGF0YSIsImdldEZlZURhdGEiLCJhdXRob3JpemF0aW9uTGlzdCIsImxlbmd0aCIsInBvcHVsYXRlQXV0aG9yaXphdGlvbiIsIl9hdXRoIiwiYXV0aCIsIk9iamVjdCIsImFzc2lnbiIsImNhbGwiLCJyZXNvbHZlTmFtZSIsIm5hbWUiLCJzZW5kVHJhbnNhY3Rpb24iLCJ0eE9iaiIsImJyb2FkY2FzdFRyYW5zYWN0aW9uIiwic2lnblRyYW5zYWN0aW9uIiwiYXV0aG9yaXplIiwiYXV0aG9yaXphdGlvbiIsImNvbnN0cnVjdG9yIiwiVm9pZFNpZ25lciIsImNvbm5lY3QiLCJ0aHJvd1Vuc3VwcG9ydGVkIiwic2lnbk1lc3NhZ2UiLCJtZXNzYWdlIiwic2lnblR5cGVkRGF0YSIsImRvbWFpbiIsInR5cGVzIiwidmFsdWUiLCJzdWZmaXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/providers/abstract-signer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/providers/ens-resolver.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/ens-resolver.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BasicMulticoinProviderPlugin: function() { return /* binding */ BasicMulticoinProviderPlugin; },\n/* harmony export */   EnsResolver: function() { return /* binding */ EnsResolver; },\n/* harmony export */   MulticoinProviderPlugin: function() { return /* binding */ MulticoinProviderPlugin; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_get */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_get.js\");\n/* harmony import */ var _swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_init */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_init.js\");\n/* harmony import */ var _swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_set */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_set.js\");\n/* harmony import */ var _swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @swc/helpers/_/_class_private_method_get */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_method_get.js\");\n/* harmony import */ var _swc_helpers_class_private_method_init__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @swc/helpers/_/_class_private_method_init */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_method_init.js\");\n/* harmony import */ var _swc_helpers_class_static_private_method_get__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @swc/helpers/_/_class_static_private_method_get */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_static_private_method_get.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../address/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _constants_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../constants/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/constants/addresses.js\");\n/* harmony import */ var _contract_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../contract/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/contract/contract.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../hash/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/hash/namehash.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/base58.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/fetch.js\");\n/**\n *  ENS is a service which allows easy-to-remember names to map to\n *  network addresses.\n *\n *  @_section: api/providers/ens-resolver:ENS Resolver  [about-ens-rsolver]\n */ \n\n\n\n\n\n\n\n\n\n\n// @TODO: This should use the fetch-data:ipfs gateway\n// Trim off the ipfs:// prefix and return the default gateway URL\nfunction getIpfsLink(link) {\n    if (link.match(/^ipfs:\\/\\/ipfs\\//i)) {\n        link = link.substring(12);\n    } else if (link.match(/^ipfs:\\/\\//i)) {\n        link = link.substring(7);\n    } else {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"unsupported IPFS format\", \"link\", link);\n    }\n    return \"https://gateway.ipfs.io/ipfs/\".concat(link);\n}\n;\n;\n/**\n *  A provider plugin super-class for processing multicoin address types.\n */ class MulticoinProviderPlugin {\n    connect(proivder) {\n        return this;\n    }\n    /**\n     *  Returns ``true`` if %%coinType%% is supported by this plugin.\n     */ supportsCoinType(coinType) {\n        return false;\n    }\n    /**\n     *  Resolves to the encoded %%address%% for %%coinType%%.\n     */ async encodeAddress(coinType, address) {\n        throw new Error(\"unsupported coin\");\n    }\n    /**\n     *  Resolves to the decoded %%data%% for %%coinType%%.\n     */ async decodeAddress(coinType, data) {\n        throw new Error(\"unsupported coin\");\n    }\n    /**\n     *  Creates a new **MulticoinProviderPluing** for %%name%%.\n     */ constructor(name){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            name\n        });\n    }\n}\nconst BasicMulticoinPluginId = \"org.ethers.plugins.provider.BasicMulticoin\";\n/**\n *  A **BasicMulticoinProviderPlugin** provides service for common\n *  coin types, which do not require additional libraries to encode or\n *  decode.\n */ class BasicMulticoinProviderPlugin extends MulticoinProviderPlugin {\n    /**\n     *  Creates a new **BasicMulticoinProviderPlugin**.\n     */ constructor(){\n        super(BasicMulticoinPluginId);\n    }\n}\nconst matcherIpfs = new RegExp(\"^(ipfs)://(.*)$\", \"i\");\nconst matchers = [\n    new RegExp(\"^(https)://(.*)$\", \"i\"),\n    new RegExp(\"^(data):(.*)$\", \"i\"),\n    matcherIpfs,\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\")\n];\nvar // For EIP-2544 names, the ancestor that provided the resolver\n_supports2544 = /*#__PURE__*/ new WeakMap(), _resolver = /*#__PURE__*/ new WeakMap(), _fetch = /*#__PURE__*/ new WeakSet();\n/**\n *  A connected object to a resolved ENS name resolver, which can be\n *  used to query additional details.\n */ class EnsResolver {\n    /**\n     *  Resolves to true if the resolver supports wildcard resolution.\n     */ async supportsWildcard() {\n        if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _supports2544) == null) {\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_3__._)(this, _supports2544, (async ()=>{\n                try {\n                    return await (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _resolver).supportsInterface(\"0x9061b923\");\n                } catch (error) {\n                    // Wildcard resolvers must understand supportsInterface\n                    // and return true.\n                    if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"CALL_EXCEPTION\")) {\n                        return false;\n                    }\n                    // Let future attempts try again...\n                    (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_3__._)(this, _supports2544, null);\n                    throw error;\n                }\n            })());\n        }\n        return await (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _supports2544);\n    }\n    /**\n     *  Resolves to the address for %%coinType%% or null if the\n     *  provided %%coinType%% has not been configured.\n     */ async getAddress(coinType) {\n        if (coinType == null) {\n            coinType = 60;\n        }\n        if (coinType === 60) {\n            try {\n                const result = await (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _fetch, fetch).call(this, \"addr(bytes32)\");\n                // No address\n                if (result == null || result === _constants_index_js__WEBPACK_IMPORTED_MODULE_5__.ZeroAddress) {\n                    return null;\n                }\n                return result;\n            } catch (error) {\n                if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"CALL_EXCEPTION\")) {\n                    return null;\n                }\n                throw error;\n            }\n        }\n        // Try decoding its EVM canonical chain as an EVM chain address first\n        if (coinType >= 0 && coinType < 0x80000000) {\n            let ethCoinType = coinType + 0x80000000;\n            const data = await (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _fetch, fetch).call(this, \"addr(bytes32,uint)\", [\n                ethCoinType\n            ]);\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.isHexString)(data, 20)) {\n                return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_7__.getAddress)(data);\n            }\n        }\n        let coinPlugin = null;\n        for (const plugin of this.provider.plugins){\n            if (!(plugin instanceof MulticoinProviderPlugin)) {\n                continue;\n            }\n            if (plugin.supportsCoinType(coinType)) {\n                coinPlugin = plugin;\n                break;\n            }\n        }\n        if (coinPlugin == null) {\n            return null;\n        }\n        // keccak256(\"addr(bytes32,uint256\")\n        const data = await (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _fetch, fetch).call(this, \"addr(bytes32,uint)\", [\n            coinType\n        ]);\n        // No address\n        if (data == null || data === \"0x\") {\n            return null;\n        }\n        // Compute the address\n        const address = await coinPlugin.decodeAddress(coinType, data);\n        if (address != null) {\n            return address;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"invalid coin data\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"getAddress(\".concat(coinType, \")\"),\n            info: {\n                coinType,\n                data\n            }\n        });\n    }\n    /**\n     *  Resolves to the EIP-634 text record for %%key%%, or ``null``\n     *  if unconfigured.\n     */ async getText(key) {\n        const data = await (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _fetch, fetch).call(this, \"text(bytes32,string)\", [\n            key\n        ]);\n        if (data == null || data === \"0x\") {\n            return null;\n        }\n        return data;\n    }\n    /**\n     *  Rsolves to the content-hash or ``null`` if unconfigured.\n     */ async getContentHash() {\n        // keccak256(\"contenthash()\")\n        const data = await (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _fetch, fetch).call(this, \"contenthash(bytes32)\");\n        // No contenthash\n        if (data == null || data === \"0x\") {\n            return null;\n        }\n        // IPFS (CID: 1, Type: 70=DAG-PB, 72=libp2p-key)\n        const ipfs = data.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n        if (ipfs) {\n            const scheme = ipfs[1] === \"e3010170\" ? \"ipfs\" : \"ipns\";\n            const length = parseInt(ipfs[4], 16);\n            if (ipfs[5].length === length * 2) {\n                return \"\".concat(scheme, \"://\").concat((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.encodeBase58)(\"0x\" + ipfs[2]));\n            }\n        }\n        // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n        const swarm = data.match(/^0xe40101fa011b20([0-9a-f]*)$/);\n        if (swarm && swarm[1].length === 64) {\n            return \"bzz://\".concat(swarm[1]);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"invalid or unsupported content hash data\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"getContentHash()\",\n            info: {\n                data\n            }\n        });\n    }\n    /**\n     *  Resolves to the avatar url or ``null`` if the avatar is either\n     *  unconfigured or incorrectly configured (e.g. references an NFT\n     *  not owned by the address).\n     *\n     *  If diagnosing issues with configurations, the [[_getAvatar]]\n     *  method may be useful.\n     */ async getAvatar() {\n        const avatar = await this._getAvatar();\n        return avatar.url;\n    }\n    /**\n     *  When resolving an avatar, there are many steps involved, such\n     *  fetching metadata and possibly validating ownership of an\n     *  NFT.\n     *\n     *  This method can be used to examine each step and the value it\n     *  was working from.\n     */ async _getAvatar() {\n        const linkage = [\n            {\n                type: \"name\",\n                value: this.name\n            }\n        ];\n        try {\n            // test data for ricmoo.eth\n            //const avatar = \"eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233\";\n            const avatar = await this.getText(\"avatar\");\n            if (avatar == null) {\n                linkage.push({\n                    type: \"!avatar\",\n                    value: \"\"\n                });\n                return {\n                    url: null,\n                    linkage\n                };\n            }\n            linkage.push({\n                type: \"avatar\",\n                value: avatar\n            });\n            for(let i = 0; i < matchers.length; i++){\n                const match = avatar.match(matchers[i]);\n                if (match == null) {\n                    continue;\n                }\n                const scheme = match[1].toLowerCase();\n                switch(scheme){\n                    case \"https\":\n                    case \"data\":\n                        linkage.push({\n                            type: \"url\",\n                            value: avatar\n                        });\n                        return {\n                            linkage,\n                            url: avatar\n                        };\n                    case \"ipfs\":\n                        {\n                            const url = getIpfsLink(avatar);\n                            linkage.push({\n                                type: \"ipfs\",\n                                value: avatar\n                            });\n                            linkage.push({\n                                type: \"url\",\n                                value: url\n                            });\n                            return {\n                                linkage,\n                                url\n                            };\n                        }\n                    case \"erc721\":\n                    case \"erc1155\":\n                        {\n                            // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\n                            const selector = scheme === \"erc721\" ? \"tokenURI(uint256)\" : \"uri(uint256)\";\n                            linkage.push({\n                                type: scheme,\n                                value: avatar\n                            });\n                            // The owner of this name\n                            const owner = await this.getAddress();\n                            if (owner == null) {\n                                linkage.push({\n                                    type: \"!owner\",\n                                    value: \"\"\n                                });\n                                return {\n                                    url: null,\n                                    linkage\n                                };\n                            }\n                            const comps = (match[2] || \"\").split(\"/\");\n                            if (comps.length !== 2) {\n                                linkage.push({\n                                    type: \"!\".concat(scheme, \"caip\"),\n                                    value: match[2] || \"\"\n                                });\n                                return {\n                                    url: null,\n                                    linkage\n                                };\n                            }\n                            const tokenId = comps[1];\n                            const contract = new _contract_index_js__WEBPACK_IMPORTED_MODULE_9__.Contract(comps[0], [\n                                // ERC-721\n                                \"function tokenURI(uint) view returns (string)\",\n                                \"function ownerOf(uint) view returns (address)\",\n                                // ERC-1155\n                                \"function uri(uint) view returns (string)\",\n                                \"function balanceOf(address, uint256) view returns (uint)\"\n                            ], this.provider);\n                            // Check that this account owns the token\n                            if (scheme === \"erc721\") {\n                                const tokenOwner = await contract.ownerOf(tokenId);\n                                if (owner !== tokenOwner) {\n                                    linkage.push({\n                                        type: \"!owner\",\n                                        value: tokenOwner\n                                    });\n                                    return {\n                                        url: null,\n                                        linkage\n                                    };\n                                }\n                                linkage.push({\n                                    type: \"owner\",\n                                    value: tokenOwner\n                                });\n                            } else if (scheme === \"erc1155\") {\n                                const balance = await contract.balanceOf(owner, tokenId);\n                                if (!balance) {\n                                    linkage.push({\n                                        type: \"!balance\",\n                                        value: \"0\"\n                                    });\n                                    return {\n                                        url: null,\n                                        linkage\n                                    };\n                                }\n                                linkage.push({\n                                    type: \"balance\",\n                                    value: balance.toString()\n                                });\n                            }\n                            // Call the token contract for the metadata URL\n                            let metadataUrl = await contract[selector](tokenId);\n                            if (metadataUrl == null || metadataUrl === \"0x\") {\n                                linkage.push({\n                                    type: \"!metadata-url\",\n                                    value: \"\"\n                                });\n                                return {\n                                    url: null,\n                                    linkage\n                                };\n                            }\n                            linkage.push({\n                                type: \"metadata-url-base\",\n                                value: metadataUrl\n                            });\n                            // ERC-1155 allows a generic {id} in the URL\n                            if (scheme === \"erc1155\") {\n                                metadataUrl = metadataUrl.replace(\"{id}\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.toBeHex)(tokenId, 32).substring(2));\n                                linkage.push({\n                                    type: \"metadata-url-expanded\",\n                                    value: metadataUrl\n                                });\n                            }\n                            // Transform IPFS metadata links\n                            if (metadataUrl.match(/^ipfs:/i)) {\n                                metadataUrl = getIpfsLink(metadataUrl);\n                            }\n                            linkage.push({\n                                type: \"metadata-url\",\n                                value: metadataUrl\n                            });\n                            // Get the token metadata\n                            let metadata = {};\n                            const response = await new _utils_index_js__WEBPACK_IMPORTED_MODULE_11__.FetchRequest(metadataUrl).send();\n                            response.assertOk();\n                            try {\n                                metadata = response.bodyJson;\n                            } catch (error) {\n                                try {\n                                    linkage.push({\n                                        type: \"!metadata\",\n                                        value: response.bodyText\n                                    });\n                                } catch (error) {\n                                    const bytes = response.body;\n                                    if (bytes) {\n                                        linkage.push({\n                                            type: \"!metadata\",\n                                            value: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.hexlify)(bytes)\n                                        });\n                                    }\n                                    return {\n                                        url: null,\n                                        linkage\n                                    };\n                                }\n                                return {\n                                    url: null,\n                                    linkage\n                                };\n                            }\n                            if (!metadata) {\n                                linkage.push({\n                                    type: \"!metadata\",\n                                    value: \"\"\n                                });\n                                return {\n                                    url: null,\n                                    linkage\n                                };\n                            }\n                            linkage.push({\n                                type: \"metadata\",\n                                value: JSON.stringify(metadata)\n                            });\n                            // Pull the image URL out\n                            let imageUrl = metadata.image;\n                            if (typeof imageUrl !== \"string\") {\n                                linkage.push({\n                                    type: \"!imageUrl\",\n                                    value: \"\"\n                                });\n                                return {\n                                    url: null,\n                                    linkage\n                                };\n                            }\n                            if (imageUrl.match(/^(https:\\/\\/|data:)/i)) {\n                            // Allow\n                            } else {\n                                // Transform IPFS link to gateway\n                                const ipfs = imageUrl.match(matcherIpfs);\n                                if (ipfs == null) {\n                                    linkage.push({\n                                        type: \"!imageUrl-ipfs\",\n                                        value: imageUrl\n                                    });\n                                    return {\n                                        url: null,\n                                        linkage\n                                    };\n                                }\n                                linkage.push({\n                                    type: \"imageUrl-ipfs\",\n                                    value: imageUrl\n                                });\n                                imageUrl = getIpfsLink(imageUrl);\n                            }\n                            linkage.push({\n                                type: \"url\",\n                                value: imageUrl\n                            });\n                            return {\n                                linkage,\n                                url: imageUrl\n                            };\n                        }\n                }\n            }\n        } catch (error) {}\n        return {\n            linkage,\n            url: null\n        };\n    }\n    static async getEnsAddress(provider) {\n        const network = await provider.getNetwork();\n        const ensPlugin = network.getPlugin(\"org.ethers.plugins.network.Ens\");\n        // No ENS...\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(ensPlugin, \"network does not support ENS\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"getEnsAddress\",\n            info: {\n                network\n            }\n        });\n        return ensPlugin.address;\n    }\n    /**\n     *  Resolve to the ENS resolver for %%name%% using %%provider%% or\n     *  ``null`` if unconfigured.\n     */ static async fromName(provider, name) {\n        let currentName = name;\n        while(true){\n            if (currentName === \"\" || currentName === \".\") {\n                return null;\n            }\n            // Optimization since the eth node cannot change and does\n            // not have a wildcard resolver\n            if (name !== \"eth\" && currentName === \"eth\") {\n                return null;\n            }\n            // Check the current node for a resolver\n            const addr = await (0,_swc_helpers_class_static_private_method_get__WEBPACK_IMPORTED_MODULE_12__._)(EnsResolver, EnsResolver, getResolver).call(EnsResolver, provider, currentName);\n            // Found a resolver!\n            if (addr != null) {\n                const resolver = new EnsResolver(provider, addr, name);\n                // Legacy resolver found, using EIP-2544 so it isn't safe to use\n                if (currentName !== name && !await resolver.supportsWildcard()) {\n                    return null;\n                }\n                return resolver;\n            }\n            // Get the parent node\n            currentName = currentName.split(\".\").slice(1).join(\".\");\n        }\n    }\n    constructor(provider, address, name){\n        (0,_swc_helpers_class_private_method_init__WEBPACK_IMPORTED_MODULE_13__._)(this, _fetch);\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_14__._)(this, _supports2544, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_14__._)(this, _resolver, {\n            writable: true,\n            value: void 0\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            provider,\n            address,\n            name\n        });\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_3__._)(this, _supports2544, null);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_3__._)(this, _resolver, new _contract_index_js__WEBPACK_IMPORTED_MODULE_9__.Contract(address, [\n            \"function supportsInterface(bytes4) view returns (bool)\",\n            \"function resolve(bytes, bytes) view returns (bytes)\",\n            \"function addr(bytes32) view returns (address)\",\n            \"function addr(bytes32, uint) view returns (bytes)\",\n            \"function text(bytes32, string) view returns (string)\",\n            \"function contenthash(bytes32) view returns (bytes)\"\n        ], provider));\n    }\n} //# sourceMappingURL=ens-resolver.js.map\nasync function fetch(funcName, params) {\n    params = (params || []).slice();\n    const iface = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _resolver).interface;\n    // The first parameters is always the nodehash\n    params.unshift((0,_hash_index_js__WEBPACK_IMPORTED_MODULE_15__.namehash)(this.name));\n    let fragment = null;\n    if (await this.supportsWildcard()) {\n        fragment = iface.getFunction(funcName);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(fragment, \"missing fragment\", \"UNKNOWN_ERROR\", {\n            info: {\n                funcName\n            }\n        });\n        params = [\n            (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_15__.dnsEncode)(this.name, 255),\n            iface.encodeFunctionData(fragment, params)\n        ];\n        funcName = \"resolve(bytes,bytes)\";\n    }\n    params.push({\n        enableCcipRead: true\n    });\n    try {\n        const result = await (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _resolver)[funcName](...params);\n        if (fragment) {\n            return iface.decodeFunctionResult(fragment, result)[0];\n        }\n        return result;\n    } catch (error) {\n        if (!(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"CALL_EXCEPTION\")) {\n            throw error;\n        }\n    }\n    return null;\n}\nasync function getResolver(provider, name) {\n    const ensAddr = await EnsResolver.getEnsAddress(provider);\n    try {\n        const contract = new _contract_index_js__WEBPACK_IMPORTED_MODULE_9__.Contract(ensAddr, [\n            \"function resolver(bytes32) view returns (address)\"\n        ], provider);\n        const addr = await contract.resolver((0,_hash_index_js__WEBPACK_IMPORTED_MODULE_15__.namehash)(name), {\n            enableCcipRead: true\n        });\n        if (addr === _constants_index_js__WEBPACK_IMPORTED_MODULE_5__.ZeroAddress) {\n            return null;\n        }\n        return addr;\n    } catch (error) {\n        // ENS registry cannot throw errors on resolver(bytes32),\n        // so probably a link error\n        throw error;\n    }\n    return null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvZW5zLXJlc29sdmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Q0FLQzs7Ozs7O0FBQ2dEO0FBQ0c7QUFDSjtBQUNPO0FBQzBGO0FBQ2pKLHFEQUFxRDtBQUNyRCxpRUFBaUU7QUFDakUsU0FBU2MsWUFBWUMsSUFBSTtJQUNyQixJQUFJQSxLQUFLQyxLQUFLLENBQUMsc0JBQXNCO1FBQ2pDRCxPQUFPQSxLQUFLRSxTQUFTLENBQUM7SUFDMUIsT0FDSyxJQUFJRixLQUFLQyxLQUFLLENBQUMsZ0JBQWdCO1FBQ2hDRCxPQUFPQSxLQUFLRSxTQUFTLENBQUM7SUFDMUIsT0FDSztRQUNETiwrREFBY0EsQ0FBQyxPQUFPLDJCQUEyQixRQUFRSTtJQUM3RDtJQUNBLE9BQU8sZ0NBQXNDLE9BQUxBO0FBQzVDOzs7QUFHQTs7Q0FFQyxHQUNNLE1BQU1HO0lBV1RDLFFBQVFDLFFBQVEsRUFBRTtRQUNkLE9BQU8sSUFBSTtJQUNmO0lBQ0E7O0tBRUMsR0FDREMsaUJBQWlCQyxRQUFRLEVBQUU7UUFDdkIsT0FBTztJQUNYO0lBQ0E7O0tBRUMsR0FDRCxNQUFNQyxjQUFjRCxRQUFRLEVBQUVFLE9BQU8sRUFBRTtRQUNuQyxNQUFNLElBQUlDLE1BQU07SUFDcEI7SUFDQTs7S0FFQyxHQUNELE1BQU1DLGNBQWNKLFFBQVEsRUFBRUssSUFBSSxFQUFFO1FBQ2hDLE1BQU0sSUFBSUYsTUFBTTtJQUNwQjtJQTFCQTs7S0FFQyxHQUNERyxZQUFZQyxJQUFJLENBQUU7UUFDZHJCLGlFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFBRXFCO1FBQUs7SUFDbEM7QUFzQko7QUFDQSxNQUFNQyx5QkFBeUI7QUFDL0I7Ozs7Q0FJQyxHQUNNLE1BQU1DLHFDQUFxQ2I7SUFDOUM7O0tBRUMsR0FDRFUsYUFBYztRQUNWLEtBQUssQ0FBQ0U7SUFDVjtBQUNKO0FBQ0EsTUFBTUUsY0FBYyxJQUFJQyxPQUFPLG1CQUFvQjtBQUNuRCxNQUFNQyxXQUFXO0lBQ2IsSUFBSUQsT0FBTyxvQkFBcUI7SUFDaEMsSUFBSUEsT0FBTyxpQkFBaUI7SUFDNUJEO0lBQ0EsSUFBSUMsT0FBTyxvQ0FBb0M7Q0FDbEQ7SUFrQkcsOERBQThEO0FBQzlELDZDQUNBLHlDQW9DTTtBQXZEVjs7O0NBR0MsR0FDTSxNQUFNRTtJQTRCVDs7S0FFQyxHQUNELE1BQU1DLG1CQUFtQjtRQUNyQixJQUFJLDRFQUFJLEVBQUVDLGtCQUFnQixNQUFNOzBGQUN0QkEsZUFBZSxDQUFDO2dCQUNsQixJQUFJO29CQUNBLE9BQU8sTUFBTSw0RUFBSSxFQUFFQyxXQUFTQyxpQkFBaUIsQ0FBQztnQkFDbEQsRUFDQSxPQUFPQyxPQUFPO29CQUNWLHVEQUF1RDtvQkFDdkQsbUJBQW1CO29CQUNuQixJQUFJNUIsd0RBQU9BLENBQUM0QixPQUFPLG1CQUFtQjt3QkFDbEMsT0FBTztvQkFDWDtvQkFDQSxtQ0FBbUM7a0dBQzdCSCxlQUFlO29CQUNyQixNQUFNRztnQkFDVjtZQUNKO1FBQ0o7UUFDQSxPQUFPLE1BQU0sNEVBQUksRUFBRUg7SUFDdkI7SUFtQ0E7OztLQUdDLEdBQ0QsTUFBTXJDLFdBQVdzQixRQUFRLEVBQUU7UUFDdkIsSUFBSUEsWUFBWSxNQUFNO1lBQ2xCQSxXQUFXO1FBQ2Y7UUFDQSxJQUFJQSxhQUFhLElBQUk7WUFDakIsSUFBSTtnQkFDQSxNQUFNbUIsU0FBUyxNQUFNLDZFQUFJLEVBQUVDLFFBQUFBLFlBQU4sSUFBSSxFQUFRO2dCQUNqQyxhQUFhO2dCQUNiLElBQUlELFVBQVUsUUFBUUEsV0FBV3hDLDREQUFXQSxFQUFFO29CQUMxQyxPQUFPO2dCQUNYO2dCQUNBLE9BQU93QztZQUNYLEVBQ0EsT0FBT0QsT0FBTztnQkFDVixJQUFJNUIsd0RBQU9BLENBQUM0QixPQUFPLG1CQUFtQjtvQkFDbEMsT0FBTztnQkFDWDtnQkFDQSxNQUFNQTtZQUNWO1FBQ0o7UUFDQSxxRUFBcUU7UUFDckUsSUFBSWxCLFlBQVksS0FBS0EsV0FBVyxZQUFZO1lBQ3hDLElBQUlxQixjQUFjckIsV0FBVztZQUM3QixNQUFNSyxPQUFPLE1BQU0sNkVBQUksRUFBRWUsUUFBQUEsWUFBTixJQUFJLEVBQVEsc0JBQXNCO2dCQUFDQzthQUFZO1lBQ2xFLElBQUlyQyw0REFBV0EsQ0FBQ3FCLE1BQU0sS0FBSztnQkFDdkIsT0FBTzNCLDZEQUFVQSxDQUFDMkI7WUFDdEI7UUFDSjtRQUNBLElBQUlpQixhQUFhO1FBQ2pCLEtBQUssTUFBTUMsVUFBVSxJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsT0FBTyxDQUFFO1lBQ3hDLElBQUksQ0FBRUYsQ0FBQUEsa0JBQWtCM0IsdUJBQXNCLEdBQUk7Z0JBQzlDO1lBQ0o7WUFDQSxJQUFJMkIsT0FBT3hCLGdCQUFnQixDQUFDQyxXQUFXO2dCQUNuQ3NCLGFBQWFDO2dCQUNiO1lBQ0o7UUFDSjtRQUNBLElBQUlELGNBQWMsTUFBTTtZQUNwQixPQUFPO1FBQ1g7UUFDQSxvQ0FBb0M7UUFDcEMsTUFBTWpCLE9BQU8sTUFBTSw2RUFBSSxFQUFFZSxRQUFBQSxZQUFOLElBQUksRUFBUSxzQkFBc0I7WUFBQ3BCO1NBQVM7UUFDL0QsYUFBYTtRQUNiLElBQUlLLFFBQVEsUUFBUUEsU0FBUyxNQUFNO1lBQy9CLE9BQU87UUFDWDtRQUNBLHNCQUFzQjtRQUN0QixNQUFNSCxVQUFVLE1BQU1vQixXQUFXbEIsYUFBYSxDQUFDSixVQUFVSztRQUN6RCxJQUFJSCxXQUFXLE1BQU07WUFDakIsT0FBT0E7UUFDWDtRQUNBZCx1REFBTUEsQ0FBQyxPQUFRLHFCQUFvQix5QkFBeUI7WUFDeERzQyxXQUFXLGNBQXVCLE9BQVQxQixVQUFTO1lBQ2xDMkIsTUFBTTtnQkFBRTNCO2dCQUFVSztZQUFLO1FBQzNCO0lBQ0o7SUFDQTs7O0tBR0MsR0FDRCxNQUFNdUIsUUFBUUMsR0FBRyxFQUFFO1FBQ2YsTUFBTXhCLE9BQU8sTUFBTSw2RUFBSSxFQUFFZSxRQUFBQSxZQUFOLElBQUksRUFBUSx3QkFBd0I7WUFBQ1M7U0FBSTtRQUM1RCxJQUFJeEIsUUFBUSxRQUFRQSxTQUFTLE1BQU07WUFDL0IsT0FBTztRQUNYO1FBQ0EsT0FBT0E7SUFDWDtJQUNBOztLQUVDLEdBQ0QsTUFBTXlCLGlCQUFpQjtRQUNuQiw2QkFBNkI7UUFDN0IsTUFBTXpCLE9BQU8sTUFBTSw2RUFBSSxFQUFFZSxRQUFBQSxZQUFOLElBQUksRUFBUTtRQUMvQixpQkFBaUI7UUFDakIsSUFBSWYsUUFBUSxRQUFRQSxTQUFTLE1BQU07WUFDL0IsT0FBTztRQUNYO1FBQ0EsZ0RBQWdEO1FBQ2hELE1BQU0wQixPQUFPMUIsS0FBS1gsS0FBSyxDQUFDO1FBQ3hCLElBQUlxQyxNQUFNO1lBQ04sTUFBTUMsU0FBUyxJQUFLLENBQUMsRUFBRSxLQUFLLGFBQWMsU0FBUztZQUNuRCxNQUFNQyxTQUFTQyxTQUFTSCxJQUFJLENBQUMsRUFBRSxFQUFFO1lBQ2pDLElBQUlBLElBQUksQ0FBQyxFQUFFLENBQUNFLE1BQU0sS0FBS0EsU0FBUyxHQUFHO2dCQUMvQixPQUFPLEdBQWdCOUMsT0FBYjZDLFFBQU8sT0FBbUMsT0FBN0I3Qyw2REFBWUEsQ0FBQyxPQUFPNEMsSUFBSSxDQUFDLEVBQUU7WUFDdEQ7UUFDSjtRQUNBLCtFQUErRTtRQUMvRSxNQUFNSSxRQUFROUIsS0FBS1gsS0FBSyxDQUFDO1FBQ3pCLElBQUl5QyxTQUFTQSxLQUFLLENBQUMsRUFBRSxDQUFDRixNQUFNLEtBQUssSUFBSTtZQUNqQyxPQUFPLFNBQW1CLE9BQVRFLEtBQUssQ0FBQyxFQUFFO1FBQzdCO1FBQ0EvQyx1REFBTUEsQ0FBQyxPQUFRLDRDQUEyQyx5QkFBeUI7WUFDL0VzQyxXQUFXO1lBQ1hDLE1BQU07Z0JBQUV0QjtZQUFLO1FBQ2pCO0lBQ0o7SUFDQTs7Ozs7OztLQU9DLEdBQ0QsTUFBTStCLFlBQVk7UUFDZCxNQUFNQyxTQUFTLE1BQU0sSUFBSSxDQUFDQyxVQUFVO1FBQ3BDLE9BQU9ELE9BQU9FLEdBQUc7SUFDckI7SUFDQTs7Ozs7OztLQU9DLEdBQ0QsTUFBTUQsYUFBYTtRQUNmLE1BQU1FLFVBQVU7WUFBQztnQkFBRUMsTUFBTTtnQkFBUUMsT0FBTyxJQUFJLENBQUNuQyxJQUFJO1lBQUM7U0FBRTtRQUNwRCxJQUFJO1lBQ0EsMkJBQTJCO1lBQzNCLG9GQUFvRjtZQUNwRixNQUFNOEIsU0FBUyxNQUFNLElBQUksQ0FBQ1QsT0FBTyxDQUFDO1lBQ2xDLElBQUlTLFVBQVUsTUFBTTtnQkFDaEJHLFFBQVFHLElBQUksQ0FBQztvQkFBRUYsTUFBTTtvQkFBV0MsT0FBTztnQkFBRztnQkFDMUMsT0FBTztvQkFBRUgsS0FBSztvQkFBTUM7Z0JBQVE7WUFDaEM7WUFDQUEsUUFBUUcsSUFBSSxDQUFDO2dCQUFFRixNQUFNO2dCQUFVQyxPQUFPTDtZQUFPO1lBQzdDLElBQUssSUFBSU8sSUFBSSxHQUFHQSxJQUFJaEMsU0FBU3FCLE1BQU0sRUFBRVcsSUFBSztnQkFDdEMsTUFBTWxELFFBQVEyQyxPQUFPM0MsS0FBSyxDQUFDa0IsUUFBUSxDQUFDZ0MsRUFBRTtnQkFDdEMsSUFBSWxELFNBQVMsTUFBTTtvQkFDZjtnQkFDSjtnQkFDQSxNQUFNc0MsU0FBU3RDLEtBQUssQ0FBQyxFQUFFLENBQUNtRCxXQUFXO2dCQUNuQyxPQUFRYjtvQkFDSixLQUFLO29CQUNMLEtBQUs7d0JBQ0RRLFFBQVFHLElBQUksQ0FBQzs0QkFBRUYsTUFBTTs0QkFBT0MsT0FBT0w7d0JBQU87d0JBQzFDLE9BQU87NEJBQUVHOzRCQUFTRCxLQUFLRjt3QkFBTztvQkFDbEMsS0FBSzt3QkFBUTs0QkFDVCxNQUFNRSxNQUFNL0MsWUFBWTZDOzRCQUN4QkcsUUFBUUcsSUFBSSxDQUFDO2dDQUFFRixNQUFNO2dDQUFRQyxPQUFPTDs0QkFBTzs0QkFDM0NHLFFBQVFHLElBQUksQ0FBQztnQ0FBRUYsTUFBTTtnQ0FBT0MsT0FBT0g7NEJBQUk7NEJBQ3ZDLE9BQU87Z0NBQUVDO2dDQUFTRDs0QkFBSTt3QkFDMUI7b0JBQ0EsS0FBSztvQkFDTCxLQUFLO3dCQUFXOzRCQUNaLG1FQUFtRTs0QkFDbkUsTUFBTU8sV0FBVyxXQUFZLFdBQVksc0JBQXNCOzRCQUMvRE4sUUFBUUcsSUFBSSxDQUFDO2dDQUFFRixNQUFNVDtnQ0FBUVUsT0FBT0w7NEJBQU87NEJBQzNDLHlCQUF5Qjs0QkFDekIsTUFBTVUsUUFBUSxNQUFNLElBQUksQ0FBQ3JFLFVBQVU7NEJBQ25DLElBQUlxRSxTQUFTLE1BQU07Z0NBQ2ZQLFFBQVFHLElBQUksQ0FBQztvQ0FBRUYsTUFBTTtvQ0FBVUMsT0FBTztnQ0FBRztnQ0FDekMsT0FBTztvQ0FBRUgsS0FBSztvQ0FBTUM7Z0NBQVE7NEJBQ2hDOzRCQUNBLE1BQU1RLFFBQVEsQ0FBQ3RELEtBQUssQ0FBQyxFQUFFLElBQUksRUFBQyxFQUFHdUQsS0FBSyxDQUFDOzRCQUNyQyxJQUFJRCxNQUFNZixNQUFNLEtBQUssR0FBRztnQ0FDcEJPLFFBQVFHLElBQUksQ0FBQztvQ0FBRUYsTUFBTSxJQUFXLE9BQVBULFFBQU87b0NBQU9VLE9BQVFoRCxLQUFLLENBQUMsRUFBRSxJQUFJO2dDQUFJO2dDQUMvRCxPQUFPO29DQUFFNkMsS0FBSztvQ0FBTUM7Z0NBQVE7NEJBQ2hDOzRCQUNBLE1BQU1VLFVBQVVGLEtBQUssQ0FBQyxFQUFFOzRCQUN4QixNQUFNRyxXQUFXLElBQUl2RSx3REFBUUEsQ0FBQ29FLEtBQUssQ0FBQyxFQUFFLEVBQUU7Z0NBQ3BDLFVBQVU7Z0NBQ1Y7Z0NBQ0E7Z0NBQ0EsV0FBVztnQ0FDWDtnQ0FDQTs2QkFDSCxFQUFFLElBQUksQ0FBQ3hCLFFBQVE7NEJBQ2hCLHlDQUF5Qzs0QkFDekMsSUFBSVEsV0FBVyxVQUFVO2dDQUNyQixNQUFNb0IsYUFBYSxNQUFNRCxTQUFTRSxPQUFPLENBQUNIO2dDQUMxQyxJQUFJSCxVQUFVSyxZQUFZO29DQUN0QlosUUFBUUcsSUFBSSxDQUFDO3dDQUFFRixNQUFNO3dDQUFVQyxPQUFPVTtvQ0FBVztvQ0FDakQsT0FBTzt3Q0FBRWIsS0FBSzt3Q0FBTUM7b0NBQVE7Z0NBQ2hDO2dDQUNBQSxRQUFRRyxJQUFJLENBQUM7b0NBQUVGLE1BQU07b0NBQVNDLE9BQU9VO2dDQUFXOzRCQUNwRCxPQUNLLElBQUlwQixXQUFXLFdBQVc7Z0NBQzNCLE1BQU1zQixVQUFVLE1BQU1ILFNBQVNJLFNBQVMsQ0FBQ1IsT0FBT0c7Z0NBQ2hELElBQUksQ0FBQ0ksU0FBUztvQ0FDVmQsUUFBUUcsSUFBSSxDQUFDO3dDQUFFRixNQUFNO3dDQUFZQyxPQUFPO29DQUFJO29DQUM1QyxPQUFPO3dDQUFFSCxLQUFLO3dDQUFNQztvQ0FBUTtnQ0FDaEM7Z0NBQ0FBLFFBQVFHLElBQUksQ0FBQztvQ0FBRUYsTUFBTTtvQ0FBV0MsT0FBT1ksUUFBUUUsUUFBUTtnQ0FBRzs0QkFDOUQ7NEJBQ0EsK0NBQStDOzRCQUMvQyxJQUFJQyxjQUFjLE1BQU1OLFFBQVEsQ0FBQ0wsU0FBUyxDQUFDSTs0QkFDM0MsSUFBSU8sZUFBZSxRQUFRQSxnQkFBZ0IsTUFBTTtnQ0FDN0NqQixRQUFRRyxJQUFJLENBQUM7b0NBQUVGLE1BQU07b0NBQWlCQyxPQUFPO2dDQUFHO2dDQUNoRCxPQUFPO29DQUFFSCxLQUFLO29DQUFNQztnQ0FBUTs0QkFDaEM7NEJBQ0FBLFFBQVFHLElBQUksQ0FBQztnQ0FBRUYsTUFBTTtnQ0FBcUJDLE9BQU9lOzRCQUFZOzRCQUM3RCw0Q0FBNEM7NEJBQzVDLElBQUl6QixXQUFXLFdBQVc7Z0NBQ3RCeUIsY0FBY0EsWUFBWUMsT0FBTyxDQUFDLFFBQVF6RSx5REFBT0EsQ0FBQ2lFLFNBQVMsSUFBSXZELFNBQVMsQ0FBQztnQ0FDekU2QyxRQUFRRyxJQUFJLENBQUM7b0NBQUVGLE1BQU07b0NBQXlCQyxPQUFPZTtnQ0FBWTs0QkFDckU7NEJBQ0EsZ0NBQWdDOzRCQUNoQyxJQUFJQSxZQUFZL0QsS0FBSyxDQUFDLFlBQVk7Z0NBQzlCK0QsY0FBY2pFLFlBQVlpRTs0QkFDOUI7NEJBQ0FqQixRQUFRRyxJQUFJLENBQUM7Z0NBQUVGLE1BQU07Z0NBQWdCQyxPQUFPZTs0QkFBWTs0QkFDeEQseUJBQXlCOzRCQUN6QixJQUFJRSxXQUFXLENBQUM7NEJBQ2hCLE1BQU1DLFdBQVcsTUFBTSxJQUFLckUsMERBQVlBLENBQUNrRSxhQUFjSSxJQUFJOzRCQUMzREQsU0FBU0UsUUFBUTs0QkFDakIsSUFBSTtnQ0FDQUgsV0FBV0MsU0FBU0csUUFBUTs0QkFDaEMsRUFDQSxPQUFPN0MsT0FBTztnQ0FDVixJQUFJO29DQUNBc0IsUUFBUUcsSUFBSSxDQUFDO3dDQUFFRixNQUFNO3dDQUFhQyxPQUFPa0IsU0FBU0ksUUFBUTtvQ0FBQztnQ0FDL0QsRUFDQSxPQUFPOUMsT0FBTztvQ0FDVixNQUFNK0MsUUFBUUwsU0FBU00sSUFBSTtvQ0FDM0IsSUFBSUQsT0FBTzt3Q0FDUHpCLFFBQVFHLElBQUksQ0FBQzs0Q0FBRUYsTUFBTTs0Q0FBYUMsT0FBTzNELHdEQUFPQSxDQUFDa0Y7d0NBQU87b0NBQzVEO29DQUNBLE9BQU87d0NBQUUxQixLQUFLO3dDQUFNQztvQ0FBUTtnQ0FDaEM7Z0NBQ0EsT0FBTztvQ0FBRUQsS0FBSztvQ0FBTUM7Z0NBQVE7NEJBQ2hDOzRCQUNBLElBQUksQ0FBQ21CLFVBQVU7Z0NBQ1huQixRQUFRRyxJQUFJLENBQUM7b0NBQUVGLE1BQU07b0NBQWFDLE9BQU87Z0NBQUc7Z0NBQzVDLE9BQU87b0NBQUVILEtBQUs7b0NBQU1DO2dDQUFROzRCQUNoQzs0QkFDQUEsUUFBUUcsSUFBSSxDQUFDO2dDQUFFRixNQUFNO2dDQUFZQyxPQUFPeUIsS0FBS0MsU0FBUyxDQUFDVDs0QkFBVTs0QkFDakUseUJBQXlCOzRCQUN6QixJQUFJVSxXQUFXVixTQUFTVyxLQUFLOzRCQUM3QixJQUFJLE9BQVFELGFBQWMsVUFBVTtnQ0FDaEM3QixRQUFRRyxJQUFJLENBQUM7b0NBQUVGLE1BQU07b0NBQWFDLE9BQU87Z0NBQUc7Z0NBQzVDLE9BQU87b0NBQUVILEtBQUs7b0NBQU1DO2dDQUFROzRCQUNoQzs0QkFDQSxJQUFJNkIsU0FBUzNFLEtBQUssQ0FBQyx5QkFBeUI7NEJBQ3hDLFFBQVE7NEJBQ1osT0FDSztnQ0FDRCxpQ0FBaUM7Z0NBQ2pDLE1BQU1xQyxPQUFPc0MsU0FBUzNFLEtBQUssQ0FBQ2dCO2dDQUM1QixJQUFJcUIsUUFBUSxNQUFNO29DQUNkUyxRQUFRRyxJQUFJLENBQUM7d0NBQUVGLE1BQU07d0NBQWtCQyxPQUFPMkI7b0NBQVM7b0NBQ3ZELE9BQU87d0NBQUU5QixLQUFLO3dDQUFNQztvQ0FBUTtnQ0FDaEM7Z0NBQ0FBLFFBQVFHLElBQUksQ0FBQztvQ0FBRUYsTUFBTTtvQ0FBaUJDLE9BQU8yQjtnQ0FBUztnQ0FDdERBLFdBQVc3RSxZQUFZNkU7NEJBQzNCOzRCQUNBN0IsUUFBUUcsSUFBSSxDQUFDO2dDQUFFRixNQUFNO2dDQUFPQyxPQUFPMkI7NEJBQVM7NEJBQzVDLE9BQU87Z0NBQUU3QjtnQ0FBU0QsS0FBSzhCOzRCQUFTO3dCQUNwQztnQkFDSjtZQUNKO1FBQ0osRUFDQSxPQUFPbkQsT0FBTyxDQUFFO1FBQ2hCLE9BQU87WUFBRXNCO1lBQVNELEtBQUs7UUFBSztJQUNoQztJQUNBLGFBQWFnQyxjQUFjL0MsUUFBUSxFQUFFO1FBQ2pDLE1BQU1nRCxVQUFVLE1BQU1oRCxTQUFTaUQsVUFBVTtRQUN6QyxNQUFNQyxZQUFZRixRQUFRRyxTQUFTLENBQUM7UUFDcEMsWUFBWTtRQUNadkYsdURBQU1BLENBQUNzRixXQUFXLGdDQUFnQyx5QkFBeUI7WUFDdkVoRCxXQUFXO1lBQWlCQyxNQUFNO2dCQUFFNkM7WUFBUTtRQUNoRDtRQUNBLE9BQU9FLFVBQVV4RSxPQUFPO0lBQzVCO0lBc0JBOzs7S0FHQyxHQUNELGFBQWEwRSxTQUFTcEQsUUFBUSxFQUFFakIsSUFBSSxFQUFFO1FBQ2xDLElBQUlzRSxjQUFjdEU7UUFDbEIsTUFBTyxLQUFNO1lBQ1QsSUFBSXNFLGdCQUFnQixNQUFNQSxnQkFBZ0IsS0FBSztnQkFDM0MsT0FBTztZQUNYO1lBQ0EseURBQXlEO1lBQ3pELCtCQUErQjtZQUMvQixJQUFJdEUsU0FBUyxTQUFTc0UsZ0JBQWdCLE9BQU87Z0JBQ3pDLE9BQU87WUFDWDtZQUNBLHdDQUF3QztZQUN4QyxNQUFNQyxPQUFPLE1BQU1qRSxnRkFBQUEsQ0FBQUEsYUF4WWxCQSxhQXdZK0JrRSxrQkF4WS9CbEUsYUF3WTJDVyxVQUFVcUQ7WUFDdEQsb0JBQW9CO1lBQ3BCLElBQUlDLFFBQVEsTUFBTTtnQkFDZCxNQUFNOUQsV0FBVyxJQUFJSCxZQUFZVyxVQUFVc0QsTUFBTXZFO2dCQUNqRCxnRUFBZ0U7Z0JBQ2hFLElBQUlzRSxnQkFBZ0J0RSxRQUFRLENBQUUsTUFBTVMsU0FBU0YsZ0JBQWdCLElBQUs7b0JBQzlELE9BQU87Z0JBQ1g7Z0JBQ0EsT0FBT0U7WUFDWDtZQUNBLHNCQUFzQjtZQUN0QjZELGNBQWNBLFlBQVk1QixLQUFLLENBQUMsS0FBSytCLEtBQUssQ0FBQyxHQUFHQyxJQUFJLENBQUM7UUFDdkQ7SUFDSjtJQXJZQTNFLFlBQVlrQixRQUFRLEVBQUV0QixPQUFPLEVBQUVLLElBQUksQ0FBRTtRQW1DckMsaUZBQU07UUFyQ047O21CQUFBOztRQUNBOzttQkFBQTs7UUFFSXJCLGlFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFBRXNDO1lBQVV0QjtZQUFTSztRQUFLO3NGQUMzQ1EsZUFBZTtzRkFDZkMsV0FBVyxJQUFJcEMsd0RBQVFBLENBQUNzQixTQUFTO1lBQ25DO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtTQUNILEVBQUVzQjtJQUNQO0FBMlhKLEVBQ0Esd0NBQXdDO0FBcFdwQyxxQkFBYTBELFFBQVEsRUFBRUMsTUFBTTtJQUN6QkEsU0FBUyxDQUFDQSxVQUFVLEVBQUUsRUFBRUgsS0FBSztJQUM3QixNQUFNSSxRQUFRLDRFQUFJLEVBQUVwRSxXQUFTcUUsU0FBUztJQUN0Qyw4Q0FBOEM7SUFDOUNGLE9BQU9HLE9BQU8sQ0FBQ3hHLHlEQUFRQSxDQUFDLElBQUksQ0FBQ3lCLElBQUk7SUFDakMsSUFBSWdGLFdBQVc7SUFDZixJQUFJLE1BQU0sSUFBSSxDQUFDekUsZ0JBQWdCLElBQUk7UUFDL0J5RSxXQUFXSCxNQUFNSSxXQUFXLENBQUNOO1FBQzdCOUYsdURBQU1BLENBQUNtRyxVQUFVLG9CQUFvQixpQkFBaUI7WUFDbEQ1RCxNQUFNO2dCQUFFdUQ7WUFBUztRQUNyQjtRQUNBQyxTQUFTO1lBQ0x0RywwREFBU0EsQ0FBQyxJQUFJLENBQUMwQixJQUFJLEVBQUU7WUFDckI2RSxNQUFNSyxrQkFBa0IsQ0FBQ0YsVUFBVUo7U0FDdEM7UUFDREQsV0FBVztJQUNmO0lBQ0FDLE9BQU94QyxJQUFJLENBQUM7UUFDUitDLGdCQUFnQjtJQUNwQjtJQUNBLElBQUk7UUFDQSxNQUFNdkUsU0FBUyxNQUFNLDRFQUFJLEVBQUVILFVBQVEsQ0FBQ2tFLFNBQVMsSUFBSUM7UUFDakQsSUFBSUksVUFBVTtZQUNWLE9BQU9ILE1BQU1PLG9CQUFvQixDQUFDSixVQUFVcEUsT0FBTyxDQUFDLEVBQUU7UUFDMUQ7UUFDQSxPQUFPQTtJQUNYLEVBQ0EsT0FBT0QsT0FBTztRQUNWLElBQUksQ0FBQzVCLHdEQUFPQSxDQUFDNEIsT0FBTyxtQkFBbUI7WUFDbkMsTUFBTUE7UUFDVjtJQUNKO0lBQ0EsT0FBTztBQUNYO0FBK1FBLDJCQUEwQk0sUUFBUSxFQUFFakIsSUFBSTtJQUNwQyxNQUFNcUYsVUFBVSxNQUFNL0UsWUFBWTBELGFBQWEsQ0FBQy9DO0lBQ2hELElBQUk7UUFDQSxNQUFNMkIsV0FBVyxJQUFJdkUsd0RBQVFBLENBQUNnSCxTQUFTO1lBQ25DO1NBQ0gsRUFBRXBFO1FBQ0gsTUFBTXNELE9BQU8sTUFBTTNCLFNBQVNuQyxRQUFRLENBQUNsQyx5REFBUUEsQ0FBQ3lCLE9BQU87WUFDakRtRixnQkFBZ0I7UUFDcEI7UUFDQSxJQUFJWixTQUFTbkcsNERBQVdBLEVBQUU7WUFDdEIsT0FBTztRQUNYO1FBQ0EsT0FBT21HO0lBQ1gsRUFDQSxPQUFPNUQsT0FBTztRQUNWLHlEQUF5RDtRQUN6RCwyQkFBMkI7UUFDM0IsTUFBTUE7SUFDVjtJQUNBLE9BQU87QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL2Vucy1yZXNvbHZlci5qcz80MjMyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIEVOUyBpcyBhIHNlcnZpY2Ugd2hpY2ggYWxsb3dzIGVhc3ktdG8tcmVtZW1iZXIgbmFtZXMgdG8gbWFwIHRvXG4gKiAgbmV0d29yayBhZGRyZXNzZXMuXG4gKlxuICogIEBfc2VjdGlvbjogYXBpL3Byb3ZpZGVycy9lbnMtcmVzb2x2ZXI6RU5TIFJlc29sdmVyICBbYWJvdXQtZW5zLXJzb2x2ZXJdXG4gKi9cbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgWmVyb0FkZHJlc3MgfSBmcm9tIFwiLi4vY29uc3RhbnRzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBDb250cmFjdCB9IGZyb20gXCIuLi9jb250cmFjdC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZG5zRW5jb2RlLCBuYW1laGFzaCB9IGZyb20gXCIuLi9oYXNoL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBoZXhsaWZ5LCBpc0hleFN0cmluZywgdG9CZUhleCwgZGVmaW5lUHJvcGVydGllcywgZW5jb2RlQmFzZTU4LCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50LCBpc0Vycm9yLCBGZXRjaFJlcXVlc3QgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbi8vIEBUT0RPOiBUaGlzIHNob3VsZCB1c2UgdGhlIGZldGNoLWRhdGE6aXBmcyBnYXRld2F5XG4vLyBUcmltIG9mZiB0aGUgaXBmczovLyBwcmVmaXggYW5kIHJldHVybiB0aGUgZGVmYXVsdCBnYXRld2F5IFVSTFxuZnVuY3Rpb24gZ2V0SXBmc0xpbmsobGluaykge1xuICAgIGlmIChsaW5rLm1hdGNoKC9eaXBmczpcXC9cXC9pcGZzXFwvL2kpKSB7XG4gICAgICAgIGxpbmsgPSBsaW5rLnN1YnN0cmluZygxMik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxpbmsubWF0Y2goL15pcGZzOlxcL1xcLy9pKSkge1xuICAgICAgICBsaW5rID0gbGluay5zdWJzdHJpbmcoNyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bnN1cHBvcnRlZCBJUEZTIGZvcm1hdFwiLCBcImxpbmtcIiwgbGluayk7XG4gICAgfVxuICAgIHJldHVybiBgaHR0cHM6L1xcL2dhdGV3YXkuaXBmcy5pby9pcGZzLyR7bGlua31gO1xufVxuO1xuO1xuLyoqXG4gKiAgQSBwcm92aWRlciBwbHVnaW4gc3VwZXItY2xhc3MgZm9yIHByb2Nlc3NpbmcgbXVsdGljb2luIGFkZHJlc3MgdHlwZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBNdWx0aWNvaW5Qcm92aWRlclBsdWdpbiB7XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lLlxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipNdWx0aWNvaW5Qcm92aWRlclBsdWluZyoqIGZvciAlJW5hbWUlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBuYW1lIH0pO1xuICAgIH1cbiAgICBjb25uZWN0KHByb2l2ZGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBpZiAlJWNvaW5UeXBlJSUgaXMgc3VwcG9ydGVkIGJ5IHRoaXMgcGx1Z2luLlxuICAgICAqL1xuICAgIHN1cHBvcnRzQ29pblR5cGUoY29pblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGVuY29kZWQgJSVhZGRyZXNzJSUgZm9yICUlY29pblR5cGUlJS5cbiAgICAgKi9cbiAgICBhc3luYyBlbmNvZGVBZGRyZXNzKGNvaW5UeXBlLCBhZGRyZXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGNvaW5cIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgZGVjb2RlZCAlJWRhdGElJSBmb3IgJSVjb2luVHlwZSUlLlxuICAgICAqL1xuICAgIGFzeW5jIGRlY29kZUFkZHJlc3MoY29pblR5cGUsIGRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgY29pblwiKTtcbiAgICB9XG59XG5jb25zdCBCYXNpY011bHRpY29pblBsdWdpbklkID0gXCJvcmcuZXRoZXJzLnBsdWdpbnMucHJvdmlkZXIuQmFzaWNNdWx0aWNvaW5cIjtcbi8qKlxuICogIEEgKipCYXNpY011bHRpY29pblByb3ZpZGVyUGx1Z2luKiogcHJvdmlkZXMgc2VydmljZSBmb3IgY29tbW9uXG4gKiAgY29pbiB0eXBlcywgd2hpY2ggZG8gbm90IHJlcXVpcmUgYWRkaXRpb25hbCBsaWJyYXJpZXMgdG8gZW5jb2RlIG9yXG4gKiAgZGVjb2RlLlxuICovXG5leHBvcnQgY2xhc3MgQmFzaWNNdWx0aWNvaW5Qcm92aWRlclBsdWdpbiBleHRlbmRzIE11bHRpY29pblByb3ZpZGVyUGx1Z2luIHtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkJhc2ljTXVsdGljb2luUHJvdmlkZXJQbHVnaW4qKi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoQmFzaWNNdWx0aWNvaW5QbHVnaW5JZCk7XG4gICAgfVxufVxuY29uc3QgbWF0Y2hlcklwZnMgPSBuZXcgUmVnRXhwKFwiXihpcGZzKTovXFwvKC4qKSRcIiwgXCJpXCIpO1xuY29uc3QgbWF0Y2hlcnMgPSBbXG4gICAgbmV3IFJlZ0V4cChcIl4oaHR0cHMpOi9cXC8oLiopJFwiLCBcImlcIiksXG4gICAgbmV3IFJlZ0V4cChcIl4oZGF0YSk6KC4qKSRcIiwgXCJpXCIpLFxuICAgIG1hdGNoZXJJcGZzLFxuICAgIG5ldyBSZWdFeHAoXCJeZWlwMTU1OlswLTldKy8oZXJjWzAtOV0rKTooLiopJFwiLCBcImlcIiksXG5dO1xuLyoqXG4gKiAgQSBjb25uZWN0ZWQgb2JqZWN0IHRvIGEgcmVzb2x2ZWQgRU5TIG5hbWUgcmVzb2x2ZXIsIHdoaWNoIGNhbiBiZVxuICogIHVzZWQgdG8gcXVlcnkgYWRkaXRpb25hbCBkZXRhaWxzLlxuICovXG5leHBvcnQgY2xhc3MgRW5zUmVzb2x2ZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgY29ubmVjdGVkIHByb3ZpZGVyLlxuICAgICAqL1xuICAgIHByb3ZpZGVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgYWRkcmVzcyBvZiB0aGUgcmVzb2x2ZXIuXG4gICAgICovXG4gICAgYWRkcmVzcztcbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUgdGhpcyByZXNvbHZlciB3YXMgcmVzb2x2ZWQgYWdhaW5zdC5cbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8vIEZvciBFSVAtMjU0NCBuYW1lcywgdGhlIGFuY2VzdG9yIHRoYXQgcHJvdmlkZWQgdGhlIHJlc29sdmVyXG4gICAgI3N1cHBvcnRzMjU0NDtcbiAgICAjcmVzb2x2ZXI7XG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGFkZHJlc3MsIG5hbWUpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHByb3ZpZGVyLCBhZGRyZXNzLCBuYW1lIH0pO1xuICAgICAgICB0aGlzLiNzdXBwb3J0czI1NDQgPSBudWxsO1xuICAgICAgICB0aGlzLiNyZXNvbHZlciA9IG5ldyBDb250cmFjdChhZGRyZXNzLCBbXG4gICAgICAgICAgICBcImZ1bmN0aW9uIHN1cHBvcnRzSW50ZXJmYWNlKGJ5dGVzNCkgdmlldyByZXR1cm5zIChib29sKVwiLFxuICAgICAgICAgICAgXCJmdW5jdGlvbiByZXNvbHZlKGJ5dGVzLCBieXRlcykgdmlldyByZXR1cm5zIChieXRlcylcIixcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gYWRkcihieXRlczMyKSB2aWV3IHJldHVybnMgKGFkZHJlc3MpXCIsXG4gICAgICAgICAgICBcImZ1bmN0aW9uIGFkZHIoYnl0ZXMzMiwgdWludCkgdmlldyByZXR1cm5zIChieXRlcylcIixcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gdGV4dChieXRlczMyLCBzdHJpbmcpIHZpZXcgcmV0dXJucyAoc3RyaW5nKVwiLFxuICAgICAgICAgICAgXCJmdW5jdGlvbiBjb250ZW50aGFzaChieXRlczMyKSB2aWV3IHJldHVybnMgKGJ5dGVzKVwiLFxuICAgICAgICBdLCBwcm92aWRlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0cnVlIGlmIHRoZSByZXNvbHZlciBzdXBwb3J0cyB3aWxkY2FyZCByZXNvbHV0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIHN1cHBvcnRzV2lsZGNhcmQoKSB7XG4gICAgICAgIGlmICh0aGlzLiNzdXBwb3J0czI1NDQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy4jc3VwcG9ydHMyNTQ0ID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jcmVzb2x2ZXIuc3VwcG9ydHNJbnRlcmZhY2UoXCIweDkwNjFiOTIzXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2lsZGNhcmQgcmVzb2x2ZXJzIG11c3QgdW5kZXJzdGFuZCBzdXBwb3J0c0ludGVyZmFjZVxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgcmV0dXJuIHRydWUuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Vycm9yKGVycm9yLCBcIkNBTExfRVhDRVBUSU9OXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gTGV0IGZ1dHVyZSBhdHRlbXB0cyB0cnkgYWdhaW4uLi5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jc3VwcG9ydHMyNTQ0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jc3VwcG9ydHMyNTQ0O1xuICAgIH1cbiAgICBhc3luYyAjZmV0Y2goZnVuY05hbWUsIHBhcmFtcykge1xuICAgICAgICBwYXJhbXMgPSAocGFyYW1zIHx8IFtdKS5zbGljZSgpO1xuICAgICAgICBjb25zdCBpZmFjZSA9IHRoaXMuI3Jlc29sdmVyLmludGVyZmFjZTtcbiAgICAgICAgLy8gVGhlIGZpcnN0IHBhcmFtZXRlcnMgaXMgYWx3YXlzIHRoZSBub2RlaGFzaFxuICAgICAgICBwYXJhbXMudW5zaGlmdChuYW1laGFzaCh0aGlzLm5hbWUpKTtcbiAgICAgICAgbGV0IGZyYWdtZW50ID0gbnVsbDtcbiAgICAgICAgaWYgKGF3YWl0IHRoaXMuc3VwcG9ydHNXaWxkY2FyZCgpKSB7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGlmYWNlLmdldEZ1bmN0aW9uKGZ1bmNOYW1lKTtcbiAgICAgICAgICAgIGFzc2VydChmcmFnbWVudCwgXCJtaXNzaW5nIGZyYWdtZW50XCIsIFwiVU5LTk9XTl9FUlJPUlwiLCB7XG4gICAgICAgICAgICAgICAgaW5mbzogeyBmdW5jTmFtZSB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBhcmFtcyA9IFtcbiAgICAgICAgICAgICAgICBkbnNFbmNvZGUodGhpcy5uYW1lLCAyNTUpLFxuICAgICAgICAgICAgICAgIGlmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YShmcmFnbWVudCwgcGFyYW1zKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGZ1bmNOYW1lID0gXCJyZXNvbHZlKGJ5dGVzLGJ5dGVzKVwiO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcy5wdXNoKHtcbiAgICAgICAgICAgIGVuYWJsZUNjaXBSZWFkOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy4jcmVzb2x2ZXJbZnVuY05hbWVdKC4uLnBhcmFtcyk7XG4gICAgICAgICAgICBpZiAoZnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWZhY2UuZGVjb2RlRnVuY3Rpb25SZXN1bHQoZnJhZ21lbnQsIHJlc3VsdClbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKCFpc0Vycm9yKGVycm9yLCBcIkNBTExfRVhDRVBUSU9OXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgYWRkcmVzcyBmb3IgJSVjb2luVHlwZSUlIG9yIG51bGwgaWYgdGhlXG4gICAgICogIHByb3ZpZGVkICUlY29pblR5cGUlJSBoYXMgbm90IGJlZW4gY29uZmlndXJlZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRBZGRyZXNzKGNvaW5UeXBlKSB7XG4gICAgICAgIGlmIChjb2luVHlwZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb2luVHlwZSA9IDYwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2luVHlwZSA9PT0gNjApIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy4jZmV0Y2goXCJhZGRyKGJ5dGVzMzIpXCIpO1xuICAgICAgICAgICAgICAgIC8vIE5vIGFkZHJlc3NcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwgfHwgcmVzdWx0ID09PSBaZXJvQWRkcmVzcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChpc0Vycm9yKGVycm9yLCBcIkNBTExfRVhDRVBUSU9OXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUcnkgZGVjb2RpbmcgaXRzIEVWTSBjYW5vbmljYWwgY2hhaW4gYXMgYW4gRVZNIGNoYWluIGFkZHJlc3MgZmlyc3RcbiAgICAgICAgaWYgKGNvaW5UeXBlID49IDAgJiYgY29pblR5cGUgPCAweDgwMDAwMDAwKSB7XG4gICAgICAgICAgICBsZXQgZXRoQ29pblR5cGUgPSBjb2luVHlwZSArIDB4ODAwMDAwMDA7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy4jZmV0Y2goXCJhZGRyKGJ5dGVzMzIsdWludClcIiwgW2V0aENvaW5UeXBlXSk7XG4gICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcoZGF0YSwgMjApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEFkZHJlc3MoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvaW5QbHVnaW4gPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiB0aGlzLnByb3ZpZGVyLnBsdWdpbnMpIHtcbiAgICAgICAgICAgIGlmICghKHBsdWdpbiBpbnN0YW5jZW9mIE11bHRpY29pblByb3ZpZGVyUGx1Z2luKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBsdWdpbi5zdXBwb3J0c0NvaW5UeXBlKGNvaW5UeXBlKSkge1xuICAgICAgICAgICAgICAgIGNvaW5QbHVnaW4gPSBwbHVnaW47XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvaW5QbHVnaW4gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8ga2VjY2FrMjU2KFwiYWRkcihieXRlczMyLHVpbnQyNTZcIilcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuI2ZldGNoKFwiYWRkcihieXRlczMyLHVpbnQpXCIsIFtjb2luVHlwZV0pO1xuICAgICAgICAvLyBObyBhZGRyZXNzXG4gICAgICAgIGlmIChkYXRhID09IG51bGwgfHwgZGF0YSA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlIHRoZSBhZGRyZXNzXG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCBjb2luUGx1Z2luLmRlY29kZUFkZHJlc3MoY29pblR5cGUsIGRhdGEpO1xuICAgICAgICBpZiAoYWRkcmVzcyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoZmFsc2UsIGBpbnZhbGlkIGNvaW4gZGF0YWAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogYGdldEFkZHJlc3MoJHtjb2luVHlwZX0pYCxcbiAgICAgICAgICAgIGluZm86IHsgY29pblR5cGUsIGRhdGEgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBFSVAtNjM0IHRleHQgcmVjb3JkIGZvciAlJWtleSUlLCBvciBgYG51bGxgYFxuICAgICAqICBpZiB1bmNvbmZpZ3VyZWQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VGV4dChrZXkpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuI2ZldGNoKFwidGV4dChieXRlczMyLHN0cmluZylcIiwgW2tleV0pO1xuICAgICAgICBpZiAoZGF0YSA9PSBudWxsIHx8IGRhdGEgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSc29sdmVzIHRvIHRoZSBjb250ZW50LWhhc2ggb3IgYGBudWxsYGAgaWYgdW5jb25maWd1cmVkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldENvbnRlbnRIYXNoKCkge1xuICAgICAgICAvLyBrZWNjYWsyNTYoXCJjb250ZW50aGFzaCgpXCIpXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLiNmZXRjaChcImNvbnRlbnRoYXNoKGJ5dGVzMzIpXCIpO1xuICAgICAgICAvLyBObyBjb250ZW50aGFzaFxuICAgICAgICBpZiAoZGF0YSA9PSBudWxsIHx8IGRhdGEgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSVBGUyAoQ0lEOiAxLCBUeXBlOiA3MD1EQUctUEIsIDcyPWxpYnAycC1rZXkpXG4gICAgICAgIGNvbnN0IGlwZnMgPSBkYXRhLm1hdGNoKC9eMHgoZTMwMTAxNzB8ZTUwMTAxNzIpKChbMC05YS1mXVswLTlhLWZdKShbMC05YS1mXVswLTlhLWZdKShbMC05YS1mXSopKSQvKTtcbiAgICAgICAgaWYgKGlwZnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtZSA9IChpcGZzWzFdID09PSBcImUzMDEwMTcwXCIpID8gXCJpcGZzXCIgOiBcImlwbnNcIjtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KGlwZnNbNF0sIDE2KTtcbiAgICAgICAgICAgIGlmIChpcGZzWzVdLmxlbmd0aCA9PT0gbGVuZ3RoICogMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHtzY2hlbWV9Oi9cXC8ke2VuY29kZUJhc2U1OChcIjB4XCIgKyBpcGZzWzJdKX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFN3YXJtIChDSUQ6IDEsIFR5cGU6IHN3YXJtLW1hbmlmZXN0OyBoYXNoL2xlbmd0aCBoYXJkLWNvZGVkIHRvIGtlY2NhazI1Ni8zMilcbiAgICAgICAgY29uc3Qgc3dhcm0gPSBkYXRhLm1hdGNoKC9eMHhlNDAxMDFmYTAxMWIyMChbMC05YS1mXSopJC8pO1xuICAgICAgICBpZiAoc3dhcm0gJiYgc3dhcm1bMV0ubGVuZ3RoID09PSA2NCkge1xuICAgICAgICAgICAgcmV0dXJuIGBieno6L1xcLyR7c3dhcm1bMV19YDtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoZmFsc2UsIGBpbnZhbGlkIG9yIHVuc3VwcG9ydGVkIGNvbnRlbnQgaGFzaCBkYXRhYCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImdldENvbnRlbnRIYXNoKClcIixcbiAgICAgICAgICAgIGluZm86IHsgZGF0YSB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGF2YXRhciB1cmwgb3IgYGBudWxsYGAgaWYgdGhlIGF2YXRhciBpcyBlaXRoZXJcbiAgICAgKiAgdW5jb25maWd1cmVkIG9yIGluY29ycmVjdGx5IGNvbmZpZ3VyZWQgKGUuZy4gcmVmZXJlbmNlcyBhbiBORlRcbiAgICAgKiAgbm90IG93bmVkIGJ5IHRoZSBhZGRyZXNzKS5cbiAgICAgKlxuICAgICAqICBJZiBkaWFnbm9zaW5nIGlzc3VlcyB3aXRoIGNvbmZpZ3VyYXRpb25zLCB0aGUgW1tfZ2V0QXZhdGFyXV1cbiAgICAgKiAgbWV0aG9kIG1heSBiZSB1c2VmdWwuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QXZhdGFyKCkge1xuICAgICAgICBjb25zdCBhdmF0YXIgPSBhd2FpdCB0aGlzLl9nZXRBdmF0YXIoKTtcbiAgICAgICAgcmV0dXJuIGF2YXRhci51cmw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBXaGVuIHJlc29sdmluZyBhbiBhdmF0YXIsIHRoZXJlIGFyZSBtYW55IHN0ZXBzIGludm9sdmVkLCBzdWNoXG4gICAgICogIGZldGNoaW5nIG1ldGFkYXRhIGFuZCBwb3NzaWJseSB2YWxpZGF0aW5nIG93bmVyc2hpcCBvZiBhblxuICAgICAqICBORlQuXG4gICAgICpcbiAgICAgKiAgVGhpcyBtZXRob2QgY2FuIGJlIHVzZWQgdG8gZXhhbWluZSBlYWNoIHN0ZXAgYW5kIHRoZSB2YWx1ZSBpdFxuICAgICAqICB3YXMgd29ya2luZyBmcm9tLlxuICAgICAqL1xuICAgIGFzeW5jIF9nZXRBdmF0YXIoKSB7XG4gICAgICAgIGNvbnN0IGxpbmthZ2UgPSBbeyB0eXBlOiBcIm5hbWVcIiwgdmFsdWU6IHRoaXMubmFtZSB9XTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIHRlc3QgZGF0YSBmb3IgcmljbW9vLmV0aFxuICAgICAgICAgICAgLy9jb25zdCBhdmF0YXIgPSBcImVpcDE1NToxL2VyYzcyMToweDI2NTM4NWM3ZjQxMzIyMjhBMGQ1NEVCMUE5ZTc0NjBiOTFjMGNDNjgvMjkyMzNcIjtcbiAgICAgICAgICAgIGNvbnN0IGF2YXRhciA9IGF3YWl0IHRoaXMuZ2V0VGV4dChcImF2YXRhclwiKTtcbiAgICAgICAgICAgIGlmIChhdmF0YXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIWF2YXRhclwiLCB2YWx1ZTogXCJcIiB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiYXZhdGFyXCIsIHZhbHVlOiBhdmF0YXIgfSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBhdmF0YXIubWF0Y2gobWF0Y2hlcnNbaV0pO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzY2hlbWUgPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoc2NoZW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJodHRwc1wiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZGF0YVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJ1cmxcIiwgdmFsdWU6IGF2YXRhciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGxpbmthZ2UsIHVybDogYXZhdGFyIH07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpcGZzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IGdldElwZnNMaW5rKGF2YXRhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcImlwZnNcIiwgdmFsdWU6IGF2YXRhciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwidXJsXCIsIHZhbHVlOiB1cmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBsaW5rYWdlLCB1cmwgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZXJjNzIxXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlcmMxMTU1XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlcGVuZGluZyBvbiB0aGUgRVJDIHR5cGUsIHVzZSB0b2tlblVSSSh1aW50MjU2KSBvciB1cmwodWludDI1NilcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0gKHNjaGVtZSA9PT0gXCJlcmM3MjFcIikgPyBcInRva2VuVVJJKHVpbnQyNTYpXCIgOiBcInVyaSh1aW50MjU2KVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogc2NoZW1lLCB2YWx1ZTogYXZhdGFyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG93bmVyIG9mIHRoaXMgbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3duZXIgPSBhd2FpdCB0aGlzLmdldEFkZHJlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvd25lciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhb3duZXJcIiwgdmFsdWU6IFwiXCIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wcyA9IChtYXRjaFsyXSB8fCBcIlwiKS5zcGxpdChcIi9cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogYCEke3NjaGVtZX1jYWlwYCwgdmFsdWU6IChtYXRjaFsyXSB8fCBcIlwiKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuSWQgPSBjb21wc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IENvbnRyYWN0KGNvbXBzWzBdLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRVJDLTcyMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gdG9rZW5VUkkodWludCkgdmlldyByZXR1cm5zIChzdHJpbmcpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvbiBvd25lck9mKHVpbnQpIHZpZXcgcmV0dXJucyAoYWRkcmVzcylcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFUkMtMTE1NVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gdXJpKHVpbnQpIHZpZXcgcmV0dXJucyAoc3RyaW5nKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gYmFsYW5jZU9mKGFkZHJlc3MsIHVpbnQyNTYpIHZpZXcgcmV0dXJucyAodWludClcIlxuICAgICAgICAgICAgICAgICAgICAgICAgXSwgdGhpcy5wcm92aWRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoaXMgYWNjb3VudCBvd25zIHRoZSB0b2tlblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtZSA9PT0gXCJlcmM3MjFcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuT3duZXIgPSBhd2FpdCBjb250cmFjdC5vd25lck9mKHRva2VuSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvd25lciAhPT0gdG9rZW5Pd25lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFvd25lclwiLCB2YWx1ZTogdG9rZW5Pd25lciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwib3duZXJcIiwgdmFsdWU6IHRva2VuT3duZXIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzY2hlbWUgPT09IFwiZXJjMTE1NVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFsYW5jZSA9IGF3YWl0IGNvbnRyYWN0LmJhbGFuY2VPZihvd25lciwgdG9rZW5JZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFiYWxhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIWJhbGFuY2VcIiwgdmFsdWU6IFwiMFwiIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJiYWxhbmNlXCIsIHZhbHVlOiBiYWxhbmNlLnRvU3RyaW5nKCkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIHRoZSB0b2tlbiBjb250cmFjdCBmb3IgdGhlIG1ldGFkYXRhIFVSTFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1ldGFkYXRhVXJsID0gYXdhaXQgY29udHJhY3Rbc2VsZWN0b3JdKHRva2VuSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhVXJsID09IG51bGwgfHwgbWV0YWRhdGFVcmwgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIW1ldGFkYXRhLXVybFwiLCB2YWx1ZTogXCJcIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwibWV0YWRhdGEtdXJsLWJhc2VcIiwgdmFsdWU6IG1ldGFkYXRhVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRVJDLTExNTUgYWxsb3dzIGEgZ2VuZXJpYyB7aWR9IGluIHRoZSBVUkxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWUgPT09IFwiZXJjMTE1NVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGFVcmwgPSBtZXRhZGF0YVVybC5yZXBsYWNlKFwie2lkfVwiLCB0b0JlSGV4KHRva2VuSWQsIDMyKS5zdWJzdHJpbmcoMikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwibWV0YWRhdGEtdXJsLWV4cGFuZGVkXCIsIHZhbHVlOiBtZXRhZGF0YVVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBJUEZTIG1ldGFkYXRhIGxpbmtzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGFVcmwubWF0Y2goL15pcGZzOi9pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhVXJsID0gZ2V0SXBmc0xpbmsobWV0YWRhdGFVcmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJtZXRhZGF0YS11cmxcIiwgdmFsdWU6IG1ldGFkYXRhVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSB0b2tlbiBtZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1ldGFkYXRhID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IChuZXcgRmV0Y2hSZXF1ZXN0KG1ldGFkYXRhVXJsKSkuc2VuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuYXNzZXJ0T2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEgPSByZXNwb25zZS5ib2R5SnNvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIW1ldGFkYXRhXCIsIHZhbHVlOiByZXNwb25zZS5ib2R5VGV4dCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gcmVzcG9uc2UuYm9keTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ5dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFtZXRhZGF0YVwiLCB2YWx1ZTogaGV4bGlmeShieXRlcykgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIW1ldGFkYXRhXCIsIHZhbHVlOiBcIlwiIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJtZXRhZGF0YVwiLCB2YWx1ZTogSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHVsbCB0aGUgaW1hZ2UgVVJMIG91dFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGltYWdlVXJsID0gbWV0YWRhdGEuaW1hZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChpbWFnZVVybCkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFpbWFnZVVybFwiLCB2YWx1ZTogXCJcIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbWFnZVVybC5tYXRjaCgvXihodHRwczpcXC9cXC98ZGF0YTopL2kpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3dcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBJUEZTIGxpbmsgdG8gZ2F0ZXdheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlwZnMgPSBpbWFnZVVybC5tYXRjaChtYXRjaGVySXBmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlwZnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFpbWFnZVVybC1pcGZzXCIsIHZhbHVlOiBpbWFnZVVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiaW1hZ2VVcmwtaXBmc1wiLCB2YWx1ZTogaW1hZ2VVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VVcmwgPSBnZXRJcGZzTGluayhpbWFnZVVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcInVybFwiLCB2YWx1ZTogaW1hZ2VVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBsaW5rYWdlLCB1cmw6IGltYWdlVXJsIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgcmV0dXJuIHsgbGlua2FnZSwgdXJsOiBudWxsIH07XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBnZXRFbnNBZGRyZXNzKHByb3ZpZGVyKSB7XG4gICAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCBwcm92aWRlci5nZXROZXR3b3JrKCk7XG4gICAgICAgIGNvbnN0IGVuc1BsdWdpbiA9IG5ldHdvcmsuZ2V0UGx1Z2luKFwib3JnLmV0aGVycy5wbHVnaW5zLm5ldHdvcmsuRW5zXCIpO1xuICAgICAgICAvLyBObyBFTlMuLi5cbiAgICAgICAgYXNzZXJ0KGVuc1BsdWdpbiwgXCJuZXR3b3JrIGRvZXMgbm90IHN1cHBvcnQgRU5TXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJnZXRFbnNBZGRyZXNzXCIsIGluZm86IHsgbmV0d29yayB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZW5zUGx1Z2luLmFkZHJlc3M7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyAjZ2V0UmVzb2x2ZXIocHJvdmlkZXIsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgZW5zQWRkciA9IGF3YWl0IEVuc1Jlc29sdmVyLmdldEVuc0FkZHJlc3MocHJvdmlkZXIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY29udHJhY3QgPSBuZXcgQ29udHJhY3QoZW5zQWRkciwgW1xuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gcmVzb2x2ZXIoYnl0ZXMzMikgdmlldyByZXR1cm5zIChhZGRyZXNzKVwiXG4gICAgICAgICAgICBdLCBwcm92aWRlcik7XG4gICAgICAgICAgICBjb25zdCBhZGRyID0gYXdhaXQgY29udHJhY3QucmVzb2x2ZXIobmFtZWhhc2gobmFtZSksIHtcbiAgICAgICAgICAgICAgICBlbmFibGVDY2lwUmVhZDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoYWRkciA9PT0gWmVyb0FkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhZGRyO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gRU5TIHJlZ2lzdHJ5IGNhbm5vdCB0aHJvdyBlcnJvcnMgb24gcmVzb2x2ZXIoYnl0ZXMzMiksXG4gICAgICAgICAgICAvLyBzbyBwcm9iYWJseSBhIGxpbmsgZXJyb3JcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZSB0byB0aGUgRU5TIHJlc29sdmVyIGZvciAlJW5hbWUlJSB1c2luZyAlJXByb3ZpZGVyJSUgb3JcbiAgICAgKiAgYGBudWxsYGAgaWYgdW5jb25maWd1cmVkLlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBmcm9tTmFtZShwcm92aWRlciwgbmFtZSkge1xuICAgICAgICBsZXQgY3VycmVudE5hbWUgPSBuYW1lO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnROYW1lID09PSBcIlwiIHx8IGN1cnJlbnROYW1lID09PSBcIi5cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3B0aW1pemF0aW9uIHNpbmNlIHRoZSBldGggbm9kZSBjYW5ub3QgY2hhbmdlIGFuZCBkb2VzXG4gICAgICAgICAgICAvLyBub3QgaGF2ZSBhIHdpbGRjYXJkIHJlc29sdmVyXG4gICAgICAgICAgICBpZiAobmFtZSAhPT0gXCJldGhcIiAmJiBjdXJyZW50TmFtZSA9PT0gXCJldGhcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIGN1cnJlbnQgbm9kZSBmb3IgYSByZXNvbHZlclxuICAgICAgICAgICAgY29uc3QgYWRkciA9IGF3YWl0IEVuc1Jlc29sdmVyLiNnZXRSZXNvbHZlcihwcm92aWRlciwgY3VycmVudE5hbWUpO1xuICAgICAgICAgICAgLy8gRm91bmQgYSByZXNvbHZlciFcbiAgICAgICAgICAgIGlmIChhZGRyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlciA9IG5ldyBFbnNSZXNvbHZlcihwcm92aWRlciwgYWRkciwgbmFtZSk7XG4gICAgICAgICAgICAgICAgLy8gTGVnYWN5IHJlc29sdmVyIGZvdW5kLCB1c2luZyBFSVAtMjU0NCBzbyBpdCBpc24ndCBzYWZlIHRvIHVzZVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50TmFtZSAhPT0gbmFtZSAmJiAhKGF3YWl0IHJlc29sdmVyLnN1cHBvcnRzV2lsZGNhcmQoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdldCB0aGUgcGFyZW50IG5vZGVcbiAgICAgICAgICAgIGN1cnJlbnROYW1lID0gY3VycmVudE5hbWUuc3BsaXQoXCIuXCIpLnNsaWNlKDEpLmpvaW4oXCIuXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW5zLXJlc29sdmVyLmpzLm1hcCJdLCJuYW1lcyI6WyJnZXRBZGRyZXNzIiwiWmVyb0FkZHJlc3MiLCJDb250cmFjdCIsImRuc0VuY29kZSIsIm5hbWVoYXNoIiwiaGV4bGlmeSIsImlzSGV4U3RyaW5nIiwidG9CZUhleCIsImRlZmluZVByb3BlcnRpZXMiLCJlbmNvZGVCYXNlNTgiLCJhc3NlcnQiLCJhc3NlcnRBcmd1bWVudCIsImlzRXJyb3IiLCJGZXRjaFJlcXVlc3QiLCJnZXRJcGZzTGluayIsImxpbmsiLCJtYXRjaCIsInN1YnN0cmluZyIsIk11bHRpY29pblByb3ZpZGVyUGx1Z2luIiwiY29ubmVjdCIsInByb2l2ZGVyIiwic3VwcG9ydHNDb2luVHlwZSIsImNvaW5UeXBlIiwiZW5jb2RlQWRkcmVzcyIsImFkZHJlc3MiLCJFcnJvciIsImRlY29kZUFkZHJlc3MiLCJkYXRhIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiQmFzaWNNdWx0aWNvaW5QbHVnaW5JZCIsIkJhc2ljTXVsdGljb2luUHJvdmlkZXJQbHVnaW4iLCJtYXRjaGVySXBmcyIsIlJlZ0V4cCIsIm1hdGNoZXJzIiwiRW5zUmVzb2x2ZXIiLCJzdXBwb3J0c1dpbGRjYXJkIiwic3VwcG9ydHMyNTQ0IiwicmVzb2x2ZXIiLCJzdXBwb3J0c0ludGVyZmFjZSIsImVycm9yIiwicmVzdWx0IiwiZmV0Y2giLCJldGhDb2luVHlwZSIsImNvaW5QbHVnaW4iLCJwbHVnaW4iLCJwcm92aWRlciIsInBsdWdpbnMiLCJvcGVyYXRpb24iLCJpbmZvIiwiZ2V0VGV4dCIsImtleSIsImdldENvbnRlbnRIYXNoIiwiaXBmcyIsInNjaGVtZSIsImxlbmd0aCIsInBhcnNlSW50Iiwic3dhcm0iLCJnZXRBdmF0YXIiLCJhdmF0YXIiLCJfZ2V0QXZhdGFyIiwidXJsIiwibGlua2FnZSIsInR5cGUiLCJ2YWx1ZSIsInB1c2giLCJpIiwidG9Mb3dlckNhc2UiLCJzZWxlY3RvciIsIm93bmVyIiwiY29tcHMiLCJzcGxpdCIsInRva2VuSWQiLCJjb250cmFjdCIsInRva2VuT3duZXIiLCJvd25lck9mIiwiYmFsYW5jZSIsImJhbGFuY2VPZiIsInRvU3RyaW5nIiwibWV0YWRhdGFVcmwiLCJyZXBsYWNlIiwibWV0YWRhdGEiLCJyZXNwb25zZSIsInNlbmQiLCJhc3NlcnRPayIsImJvZHlKc29uIiwiYm9keVRleHQiLCJieXRlcyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiaW1hZ2VVcmwiLCJpbWFnZSIsImdldEVuc0FkZHJlc3MiLCJuZXR3b3JrIiwiZ2V0TmV0d29yayIsImVuc1BsdWdpbiIsImdldFBsdWdpbiIsImZyb21OYW1lIiwiY3VycmVudE5hbWUiLCJhZGRyIiwiZ2V0UmVzb2x2ZXIiLCJzbGljZSIsImpvaW4iLCJmdW5jTmFtZSIsInBhcmFtcyIsImlmYWNlIiwiaW50ZXJmYWNlIiwidW5zaGlmdCIsImZyYWdtZW50IiwiZ2V0RnVuY3Rpb24iLCJlbmNvZGVGdW5jdGlvbkRhdGEiLCJlbmFibGVDY2lwUmVhZCIsImRlY29kZUZ1bmN0aW9uUmVzdWx0IiwiZW5zQWRkciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/providers/ens-resolver.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/providers/format.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/format.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   allowNull: function() { return /* binding */ allowNull; },\n/* harmony export */   arrayOf: function() { return /* binding */ arrayOf; },\n/* harmony export */   formatBlock: function() { return /* binding */ formatBlock; },\n/* harmony export */   formatBoolean: function() { return /* binding */ formatBoolean; },\n/* harmony export */   formatData: function() { return /* binding */ formatData; },\n/* harmony export */   formatHash: function() { return /* binding */ formatHash; },\n/* harmony export */   formatLog: function() { return /* binding */ formatLog; },\n/* harmony export */   formatReceiptLog: function() { return /* binding */ formatReceiptLog; },\n/* harmony export */   formatTransactionReceipt: function() { return /* binding */ formatTransactionReceipt; },\n/* harmony export */   formatTransactionResponse: function() { return /* binding */ formatTransactionResponse; },\n/* harmony export */   formatUint256: function() { return /* binding */ formatUint256; },\n/* harmony export */   object: function() { return /* binding */ object; }\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../address/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../address/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/address/contract-address.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../crypto/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/crypto/signature.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../transaction/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/transaction/accesslist.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/**\n *  @_ignore\n */ \n\n\n\nconst BN_0 = BigInt(0);\nfunction allowNull(format, nullValue) {\n    return function(value) {\n        if (value == null) {\n            return nullValue;\n        }\n        return format(value);\n    };\n}\nfunction arrayOf(format, allowNull) {\n    return (array)=>{\n        if (allowNull && array == null) {\n            return null;\n        }\n        if (!Array.isArray(array)) {\n            throw new Error(\"not an array\");\n        }\n        return array.map((i)=>format(i));\n    };\n}\n// Requires an object which matches a fleet of other formatters\n// Any FormatFunc may return `undefined` to have the value omitted\n// from the result object. Calls preserve `this`.\nfunction object(format, altNames) {\n    return (value)=>{\n        const result = {};\n        for(const key in format){\n            let srcKey = key;\n            if (altNames && key in altNames && !(srcKey in value)) {\n                for (const altKey of altNames[key]){\n                    if (altKey in value) {\n                        srcKey = altKey;\n                        break;\n                    }\n                }\n            }\n            try {\n                const nv = format[key](value[srcKey]);\n                if (nv !== undefined) {\n                    result[key] = nv;\n                }\n            } catch (error) {\n                const message = error instanceof Error ? error.message : \"not-an-error\";\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"invalid value for value.\".concat(key, \" (\").concat(message, \")\"), \"BAD_DATA\", {\n                    value\n                });\n            }\n        }\n        return result;\n    };\n}\nfunction formatBoolean(value) {\n    switch(value){\n        case true:\n        case \"true\":\n            return true;\n        case false:\n        case \"false\":\n            return false;\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid boolean; \".concat(JSON.stringify(value)), \"value\", value);\n}\nfunction formatData(value) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(value, true), \"invalid data\", \"value\", value);\n    return value;\n}\nfunction formatHash(value) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(value, 32), \"invalid hash\", \"value\", value);\n    return value;\n}\nfunction formatUint256(value) {\n    if (!(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(value)) {\n        throw new Error(\"invalid uint256\");\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.zeroPadValue)(value, 32);\n}\nconst _formatLog = object({\n    address: _address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress,\n    blockHash: formatHash,\n    blockNumber: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    data: formatData,\n    index: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    removed: allowNull(formatBoolean, false),\n    topics: arrayOf(formatHash),\n    transactionHash: formatHash,\n    transactionIndex: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber\n}, {\n    index: [\n        \"logIndex\"\n    ]\n});\nfunction formatLog(value) {\n    return _formatLog(value);\n}\nconst _formatBlock = object({\n    hash: allowNull(formatHash),\n    parentHash: formatHash,\n    parentBeaconBlockRoot: allowNull(formatHash, null),\n    number: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    timestamp: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    nonce: allowNull(formatData),\n    difficulty: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt,\n    gasLimit: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt,\n    gasUsed: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt,\n    stateRoot: allowNull(formatHash, null),\n    receiptsRoot: allowNull(formatHash, null),\n    blobGasUsed: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt, null),\n    excessBlobGas: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt, null),\n    miner: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress),\n    prevRandao: allowNull(formatHash, null),\n    extraData: formatData,\n    baseFeePerGas: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)\n}, {\n    prevRandao: [\n        \"mixHash\"\n    ]\n});\nfunction formatBlock(value) {\n    const result = _formatBlock(value);\n    result.transactions = value.transactions.map((tx)=>{\n        if (typeof tx === \"string\") {\n            return tx;\n        }\n        return formatTransactionResponse(tx);\n    });\n    return result;\n}\nconst _formatReceiptLog = object({\n    transactionIndex: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    blockNumber: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    transactionHash: formatHash,\n    address: _address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress,\n    topics: arrayOf(formatHash),\n    data: formatData,\n    index: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    blockHash: formatHash\n}, {\n    index: [\n        \"logIndex\"\n    ]\n});\nfunction formatReceiptLog(value) {\n    return _formatReceiptLog(value);\n}\nconst _formatTransactionReceipt = object({\n    to: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress, null),\n    from: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress, null),\n    contractAddress: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress, null),\n    // should be allowNull(hash), but broken-EIP-658 support is handled in receipt\n    index: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    root: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify),\n    gasUsed: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt,\n    blobGasUsed: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt, null),\n    logsBloom: allowNull(formatData),\n    blockHash: formatHash,\n    hash: formatHash,\n    logs: arrayOf(formatReceiptLog),\n    blockNumber: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    //confirmations: allowNull(getNumber, null),\n    cumulativeGasUsed: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt,\n    effectiveGasPrice: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt),\n    blobGasPrice: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt, null),\n    status: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber),\n    type: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber, 0)\n}, {\n    effectiveGasPrice: [\n        \"gasPrice\"\n    ],\n    hash: [\n        \"transactionHash\"\n    ],\n    index: [\n        \"transactionIndex\"\n    ]\n});\nfunction formatTransactionReceipt(value) {\n    return _formatTransactionReceipt(value);\n}\nfunction formatTransactionResponse(value) {\n    // Some clients (TestRPC) do strange things like return 0x0 for the\n    // 0 address; correct this to be a real address\n    if (value.to && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)(value.to) === BN_0) {\n        value.to = \"0x0000000000000000000000000000000000000000\";\n    }\n    const result = object({\n        hash: formatHash,\n        // Some nodes do not return this, usually test nodes (like Ganache)\n        index: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber, undefined),\n        type: (value)=>{\n            if (value === \"0x\" || value == null) {\n                return 0;\n            }\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber)(value);\n        },\n        accessList: allowNull(_transaction_index_js__WEBPACK_IMPORTED_MODULE_4__.accessListify, null),\n        blobVersionedHashes: allowNull(arrayOf(formatHash, true), null),\n        authorizationList: allowNull(arrayOf((v)=>{\n            let sig;\n            if (v.signature) {\n                sig = v.signature;\n            } else {\n                let yParity = v.yParity;\n                if (yParity === \"0x1b\") {\n                    yParity = 0;\n                } else if (yParity === \"0x1c\") {\n                    yParity = 1;\n                }\n                sig = Object.assign({}, v, {\n                    yParity\n                });\n            }\n            return {\n                address: (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress)(v.address),\n                chainId: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)(v.chainId),\n                nonce: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)(v.nonce),\n                signature: _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.Signature.from(sig)\n            };\n        }, false), null),\n        blockHash: allowNull(formatHash, null),\n        blockNumber: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber, null),\n        transactionIndex: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber, null),\n        from: _address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress,\n        // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas) must be set\n        gasPrice: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt),\n        maxPriorityFeePerGas: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt),\n        maxFeePerGas: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt),\n        maxFeePerBlobGas: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt, null),\n        gasLimit: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt,\n        to: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress, null),\n        value: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt,\n        nonce: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n        data: formatData,\n        creates: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress, null),\n        chainId: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt, null)\n    }, {\n        data: [\n            \"input\"\n        ],\n        gasLimit: [\n            \"gas\"\n        ],\n        index: [\n            \"transactionIndex\"\n        ]\n    })(value);\n    // If to and creates are empty, populate the creates from the value\n    if (result.to == null && result.creates == null) {\n        result.creates = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_6__.getCreateAddress)(result);\n    }\n    // @TODO: Check fee data\n    // Add an access list to supported transaction types\n    if ((value.type === 1 || value.type === 2) && value.accessList == null) {\n        result.accessList = [];\n    }\n    // Compute the signature\n    if (value.signature) {\n        result.signature = _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.Signature.from(value.signature);\n    } else {\n        result.signature = _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.Signature.from(value);\n    }\n    // Some backends omit ChainId on legacy transactions, but we can compute it\n    if (result.chainId == null) {\n        const chainId = result.signature.legacyChainId;\n        if (chainId != null) {\n            result.chainId = chainId;\n        }\n    }\n    // @TODO: check chainID\n    /*\n    if (value.chainId != null) {\n        let chainId = value.chainId;\n\n        if (isHexString(chainId)) {\n            chainId = BigNumber.from(chainId).toNumber();\n        }\n\n        result.chainId = chainId;\n\n    } else {\n        let chainId = value.networkId;\n\n        // geth-etc returns chainId\n        if (chainId == null && result.v == null) {\n            chainId = value.chainId;\n        }\n\n        if (isHexString(chainId)) {\n            chainId = BigNumber.from(chainId).toNumber();\n        }\n\n        if (typeof(chainId) !== \"number\" && result.v != null) {\n            chainId = (result.v - 35) / 2;\n            if (chainId < 0) { chainId = 0; }\n            chainId = parseInt(chainId);\n        }\n\n        if (typeof(chainId) !== \"number\") { chainId = 0; }\n\n        result.chainId = chainId;\n    }\n    */ // 0x0000... should actually be null\n    if (result.blockHash && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)(result.blockHash) === BN_0) {\n        result.blockHash = null;\n    }\n    return result;\n} //# sourceMappingURL=format.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvZm9ybWF0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Q0FFQyxHQUNrRTtBQUNwQjtBQUNTO0FBQzZEO0FBQ3JILE1BQU1XLE9BQU9DLE9BQU87QUFDYixTQUFTQyxVQUFVQyxNQUFNLEVBQUVDLFNBQVM7SUFDdkMsT0FBUSxTQUFVQyxLQUFLO1FBQ25CLElBQUlBLFNBQVMsTUFBTTtZQUNmLE9BQU9EO1FBQ1g7UUFDQSxPQUFPRCxPQUFPRTtJQUNsQjtBQUNKO0FBQ08sU0FBU0MsUUFBUUgsTUFBTSxFQUFFRCxTQUFTO0lBQ3JDLE9BQVEsQ0FBQ0s7UUFDTCxJQUFJTCxhQUFhSyxTQUFTLE1BQU07WUFDNUIsT0FBTztRQUNYO1FBQ0EsSUFBSSxDQUFDQyxNQUFNQyxPQUFPLENBQUNGLFFBQVE7WUFDdkIsTUFBTSxJQUFJRyxNQUFNO1FBQ3BCO1FBQ0EsT0FBT0gsTUFBTUksR0FBRyxDQUFDLENBQUNDLElBQU1ULE9BQU9TO0lBQ25DO0FBQ0o7QUFDQSwrREFBK0Q7QUFDL0Qsa0VBQWtFO0FBQ2xFLGlEQUFpRDtBQUMxQyxTQUFTQyxPQUFPVixNQUFNLEVBQUVXLFFBQVE7SUFDbkMsT0FBUSxDQUFDVDtRQUNMLE1BQU1VLFNBQVMsQ0FBQztRQUNoQixJQUFLLE1BQU1DLE9BQU9iLE9BQVE7WUFDdEIsSUFBSWMsU0FBU0Q7WUFDYixJQUFJRixZQUFZRSxPQUFPRixZQUFZLENBQUVHLENBQUFBLFVBQVVaLEtBQUksR0FBSTtnQkFDbkQsS0FBSyxNQUFNYSxVQUFVSixRQUFRLENBQUNFLElBQUksQ0FBRTtvQkFDaEMsSUFBSUUsVUFBVWIsT0FBTzt3QkFDakJZLFNBQVNDO3dCQUNUO29CQUNKO2dCQUNKO1lBQ0o7WUFDQSxJQUFJO2dCQUNBLE1BQU1DLEtBQUtoQixNQUFNLENBQUNhLElBQUksQ0FBQ1gsS0FBSyxDQUFDWSxP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QUFNQSxVQUFVdkUsT0FBT21FLFNBQVMsQ0FBQ1UsYUFBYTtRQUM5QyxJQUFJTixXQUFXLE1BQU07WUFDakJ2RSxPQUFPdUUsT0FBTyxHQUFHQTtRQUNyQjtJQUNKO0lBQ0EsdUJBQXVCO0lBQ3ZCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQWdDQSxHQUNBLG9DQUFvQztJQUNwQyxJQUFJdkUsT0FBT2dCLFNBQVMsSUFBSXRDLDBEQUFTQSxDQUFDc0IsT0FBT2dCLFNBQVMsTUFBTS9CLE1BQU07UUFDMURlLE9BQU9nQixTQUFTLEdBQUc7SUFDdkI7SUFDQSxPQUFPaEI7QUFDWCxFQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL2Zvcm1hdC5qcz83YzRhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmltcG9ydCB7IGdldEFkZHJlc3MsIGdldENyZWF0ZUFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgYWNjZXNzTGlzdGlmeSB9IGZyb20gXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0QmlnSW50LCBnZXROdW1iZXIsIGhleGxpZnksIGlzSGV4U3RyaW5nLCB6ZXJvUGFkVmFsdWUsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5leHBvcnQgZnVuY3Rpb24gYWxsb3dOdWxsKGZvcm1hdCwgbnVsbFZhbHVlKSB7XG4gICAgcmV0dXJuIChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdCh2YWx1ZSk7XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYXJyYXlPZihmb3JtYXQsIGFsbG93TnVsbCkge1xuICAgIHJldHVybiAoKGFycmF5KSA9PiB7XG4gICAgICAgIGlmIChhbGxvd051bGwgJiYgYXJyYXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGFuIGFycmF5XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJheS5tYXAoKGkpID0+IGZvcm1hdChpKSk7XG4gICAgfSk7XG59XG4vLyBSZXF1aXJlcyBhbiBvYmplY3Qgd2hpY2ggbWF0Y2hlcyBhIGZsZWV0IG9mIG90aGVyIGZvcm1hdHRlcnNcbi8vIEFueSBGb3JtYXRGdW5jIG1heSByZXR1cm4gYHVuZGVmaW5lZGAgdG8gaGF2ZSB0aGUgdmFsdWUgb21pdHRlZFxuLy8gZnJvbSB0aGUgcmVzdWx0IG9iamVjdC4gQ2FsbHMgcHJlc2VydmUgYHRoaXNgLlxuZXhwb3J0IGZ1bmN0aW9uIG9iamVjdChmb3JtYXQsIGFsdE5hbWVzKSB7XG4gICAgcmV0dXJuICgodmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGZvcm1hdCkge1xuICAgICAgICAgICAgbGV0IHNyY0tleSA9IGtleTtcbiAgICAgICAgICAgIGlmIChhbHROYW1lcyAmJiBrZXkgaW4gYWx0TmFtZXMgJiYgIShzcmNLZXkgaW4gdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBhbHRLZXkgb2YgYWx0TmFtZXNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWx0S2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcmNLZXkgPSBhbHRLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbnYgPSBmb3JtYXRba2V5XSh2YWx1ZVtzcmNLZXldKTtcbiAgICAgICAgICAgICAgICBpZiAobnYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IG52O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikgPyBlcnJvci5tZXNzYWdlIDogXCJub3QtYW4tZXJyb3JcIjtcbiAgICAgICAgICAgICAgICBhc3NlcnQoZmFsc2UsIGBpbnZhbGlkIHZhbHVlIGZvciB2YWx1ZS4ke2tleX0gKCR7bWVzc2FnZX0pYCwgXCJCQURfREFUQVwiLCB7IHZhbHVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0Qm9vbGVhbih2YWx1ZSkge1xuICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgY2FzZSB0cnVlOlxuICAgICAgICBjYXNlIFwidHJ1ZVwiOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgZmFsc2U6XG4gICAgICAgIGNhc2UgXCJmYWxzZVwiOlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGludmFsaWQgYm9vbGVhbjsgJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9YCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RGF0YSh2YWx1ZSkge1xuICAgIGFzc2VydEFyZ3VtZW50KGlzSGV4U3RyaW5nKHZhbHVlLCB0cnVlKSwgXCJpbnZhbGlkIGRhdGFcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEhhc2godmFsdWUpIHtcbiAgICBhc3NlcnRBcmd1bWVudChpc0hleFN0cmluZyh2YWx1ZSwgMzIpLCBcImludmFsaWQgaGFzaFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0VWludDI1Nih2YWx1ZSkge1xuICAgIGlmICghaXNIZXhTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdWludDI1NlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHplcm9QYWRWYWx1ZSh2YWx1ZSwgMzIpO1xufVxuY29uc3QgX2Zvcm1hdExvZyA9IG9iamVjdCh7XG4gICAgYWRkcmVzczogZ2V0QWRkcmVzcyxcbiAgICBibG9ja0hhc2g6IGZvcm1hdEhhc2gsXG4gICAgYmxvY2tOdW1iZXI6IGdldE51bWJlcixcbiAgICBkYXRhOiBmb3JtYXREYXRhLFxuICAgIGluZGV4OiBnZXROdW1iZXIsXG4gICAgcmVtb3ZlZDogYWxsb3dOdWxsKGZvcm1hdEJvb2xlYW4sIGZhbHNlKSxcbiAgICB0b3BpY3M6IGFycmF5T2YoZm9ybWF0SGFzaCksXG4gICAgdHJhbnNhY3Rpb25IYXNoOiBmb3JtYXRIYXNoLFxuICAgIHRyYW5zYWN0aW9uSW5kZXg6IGdldE51bWJlcixcbn0sIHtcbiAgICBpbmRleDogW1wibG9nSW5kZXhcIl1cbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdExvZyh2YWx1ZSkge1xuICAgIHJldHVybiBfZm9ybWF0TG9nKHZhbHVlKTtcbn1cbmNvbnN0IF9mb3JtYXRCbG9jayA9IG9iamVjdCh7XG4gICAgaGFzaDogYWxsb3dOdWxsKGZvcm1hdEhhc2gpLFxuICAgIHBhcmVudEhhc2g6IGZvcm1hdEhhc2gsXG4gICAgcGFyZW50QmVhY29uQmxvY2tSb290OiBhbGxvd051bGwoZm9ybWF0SGFzaCwgbnVsbCksXG4gICAgbnVtYmVyOiBnZXROdW1iZXIsXG4gICAgdGltZXN0YW1wOiBnZXROdW1iZXIsXG4gICAgbm9uY2U6IGFsbG93TnVsbChmb3JtYXREYXRhKSxcbiAgICBkaWZmaWN1bHR5OiBnZXRCaWdJbnQsXG4gICAgZ2FzTGltaXQ6IGdldEJpZ0ludCxcbiAgICBnYXNVc2VkOiBnZXRCaWdJbnQsXG4gICAgc3RhdGVSb290OiBhbGxvd051bGwoZm9ybWF0SGFzaCwgbnVsbCksXG4gICAgcmVjZWlwdHNSb290OiBhbGxvd051bGwoZm9ybWF0SGFzaCwgbnVsbCksXG4gICAgYmxvYkdhc1VzZWQ6IGFsbG93TnVsbChnZXRCaWdJbnQsIG51bGwpLFxuICAgIGV4Y2Vzc0Jsb2JHYXM6IGFsbG93TnVsbChnZXRCaWdJbnQsIG51bGwpLFxuICAgIG1pbmVyOiBhbGxvd051bGwoZ2V0QWRkcmVzcyksXG4gICAgcHJldlJhbmRhbzogYWxsb3dOdWxsKGZvcm1hdEhhc2gsIG51bGwpLFxuICAgIGV4dHJhRGF0YTogZm9ybWF0RGF0YSxcbiAgICBiYXNlRmVlUGVyR2FzOiBhbGxvd051bGwoZ2V0QmlnSW50KVxufSwge1xuICAgIHByZXZSYW5kYW86IFtcIm1peEhhc2hcIl1cbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEJsb2NrKHZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gX2Zvcm1hdEJsb2NrKHZhbHVlKTtcbiAgICByZXN1bHQudHJhbnNhY3Rpb25zID0gdmFsdWUudHJhbnNhY3Rpb25zLm1hcCgodHgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiAodHgpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdFRyYW5zYWN0aW9uUmVzcG9uc2UodHgpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBfZm9ybWF0UmVjZWlwdExvZyA9IG9iamVjdCh7XG4gICAgdHJhbnNhY3Rpb25JbmRleDogZ2V0TnVtYmVyLFxuICAgIGJsb2NrTnVtYmVyOiBnZXROdW1iZXIsXG4gICAgdHJhbnNhY3Rpb25IYXNoOiBmb3JtYXRIYXNoLFxuICAgIGFkZHJlc3M6IGdldEFkZHJlc3MsXG4gICAgdG9waWNzOiBhcnJheU9mKGZvcm1hdEhhc2gpLFxuICAgIGRhdGE6IGZvcm1hdERhdGEsXG4gICAgaW5kZXg6IGdldE51bWJlcixcbiAgICBibG9ja0hhc2g6IGZvcm1hdEhhc2gsXG59LCB7XG4gICAgaW5kZXg6IFtcImxvZ0luZGV4XCJdXG59KTtcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRSZWNlaXB0TG9nKHZhbHVlKSB7XG4gICAgcmV0dXJuIF9mb3JtYXRSZWNlaXB0TG9nKHZhbHVlKTtcbn1cbmNvbnN0IF9mb3JtYXRUcmFuc2FjdGlvblJlY2VpcHQgPSBvYmplY3Qoe1xuICAgIHRvOiBhbGxvd051bGwoZ2V0QWRkcmVzcywgbnVsbCksXG4gICAgZnJvbTogYWxsb3dOdWxsKGdldEFkZHJlc3MsIG51bGwpLFxuICAgIGNvbnRyYWN0QWRkcmVzczogYWxsb3dOdWxsKGdldEFkZHJlc3MsIG51bGwpLFxuICAgIC8vIHNob3VsZCBiZSBhbGxvd051bGwoaGFzaCksIGJ1dCBicm9rZW4tRUlQLTY1OCBzdXBwb3J0IGlzIGhhbmRsZWQgaW4gcmVjZWlwdFxuICAgIGluZGV4OiBnZXROdW1iZXIsXG4gICAgcm9vdDogYWxsb3dOdWxsKGhleGxpZnkpLFxuICAgIGdhc1VzZWQ6IGdldEJpZ0ludCxcbiAgICBibG9iR2FzVXNlZDogYWxsb3dOdWxsKGdldEJpZ0ludCwgbnVsbCksXG4gICAgbG9nc0Jsb29tOiBhbGxvd051bGwoZm9ybWF0RGF0YSksXG4gICAgYmxvY2tIYXNoOiBmb3JtYXRIYXNoLFxuICAgIGhhc2g6IGZvcm1hdEhhc2gsXG4gICAgbG9nczogYXJyYXlPZihmb3JtYXRSZWNlaXB0TG9nKSxcbiAgICBibG9ja051bWJlcjogZ2V0TnVtYmVyLFxuICAgIC8vY29uZmlybWF0aW9uczogYWxsb3dOdWxsKGdldE51bWJlciwgbnVsbCksXG4gICAgY3VtdWxhdGl2ZUdhc1VzZWQ6IGdldEJpZ0ludCxcbiAgICBlZmZlY3RpdmVHYXNQcmljZTogYWxsb3dOdWxsKGdldEJpZ0ludCksXG4gICAgYmxvYkdhc1ByaWNlOiBhbGxvd051bGwoZ2V0QmlnSW50LCBudWxsKSxcbiAgICBzdGF0dXM6IGFsbG93TnVsbChnZXROdW1iZXIpLFxuICAgIHR5cGU6IGFsbG93TnVsbChnZXROdW1iZXIsIDApXG59LCB7XG4gICAgZWZmZWN0aXZlR2FzUHJpY2U6IFtcImdhc1ByaWNlXCJdLFxuICAgIGhhc2g6IFtcInRyYW5zYWN0aW9uSGFzaFwiXSxcbiAgICBpbmRleDogW1widHJhbnNhY3Rpb25JbmRleFwiXSxcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdCh2YWx1ZSkge1xuICAgIHJldHVybiBfZm9ybWF0VHJhbnNhY3Rpb25SZWNlaXB0KHZhbHVlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRUcmFuc2FjdGlvblJlc3BvbnNlKHZhbHVlKSB7XG4gICAgLy8gU29tZSBjbGllbnRzIChUZXN0UlBDKSBkbyBzdHJhbmdlIHRoaW5ncyBsaWtlIHJldHVybiAweDAgZm9yIHRoZVxuICAgIC8vIDAgYWRkcmVzczsgY29ycmVjdCB0aGlzIHRvIGJlIGEgcmVhbCBhZGRyZXNzXG4gICAgaWYgKHZhbHVlLnRvICYmIGdldEJpZ0ludCh2YWx1ZS50bykgPT09IEJOXzApIHtcbiAgICAgICAgdmFsdWUudG8gPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBvYmplY3Qoe1xuICAgICAgICBoYXNoOiBmb3JtYXRIYXNoLFxuICAgICAgICAvLyBTb21lIG5vZGVzIGRvIG5vdCByZXR1cm4gdGhpcywgdXN1YWxseSB0ZXN0IG5vZGVzIChsaWtlIEdhbmFjaGUpXG4gICAgICAgIGluZGV4OiBhbGxvd051bGwoZ2V0TnVtYmVyLCB1bmRlZmluZWQpLFxuICAgICAgICB0eXBlOiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gXCIweFwiIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnZXROdW1iZXIodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBhY2Nlc3NMaXN0OiBhbGxvd051bGwoYWNjZXNzTGlzdGlmeSwgbnVsbCksXG4gICAgICAgIGJsb2JWZXJzaW9uZWRIYXNoZXM6IGFsbG93TnVsbChhcnJheU9mKGZvcm1hdEhhc2gsIHRydWUpLCBudWxsKSxcbiAgICAgICAgYXV0aG9yaXphdGlvbkxpc3Q6IGFsbG93TnVsbChhcnJheU9mKCh2KSA9PiB7XG4gICAgICAgICAgICBsZXQgc2lnO1xuICAgICAgICAgICAgaWYgKHYuc2lnbmF0dXJlKSB7XG4gICAgICAgICAgICAgICAgc2lnID0gdi5zaWduYXR1cmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgeVBhcml0eSA9IHYueVBhcml0eTtcbiAgICAgICAgICAgICAgICBpZiAoeVBhcml0eSA9PT0gXCIweDFiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgeVBhcml0eSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHlQYXJpdHkgPT09IFwiMHgxY1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHlQYXJpdHkgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzaWcgPSBPYmplY3QuYXNzaWduKHt9LCB2LCB7IHlQYXJpdHkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IGdldEFkZHJlc3Modi5hZGRyZXNzKSxcbiAgICAgICAgICAgICAgICBjaGFpbklkOiBnZXRCaWdJbnQodi5jaGFpbklkKSxcbiAgICAgICAgICAgICAgICBub25jZTogZ2V0QmlnSW50KHYubm9uY2UpLFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogU2lnbmF0dXJlLmZyb20oc2lnKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgZmFsc2UpLCBudWxsKSxcbiAgICAgICAgYmxvY2tIYXNoOiBhbGxvd051bGwoZm9ybWF0SGFzaCwgbnVsbCksXG4gICAgICAgIGJsb2NrTnVtYmVyOiBhbGxvd051bGwoZ2V0TnVtYmVyLCBudWxsKSxcbiAgICAgICAgdHJhbnNhY3Rpb25JbmRleDogYWxsb3dOdWxsKGdldE51bWJlciwgbnVsbCksXG4gICAgICAgIGZyb206IGdldEFkZHJlc3MsXG4gICAgICAgIC8vIGVpdGhlciAoZ2FzUHJpY2UpIG9yIChtYXhQcmlvcml0eUZlZVBlckdhcyArIG1heEZlZVBlckdhcykgbXVzdCBiZSBzZXRcbiAgICAgICAgZ2FzUHJpY2U6IGFsbG93TnVsbChnZXRCaWdJbnQpLFxuICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogYWxsb3dOdWxsKGdldEJpZ0ludCksXG4gICAgICAgIG1heEZlZVBlckdhczogYWxsb3dOdWxsKGdldEJpZ0ludCksXG4gICAgICAgIG1heEZlZVBlckJsb2JHYXM6IGFsbG93TnVsbChnZXRCaWdJbnQsIG51bGwpLFxuICAgICAgICBnYXNMaW1pdDogZ2V0QmlnSW50LFxuICAgICAgICB0bzogYWxsb3dOdWxsKGdldEFkZHJlc3MsIG51bGwpLFxuICAgICAgICB2YWx1ZTogZ2V0QmlnSW50LFxuICAgICAgICBub25jZTogZ2V0TnVtYmVyLFxuICAgICAgICBkYXRhOiBmb3JtYXREYXRhLFxuICAgICAgICBjcmVhdGVzOiBhbGxvd051bGwoZ2V0QWRkcmVzcywgbnVsbCksXG4gICAgICAgIGNoYWluSWQ6IGFsbG93TnVsbChnZXRCaWdJbnQsIG51bGwpXG4gICAgfSwge1xuICAgICAgICBkYXRhOiBbXCJpbnB1dFwiXSxcbiAgICAgICAgZ2FzTGltaXQ6IFtcImdhc1wiXSxcbiAgICAgICAgaW5kZXg6IFtcInRyYW5zYWN0aW9uSW5kZXhcIl1cbiAgICB9KSh2YWx1ZSk7XG4gICAgLy8gSWYgdG8gYW5kIGNyZWF0ZXMgYXJlIGVtcHR5LCBwb3B1bGF0ZSB0aGUgY3JlYXRlcyBmcm9tIHRoZSB2YWx1ZVxuICAgIGlmIChyZXN1bHQudG8gPT0gbnVsbCAmJiByZXN1bHQuY3JlYXRlcyA9PSBudWxsKSB7XG4gICAgICAgIHJlc3VsdC5jcmVhdGVzID0gZ2V0Q3JlYXRlQWRkcmVzcyhyZXN1bHQpO1xuICAgIH1cbiAgICAvLyBAVE9ETzogQ2hlY2sgZmVlIGRhdGFcbiAgICAvLyBBZGQgYW4gYWNjZXNzIGxpc3QgdG8gc3VwcG9ydGVkIHRyYW5zYWN0aW9uIHR5cGVzXG4gICAgaWYgKCh2YWx1ZS50eXBlID09PSAxIHx8IHZhbHVlLnR5cGUgPT09IDIpICYmIHZhbHVlLmFjY2Vzc0xpc3QgPT0gbnVsbCkge1xuICAgICAgICByZXN1bHQuYWNjZXNzTGlzdCA9IFtdO1xuICAgIH1cbiAgICAvLyBDb21wdXRlIHRoZSBzaWduYXR1cmVcbiAgICBpZiAodmFsdWUuc2lnbmF0dXJlKSB7XG4gICAgICAgIHJlc3VsdC5zaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbSh2YWx1ZS5zaWduYXR1cmUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0LnNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tKHZhbHVlKTtcbiAgICB9XG4gICAgLy8gU29tZSBiYWNrZW5kcyBvbWl0IENoYWluSWQgb24gbGVnYWN5IHRyYW5zYWN0aW9ucywgYnV0IHdlIGNhbiBjb21wdXRlIGl0XG4gICAgaWYgKHJlc3VsdC5jaGFpbklkID09IG51bGwpIHtcbiAgICAgICAgY29uc3QgY2hhaW5JZCA9IHJlc3VsdC5zaWduYXR1cmUubGVnYWN5Q2hhaW5JZDtcbiAgICAgICAgaWYgKGNoYWluSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LmNoYWluSWQgPSBjaGFpbklkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEBUT0RPOiBjaGVjayBjaGFpbklEXG4gICAgLypcbiAgICBpZiAodmFsdWUuY2hhaW5JZCAhPSBudWxsKSB7XG4gICAgICAgIGxldCBjaGFpbklkID0gdmFsdWUuY2hhaW5JZDtcblxuICAgICAgICBpZiAoaXNIZXhTdHJpbmcoY2hhaW5JZCkpIHtcbiAgICAgICAgICAgIGNoYWluSWQgPSBCaWdOdW1iZXIuZnJvbShjaGFpbklkKS50b051bWJlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LmNoYWluSWQgPSBjaGFpbklkO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGNoYWluSWQgPSB2YWx1ZS5uZXR3b3JrSWQ7XG5cbiAgICAgICAgLy8gZ2V0aC1ldGMgcmV0dXJucyBjaGFpbklkXG4gICAgICAgIGlmIChjaGFpbklkID09IG51bGwgJiYgcmVzdWx0LnYgPT0gbnVsbCkge1xuICAgICAgICAgICAgY2hhaW5JZCA9IHZhbHVlLmNoYWluSWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNIZXhTdHJpbmcoY2hhaW5JZCkpIHtcbiAgICAgICAgICAgIGNoYWluSWQgPSBCaWdOdW1iZXIuZnJvbShjaGFpbklkKS50b051bWJlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZihjaGFpbklkKSAhPT0gXCJudW1iZXJcIiAmJiByZXN1bHQudiAhPSBudWxsKSB7XG4gICAgICAgICAgICBjaGFpbklkID0gKHJlc3VsdC52IC0gMzUpIC8gMjtcbiAgICAgICAgICAgIGlmIChjaGFpbklkIDwgMCkgeyBjaGFpbklkID0gMDsgfVxuICAgICAgICAgICAgY2hhaW5JZCA9IHBhcnNlSW50KGNoYWluSWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZihjaGFpbklkKSAhPT0gXCJudW1iZXJcIikgeyBjaGFpbklkID0gMDsgfVxuXG4gICAgICAgIHJlc3VsdC5jaGFpbklkID0gY2hhaW5JZDtcbiAgICB9XG4gICAgKi9cbiAgICAvLyAweDAwMDAuLi4gc2hvdWxkIGFjdHVhbGx5IGJlIG51bGxcbiAgICBpZiAocmVzdWx0LmJsb2NrSGFzaCAmJiBnZXRCaWdJbnQocmVzdWx0LmJsb2NrSGFzaCkgPT09IEJOXzApIHtcbiAgICAgICAgcmVzdWx0LmJsb2NrSGFzaCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JtYXQuanMubWFwIl0sIm5hbWVzIjpbImdldEFkZHJlc3MiLCJnZXRDcmVhdGVBZGRyZXNzIiwiU2lnbmF0dXJlIiwiYWNjZXNzTGlzdGlmeSIsImdldEJpZ0ludCIsImdldE51bWJlciIsImhleGxpZnkiLCJpc0hleFN0cmluZyIsInplcm9QYWRWYWx1ZSIsImFzc2VydCIsImFzc2VydEFyZ3VtZW50IiwiQk5fMCIsIkJpZ0ludCIsImFsbG93TnVsbCIsImZvcm1hdCIsIm51bGxWYWx1ZSIsInZhbHVlIiwiYXJyYXlPZiIsImFycmF5IiwiQXJyYXkiLCJpc0FycmF5IiwiRXJyb3IiLCJtYXAiLCJpIiwib2JqZWN0IiwiYWx0TmFtZXMiLCJyZXN1bHQiLCJrZXkiLCJzcmNLZXkiLCJhbHRLZXkiLCJudiIsInVuZGVmaW5lZCIsImVycm9yIiwibWVzc2FnZSIsImZvcm1hdEJvb2xlYW4iLCJKU09OIiwic3RyaW5naWZ5IiwiZm9ybWF0RGF0YSIsImZvcm1hdEhhc2giLCJmb3JtYXRVaW50MjU2IiwiX2Zvcm1hdExvZyIsImFkZHJlc3MiLCJibG9ja0hhc2giLCJibG9ja051bWJlciIsImRhdGEiLCJpbmRleCIsInJlbW92ZWQiLCJ0b3BpY3MiLCJ0cmFuc2FjdGlvbkhhc2giLCJ0cmFuc2FjdGlvbkluZGV4IiwiZm9ybWF0TG9nIiwiX2Zvcm1hdEJsb2NrIiwiaGFzaCIsInBhcmVudEhhc2giLCJwYXJlbnRCZWFjb25CbG9ja1Jvb3QiLCJudW1iZXIiLCJ0aW1lc3RhbXAiLCJub25jZSIsImRpZmZpY3VsdHkiLCJnYXNMaW1pdCIsImdhc1VzZWQiLCJzdGF0ZVJvb3QiLCJyZWNlaXB0c1Jvb3QiLCJibG9iR2FzVXNlZCIsImV4Y2Vzc0Jsb2JHYXMiLCJtaW5lciIsInByZXZSYW5kYW8iLCJleHRyYURhdGEiLCJiYXNlRmVlUGVyR2FzIiwiZm9ybWF0QmxvY2siLCJ0cmFuc2FjdGlvbnMiLCJ0eCIsImZvcm1hdFRyYW5zYWN0aW9uUmVzcG9uc2UiLCJfZm9ybWF0UmVjZWlwdExvZyIsImZvcm1hdFJlY2VpcHRMb2ciLCJfZm9ybWF0VHJhbnNhY3Rpb25SZWNlaXB0IiwidG8iLCJmcm9tIiwiY29udHJhY3RBZGRyZXNzIiwicm9vdCIsImxvZ3NCbG9vbSIsImxvZ3MiLCJjdW11bGF0aXZlR2FzVXNlZCIsImVmZmVjdGl2ZUdhc1ByaWNlIiwiYmxvYkdhc1ByaWNlIiwic3RhdHVzIiwidHlwZSIsImZvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdCIsImFjY2Vzc0xpc3QiLCJibG9iVmVyc2lvbmVkSGFzaGVzIiwiYXV0aG9yaXphdGlvbkxpc3QiLCJ2Iiwic2lnIiwic2lnbmF0dXJlIiwieVBhcml0eSIsIk9iamVjdCIsImFzc2lnbiIsImNoYWluSWQiLCJnYXNQcmljZSIsIm1heFByaW9yaXR5RmVlUGVyR2FzIiwibWF4RmVlUGVyR2FzIiwibWF4RmVlUGVyQmxvYkdhcyIsImNyZWF0ZXMiLCJsZWdhY3lDaGFpbklkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/providers/format.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/providers/network.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/network.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Network: function() { return /* binding */ Network; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_get */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_get.js\");\n/* harmony import */ var _swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_init */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_init.js\");\n/* harmony import */ var _swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_set */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_set.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../transaction/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/transaction/accesslist.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _plugins_network_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./plugins-network.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/providers/plugins-network.js\");\n/**\n *  A **Network** encapsulates the various properties required to\n *  interact with a specific chain.\n *\n *  @_subsection: api/providers:Networks  [networks]\n */ \n\n\n\n\n\n/* * * *\n// Networks which operation against an L2 can use this plugin to\n// specify how to access L1, for the purpose of resolving ENS,\n// for example.\nexport class LayerOneConnectionPlugin extends NetworkPlugin {\n    readonly provider!: Provider;\n// @TODO: Rename to ChainAccess and allow for connecting to any chain\n    constructor(provider: Provider) {\n        super(\"org.ethers.plugins.layer-one-connection\");\n        defineProperties<LayerOneConnectionPlugin>(this, { provider });\n    }\n\n    clone(): LayerOneConnectionPlugin {\n        return new LayerOneConnectionPlugin(this.provider);\n    }\n}\n*/ const Networks = new Map();\nvar _name = /*#__PURE__*/ new WeakMap(), _chainId = /*#__PURE__*/ new WeakMap(), _plugins = /*#__PURE__*/ new WeakMap();\n/**\n *  A **Network** provides access to a chain's properties and allows\n *  for plug-ins to extend functionality.\n */ class Network {\n    /**\n     *  Returns a JSON-compatible representation of a Network.\n     */ toJSON() {\n        return {\n            name: this.name,\n            chainId: String(this.chainId)\n        };\n    }\n    /**\n     *  The network common name.\n     *\n     *  This is the canonical name, as networks migh have multiple\n     *  names.\n     */ get name() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _name);\n    }\n    set name(value) {\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_1__._)(this, _name, value);\n    }\n    /**\n     *  The network chain ID.\n     */ get chainId() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _chainId);\n    }\n    set chainId(value) {\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_1__._)(this, _chainId, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBigInt)(value, \"chainId\"));\n    }\n    /**\n     *  Returns true if %%other%% matches this network. Any chain ID\n     *  must match, and if no chain ID is present, the name must match.\n     *\n     *  This method does not currently check for additional properties,\n     *  such as ENS address or plug-in compatibility.\n     */ matches(other) {\n        if (other == null) {\n            return false;\n        }\n        if (typeof other === \"string\") {\n            try {\n                return this.chainId === (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBigInt)(other);\n            } catch (error) {}\n            return this.name === other;\n        }\n        if (typeof other === \"number\" || typeof other === \"bigint\") {\n            try {\n                return this.chainId === (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBigInt)(other);\n            } catch (error) {}\n            return false;\n        }\n        if (typeof other === \"object\") {\n            if (other.chainId != null) {\n                try {\n                    return this.chainId === (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBigInt)(other.chainId);\n                } catch (error) {}\n                return false;\n            }\n            if (other.name != null) {\n                return this.name === other.name;\n            }\n            return false;\n        }\n        return false;\n    }\n    /**\n     *  Returns the list of plugins currently attached to this Network.\n     */ get plugins() {\n        return Array.from((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _plugins).values());\n    }\n    /**\n     *  Attach a new %%plugin%% to this Network. The network name\n     *  must be unique, excluding any fragment.\n     */ attachPlugin(plugin) {\n        if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _plugins).get(plugin.name)) {\n            throw new Error(\"cannot replace existing plugin: \".concat(plugin.name, \" \"));\n        }\n        (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _plugins).set(plugin.name, plugin.clone());\n        return this;\n    }\n    /**\n     *  Return the plugin, if any, matching %%name%% exactly. Plugins\n     *  with fragments will not be returned unless %%name%% includes\n     *  a fragment.\n     */ getPlugin(name) {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _plugins).get(name) || null;\n    }\n    /**\n     *  Gets a list of all plugins that match %%name%%, with otr without\n     *  a fragment.\n     */ getPlugins(basename) {\n        return this.plugins.filter((p)=>p.name.split(\"#\")[0] === basename);\n    }\n    /**\n     *  Create a copy of this Network.\n     */ clone() {\n        const clone = new Network(this.name, this.chainId);\n        this.plugins.forEach((plugin)=>{\n            clone.attachPlugin(plugin.clone());\n        });\n        return clone;\n    }\n    /**\n     *  Compute the intrinsic gas required for a transaction.\n     *\n     *  A GasCostPlugin can be attached to override the default\n     *  values.\n     */ computeIntrinsicGas(tx) {\n        const costs = this.getPlugin(\"org.ethers.plugins.network.GasCost\") || new _plugins_network_js__WEBPACK_IMPORTED_MODULE_3__.GasCostPlugin();\n        let gas = costs.txBase;\n        if (tx.to == null) {\n            gas += costs.txCreate;\n        }\n        if (tx.data) {\n            for(let i = 2; i < tx.data.length; i += 2){\n                if (tx.data.substring(i, i + 2) === \"00\") {\n                    gas += costs.txDataZero;\n                } else {\n                    gas += costs.txDataNonzero;\n                }\n            }\n        }\n        if (tx.accessList) {\n            const accessList = (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_4__.accessListify)(tx.accessList);\n            for(const addr in accessList){\n                gas += costs.txAccessListAddress + costs.txAccessListStorageKey * accessList[addr].storageKeys.length;\n            }\n        }\n        return gas;\n    }\n    /**\n     *  Returns a new Network for the %%network%% name or chainId.\n     */ static from(network) {\n        injectCommonNetworks();\n        // Default network\n        if (network == null) {\n            return Network.from(\"mainnet\");\n        }\n        // Canonical name or chain ID\n        if (typeof network === \"number\") {\n            network = BigInt(network);\n        }\n        if (typeof network === \"string\" || typeof network === \"bigint\") {\n            const networkFunc = Networks.get(network);\n            if (networkFunc) {\n                return networkFunc();\n            }\n            if (typeof network === \"bigint\") {\n                return new Network(\"unknown\", network);\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.assertArgument)(false, \"unknown network\", \"network\", network);\n        }\n        // Clonable with network-like abilities\n        if (typeof network.clone === \"function\") {\n            const clone = network.clone();\n            //if (typeof(network.name) !== \"string\" || typeof(network.chainId) !== \"number\") {\n            //}\n            return clone;\n        }\n        // Networkish\n        if (typeof network === \"object\") {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.assertArgument)(typeof network.name === \"string\" && typeof network.chainId === \"number\", \"invalid network object name or chainId\", \"network\", network);\n            const custom = new Network(network.name, network.chainId);\n            if (network.ensAddress || network.ensNetwork != null) {\n                custom.attachPlugin(new _plugins_network_js__WEBPACK_IMPORTED_MODULE_3__.EnsPlugin(network.ensAddress, network.ensNetwork));\n            }\n            //if ((<any>network).layerOneConnection) {\n            //    custom.attachPlugin(new LayerOneConnectionPlugin((<any>network).layerOneConnection));\n            //}\n            return custom;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.assertArgument)(false, \"invalid network\", \"network\", network);\n    }\n    /**\n     *  Register %%nameOrChainId%% with a function which returns\n     *  an instance of a Network representing that chain.\n     */ static register(nameOrChainId, networkFunc) {\n        if (typeof nameOrChainId === \"number\") {\n            nameOrChainId = BigInt(nameOrChainId);\n        }\n        const existing = Networks.get(nameOrChainId);\n        if (existing) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.assertArgument)(false, \"conflicting network for \".concat(JSON.stringify(existing.name)), \"nameOrChainId\", nameOrChainId);\n        }\n        Networks.set(nameOrChainId, networkFunc);\n    }\n    /**\n     *  Creates a new **Network** for %%name%% and %%chainId%%.\n     */ constructor(name, chainId){\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_6__._)(this, _name, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_6__._)(this, _chainId, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_6__._)(this, _plugins, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_1__._)(this, _name, name);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_1__._)(this, _chainId, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBigInt)(chainId));\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_1__._)(this, _plugins, new Map());\n    }\n}\n// We don't want to bring in formatUnits because it is backed by\n// FixedNumber and we want to keep Networks tiny. The values\n// included by the Gas Stations are also IEEE 754 with lots of\n// rounding issues and exceed the strict checks formatUnits has.\nfunction parseUnits(_value, decimals) {\n    const value = String(_value);\n    if (!value.match(/^[0-9.]+$/)) {\n        throw new Error(\"invalid gwei value: \".concat(_value));\n    }\n    // Break into [ whole, fraction ]\n    const comps = value.split(\".\");\n    if (comps.length === 1) {\n        comps.push(\"\");\n    }\n    // More than 1 decimal point or too many fractional positions\n    if (comps.length !== 2) {\n        throw new Error(\"invalid gwei value: \".concat(_value));\n    }\n    // Pad the fraction to 9 decimalplaces\n    while(comps[1].length < decimals){\n        comps[1] += \"0\";\n    }\n    // Too many decimals and some non-zero ending, take the ceiling\n    if (comps[1].length > 9) {\n        let frac = BigInt(comps[1].substring(0, 9));\n        if (!comps[1].substring(9).match(/^0+$/)) {\n            frac++;\n        }\n        comps[1] = frac.toString();\n    }\n    return BigInt(comps[0] + comps[1]);\n}\n// Used by Polygon to use a gas station for fee data\nfunction getGasStationPlugin(url) {\n    return new _plugins_network_js__WEBPACK_IMPORTED_MODULE_3__.FetchUrlFeeDataNetworkPlugin(url, async (fetchFeeData, provider, request)=>{\n        // Prevent Cloudflare from blocking our request in node.js\n        request.setHeader(\"User-Agent\", \"ethers\");\n        let response;\n        try {\n            const [_response, _feeData] = await Promise.all([\n                request.send(),\n                fetchFeeData()\n            ]);\n            response = _response;\n            const payload = response.bodyJson.standard;\n            const feeData = {\n                gasPrice: _feeData.gasPrice,\n                maxFeePerGas: parseUnits(payload.maxFee, 9),\n                maxPriorityFeePerGas: parseUnits(payload.maxPriorityFee, 9)\n            };\n            return feeData;\n        } catch (error) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.assert)(false, \"error encountered with polygon gas station (\".concat(JSON.stringify(request.url), \")\"), \"SERVER_ERROR\", {\n                request,\n                response,\n                error\n            });\n        }\n    });\n}\n// See: https://chainlist.org\nlet injected = false;\nfunction injectCommonNetworks() {\n    if (injected) {\n        return;\n    }\n    injected = true;\n    /// Register popular Ethereum networks\n    function registerEth(name, chainId, options) {\n        const func = function() {\n            const network = new Network(name, chainId);\n            // We use 0 to disable ENS\n            if (options.ensNetwork != null) {\n                network.attachPlugin(new _plugins_network_js__WEBPACK_IMPORTED_MODULE_3__.EnsPlugin(null, options.ensNetwork));\n            }\n            network.attachPlugin(new _plugins_network_js__WEBPACK_IMPORTED_MODULE_3__.GasCostPlugin());\n            (options.plugins || []).forEach((plugin)=>{\n                network.attachPlugin(plugin);\n            });\n            return network;\n        };\n        // Register the network by name and chain ID\n        Network.register(name, func);\n        Network.register(chainId, func);\n        if (options.altNames) {\n            options.altNames.forEach((name)=>{\n                Network.register(name, func);\n            });\n        }\n    }\n    registerEth(\"mainnet\", 1, {\n        ensNetwork: 1,\n        altNames: [\n            \"homestead\"\n        ]\n    });\n    registerEth(\"ropsten\", 3, {\n        ensNetwork: 3\n    });\n    registerEth(\"rinkeby\", 4, {\n        ensNetwork: 4\n    });\n    registerEth(\"goerli\", 5, {\n        ensNetwork: 5\n    });\n    registerEth(\"kovan\", 42, {\n        ensNetwork: 42\n    });\n    registerEth(\"sepolia\", 11155111, {\n        ensNetwork: 11155111\n    });\n    registerEth(\"holesky\", 17000, {\n        ensNetwork: 17000\n    });\n    registerEth(\"classic\", 61, {});\n    registerEth(\"classicKotti\", 6, {});\n    registerEth(\"arbitrum\", 42161, {\n        ensNetwork: 1\n    });\n    registerEth(\"arbitrum-goerli\", 421613, {});\n    registerEth(\"arbitrum-sepolia\", 421614, {});\n    registerEth(\"base\", 8453, {\n        ensNetwork: 1\n    });\n    registerEth(\"base-goerli\", 84531, {});\n    registerEth(\"base-sepolia\", 84532, {});\n    registerEth(\"bnb\", 56, {\n        ensNetwork: 1\n    });\n    registerEth(\"bnbt\", 97, {});\n    registerEth(\"filecoin\", 314, {});\n    registerEth(\"filecoin-calibration\", 314159, {});\n    registerEth(\"linea\", 59144, {\n        ensNetwork: 1\n    });\n    registerEth(\"linea-goerli\", 59140, {});\n    registerEth(\"linea-sepolia\", 59141, {});\n    registerEth(\"matic\", 137, {\n        ensNetwork: 1,\n        plugins: [\n            getGasStationPlugin(\"https://gasstation.polygon.technology/v2\")\n        ]\n    });\n    registerEth(\"matic-amoy\", 80002, {});\n    registerEth(\"matic-mumbai\", 80001, {\n        altNames: [\n            \"maticMumbai\",\n            \"maticmum\"\n        ],\n        plugins: [\n            getGasStationPlugin(\"https://gasstation-testnet.polygon.technology/v2\")\n        ]\n    });\n    registerEth(\"optimism\", 10, {\n        ensNetwork: 1,\n        plugins: []\n    });\n    registerEth(\"optimism-goerli\", 420, {});\n    registerEth(\"optimism-sepolia\", 11155420, {});\n    registerEth(\"xdai\", 100, {\n        ensNetwork: 1\n    });\n} //# sourceMappingURL=network.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvbmV0d29yay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOzs7OztDQUtDOzs7QUFDdUQ7QUFDYztBQUN3QjtBQUM5Rjs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQSxHQUNBLE1BQU1PLFdBQVcsSUFBSUM7SUFNakIscUNBQ0Esd0NBQ0E7QUFQSjs7O0NBR0MsR0FDTSxNQUFNQztJQVlUOztLQUVDLEdBQ0RDLFNBQVM7UUFDTCxPQUFPO1lBQUVDLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQUVDLFNBQVNDLE9BQU8sSUFBSSxDQUFDRCxPQUFPO1FBQUU7SUFDNUQ7SUFDQTs7Ozs7S0FLQyxHQUNELElBQUlELE9BQU87UUFBRSxPQUFPLDRFQUFJLEVBQUVBO0lBQU07SUFDaEMsSUFBSUEsS0FBS0csS0FBSyxFQUFFO3NGQUFRSCxPQUFPRztJQUFPO0lBQ3RDOztLQUVDLEdBQ0QsSUFBSUYsVUFBVTtRQUFFLE9BQU8sNEVBQUksRUFBRUE7SUFBUztJQUN0QyxJQUFJQSxRQUFRRSxLQUFLLEVBQUU7c0ZBQVFGLFVBQVVYLDBEQUFTQSxDQUFDYSxPQUFPO0lBQVk7SUFDbEU7Ozs7OztLQU1DLEdBQ0RDLFFBQVFDLEtBQUssRUFBRTtRQUNYLElBQUlBLFNBQVMsTUFBTTtZQUNmLE9BQU87UUFDWDtRQUNBLElBQUksT0FBUUEsVUFBVyxVQUFVO1lBQzdCLElBQUk7Z0JBQ0EsT0FBUSxJQUFJLENBQUNKLE9BQU8sS0FBS1gsMERBQVNBLENBQUNlO1lBQ3ZDLEVBQ0EsT0FBT0MsT0FBTyxDQUFFO1lBQ2hCLE9BQVEsSUFBSSxDQUFDTixJQUFJLEtBQUtLO1FBQzFCO1FBQ0EsSUFBSSxPQUFRQSxVQUFXLFlBQVksT0FBUUEsVUFBVyxVQUFVO1lBQzVELElBQUk7Z0JBQ0EsT0FBUSxJQUFJLENBQUNKLE9BQU8sS0FBS1gsMERBQVNBLENBQUNlO1lBQ3ZDLEVBQ0EsT0FBT0MsT0FBTyxDQUFFO1lBQ2hCLE9BQU87UUFDWDtRQUNBLElBQUksT0FBUUQsVUFBVyxVQUFVO1lBQzdCLElBQUlBLE1BQU1KLE9BQU8sSUFBSSxNQUFNO2dCQUN2QixJQUFJO29CQUNBLE9BQVEsSUFBSSxDQUFDQSxPQUFPLEtBQUtYLDBEQUFTQSxDQUFDZSxNQUFNSixPQUFPO2dCQUNwRCxFQUNBLE9BQU9LLE9BQU8sQ0FBRTtnQkFDaEIsT0FBTztZQUNYO1lBQ0EsSUFBSUQsTUFBTUwsSUFBSSxJQUFJLE1BQU07Z0JBQ3BCLE9BQVEsSUFBSSxDQUFDQSxJQUFJLEtBQUtLLE1BQU1MLElBQUk7WUFDcEM7WUFDQSxPQUFPO1FBQ1g7UUFDQSxPQUFPO0lBQ1g7SUFDQTs7S0FFQyxHQUNELElBQUlPLFVBQVU7UUFDVixPQUFPQyxNQUFNQyxJQUFJLENBQUMsNEVBQUksRUFBRUYsVUFBUUcsTUFBTTtJQUMxQztJQUNBOzs7S0FHQyxHQUNEQyxhQUFhQyxNQUFNLEVBQUU7UUFDakIsSUFBSSw0RUFBSSxFQUFFTCxVQUFRTSxHQUFHLENBQUNELE9BQU9aLElBQUksR0FBRztZQUNoQyxNQUFNLElBQUljLE1BQU0sbUNBQStDLE9BQVpGLE9BQU9aLElBQUksRUFBQztRQUNuRTtRQUNBLDRFQUFJLEVBQUVPLFVBQVFRLEdBQUcsQ0FBQ0gsT0FBT1osSUFBSSxFQUFFWSxPQUFPSSxLQUFLO1FBQzNDLE9BQU8sSUFBSTtJQUNmO0lBQ0E7Ozs7S0FJQyxHQUNEQyxVQUFVakIsSUFBSSxFQUFFO1FBQ1osT0FBTyx3RUFBQyxJQUFJLEVBQUVPLFVBQVFNLEdBQUcsQ0FBQ2IsU0FBVTtJQUN4QztJQUNBOzs7S0FHQyxHQUNEa0IsV0FBV0MsUUFBUSxFQUFFO1FBQ2pCLE9BQVEsSUFBSSxDQUFDWixPQUFPLENBQUNhLE1BQU0sQ0FBQyxDQUFDQyxJQUFPQSxFQUFFckIsSUFBSSxDQUFDc0IsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLEtBQUtIO0lBQ2pFO0lBQ0E7O0tBRUMsR0FDREgsUUFBUTtRQUNKLE1BQU1BLFFBQVEsSUFBSWxCLFFBQVEsSUFBSSxDQUFDRSxJQUFJLEVBQUUsSUFBSSxDQUFDQyxPQUFPO1FBQ2pELElBQUksQ0FBQ00sT0FBTyxDQUFDZ0IsT0FBTyxDQUFDLENBQUNYO1lBQ2xCSSxNQUFNTCxZQUFZLENBQUNDLE9BQU9JLEtBQUs7UUFDbkM7UUFDQSxPQUFPQTtJQUNYO0lBQ0E7Ozs7O0tBS0MsR0FDRFEsb0JBQW9CQyxFQUFFLEVBQUU7UUFDcEIsTUFBTUMsUUFBUSxJQUFJLENBQUNULFNBQVMsQ0FBQyx5Q0FBMEMsSUFBSXRCLDhEQUFhQTtRQUN4RixJQUFJZ0MsTUFBTUQsTUFBTUUsTUFBTTtRQUN0QixJQUFJSCxHQUFHSSxFQUFFLElBQUksTUFBTTtZQUNmRixPQUFPRCxNQUFNSSxRQUFRO1FBQ3pCO1FBQ0EsSUFBSUwsR0FBR00sSUFBSSxFQUFFO1lBQ1QsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlQLEdBQUdNLElBQUksQ0FBQ0UsTUFBTSxFQUFFRCxLQUFLLEVBQUc7Z0JBQ3hDLElBQUlQLEdBQUdNLElBQUksQ0FBQ0csU0FBUyxDQUFDRixHQUFHQSxJQUFJLE9BQU8sTUFBTTtvQkFDdENMLE9BQU9ELE1BQU1TLFVBQVU7Z0JBQzNCLE9BQ0s7b0JBQ0RSLE9BQU9ELE1BQU1VLGFBQWE7Z0JBQzlCO1lBQ0o7UUFDSjtRQUNBLElBQUlYLEdBQUdZLFVBQVUsRUFBRTtZQUNmLE1BQU1BLGFBQWFoRCxvRUFBYUEsQ0FBQ29DLEdBQUdZLFVBQVU7WUFDOUMsSUFBSyxNQUFNQyxRQUFRRCxXQUFZO2dCQUMzQlYsT0FBT0QsTUFBTWEsbUJBQW1CLEdBQUdiLE1BQU1jLHNCQUFzQixHQUFHSCxVQUFVLENBQUNDLEtBQUssQ0FBQ0csV0FBVyxDQUFDUixNQUFNO1lBQ3pHO1FBQ0o7UUFDQSxPQUFPTjtJQUNYO0lBQ0E7O0tBRUMsR0FDRCxPQUFPbEIsS0FBS2lDLE9BQU8sRUFBRTtRQUNqQkM7UUFDQSxrQkFBa0I7UUFDbEIsSUFBSUQsV0FBVyxNQUFNO1lBQ2pCLE9BQU81QyxRQUFRVyxJQUFJLENBQUM7UUFDeEI7UUFDQSw2QkFBNkI7UUFDN0IsSUFBSSxPQUFRaUMsWUFBYSxVQUFVO1lBQy9CQSxVQUFVRSxPQUFPRjtRQUNyQjtRQUNBLElBQUksT0FBUUEsWUFBYSxZQUFZLE9BQVFBLFlBQWEsVUFBVTtZQUNoRSxNQUFNRyxjQUFjakQsU0FBU2lCLEdBQUcsQ0FBQzZCO1lBQ2pDLElBQUlHLGFBQWE7Z0JBQ2IsT0FBT0E7WUFDWDtZQUNBLElBQUksT0FBUUgsWUFBYSxVQUFVO2dCQUMvQixPQUFPLElBQUk1QyxRQUFRLFdBQVc0QztZQUNsQztZQUNBbEQsK0RBQWNBLENBQUMsT0FBTyxtQkFBbUIsV0FBV2tEO1FBQ3hEO1FBQ0EsdUNBQXVDO1FBQ3ZDLElBQUksT0FBUUEsUUFBUTFCLEtBQUssS0FBTSxZQUFZO1lBQ3ZDLE1BQU1BLFFBQVEwQixRQUFRMUIsS0FBSztZQUMzQixrRkFBa0Y7WUFDbEYsR0FBRztZQUNILE9BQU9BO1FBQ1g7UUFDQSxhQUFhO1FBQ2IsSUFBSSxPQUFRMEIsWUFBYSxVQUFVO1lBQy9CbEQsK0RBQWNBLENBQUMsT0FBUWtELFFBQVExQyxJQUFJLEtBQU0sWUFBWSxPQUFRMEMsUUFBUXpDLE9BQU8sS0FBTSxVQUFVLDBDQUEwQyxXQUFXeUM7WUFDakosTUFBTUksU0FBUyxJQUFJaEQsUUFBUzRDLFFBQVExQyxJQUFJLEVBQUkwQyxRQUFRekMsT0FBTztZQUMzRCxJQUFJeUMsUUFBUUssVUFBVSxJQUFJTCxRQUFRTSxVQUFVLElBQUksTUFBTTtnQkFDbERGLE9BQU9uQyxZQUFZLENBQUMsSUFBSWxCLDBEQUFTQSxDQUFDaUQsUUFBUUssVUFBVSxFQUFFTCxRQUFRTSxVQUFVO1lBQzVFO1lBQ0EsMENBQTBDO1lBQzFDLDJGQUEyRjtZQUMzRixHQUFHO1lBQ0gsT0FBT0Y7UUFDWDtRQUNBdEQsK0RBQWNBLENBQUMsT0FBTyxtQkFBbUIsV0FBV2tEO0lBQ3hEO0lBQ0E7OztLQUdDLEdBQ0QsT0FBT08sU0FBU0MsYUFBYSxFQUFFTCxXQUFXLEVBQUU7UUFDeEMsSUFBSSxPQUFRSyxrQkFBbUIsVUFBVTtZQUNyQ0EsZ0JBQWdCTixPQUFPTTtRQUMzQjtRQUNBLE1BQU1DLFdBQVd2RCxTQUFTaUIsR0FBRyxDQUFDcUM7UUFDOUIsSUFBSUMsVUFBVTtZQUNWM0QsK0RBQWNBLENBQUMsT0FBTywyQkFBeUQsT0FBOUI0RCxLQUFLQyxTQUFTLENBQUNGLFNBQVNuRCxJQUFJLElBQUssaUJBQWlCa0Q7UUFDdkc7UUFDQXRELFNBQVNtQixHQUFHLENBQUNtQyxlQUFlTDtJQUNoQztJQXBNQTs7S0FFQyxHQUNEUyxZQUFZdEQsSUFBSSxFQUFFQyxPQUFPLENBQUU7UUFOM0I7O21CQUFBOztRQUNBOzttQkFBQTs7UUFDQTs7bUJBQUE7O3NGQUtVRCxPQUFPQTtzRkFDUEMsVUFBVVgsMERBQVNBLENBQUNXO3NGQUNwQk0sVUFBVSxJQUFJVjtJQUN4QjtBQThMSjtBQUNBLGdFQUFnRTtBQUNoRSw0REFBNEQ7QUFDNUQsOERBQThEO0FBQzlELGdFQUFnRTtBQUNoRSxTQUFTMEQsV0FBV0MsTUFBTSxFQUFFQyxRQUFRO0lBQ2hDLE1BQU10RCxRQUFRRCxPQUFPc0Q7SUFDckIsSUFBSSxDQUFDckQsTUFBTXVELEtBQUssQ0FBQyxjQUFjO1FBQzNCLE1BQU0sSUFBSTVDLE1BQU0sdUJBQThCLE9BQVAwQztJQUMzQztJQUNBLGlDQUFpQztJQUNqQyxNQUFNRyxRQUFReEQsTUFBTW1CLEtBQUssQ0FBQztJQUMxQixJQUFJcUMsTUFBTTFCLE1BQU0sS0FBSyxHQUFHO1FBQ3BCMEIsTUFBTUMsSUFBSSxDQUFDO0lBQ2Y7SUFDQSw2REFBNkQ7SUFDN0QsSUFBSUQsTUFBTTFCLE1BQU0sS0FBSyxHQUFHO1FBQ3BCLE1BQU0sSUFBSW5CLE1BQU0sdUJBQThCLE9BQVAwQztJQUMzQztJQUNBLHNDQUFzQztJQUN0QyxNQUFPRyxLQUFLLENBQUMsRUFBRSxDQUFDMUIsTUFBTSxHQUFHd0IsU0FBVTtRQUMvQkUsS0FBSyxDQUFDLEVBQUUsSUFBSTtJQUNoQjtJQUNBLCtEQUErRDtJQUMvRCxJQUFJQSxLQUFLLENBQUMsRUFBRSxDQUFDMUIsTUFBTSxHQUFHLEdBQUc7UUFDckIsSUFBSTRCLE9BQU9qQixPQUFPZSxLQUFLLENBQUMsRUFBRSxDQUFDekIsU0FBUyxDQUFDLEdBQUc7UUFDeEMsSUFBSSxDQUFDeUIsS0FBSyxDQUFDLEVBQUUsQ0FBQ3pCLFNBQVMsQ0FBQyxHQUFHd0IsS0FBSyxDQUFDLFNBQVM7WUFDdENHO1FBQ0o7UUFDQUYsS0FBSyxDQUFDLEVBQUUsR0FBR0UsS0FBS0MsUUFBUTtJQUM1QjtJQUNBLE9BQU9sQixPQUFPZSxLQUFLLENBQUMsRUFBRSxHQUFHQSxLQUFLLENBQUMsRUFBRTtBQUNyQztBQUNBLG9EQUFvRDtBQUNwRCxTQUFTSSxvQkFBb0JDLEdBQUc7SUFDNUIsT0FBTyxJQUFJdEUsNkVBQTRCQSxDQUFDc0UsS0FBSyxPQUFPQyxjQUFjQyxVQUFVQztRQUN4RSwwREFBMEQ7UUFDMURBLFFBQVFDLFNBQVMsQ0FBQyxjQUFjO1FBQ2hDLElBQUlDO1FBQ0osSUFBSTtZQUNBLE1BQU0sQ0FBQ0MsV0FBV0MsU0FBUyxHQUFHLE1BQU1DLFFBQVFDLEdBQUcsQ0FBQztnQkFDNUNOLFFBQVFPLElBQUk7Z0JBQUlUO2FBQ25CO1lBQ0RJLFdBQVdDO1lBQ1gsTUFBTUssVUFBVU4sU0FBU08sUUFBUSxDQUFDQyxRQUFRO1lBQzFDLE1BQU1DLFVBQVU7Z0JBQ1pDLFVBQVVSLFNBQVNRLFFBQVE7Z0JBQzNCQyxjQUFjekIsV0FBV29CLFFBQVFNLE1BQU0sRUFBRTtnQkFDekNDLHNCQUFzQjNCLFdBQVdvQixRQUFRUSxjQUFjLEVBQUU7WUFDN0Q7WUFDQSxPQUFPTDtRQUNYLEVBQ0EsT0FBT3hFLE9BQU87WUFDVmYsdURBQU1BLENBQUMsT0FBTywrQ0FBMkUsT0FBNUI2RCxLQUFLQyxTQUFTLENBQUNjLFFBQVFILEdBQUcsR0FBRSxNQUFJLGdCQUFnQjtnQkFBRUc7Z0JBQVNFO2dCQUFVL0Q7WUFBTTtRQUM1STtJQUNKO0FBQ0o7QUFDQSw2QkFBNkI7QUFDN0IsSUFBSThFLFdBQVc7QUFDZixTQUFTekM7SUFDTCxJQUFJeUMsVUFBVTtRQUNWO0lBQ0o7SUFDQUEsV0FBVztJQUNYLHNDQUFzQztJQUN0QyxTQUFTQyxZQUFZckYsSUFBSSxFQUFFQyxPQUFPLEVBQUVxRixPQUFPO1FBQ3ZDLE1BQU1DLE9BQU87WUFDVCxNQUFNN0MsVUFBVSxJQUFJNUMsUUFBUUUsTUFBTUM7WUFDbEMsMEJBQTBCO1lBQzFCLElBQUlxRixRQUFRdEMsVUFBVSxJQUFJLE1BQU07Z0JBQzVCTixRQUFRL0IsWUFBWSxDQUFDLElBQUlsQiwwREFBU0EsQ0FBQyxNQUFNNkYsUUFBUXRDLFVBQVU7WUFDL0Q7WUFDQU4sUUFBUS9CLFlBQVksQ0FBQyxJQUFJaEIsOERBQWFBO1lBQ3JDMkYsQ0FBQUEsUUFBUS9FLE9BQU8sSUFBSSxFQUFFLEVBQUVnQixPQUFPLENBQUMsQ0FBQ1g7Z0JBQzdCOEIsUUFBUS9CLFlBQVksQ0FBQ0M7WUFDekI7WUFDQSxPQUFPOEI7UUFDWDtRQUNBLDRDQUE0QztRQUM1QzVDLFFBQVFtRCxRQUFRLENBQUNqRCxNQUFNdUY7UUFDdkJ6RixRQUFRbUQsUUFBUSxDQUFDaEQsU0FBU3NGO1FBQzFCLElBQUlELFFBQVFFLFFBQVEsRUFBRTtZQUNsQkYsUUFBUUUsUUFBUSxDQUFDakUsT0FBTyxDQUFDLENBQUN2QjtnQkFDdEJGLFFBQVFtRCxRQUFRLENBQUNqRCxNQUFNdUY7WUFDM0I7UUFDSjtJQUNKO0lBQ0FGLFlBQVksV0FBVyxHQUFHO1FBQUVyQyxZQUFZO1FBQUd3QyxVQUFVO1lBQUM7U0FBWTtJQUFDO0lBQ25FSCxZQUFZLFdBQVcsR0FBRztRQUFFckMsWUFBWTtJQUFFO0lBQzFDcUMsWUFBWSxXQUFXLEdBQUc7UUFBRXJDLFlBQVk7SUFBRTtJQUMxQ3FDLFlBQVksVUFBVSxHQUFHO1FBQUVyQyxZQUFZO0lBQUU7SUFDekNxQyxZQUFZLFNBQVMsSUFBSTtRQUFFckMsWUFBWTtJQUFHO0lBQzFDcUMsWUFBWSxXQUFXLFVBQVU7UUFBRXJDLFlBQVk7SUFBUztJQUN4RHFDLFlBQVksV0FBVyxPQUFPO1FBQUVyQyxZQUFZO0lBQU07SUFDbERxQyxZQUFZLFdBQVcsSUFBSSxDQUFDO0lBQzVCQSxZQUFZLGdCQUFnQixHQUFHLENBQUM7SUFDaENBLFlBQVksWUFBWSxPQUFPO1FBQzNCckMsWUFBWTtJQUNoQjtJQUNBcUMsWUFBWSxtQkFBbUIsUUFBUSxDQUFDO0lBQ3hDQSxZQUFZLG9CQUFvQixRQUFRLENBQUM7SUFDekNBLFlBQVksUUFBUSxNQUFNO1FBQUVyQyxZQUFZO0lBQUU7SUFDMUNxQyxZQUFZLGVBQWUsT0FBTyxDQUFDO0lBQ25DQSxZQUFZLGdCQUFnQixPQUFPLENBQUM7SUFDcENBLFlBQVksT0FBTyxJQUFJO1FBQUVyQyxZQUFZO0lBQUU7SUFDdkNxQyxZQUFZLFFBQVEsSUFBSSxDQUFDO0lBQ3pCQSxZQUFZLFlBQVksS0FBSyxDQUFDO0lBQzlCQSxZQUFZLHdCQUF3QixRQUFRLENBQUM7SUFDN0NBLFlBQVksU0FBUyxPQUFPO1FBQUVyQyxZQUFZO0lBQUU7SUFDNUNxQyxZQUFZLGdCQUFnQixPQUFPLENBQUM7SUFDcENBLFlBQVksaUJBQWlCLE9BQU8sQ0FBQztJQUNyQ0EsWUFBWSxTQUFTLEtBQUs7UUFDdEJyQyxZQUFZO1FBQ1p6QyxTQUFTO1lBQ0x3RCxvQkFBb0I7U0FDdkI7SUFDTDtJQUNBc0IsWUFBWSxjQUFjLE9BQU8sQ0FBQztJQUNsQ0EsWUFBWSxnQkFBZ0IsT0FBTztRQUMvQkcsVUFBVTtZQUFDO1lBQWU7U0FBVztRQUNyQ2pGLFNBQVM7WUFDTHdELG9CQUFvQjtTQUN2QjtJQUNMO0lBQ0FzQixZQUFZLFlBQVksSUFBSTtRQUN4QnJDLFlBQVk7UUFDWnpDLFNBQVMsRUFBRTtJQUNmO0lBQ0E4RSxZQUFZLG1CQUFtQixLQUFLLENBQUM7SUFDckNBLFlBQVksb0JBQW9CLFVBQVUsQ0FBQztJQUMzQ0EsWUFBWSxRQUFRLEtBQUs7UUFBRXJDLFlBQVk7SUFBRTtBQUM3QyxFQUNBLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL25ldHdvcmsuanM/MzgxYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBBICoqTmV0d29yayoqIGVuY2Fwc3VsYXRlcyB0aGUgdmFyaW91cyBwcm9wZXJ0aWVzIHJlcXVpcmVkIHRvXG4gKiAgaW50ZXJhY3Qgd2l0aCBhIHNwZWNpZmljIGNoYWluLlxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9wcm92aWRlcnM6TmV0d29ya3MgIFtuZXR3b3Jrc11cbiAqL1xuaW1wb3J0IHsgYWNjZXNzTGlzdGlmeSB9IGZyb20gXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0QmlnSW50LCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBFbnNQbHVnaW4sIEZldGNoVXJsRmVlRGF0YU5ldHdvcmtQbHVnaW4sIEdhc0Nvc3RQbHVnaW4gfSBmcm9tIFwiLi9wbHVnaW5zLW5ldHdvcmsuanNcIjtcbi8qICogKiAqXG4vLyBOZXR3b3JrcyB3aGljaCBvcGVyYXRpb24gYWdhaW5zdCBhbiBMMiBjYW4gdXNlIHRoaXMgcGx1Z2luIHRvXG4vLyBzcGVjaWZ5IGhvdyB0byBhY2Nlc3MgTDEsIGZvciB0aGUgcHVycG9zZSBvZiByZXNvbHZpbmcgRU5TLFxuLy8gZm9yIGV4YW1wbGUuXG5leHBvcnQgY2xhc3MgTGF5ZXJPbmVDb25uZWN0aW9uUGx1Z2luIGV4dGVuZHMgTmV0d29ya1BsdWdpbiB7XG4gICAgcmVhZG9ubHkgcHJvdmlkZXIhOiBQcm92aWRlcjtcbi8vIEBUT0RPOiBSZW5hbWUgdG8gQ2hhaW5BY2Nlc3MgYW5kIGFsbG93IGZvciBjb25uZWN0aW5nIHRvIGFueSBjaGFpblxuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyOiBQcm92aWRlcikge1xuICAgICAgICBzdXBlcihcIm9yZy5ldGhlcnMucGx1Z2lucy5sYXllci1vbmUtY29ubmVjdGlvblwiKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllczxMYXllck9uZUNvbm5lY3Rpb25QbHVnaW4+KHRoaXMsIHsgcHJvdmlkZXIgfSk7XG4gICAgfVxuXG4gICAgY2xvbmUoKTogTGF5ZXJPbmVDb25uZWN0aW9uUGx1Z2luIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMYXllck9uZUNvbm5lY3Rpb25QbHVnaW4odGhpcy5wcm92aWRlcik7XG4gICAgfVxufVxuKi9cbmNvbnN0IE5ldHdvcmtzID0gbmV3IE1hcCgpO1xuLyoqXG4gKiAgQSAqKk5ldHdvcmsqKiBwcm92aWRlcyBhY2Nlc3MgdG8gYSBjaGFpbidzIHByb3BlcnRpZXMgYW5kIGFsbG93c1xuICogIGZvciBwbHVnLWlucyB0byBleHRlbmQgZnVuY3Rpb25hbGl0eS5cbiAqL1xuZXhwb3J0IGNsYXNzIE5ldHdvcmsge1xuICAgICNuYW1lO1xuICAgICNjaGFpbklkO1xuICAgICNwbHVnaW5zO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqTmV0d29yayoqIGZvciAlJW5hbWUlJSBhbmQgJSVjaGFpbklkJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSwgY2hhaW5JZCkge1xuICAgICAgICB0aGlzLiNuYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy4jY2hhaW5JZCA9IGdldEJpZ0ludChjaGFpbklkKTtcbiAgICAgICAgdGhpcy4jcGx1Z2lucyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBKU09OLWNvbXBhdGlibGUgcmVwcmVzZW50YXRpb24gb2YgYSBOZXR3b3JrLlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgbmFtZTogdGhpcy5uYW1lLCBjaGFpbklkOiBTdHJpbmcodGhpcy5jaGFpbklkKSB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG5ldHdvcmsgY29tbW9uIG5hbWUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyB0aGUgY2Fub25pY2FsIG5hbWUsIGFzIG5ldHdvcmtzIG1pZ2ggaGF2ZSBtdWx0aXBsZVxuICAgICAqICBuYW1lcy5cbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMuI25hbWU7IH1cbiAgICBzZXQgbmFtZSh2YWx1ZSkgeyB0aGlzLiNuYW1lID0gdmFsdWU7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG5ldHdvcmsgY2hhaW4gSUQuXG4gICAgICovXG4gICAgZ2V0IGNoYWluSWQoKSB7IHJldHVybiB0aGlzLiNjaGFpbklkOyB9XG4gICAgc2V0IGNoYWluSWQodmFsdWUpIHsgdGhpcy4jY2hhaW5JZCA9IGdldEJpZ0ludCh2YWx1ZSwgXCJjaGFpbklkXCIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJW90aGVyJSUgbWF0Y2hlcyB0aGlzIG5ldHdvcmsuIEFueSBjaGFpbiBJRFxuICAgICAqICBtdXN0IG1hdGNoLCBhbmQgaWYgbm8gY2hhaW4gSUQgaXMgcHJlc2VudCwgdGhlIG5hbWUgbXVzdCBtYXRjaC5cbiAgICAgKlxuICAgICAqICBUaGlzIG1ldGhvZCBkb2VzIG5vdCBjdXJyZW50bHkgY2hlY2sgZm9yIGFkZGl0aW9uYWwgcHJvcGVydGllcyxcbiAgICAgKiAgc3VjaCBhcyBFTlMgYWRkcmVzcyBvciBwbHVnLWluIGNvbXBhdGliaWxpdHkuXG4gICAgICovXG4gICAgbWF0Y2hlcyhvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG90aGVyKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuY2hhaW5JZCA9PT0gZ2V0QmlnSW50KG90aGVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLm5hbWUgPT09IG90aGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvdGhlcikgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIChvdGhlcikgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmNoYWluSWQgPT09IGdldEJpZ0ludChvdGhlcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvdGhlcikgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGlmIChvdGhlci5jaGFpbklkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuY2hhaW5JZCA9PT0gZ2V0QmlnSW50KG90aGVyLmNoYWluSWQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3RoZXIubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLm5hbWUgPT09IG90aGVyLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIGxpc3Qgb2YgcGx1Z2lucyBjdXJyZW50bHkgYXR0YWNoZWQgdG8gdGhpcyBOZXR3b3JrLlxuICAgICAqL1xuICAgIGdldCBwbHVnaW5zKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLiNwbHVnaW5zLnZhbHVlcygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEF0dGFjaCBhIG5ldyAlJXBsdWdpbiUlIHRvIHRoaXMgTmV0d29yay4gVGhlIG5ldHdvcmsgbmFtZVxuICAgICAqICBtdXN0IGJlIHVuaXF1ZSwgZXhjbHVkaW5nIGFueSBmcmFnbWVudC5cbiAgICAgKi9cbiAgICBhdHRhY2hQbHVnaW4ocGx1Z2luKSB7XG4gICAgICAgIGlmICh0aGlzLiNwbHVnaW5zLmdldChwbHVnaW4ubmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlcGxhY2UgZXhpc3RpbmcgcGx1Z2luOiAke3BsdWdpbi5uYW1lfSBgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwbHVnaW5zLnNldChwbHVnaW4ubmFtZSwgcGx1Z2luLmNsb25lKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgcGx1Z2luLCBpZiBhbnksIG1hdGNoaW5nICUlbmFtZSUlIGV4YWN0bHkuIFBsdWdpbnNcbiAgICAgKiAgd2l0aCBmcmFnbWVudHMgd2lsbCBub3QgYmUgcmV0dXJuZWQgdW5sZXNzICUlbmFtZSUlIGluY2x1ZGVzXG4gICAgICogIGEgZnJhZ21lbnQuXG4gICAgICovXG4gICAgZ2V0UGx1Z2luKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNwbHVnaW5zLmdldChuYW1lKSkgfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldHMgYSBsaXN0IG9mIGFsbCBwbHVnaW5zIHRoYXQgbWF0Y2ggJSVuYW1lJSUsIHdpdGggb3RyIHdpdGhvdXRcbiAgICAgKiAgYSBmcmFnbWVudC5cbiAgICAgKi9cbiAgICBnZXRQbHVnaW5zKGJhc2VuYW1lKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5wbHVnaW5zLmZpbHRlcigocCkgPT4gKHAubmFtZS5zcGxpdChcIiNcIilbMF0gPT09IGJhc2VuYW1lKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgY29weSBvZiB0aGlzIE5ldHdvcmsuXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IGNsb25lID0gbmV3IE5ldHdvcmsodGhpcy5uYW1lLCB0aGlzLmNoYWluSWQpO1xuICAgICAgICB0aGlzLnBsdWdpbnMuZm9yRWFjaCgocGx1Z2luKSA9PiB7XG4gICAgICAgICAgICBjbG9uZS5hdHRhY2hQbHVnaW4ocGx1Z2luLmNsb25lKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ29tcHV0ZSB0aGUgaW50cmluc2ljIGdhcyByZXF1aXJlZCBmb3IgYSB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBBIEdhc0Nvc3RQbHVnaW4gY2FuIGJlIGF0dGFjaGVkIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0XG4gICAgICogIHZhbHVlcy5cbiAgICAgKi9cbiAgICBjb21wdXRlSW50cmluc2ljR2FzKHR4KSB7XG4gICAgICAgIGNvbnN0IGNvc3RzID0gdGhpcy5nZXRQbHVnaW4oXCJvcmcuZXRoZXJzLnBsdWdpbnMubmV0d29yay5HYXNDb3N0XCIpIHx8IChuZXcgR2FzQ29zdFBsdWdpbigpKTtcbiAgICAgICAgbGV0IGdhcyA9IGNvc3RzLnR4QmFzZTtcbiAgICAgICAgaWYgKHR4LnRvID09IG51bGwpIHtcbiAgICAgICAgICAgIGdhcyArPSBjb3N0cy50eENyZWF0ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguZGF0YSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPCB0eC5kYXRhLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR4LmRhdGEuc3Vic3RyaW5nKGksIGkgKyAyKSA9PT0gXCIwMFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGdhcyArPSBjb3N0cy50eERhdGFaZXJvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2FzICs9IGNvc3RzLnR4RGF0YU5vbnplcm87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5hY2Nlc3NMaXN0KSB7XG4gICAgICAgICAgICBjb25zdCBhY2Nlc3NMaXN0ID0gYWNjZXNzTGlzdGlmeSh0eC5hY2Nlc3NMaXN0KTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYWRkciBpbiBhY2Nlc3NMaXN0KSB7XG4gICAgICAgICAgICAgICAgZ2FzICs9IGNvc3RzLnR4QWNjZXNzTGlzdEFkZHJlc3MgKyBjb3N0cy50eEFjY2Vzc0xpc3RTdG9yYWdlS2V5ICogYWNjZXNzTGlzdFthZGRyXS5zdG9yYWdlS2V5cy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdhcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgTmV0d29yayBmb3IgdGhlICUlbmV0d29yayUlIG5hbWUgb3IgY2hhaW5JZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShuZXR3b3JrKSB7XG4gICAgICAgIGluamVjdENvbW1vbk5ldHdvcmtzKCk7XG4gICAgICAgIC8vIERlZmF1bHQgbmV0d29ya1xuICAgICAgICBpZiAobmV0d29yayA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTmV0d29yay5mcm9tKFwibWFpbm5ldFwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYW5vbmljYWwgbmFtZSBvciBjaGFpbiBJRFxuICAgICAgICBpZiAodHlwZW9mIChuZXR3b3JrKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgbmV0d29yayA9IEJpZ0ludChuZXR3b3JrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChuZXR3b3JrKSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgKG5ldHdvcmspID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrRnVuYyA9IE5ldHdvcmtzLmdldChuZXR3b3JrKTtcbiAgICAgICAgICAgIGlmIChuZXR3b3JrRnVuYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXR3b3JrRnVuYygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE5ldHdvcmsoXCJ1bmtub3duXCIsIG5ldHdvcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5rbm93biBuZXR3b3JrXCIsIFwibmV0d29ya1wiLCBuZXR3b3JrKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDbG9uYWJsZSB3aXRoIG5ldHdvcmstbGlrZSBhYmlsaXRpZXNcbiAgICAgICAgaWYgKHR5cGVvZiAobmV0d29yay5jbG9uZSkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgY2xvbmUgPSBuZXR3b3JrLmNsb25lKCk7XG4gICAgICAgICAgICAvL2lmICh0eXBlb2YobmV0d29yay5uYW1lKSAhPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YobmV0d29yay5jaGFpbklkKSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgLy99XG4gICAgICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTmV0d29ya2lzaFxuICAgICAgICBpZiAodHlwZW9mIChuZXR3b3JrKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChuZXR3b3JrLm5hbWUpID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiAobmV0d29yay5jaGFpbklkKSA9PT0gXCJudW1iZXJcIiwgXCJpbnZhbGlkIG5ldHdvcmsgb2JqZWN0IG5hbWUgb3IgY2hhaW5JZFwiLCBcIm5ldHdvcmtcIiwgbmV0d29yayk7XG4gICAgICAgICAgICBjb25zdCBjdXN0b20gPSBuZXcgTmV0d29yaygobmV0d29yay5uYW1lKSwgKG5ldHdvcmsuY2hhaW5JZCkpO1xuICAgICAgICAgICAgaWYgKG5ldHdvcmsuZW5zQWRkcmVzcyB8fCBuZXR3b3JrLmVuc05ldHdvcmsgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGN1c3RvbS5hdHRhY2hQbHVnaW4obmV3IEVuc1BsdWdpbihuZXR3b3JrLmVuc0FkZHJlc3MsIG5ldHdvcmsuZW5zTmV0d29yaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9pZiAoKDxhbnk+bmV0d29yaykubGF5ZXJPbmVDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAvLyAgICBjdXN0b20uYXR0YWNoUGx1Z2luKG5ldyBMYXllck9uZUNvbm5lY3Rpb25QbHVnaW4oKDxhbnk+bmV0d29yaykubGF5ZXJPbmVDb25uZWN0aW9uKSk7XG4gICAgICAgICAgICAvL31cbiAgICAgICAgICAgIHJldHVybiBjdXN0b207XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBuZXR3b3JrXCIsIFwibmV0d29ya1wiLCBuZXR3b3JrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlZ2lzdGVyICUlbmFtZU9yQ2hhaW5JZCUlIHdpdGggYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zXG4gICAgICogIGFuIGluc3RhbmNlIG9mIGEgTmV0d29yayByZXByZXNlbnRpbmcgdGhhdCBjaGFpbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgcmVnaXN0ZXIobmFtZU9yQ2hhaW5JZCwgbmV0d29ya0Z1bmMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAobmFtZU9yQ2hhaW5JZCkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIG5hbWVPckNoYWluSWQgPSBCaWdJbnQobmFtZU9yQ2hhaW5JZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBOZXR3b3Jrcy5nZXQobmFtZU9yQ2hhaW5JZCk7XG4gICAgICAgIGlmIChleGlzdGluZykge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBjb25mbGljdGluZyBuZXR3b3JrIGZvciAke0pTT04uc3RyaW5naWZ5KGV4aXN0aW5nLm5hbWUpfWAsIFwibmFtZU9yQ2hhaW5JZFwiLCBuYW1lT3JDaGFpbklkKTtcbiAgICAgICAgfVxuICAgICAgICBOZXR3b3Jrcy5zZXQobmFtZU9yQ2hhaW5JZCwgbmV0d29ya0Z1bmMpO1xuICAgIH1cbn1cbi8vIFdlIGRvbid0IHdhbnQgdG8gYnJpbmcgaW4gZm9ybWF0VW5pdHMgYmVjYXVzZSBpdCBpcyBiYWNrZWQgYnlcbi8vIEZpeGVkTnVtYmVyIGFuZCB3ZSB3YW50IHRvIGtlZXAgTmV0d29ya3MgdGlueS4gVGhlIHZhbHVlc1xuLy8gaW5jbHVkZWQgYnkgdGhlIEdhcyBTdGF0aW9ucyBhcmUgYWxzbyBJRUVFIDc1NCB3aXRoIGxvdHMgb2Zcbi8vIHJvdW5kaW5nIGlzc3VlcyBhbmQgZXhjZWVkIHRoZSBzdHJpY3QgY2hlY2tzIGZvcm1hdFVuaXRzIGhhcy5cbmZ1bmN0aW9uIHBhcnNlVW5pdHMoX3ZhbHVlLCBkZWNpbWFscykge1xuICAgIGNvbnN0IHZhbHVlID0gU3RyaW5nKF92YWx1ZSk7XG4gICAgaWYgKCF2YWx1ZS5tYXRjaCgvXlswLTkuXSskLykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGd3ZWkgdmFsdWU6ICR7X3ZhbHVlfWApO1xuICAgIH1cbiAgICAvLyBCcmVhayBpbnRvIFsgd2hvbGUsIGZyYWN0aW9uIF1cbiAgICBjb25zdCBjb21wcyA9IHZhbHVlLnNwbGl0KFwiLlwiKTtcbiAgICBpZiAoY29tcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbXBzLnB1c2goXCJcIik7XG4gICAgfVxuICAgIC8vIE1vcmUgdGhhbiAxIGRlY2ltYWwgcG9pbnQgb3IgdG9vIG1hbnkgZnJhY3Rpb25hbCBwb3NpdGlvbnNcbiAgICBpZiAoY29tcHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBnd2VpIHZhbHVlOiAke192YWx1ZX1gKTtcbiAgICB9XG4gICAgLy8gUGFkIHRoZSBmcmFjdGlvbiB0byA5IGRlY2ltYWxwbGFjZXNcbiAgICB3aGlsZSAoY29tcHNbMV0ubGVuZ3RoIDwgZGVjaW1hbHMpIHtcbiAgICAgICAgY29tcHNbMV0gKz0gXCIwXCI7XG4gICAgfVxuICAgIC8vIFRvbyBtYW55IGRlY2ltYWxzIGFuZCBzb21lIG5vbi16ZXJvIGVuZGluZywgdGFrZSB0aGUgY2VpbGluZ1xuICAgIGlmIChjb21wc1sxXS5sZW5ndGggPiA5KSB7XG4gICAgICAgIGxldCBmcmFjID0gQmlnSW50KGNvbXBzWzFdLnN1YnN0cmluZygwLCA5KSk7XG4gICAgICAgIGlmICghY29tcHNbMV0uc3Vic3RyaW5nKDkpLm1hdGNoKC9eMCskLykpIHtcbiAgICAgICAgICAgIGZyYWMrKztcbiAgICAgICAgfVxuICAgICAgICBjb21wc1sxXSA9IGZyYWMudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIEJpZ0ludChjb21wc1swXSArIGNvbXBzWzFdKTtcbn1cbi8vIFVzZWQgYnkgUG9seWdvbiB0byB1c2UgYSBnYXMgc3RhdGlvbiBmb3IgZmVlIGRhdGFcbmZ1bmN0aW9uIGdldEdhc1N0YXRpb25QbHVnaW4odXJsKSB7XG4gICAgcmV0dXJuIG5ldyBGZXRjaFVybEZlZURhdGFOZXR3b3JrUGx1Z2luKHVybCwgYXN5bmMgKGZldGNoRmVlRGF0YSwgcHJvdmlkZXIsIHJlcXVlc3QpID0+IHtcbiAgICAgICAgLy8gUHJldmVudCBDbG91ZGZsYXJlIGZyb20gYmxvY2tpbmcgb3VyIHJlcXVlc3QgaW4gbm9kZS5qc1xuICAgICAgICByZXF1ZXN0LnNldEhlYWRlcihcIlVzZXItQWdlbnRcIiwgXCJldGhlcnNcIik7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IFtfcmVzcG9uc2UsIF9mZWVEYXRhXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnNlbmQoKSwgZmV0Y2hGZWVEYXRhKClcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBfcmVzcG9uc2U7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gcmVzcG9uc2UuYm9keUpzb24uc3RhbmRhcmQ7XG4gICAgICAgICAgICBjb25zdCBmZWVEYXRhID0ge1xuICAgICAgICAgICAgICAgIGdhc1ByaWNlOiBfZmVlRGF0YS5nYXNQcmljZSxcbiAgICAgICAgICAgICAgICBtYXhGZWVQZXJHYXM6IHBhcnNlVW5pdHMocGF5bG9hZC5tYXhGZWUsIDkpLFxuICAgICAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBwYXJzZVVuaXRzKHBheWxvYWQubWF4UHJpb3JpdHlGZWUsIDkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBmZWVEYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBgZXJyb3IgZW5jb3VudGVyZWQgd2l0aCBwb2x5Z29uIGdhcyBzdGF0aW9uICgke0pTT04uc3RyaW5naWZ5KHJlcXVlc3QudXJsKX0pYCwgXCJTRVJWRVJfRVJST1JcIiwgeyByZXF1ZXN0LCByZXNwb25zZSwgZXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8vIFNlZTogaHR0cHM6Ly9jaGFpbmxpc3Qub3JnXG5sZXQgaW5qZWN0ZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGluamVjdENvbW1vbk5ldHdvcmtzKCkge1xuICAgIGlmIChpbmplY3RlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGluamVjdGVkID0gdHJ1ZTtcbiAgICAvLy8gUmVnaXN0ZXIgcG9wdWxhciBFdGhlcmV1bSBuZXR3b3Jrc1xuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyRXRoKG5hbWUsIGNoYWluSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ldHdvcmsgPSBuZXcgTmV0d29yayhuYW1lLCBjaGFpbklkKTtcbiAgICAgICAgICAgIC8vIFdlIHVzZSAwIHRvIGRpc2FibGUgRU5TXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5lbnNOZXR3b3JrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBuZXR3b3JrLmF0dGFjaFBsdWdpbihuZXcgRW5zUGx1Z2luKG51bGwsIG9wdGlvbnMuZW5zTmV0d29yaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV0d29yay5hdHRhY2hQbHVnaW4obmV3IEdhc0Nvc3RQbHVnaW4oKSk7XG4gICAgICAgICAgICAob3B0aW9ucy5wbHVnaW5zIHx8IFtdKS5mb3JFYWNoKChwbHVnaW4pID0+IHtcbiAgICAgICAgICAgICAgICBuZXR3b3JrLmF0dGFjaFBsdWdpbihwbHVnaW4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV0d29yaztcbiAgICAgICAgfTtcbiAgICAgICAgLy8gUmVnaXN0ZXIgdGhlIG5ldHdvcmsgYnkgbmFtZSBhbmQgY2hhaW4gSURcbiAgICAgICAgTmV0d29yay5yZWdpc3RlcihuYW1lLCBmdW5jKTtcbiAgICAgICAgTmV0d29yay5yZWdpc3RlcihjaGFpbklkLCBmdW5jKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuYWx0TmFtZXMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuYWx0TmFtZXMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIE5ldHdvcmsucmVnaXN0ZXIobmFtZSwgZnVuYyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWdpc3RlckV0aChcIm1haW5uZXRcIiwgMSwgeyBlbnNOZXR3b3JrOiAxLCBhbHROYW1lczogW1wiaG9tZXN0ZWFkXCJdIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwicm9wc3RlblwiLCAzLCB7IGVuc05ldHdvcms6IDMgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJyaW5rZWJ5XCIsIDQsIHsgZW5zTmV0d29yazogNCB9KTtcbiAgICByZWdpc3RlckV0aChcImdvZXJsaVwiLCA1LCB7IGVuc05ldHdvcms6IDUgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJrb3ZhblwiLCA0MiwgeyBlbnNOZXR3b3JrOiA0MiB9KTtcbiAgICByZWdpc3RlckV0aChcInNlcG9saWFcIiwgMTExNTUxMTEsIHsgZW5zTmV0d29yazogMTExNTUxMTEgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJob2xlc2t5XCIsIDE3MDAwLCB7IGVuc05ldHdvcms6IDE3MDAwIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwiY2xhc3NpY1wiLCA2MSwge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwiY2xhc3NpY0tvdHRpXCIsIDYsIHt9KTtcbiAgICByZWdpc3RlckV0aChcImFyYml0cnVtXCIsIDQyMTYxLCB7XG4gICAgICAgIGVuc05ldHdvcms6IDEsXG4gICAgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJhcmJpdHJ1bS1nb2VybGlcIiwgNDIxNjEzLCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJhcmJpdHJ1bS1zZXBvbGlhXCIsIDQyMTYxNCwge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwiYmFzZVwiLCA4NDUzLCB7IGVuc05ldHdvcms6IDEgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJiYXNlLWdvZXJsaVwiLCA4NDUzMSwge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwiYmFzZS1zZXBvbGlhXCIsIDg0NTMyLCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJibmJcIiwgNTYsIHsgZW5zTmV0d29yazogMSB9KTtcbiAgICByZWdpc3RlckV0aChcImJuYnRcIiwgOTcsIHt9KTtcbiAgICByZWdpc3RlckV0aChcImZpbGVjb2luXCIsIDMxNCwge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwiZmlsZWNvaW4tY2FsaWJyYXRpb25cIiwgMzE0MTU5LCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJsaW5lYVwiLCA1OTE0NCwgeyBlbnNOZXR3b3JrOiAxIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwibGluZWEtZ29lcmxpXCIsIDU5MTQwLCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJsaW5lYS1zZXBvbGlhXCIsIDU5MTQxLCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJtYXRpY1wiLCAxMzcsIHtcbiAgICAgICAgZW5zTmV0d29yazogMSxcbiAgICAgICAgcGx1Z2luczogW1xuICAgICAgICAgICAgZ2V0R2FzU3RhdGlvblBsdWdpbihcImh0dHBzOi9cXC9nYXNzdGF0aW9uLnBvbHlnb24udGVjaG5vbG9neS92MlwiKVxuICAgICAgICBdXG4gICAgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJtYXRpYy1hbW95XCIsIDgwMDAyLCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJtYXRpYy1tdW1iYWlcIiwgODAwMDEsIHtcbiAgICAgICAgYWx0TmFtZXM6IFtcIm1hdGljTXVtYmFpXCIsIFwibWF0aWNtdW1cIl0sXG4gICAgICAgIHBsdWdpbnM6IFtcbiAgICAgICAgICAgIGdldEdhc1N0YXRpb25QbHVnaW4oXCJodHRwczovXFwvZ2Fzc3RhdGlvbi10ZXN0bmV0LnBvbHlnb24udGVjaG5vbG9neS92MlwiKVxuICAgICAgICBdXG4gICAgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJvcHRpbWlzbVwiLCAxMCwge1xuICAgICAgICBlbnNOZXR3b3JrOiAxLFxuICAgICAgICBwbHVnaW5zOiBbXVxuICAgIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwib3B0aW1pc20tZ29lcmxpXCIsIDQyMCwge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwib3B0aW1pc20tc2Vwb2xpYVwiLCAxMTE1NTQyMCwge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwieGRhaVwiLCAxMDAsIHsgZW5zTmV0d29yazogMSB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5ldHdvcmsuanMubWFwIl0sIm5hbWVzIjpbImFjY2Vzc0xpc3RpZnkiLCJnZXRCaWdJbnQiLCJhc3NlcnQiLCJhc3NlcnRBcmd1bWVudCIsIkVuc1BsdWdpbiIsIkZldGNoVXJsRmVlRGF0YU5ldHdvcmtQbHVnaW4iLCJHYXNDb3N0UGx1Z2luIiwiTmV0d29ya3MiLCJNYXAiLCJOZXR3b3JrIiwidG9KU09OIiwibmFtZSIsImNoYWluSWQiLCJTdHJpbmciLCJ2YWx1ZSIsIm1hdGNoZXMiLCJvdGhlciIsImVycm9yIiwicGx1Z2lucyIsIkFycmF5IiwiZnJvbSIsInZhbHVlcyIsImF0dGFjaFBsdWdpbiIsInBsdWdpbiIsImdldCIsIkVycm9yIiwic2V0IiwiY2xvbmUiLCJnZXRQbHVnaW4iLCJnZXRQbHVnaW5zIiwiYmFzZW5hbWUiLCJmaWx0ZXIiLCJwIiwic3BsaXQiLCJmb3JFYWNoIiwiY29tcHV0ZUludHJpbnNpY0dhcyIsInR4IiwiY29zdHMiLCJnYXMiLCJ0eEJhc2UiLCJ0byIsInR4Q3JlYXRlIiwiZGF0YSIsImkiLCJsZW5ndGgiLCJzdWJzdHJpbmciLCJ0eERhdGFaZXJvIiwidHhEYXRhTm9uemVybyIsImFjY2Vzc0xpc3QiLCJhZGRyIiwidHhBY2Nlc3NMaXN0QWRkcmVzcyIsInR4QWNjZXNzTGlzdFN0b3JhZ2VLZXkiLCJzdG9yYWdlS2V5cyIsIm5ldHdvcmsiLCJpbmplY3RDb21tb25OZXR3b3JrcyIsIkJpZ0ludCIsIm5ldHdvcmtGdW5jIiwiY3VzdG9tIiwiZW5zQWRkcmVzcyIsImVuc05ldHdvcmsiLCJyZWdpc3RlciIsIm5hbWVPckNoYWluSWQiLCJleGlzdGluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJjb25zdHJ1Y3RvciIsInBhcnNlVW5pdHMiLCJfdmFsdWUiLCJkZWNpbWFscyIsIm1hdGNoIiwiY29tcHMiLCJwdXNoIiwiZnJhYyIsInRvU3RyaW5nIiwiZ2V0R2FzU3RhdGlvblBsdWdpbiIsInVybCIsImZldGNoRmVlRGF0YSIsInByb3ZpZGVyIiwicmVxdWVzdCIsInNldEhlYWRlciIsInJlc3BvbnNlIiwiX3Jlc3BvbnNlIiwiX2ZlZURhdGEiLCJQcm9taXNlIiwiYWxsIiwic2VuZCIsInBheWxvYWQiLCJib2R5SnNvbiIsInN0YW5kYXJkIiwiZmVlRGF0YSIsImdhc1ByaWNlIiwibWF4RmVlUGVyR2FzIiwibWF4RmVlIiwibWF4UHJpb3JpdHlGZWVQZXJHYXMiLCJtYXhQcmlvcml0eUZlZSIsImluamVjdGVkIiwicmVnaXN0ZXJFdGgiLCJvcHRpb25zIiwiZnVuYyIsImFsdE5hbWVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/providers/network.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/providers/plugins-network.js":
/*!******************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/plugins-network.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EnsPlugin: function() { return /* binding */ EnsPlugin; },\n/* harmony export */   FeeDataNetworkPlugin: function() { return /* binding */ FeeDataNetworkPlugin; },\n/* harmony export */   FetchUrlFeeDataNetworkPlugin: function() { return /* binding */ FetchUrlFeeDataNetworkPlugin; },\n/* harmony export */   GasCostPlugin: function() { return /* binding */ GasCostPlugin; },\n/* harmony export */   NetworkPlugin: function() { return /* binding */ NetworkPlugin; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_get */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_get.js\");\n/* harmony import */ var _swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_init */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_init.js\");\n/* harmony import */ var _swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_set */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_set.js\");\n/* harmony import */ var _utils_properties_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/properties.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n\n\n\n\n\nconst EnsAddress = \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\";\n/**\n *  A **NetworkPlugin** provides additional functionality on a [[Network]].\n */ class NetworkPlugin {\n    /**\n     *  Creates a copy of this plugin.\n     */ clone() {\n        return new NetworkPlugin(this.name);\n    }\n    /**\n     *  Creates a new **NetworkPlugin**.\n     */ constructor(name){\n        (0,_utils_properties_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            name\n        });\n    }\n}\n/**\n *  A **GasCostPlugin** allows a network to provide alternative values when\n *  computing the intrinsic gas required for a transaction.\n */ class GasCostPlugin extends NetworkPlugin {\n    clone() {\n        return new GasCostPlugin(this.effectiveBlock, this);\n    }\n    /**\n     *  Creates a new GasCostPlugin from %%effectiveBlock%% until the\n     *  latest block or another GasCostPlugin supercedes that block number,\n     *  with the associated %%costs%%.\n     */ constructor(effectiveBlock, costs){\n        if (effectiveBlock == null) {\n            effectiveBlock = 0;\n        }\n        super(\"org.ethers.network.plugins.GasCost#\".concat(effectiveBlock || 0));\n        const props = {\n            effectiveBlock\n        };\n        function set(name, nullish) {\n            let value = (costs || {})[name];\n            if (value == null) {\n                value = nullish;\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(typeof value === \"number\", \"invalud value for \".concat(name), \"costs\", costs);\n            props[name] = value;\n        }\n        set(\"txBase\", 21000);\n        set(\"txCreate\", 32000);\n        set(\"txDataZero\", 4);\n        set(\"txDataNonzero\", 16);\n        set(\"txAccessListStorageKey\", 1900);\n        set(\"txAccessListAddress\", 2400);\n        (0,_utils_properties_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, props);\n    }\n}\n/**\n *  An **EnsPlugin** allows a [[Network]] to specify the ENS Registry\n *  Contract address and the target network to use when using that\n *  contract.\n *\n *  Various testnets have their own instance of the contract to use, but\n *  in general, the mainnet instance supports multi-chain addresses and\n *  should be used.\n */ class EnsPlugin extends NetworkPlugin {\n    clone() {\n        return new EnsPlugin(this.address, this.targetNetwork);\n    }\n    /**\n     *  Creates a new **EnsPlugin** connected to %%address%% on the\n     *  %%targetNetwork%%. The default ENS address and mainnet is used\n     *  if unspecified.\n     */ constructor(address, targetNetwork){\n        super(\"org.ethers.plugins.network.Ens\");\n        (0,_utils_properties_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            address: address || EnsAddress,\n            targetNetwork: targetNetwork == null ? 1 : targetNetwork\n        });\n    }\n}\nvar _feeDataFunc = /*#__PURE__*/ new WeakMap();\n/**\n *  A **FeeDataNetworkPlugin** allows a network to provide and alternate\n *  means to specify its fee data.\n *\n *  For example, a network which does not support [[link-eip-1559]] may\n *  choose to use a Gas Station site to approximate the gas price.\n */ class FeeDataNetworkPlugin extends NetworkPlugin {\n    /**\n     *  The fee data function provided to the constructor.\n     */ get feeDataFunc() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _feeDataFunc);\n    }\n    /**\n     *  Resolves to the fee data.\n     */ async getFeeData(provider) {\n        return await (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _feeDataFunc).call(this, provider);\n    }\n    clone() {\n        return new FeeDataNetworkPlugin((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _feeDataFunc));\n    }\n    /**\n     *  Creates a new **FeeDataNetworkPlugin**.\n     */ constructor(feeDataFunc){\n        super(\"org.ethers.plugins.network.FeeData\");\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_3__._)(this, _feeDataFunc, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_4__._)(this, _feeDataFunc, feeDataFunc);\n    }\n}\nvar _url = /*#__PURE__*/ new WeakMap(), _processFunc = /*#__PURE__*/ new WeakMap();\nclass FetchUrlFeeDataNetworkPlugin extends NetworkPlugin {\n    /**\n     *  The URL to initialize the FetchRequest with in %%processFunc%%.\n     */ get url() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _url);\n    }\n    /**\n     *  The callback to use when computing the FeeData.\n     */ get processFunc() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _processFunc);\n    }\n    // We are immutable, so we can serve as our own clone\n    clone() {\n        return this;\n    }\n    /**\n     *  Creates a new **FetchUrlFeeDataNetworkPlugin** which will\n     *  be used when computing the fee data for the network.\n     */ constructor(url, processFunc){\n        super(\"org.ethers.plugins.network.FetchUrlFeeDataPlugin\");\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_3__._)(this, _url, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_3__._)(this, _processFunc, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_4__._)(this, _url, url);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_4__._)(this, _processFunc, processFunc);\n    }\n} /*\nexport class CustomBlockNetworkPlugin extends NetworkPlugin {\n    readonly #blockFunc: (provider: Provider, block: BlockParams<string>) => Block<string>;\n    readonly #blockWithTxsFunc: (provider: Provider, block: BlockParams<TransactionResponseParams>) => Block<TransactionResponse>;\n\n    constructor(blockFunc: (provider: Provider, block: BlockParams<string>) => Block<string>, blockWithTxsFunc: (provider: Provider, block: BlockParams<TransactionResponseParams>) => Block<TransactionResponse>) {\n        super(\"org.ethers.network-plugins.custom-block\");\n        this.#blockFunc = blockFunc;\n        this.#blockWithTxsFunc = blockWithTxsFunc;\n    }\n\n    async getBlock(provider: Provider, block: BlockParams<string>): Promise<Block<string>> {\n        return await this.#blockFunc(provider, block);\n    }\n\n    async getBlockions(provider: Provider, block: BlockParams<TransactionResponseParams>): Promise<Block<TransactionResponse>> {\n        return await this.#blockWithTxsFunc(provider, block);\n    }\n\n    clone(): CustomBlockNetworkPlugin {\n        return new CustomBlockNetworkPlugin(this.#blockFunc, this.#blockWithTxsFunc);\n    }\n}\n*/  //# sourceMappingURL=plugins-network.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcGx1Z2lucy1uZXR3b3JrLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEQ7QUFDUDtBQUNuRCxNQUFNRSxhQUFhO0FBQ25COztDQUVDLEdBQ00sTUFBTUM7SUFjVDs7S0FFQyxHQUNEQyxRQUFRO1FBQ0osT0FBTyxJQUFJRCxjQUFjLElBQUksQ0FBQ0UsSUFBSTtJQUN0QztJQVhBOztLQUVDLEdBQ0RDLFlBQVlELElBQUksQ0FBRTtRQUNkTCxzRUFBZ0JBLENBQUMsSUFBSSxFQUFFO1lBQUVLO1FBQUs7SUFDbEM7QUFPSjtBQUNBOzs7Q0FHQyxHQUNNLE1BQU1FLHNCQUFzQko7SUEyRC9CQyxRQUFRO1FBQ0osT0FBTyxJQUFJRyxjQUFjLElBQUksQ0FBQ0MsY0FBYyxFQUFFLElBQUk7SUFDdEQ7SUE3QkE7Ozs7S0FJQyxHQUNERixZQUFZRSxjQUFjLEVBQUVDLEtBQUssQ0FBRTtRQUMvQixJQUFJRCxrQkFBa0IsTUFBTTtZQUN4QkEsaUJBQWlCO1FBQ3JCO1FBQ0EsS0FBSyxDQUFDLHNDQUE0RCxPQUFyQkEsa0JBQWtCO1FBQy9ELE1BQU1FLFFBQVE7WUFBRUY7UUFBZTtRQUMvQixTQUFTRyxJQUFJTixJQUFJLEVBQUVPLE9BQU87WUFDdEIsSUFBSUMsUUFBUSxDQUFDSixTQUFTLENBQUMsRUFBRSxDQUFDSixLQUFLO1lBQy9CLElBQUlRLFNBQVMsTUFBTTtnQkFDZkEsUUFBUUQ7WUFDWjtZQUNBWCwrREFBY0EsQ0FBQyxPQUFRWSxVQUFXLFVBQVUscUJBQTBCLE9BQUxSLE9BQVEsU0FBU0k7WUFDbEZDLEtBQUssQ0FBQ0wsS0FBSyxHQUFHUTtRQUNsQjtRQUNBRixJQUFJLFVBQVU7UUFDZEEsSUFBSSxZQUFZO1FBQ2hCQSxJQUFJLGNBQWM7UUFDbEJBLElBQUksaUJBQWlCO1FBQ3JCQSxJQUFJLDBCQUEwQjtRQUM5QkEsSUFBSSx1QkFBdUI7UUFDM0JYLHNFQUFnQkEsQ0FBQyxJQUFJLEVBQUVVO0lBQzNCO0FBSUo7QUFDQTs7Ozs7Ozs7Q0FRQyxHQUNNLE1BQU1JLGtCQUFrQlg7SUFxQjNCQyxRQUFRO1FBQ0osT0FBTyxJQUFJVSxVQUFVLElBQUksQ0FBQ0MsT0FBTyxFQUFFLElBQUksQ0FBQ0MsYUFBYTtJQUN6RDtJQWRBOzs7O0tBSUMsR0FDRFYsWUFBWVMsT0FBTyxFQUFFQyxhQUFhLENBQUU7UUFDaEMsS0FBSyxDQUFDO1FBQ05oQixzRUFBZ0JBLENBQUMsSUFBSSxFQUFFO1lBQ25CZSxTQUFVQSxXQUFXYjtZQUNyQmMsZUFBZ0IsaUJBQWtCLE9BQVEsSUFBSUE7UUFDbEQ7SUFDSjtBQUlKO0lBU0k7QUFSSjs7Ozs7O0NBTUMsR0FDTSxNQUFNQyw2QkFBNkJkO0lBRXRDOztLQUVDLEdBQ0QsSUFBSWUsY0FBYztRQUNkLE9BQU8sNEVBQUksRUFBRUE7SUFDakI7SUFRQTs7S0FFQyxHQUNELE1BQU1DLFdBQVdDLFFBQVEsRUFBRTtRQUN2QixPQUFPLE1BQU0sNEVBQUksRUFBRUYsbUJBQU4sSUFBSSxFQUFjRTtJQUNuQztJQUNBaEIsUUFBUTtRQUNKLE9BQU8sSUFBSWEscUJBQXFCQSx1RUFBQUEsQ0FBQSxJQUFJLEVBQUVDO0lBQzFDO0lBZkE7O0tBRUMsR0FDRFosWUFBWVksV0FBVyxDQUFFO1FBQ3JCLEtBQUssQ0FBQztRQVhWOzttQkFBQTs7c0ZBWVVBLGNBQWNBO0lBQ3hCO0FBVUo7SUFFSSxvQ0FDQTtBQUZHLE1BQU1HLHFDQUFxQ2xCO0lBRzlDOztLQUVDLEdBQ0QsSUFBSW1CLE1BQU07UUFBRSxPQUFPLDRFQUFJLEVBQUVBO0lBQUs7SUFDOUI7O0tBRUMsR0FDRCxJQUFJQyxjQUFjO1FBQUUsT0FBTyw0RUFBSSxFQUFFQTtJQUFhO0lBVTlDLHFEQUFxRDtJQUNyRG5CLFFBQVE7UUFBRSxPQUFPLElBQUk7SUFBRTtJQVZ2Qjs7O0tBR0MsR0FDREUsWUFBWWdCLEdBQUcsRUFBRUMsV0FBVyxDQUFFO1FBQzFCLEtBQUssQ0FBQztRQWZWOzttQkFBQTs7UUFDQTs7bUJBQUE7O3NGQWVVRCxNQUFNQTtzRkFDTkMsY0FBY0E7SUFDeEI7QUFHSixFQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVCQSxJQUNBLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3BsdWdpbnMtbmV0d29yay5qcz80MTI5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMgfSBmcm9tIFwiLi4vdXRpbHMvcHJvcGVydGllcy5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmNvbnN0IEVuc0FkZHJlc3MgPSBcIjB4MDAwMDAwMDAwMDBDMkUwNzRlQzY5QTBkRmIyOTk3QkE2QzdkMmUxZVwiO1xuLyoqXG4gKiAgQSAqKk5ldHdvcmtQbHVnaW4qKiBwcm92aWRlcyBhZGRpdGlvbmFsIGZ1bmN0aW9uYWxpdHkgb24gYSBbW05ldHdvcmtdXS5cbiAqL1xuZXhwb3J0IGNsYXNzIE5ldHdvcmtQbHVnaW4ge1xuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luLlxuICAgICAqXG4gICAgICogIEl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSByZXZlcnNlLWRvbWFpbi1ub3RhdGlvbiwgd2hpY2ggcGVybWl0c1xuICAgICAqICB1bmlxdWUgbmFtZXMgd2l0aCBhIGtub3duIGF1dGhvcml0eSBhcyB3ZWxsIGFzIGhpZXJhcmNoYWwgZW50cmllcy5cbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqTmV0d29ya1BsdWdpbioqLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IG5hbWUgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgY29weSBvZiB0aGlzIHBsdWdpbi5cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOZXR3b3JrUGx1Z2luKHRoaXMubmFtZSk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSAqKkdhc0Nvc3RQbHVnaW4qKiBhbGxvd3MgYSBuZXR3b3JrIHRvIHByb3ZpZGUgYWx0ZXJuYXRpdmUgdmFsdWVzIHdoZW5cbiAqICBjb21wdXRpbmcgdGhlIGludHJpbnNpYyBnYXMgcmVxdWlyZWQgZm9yIGEgdHJhbnNhY3Rpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBHYXNDb3N0UGx1Z2luIGV4dGVuZHMgTmV0d29ya1BsdWdpbiB7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBudW1iZXIgdG8gdHJlYXQgdGhlc2UgdmFsdWVzIGFzIHZhbGlkIGZyb20uXG4gICAgICpcbiAgICAgKiAgVGhpcyBhbGxvd3MgYSBoYXJkZm9yayB0byBoYXZlIHVwZGF0ZWQgdmFsdWVzIGluY2x1ZGVkIGFzIHdlbGwgYXNcbiAgICAgKiAgbXVsdXRpcGxlIGhhcmRmb3JrcyB0byBiZSBzdXBwb3J0ZWQuXG4gICAgICovXG4gICAgZWZmZWN0aXZlQmxvY2s7XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbnMgYmFzZSBmZWUuXG4gICAgICovXG4gICAgdHhCYXNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmVlIGZvciBjcmVhdGluZyBhIG5ldyBhY2NvdW50LlxuICAgICAqL1xuICAgIHR4Q3JlYXRlO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmVlIHBlciB6ZXJvLWJ5dGUgaW4gdGhlIGRhdGEuXG4gICAgICovXG4gICAgdHhEYXRhWmVybztcbiAgICAvKipcbiAgICAgKiAgVGhlIGZlZSBwZXIgbm9uLXplcm8tYnl0ZSBpbiB0aGUgZGF0YS5cbiAgICAgKi9cbiAgICB0eERhdGFOb256ZXJvO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmVlIHBlciBzdG9yYWdlIGtleSBpbiB0aGUgW1tsaW5rLWVpcC0yOTMwXV0gYWNjZXNzIGxpc3QuXG4gICAgICovXG4gICAgdHhBY2Nlc3NMaXN0U3RvcmFnZUtleTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGZlZSBwZXIgYWRkcmVzcyBpbiB0aGUgW1tsaW5rLWVpcC0yOTMwXV0gYWNjZXNzIGxpc3QuXG4gICAgICovXG4gICAgdHhBY2Nlc3NMaXN0QWRkcmVzcztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBHYXNDb3N0UGx1Z2luIGZyb20gJSVlZmZlY3RpdmVCbG9jayUlIHVudGlsIHRoZVxuICAgICAqICBsYXRlc3QgYmxvY2sgb3IgYW5vdGhlciBHYXNDb3N0UGx1Z2luIHN1cGVyY2VkZXMgdGhhdCBibG9jayBudW1iZXIsXG4gICAgICogIHdpdGggdGhlIGFzc29jaWF0ZWQgJSVjb3N0cyUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVmZmVjdGl2ZUJsb2NrLCBjb3N0cykge1xuICAgICAgICBpZiAoZWZmZWN0aXZlQmxvY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgZWZmZWN0aXZlQmxvY2sgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGBvcmcuZXRoZXJzLm5ldHdvcmsucGx1Z2lucy5HYXNDb3N0IyR7KGVmZmVjdGl2ZUJsb2NrIHx8IDApfWApO1xuICAgICAgICBjb25zdCBwcm9wcyA9IHsgZWZmZWN0aXZlQmxvY2sgfTtcbiAgICAgICAgZnVuY3Rpb24gc2V0KG5hbWUsIG51bGxpc2gpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IChjb3N0cyB8fCB7fSlbbmFtZV07XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbGlzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiLCBgaW52YWx1ZCB2YWx1ZSBmb3IgJHtuYW1lfWAsIFwiY29zdHNcIiwgY29zdHMpO1xuICAgICAgICAgICAgcHJvcHNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBzZXQoXCJ0eEJhc2VcIiwgMjEwMDApO1xuICAgICAgICBzZXQoXCJ0eENyZWF0ZVwiLCAzMjAwMCk7XG4gICAgICAgIHNldChcInR4RGF0YVplcm9cIiwgNCk7XG4gICAgICAgIHNldChcInR4RGF0YU5vbnplcm9cIiwgMTYpO1xuICAgICAgICBzZXQoXCJ0eEFjY2Vzc0xpc3RTdG9yYWdlS2V5XCIsIDE5MDApO1xuICAgICAgICBzZXQoXCJ0eEFjY2Vzc0xpc3RBZGRyZXNzXCIsIDI0MDApO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHByb3BzKTtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgR2FzQ29zdFBsdWdpbih0aGlzLmVmZmVjdGl2ZUJsb2NrLCB0aGlzKTtcbiAgICB9XG59XG4vKipcbiAqICBBbiAqKkVuc1BsdWdpbioqIGFsbG93cyBhIFtbTmV0d29ya11dIHRvIHNwZWNpZnkgdGhlIEVOUyBSZWdpc3RyeVxuICogIENvbnRyYWN0IGFkZHJlc3MgYW5kIHRoZSB0YXJnZXQgbmV0d29yayB0byB1c2Ugd2hlbiB1c2luZyB0aGF0XG4gKiAgY29udHJhY3QuXG4gKlxuICogIFZhcmlvdXMgdGVzdG5ldHMgaGF2ZSB0aGVpciBvd24gaW5zdGFuY2Ugb2YgdGhlIGNvbnRyYWN0IHRvIHVzZSwgYnV0XG4gKiAgaW4gZ2VuZXJhbCwgdGhlIG1haW5uZXQgaW5zdGFuY2Ugc3VwcG9ydHMgbXVsdGktY2hhaW4gYWRkcmVzc2VzIGFuZFxuICogIHNob3VsZCBiZSB1c2VkLlxuICovXG5leHBvcnQgY2xhc3MgRW5zUGx1Z2luIGV4dGVuZHMgTmV0d29ya1BsdWdpbiB7XG4gICAgLyoqXG4gICAgICogIFRoZSBFTlMgUmVnaXN0cnR5IENvbnRyYWN0IGFkZHJlc3MuXG4gICAgICovXG4gICAgYWRkcmVzcztcbiAgICAvKipcbiAgICAgKiAgVGhlIGNoYWluIElEIHRoYXQgdGhlIEVOUyBjb250cmFjdCBsaXZlcyBvbi5cbiAgICAgKi9cbiAgICB0YXJnZXROZXR3b3JrO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqRW5zUGx1Z2luKiogY29ubmVjdGVkIHRvICUlYWRkcmVzcyUlIG9uIHRoZVxuICAgICAqICAlJXRhcmdldE5ldHdvcmslJS4gVGhlIGRlZmF1bHQgRU5TIGFkZHJlc3MgYW5kIG1haW5uZXQgaXMgdXNlZFxuICAgICAqICBpZiB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhZGRyZXNzLCB0YXJnZXROZXR3b3JrKSB7XG4gICAgICAgIHN1cGVyKFwib3JnLmV0aGVycy5wbHVnaW5zLm5ldHdvcmsuRW5zXCIpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIGFkZHJlc3M6IChhZGRyZXNzIHx8IEVuc0FkZHJlc3MpLFxuICAgICAgICAgICAgdGFyZ2V0TmV0d29yazogKCh0YXJnZXROZXR3b3JrID09IG51bGwpID8gMSA6IHRhcmdldE5ldHdvcmspXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFbnNQbHVnaW4odGhpcy5hZGRyZXNzLCB0aGlzLnRhcmdldE5ldHdvcmspO1xuICAgIH1cbn1cbi8qKlxuICogIEEgKipGZWVEYXRhTmV0d29ya1BsdWdpbioqIGFsbG93cyBhIG5ldHdvcmsgdG8gcHJvdmlkZSBhbmQgYWx0ZXJuYXRlXG4gKiAgbWVhbnMgdG8gc3BlY2lmeSBpdHMgZmVlIGRhdGEuXG4gKlxuICogIEZvciBleGFtcGxlLCBhIG5ldHdvcmsgd2hpY2ggZG9lcyBub3Qgc3VwcG9ydCBbW2xpbmstZWlwLTE1NTldXSBtYXlcbiAqICBjaG9vc2UgdG8gdXNlIGEgR2FzIFN0YXRpb24gc2l0ZSB0byBhcHByb3hpbWF0ZSB0aGUgZ2FzIHByaWNlLlxuICovXG5leHBvcnQgY2xhc3MgRmVlRGF0YU5ldHdvcmtQbHVnaW4gZXh0ZW5kcyBOZXR3b3JrUGx1Z2luIHtcbiAgICAjZmVlRGF0YUZ1bmM7XG4gICAgLyoqXG4gICAgICogIFRoZSBmZWUgZGF0YSBmdW5jdGlvbiBwcm92aWRlZCB0byB0aGUgY29uc3RydWN0b3IuXG4gICAgICovXG4gICAgZ2V0IGZlZURhdGFGdW5jKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZmVlRGF0YUZ1bmM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqRmVlRGF0YU5ldHdvcmtQbHVnaW4qKi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihmZWVEYXRhRnVuYykge1xuICAgICAgICBzdXBlcihcIm9yZy5ldGhlcnMucGx1Z2lucy5uZXR3b3JrLkZlZURhdGFcIik7XG4gICAgICAgIHRoaXMuI2ZlZURhdGFGdW5jID0gZmVlRGF0YUZ1bmM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgZmVlIGRhdGEuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0RmVlRGF0YShwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jZmVlRGF0YUZ1bmMocHJvdmlkZXIpO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGZWVEYXRhTmV0d29ya1BsdWdpbih0aGlzLiNmZWVEYXRhRnVuYyk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEZldGNoVXJsRmVlRGF0YU5ldHdvcmtQbHVnaW4gZXh0ZW5kcyBOZXR3b3JrUGx1Z2luIHtcbiAgICAjdXJsO1xuICAgICNwcm9jZXNzRnVuYztcbiAgICAvKipcbiAgICAgKiAgVGhlIFVSTCB0byBpbml0aWFsaXplIHRoZSBGZXRjaFJlcXVlc3Qgd2l0aCBpbiAlJXByb2Nlc3NGdW5jJSUuXG4gICAgICovXG4gICAgZ2V0IHVybCgpIHsgcmV0dXJuIHRoaXMuI3VybDsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgY2FsbGJhY2sgdG8gdXNlIHdoZW4gY29tcHV0aW5nIHRoZSBGZWVEYXRhLlxuICAgICAqL1xuICAgIGdldCBwcm9jZXNzRnVuYygpIHsgcmV0dXJuIHRoaXMuI3Byb2Nlc3NGdW5jOyB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipGZXRjaFVybEZlZURhdGFOZXR3b3JrUGx1Z2luKiogd2hpY2ggd2lsbFxuICAgICAqICBiZSB1c2VkIHdoZW4gY29tcHV0aW5nIHRoZSBmZWUgZGF0YSBmb3IgdGhlIG5ldHdvcmsuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodXJsLCBwcm9jZXNzRnVuYykge1xuICAgICAgICBzdXBlcihcIm9yZy5ldGhlcnMucGx1Z2lucy5uZXR3b3JrLkZldGNoVXJsRmVlRGF0YVBsdWdpblwiKTtcbiAgICAgICAgdGhpcy4jdXJsID0gdXJsO1xuICAgICAgICB0aGlzLiNwcm9jZXNzRnVuYyA9IHByb2Nlc3NGdW5jO1xuICAgIH1cbiAgICAvLyBXZSBhcmUgaW1tdXRhYmxlLCBzbyB3ZSBjYW4gc2VydmUgYXMgb3VyIG93biBjbG9uZVxuICAgIGNsb25lKCkgeyByZXR1cm4gdGhpczsgfVxufVxuLypcbmV4cG9ydCBjbGFzcyBDdXN0b21CbG9ja05ldHdvcmtQbHVnaW4gZXh0ZW5kcyBOZXR3b3JrUGx1Z2luIHtcbiAgICByZWFkb25seSAjYmxvY2tGdW5jOiAocHJvdmlkZXI6IFByb3ZpZGVyLCBibG9jazogQmxvY2tQYXJhbXM8c3RyaW5nPikgPT4gQmxvY2s8c3RyaW5nPjtcbiAgICByZWFkb25seSAjYmxvY2tXaXRoVHhzRnVuYzogKHByb3ZpZGVyOiBQcm92aWRlciwgYmxvY2s6IEJsb2NrUGFyYW1zPFRyYW5zYWN0aW9uUmVzcG9uc2VQYXJhbXM+KSA9PiBCbG9jazxUcmFuc2FjdGlvblJlc3BvbnNlPjtcblxuICAgIGNvbnN0cnVjdG9yKGJsb2NrRnVuYzogKHByb3ZpZGVyOiBQcm92aWRlciwgYmxvY2s6IEJsb2NrUGFyYW1zPHN0cmluZz4pID0+IEJsb2NrPHN0cmluZz4sIGJsb2NrV2l0aFR4c0Z1bmM6IChwcm92aWRlcjogUHJvdmlkZXIsIGJsb2NrOiBCbG9ja1BhcmFtczxUcmFuc2FjdGlvblJlc3BvbnNlUGFyYW1zPikgPT4gQmxvY2s8VHJhbnNhY3Rpb25SZXNwb25zZT4pIHtcbiAgICAgICAgc3VwZXIoXCJvcmcuZXRoZXJzLm5ldHdvcmstcGx1Z2lucy5jdXN0b20tYmxvY2tcIik7XG4gICAgICAgIHRoaXMuI2Jsb2NrRnVuYyA9IGJsb2NrRnVuYztcbiAgICAgICAgdGhpcy4jYmxvY2tXaXRoVHhzRnVuYyA9IGJsb2NrV2l0aFR4c0Z1bmM7XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0QmxvY2socHJvdmlkZXI6IFByb3ZpZGVyLCBibG9jazogQmxvY2tQYXJhbXM8c3RyaW5nPik6IFByb21pc2U8QmxvY2s8c3RyaW5nPj4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jYmxvY2tGdW5jKHByb3ZpZGVyLCBibG9jayk7XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0QmxvY2tpb25zKHByb3ZpZGVyOiBQcm92aWRlciwgYmxvY2s6IEJsb2NrUGFyYW1zPFRyYW5zYWN0aW9uUmVzcG9uc2VQYXJhbXM+KTogUHJvbWlzZTxCbG9jazxUcmFuc2FjdGlvblJlc3BvbnNlPj4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jYmxvY2tXaXRoVHhzRnVuYyhwcm92aWRlciwgYmxvY2spO1xuICAgIH1cblxuICAgIGNsb25lKCk6IEN1c3RvbUJsb2NrTmV0d29ya1BsdWdpbiB7XG4gICAgICAgIHJldHVybiBuZXcgQ3VzdG9tQmxvY2tOZXR3b3JrUGx1Z2luKHRoaXMuI2Jsb2NrRnVuYywgdGhpcy4jYmxvY2tXaXRoVHhzRnVuYyk7XG4gICAgfVxufVxuKi9cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBsdWdpbnMtbmV0d29yay5qcy5tYXAiXSwibmFtZXMiOlsiZGVmaW5lUHJvcGVydGllcyIsImFzc2VydEFyZ3VtZW50IiwiRW5zQWRkcmVzcyIsIk5ldHdvcmtQbHVnaW4iLCJjbG9uZSIsIm5hbWUiLCJjb25zdHJ1Y3RvciIsIkdhc0Nvc3RQbHVnaW4iLCJlZmZlY3RpdmVCbG9jayIsImNvc3RzIiwicHJvcHMiLCJzZXQiLCJudWxsaXNoIiwidmFsdWUiLCJFbnNQbHVnaW4iLCJhZGRyZXNzIiwidGFyZ2V0TmV0d29yayIsIkZlZURhdGFOZXR3b3JrUGx1Z2luIiwiZmVlRGF0YUZ1bmMiLCJnZXRGZWVEYXRhIiwicHJvdmlkZXIiLCJGZXRjaFVybEZlZURhdGFOZXR3b3JrUGx1Z2luIiwidXJsIiwicHJvY2Vzc0Z1bmMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/providers/plugins-network.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/providers/provider-browser.js":
/*!*******************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/provider-browser.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BrowserProvider: function() { return /* binding */ BrowserProvider; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_get */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_get.js\");\n/* harmony import */ var _swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_init */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_init.js\");\n/* harmony import */ var _swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_set */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_set.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./provider-jsonrpc.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n\n\n\n\n\n;\nvar _request = /*#__PURE__*/ new WeakMap(), _providerInfo = /*#__PURE__*/ new WeakMap();\n/**\n *  A **BrowserProvider** is intended to wrap an injected provider which\n *  adheres to the [[link-eip-1193]] standard, which most (if not all)\n *  currently do.\n */ class BrowserProvider extends _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_0__.JsonRpcApiPollingProvider {\n    get providerInfo() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_1__._)(this, _providerInfo);\n    }\n    async send(method, params) {\n        await this._start();\n        return await super.send(method, params);\n    }\n    async _send(payload) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(!Array.isArray(payload), \"EIP-1193 does not support batch request\", \"payload\", payload);\n        try {\n            const result = await (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_1__._)(this, _request).call(this, payload.method, payload.params || []);\n            return [\n                {\n                    id: payload.id,\n                    result\n                }\n            ];\n        } catch (e) {\n            return [\n                {\n                    id: payload.id,\n                    error: {\n                        code: e.code,\n                        data: e.data,\n                        message: e.message\n                    }\n                }\n            ];\n        }\n    }\n    getRpcError(payload, error) {\n        error = JSON.parse(JSON.stringify(error));\n        // EIP-1193 gives us some machine-readable error codes, so rewrite\n        // them into Ethers standard errors.\n        switch(error.error.code || -1){\n            case 4001:\n                error.error.message = \"ethers-user-denied: \".concat(error.error.message);\n                break;\n            case 4200:\n                error.error.message = \"ethers-unsupported: \".concat(error.error.message);\n                break;\n        }\n        return super.getRpcError(payload, error);\n    }\n    /**\n     *  Resolves to ``true`` if the provider manages the %%address%%.\n     */ async hasSigner(address) {\n        if (address == null) {\n            address = 0;\n        }\n        const accounts = await this.send(\"eth_accounts\", []);\n        if (typeof address === \"number\") {\n            return accounts.length > address;\n        }\n        address = address.toLowerCase();\n        return accounts.filter((a)=>a.toLowerCase() === address).length !== 0;\n    }\n    async getSigner(address) {\n        if (address == null) {\n            address = 0;\n        }\n        if (!await this.hasSigner(address)) {\n            try {\n                await (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_1__._)(this, _request).call(this, \"eth_requestAccounts\", []);\n            } catch (error) {\n                const payload = error.payload;\n                throw this.getRpcError(payload, {\n                    id: payload.id,\n                    error\n                });\n            }\n        }\n        return await super.getSigner(address);\n    }\n    /**\n     *  Discover and connect to a Provider in the Browser using the\n     *  [[link-eip-6963]] discovery mechanism. If no providers are\n     *  present, ``null`` is resolved.\n     */ static async discover(options) {\n        if (options == null) {\n            options = {};\n        }\n        if (options.provider) {\n            return new BrowserProvider(options.provider);\n        }\n        const context = options.window ? options.window : typeof window !== \"undefined\" ? window : null;\n        if (context == null) {\n            return null;\n        }\n        const anyProvider = options.anyProvider;\n        if (anyProvider && context.ethereum) {\n            return new BrowserProvider(context.ethereum);\n        }\n        if (!(\"addEventListener\" in context && \"dispatchEvent\" in context && \"removeEventListener\" in context)) {\n            return null;\n        }\n        const timeout = options.timeout ? options.timeout : 300;\n        if (timeout === 0) {\n            return null;\n        }\n        return await new Promise((resolve, reject)=>{\n            let found = [];\n            const addProvider = (event)=>{\n                found.push(event.detail);\n                if (anyProvider) {\n                    finalize();\n                }\n            };\n            const finalize = ()=>{\n                clearTimeout(timer);\n                if (found.length) {\n                    // If filtering is provided:\n                    if (options && options.filter) {\n                        // Call filter, with a copies of found provider infos\n                        const filtered = options.filter(found.map((i)=>Object.assign({}, i.info)));\n                        if (filtered == null) {\n                            // No provider selected\n                            resolve(null);\n                        } else if (filtered instanceof BrowserProvider) {\n                            // Custom provider created\n                            resolve(filtered);\n                        } else {\n                            // Find the matching provider\n                            let match = null;\n                            if (filtered.uuid) {\n                                const matches = found.filter((f)=>filtered.uuid === f.info.uuid);\n                                // @TODO: What should happen if multiple values\n                                //        for the same UUID?\n                                match = matches[0];\n                            }\n                            if (match) {\n                                const { provider, info } = match;\n                                resolve(new BrowserProvider(provider, undefined, {\n                                    providerInfo: info\n                                }));\n                            } else {\n                                reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.makeError)(\"filter returned unknown info\", \"UNSUPPORTED_OPERATION\", {\n                                    value: filtered\n                                }));\n                            }\n                        }\n                    } else {\n                        // Pick the first found provider\n                        const { provider, info } = found[0];\n                        resolve(new BrowserProvider(provider, undefined, {\n                            providerInfo: info\n                        }));\n                    }\n                } else {\n                    // Nothing found\n                    resolve(null);\n                }\n                context.removeEventListener(\"eip6963:announceProvider\", addProvider);\n            };\n            const timer = setTimeout(()=>{\n                finalize();\n            }, timeout);\n            context.addEventListener(\"eip6963:announceProvider\", addProvider);\n            context.dispatchEvent(new Event(\"eip6963:requestProvider\"));\n        });\n    }\n    /**\n     *  Connect to the %%ethereum%% provider, optionally forcing the\n     *  %%network%%.\n     */ constructor(ethereum, network, _options){\n        // Copy the options\n        const options = Object.assign({}, _options != null ? _options : {}, {\n            batchMaxCount: 1\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(ethereum && ethereum.request, \"invalid EIP-1193 provider\", \"ethereum\", ethereum);\n        super(network, options);\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_3__._)(this, _request, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_3__._)(this, _providerInfo, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_4__._)(this, _providerInfo, null);\n        if (_options && _options.providerInfo) {\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_4__._)(this, _providerInfo, _options.providerInfo);\n        }\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_4__._)(this, _request, async (method, params)=>{\n            const payload = {\n                method,\n                params\n            };\n            this.emit(\"debug\", {\n                action: \"sendEip1193Request\",\n                payload\n            });\n            try {\n                const result = await ethereum.request(payload);\n                this.emit(\"debug\", {\n                    action: \"receiveEip1193Result\",\n                    result\n                });\n                return result;\n            } catch (e) {\n                const error = new Error(e.message);\n                error.code = e.code;\n                error.data = e.data;\n                error.payload = payload;\n                this.emit(\"debug\", {\n                    action: \"receiveEip1193Error\",\n                    error\n                });\n                throw error;\n            }\n        });\n    }\n} //# sourceMappingURL=provider-browser.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBOEQ7QUFDSTs7SUFROUQsd0NBQ0E7QUFQSjs7OztDQUlDLEdBQ00sTUFBTUcsd0JBQXdCRCwyRUFBeUJBO0lBa0MxRCxJQUFJRSxlQUFlO1FBQ2YsT0FBTyw0RUFBSSxFQUFFQTtJQUNqQjtJQUNBLE1BQU1DLEtBQUtDLE1BQU0sRUFBRUMsTUFBTSxFQUFFO1FBQ3ZCLE1BQU0sSUFBSSxDQUFDQyxNQUFNO1FBQ2pCLE9BQU8sTUFBTSxLQUFLLENBQUNILEtBQUtDLFFBQVFDO0lBQ3BDO0lBQ0EsTUFBTUUsTUFBTUMsT0FBTyxFQUFFO1FBQ2pCViwrREFBY0EsQ0FBQyxDQUFDVyxNQUFNQyxPQUFPLENBQUNGLFVBQVUsMkNBQTJDLFdBQVdBO1FBQzlGLElBQUk7WUFDQSxNQUFNRyxTQUFTLE1BQU0sNEVBQUksRUFBRUMsZUFBTixJQUFJLEVBQVVKLFFBQVFKLE1BQU0sRUFBRUksUUFBUUgsTUFBTSxJQUFJLEVBQUU7WUFDdkUsT0FBTztnQkFBQztvQkFBRVEsSUFBSUwsUUFBUUssRUFBRTtvQkFBRUY7Z0JBQU87YUFBRTtRQUN2QyxFQUNBLE9BQU9HLEdBQUc7WUFDTixPQUFPO2dCQUFDO29CQUNBRCxJQUFJTCxRQUFRSyxFQUFFO29CQUNkRSxPQUFPO3dCQUFFQyxNQUFNRixFQUFFRSxJQUFJO3dCQUFFQyxNQUFNSCxFQUFFRyxJQUFJO3dCQUFFQyxTQUFTSixFQUFFSSxPQUFPO29CQUFDO2dCQUM1RDthQUFFO1FBQ1Y7SUFDSjtJQUNBQyxZQUFZWCxPQUFPLEVBQUVPLEtBQUssRUFBRTtRQUN4QkEsUUFBUUssS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxTQUFTLENBQUNQO1FBQ2xDLGtFQUFrRTtRQUNsRSxvQ0FBb0M7UUFDcEMsT0FBUUEsTUFBTUEsS0FBSyxDQUFDQyxJ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ZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItYnJvd3Nlci5qcz9jNmUxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFzc2VydEFyZ3VtZW50LCBtYWtlRXJyb3IgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IEpzb25ScGNBcGlQb2xsaW5nUHJvdmlkZXIgfSBmcm9tIFwiLi9wcm92aWRlci1qc29ucnBjLmpzXCI7XG47XG4vKipcbiAqICBBICoqQnJvd3NlclByb3ZpZGVyKiogaXMgaW50ZW5kZWQgdG8gd3JhcCBhbiBpbmplY3RlZCBwcm92aWRlciB3aGljaFxuICogIGFkaGVyZXMgdG8gdGhlIFtbbGluay1laXAtMTE5M11dIHN0YW5kYXJkLCB3aGljaCBtb3N0IChpZiBub3QgYWxsKVxuICogIGN1cnJlbnRseSBkby5cbiAqL1xuZXhwb3J0IGNsYXNzIEJyb3dzZXJQcm92aWRlciBleHRlbmRzIEpzb25ScGNBcGlQb2xsaW5nUHJvdmlkZXIge1xuICAgICNyZXF1ZXN0O1xuICAgICNwcm92aWRlckluZm87XG4gICAgLyoqXG4gICAgICogIENvbm5lY3QgdG8gdGhlICUlZXRoZXJldW0lJSBwcm92aWRlciwgb3B0aW9uYWxseSBmb3JjaW5nIHRoZVxuICAgICAqICAlJW5ldHdvcmslJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihldGhlcmV1bSwgbmV0d29yaywgX29wdGlvbnMpIHtcbiAgICAgICAgLy8gQ29weSB0aGUgb3B0aW9uc1xuICAgICAgICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgKChfb3B0aW9ucyAhPSBudWxsKSA/IF9vcHRpb25zIDoge30pLCB7IGJhdGNoTWF4Q291bnQ6IDEgfSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGV0aGVyZXVtICYmIGV0aGVyZXVtLnJlcXVlc3QsIFwiaW52YWxpZCBFSVAtMTE5MyBwcm92aWRlclwiLCBcImV0aGVyZXVtXCIsIGV0aGVyZXVtKTtcbiAgICAgICAgc3VwZXIobmV0d29yaywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVySW5mbyA9IG51bGw7XG4gICAgICAgIGlmIChfb3B0aW9ucyAmJiBfb3B0aW9ucy5wcm92aWRlckluZm8pIHtcbiAgICAgICAgICAgIHRoaXMuI3Byb3ZpZGVySW5mbyA9IF9vcHRpb25zLnByb3ZpZGVySW5mbztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNyZXF1ZXN0ID0gYXN5bmMgKG1ldGhvZCwgcGFyYW1zKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0geyBtZXRob2QsIHBhcmFtcyB9O1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwic2VuZEVpcDExOTNSZXF1ZXN0XCIsIHBheWxvYWQgfSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV0aGVyZXVtLnJlcXVlc3QocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZUVpcDExOTNSZXN1bHRcIiwgcmVzdWx0IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgZXJyb3IuY29kZSA9IGUuY29kZTtcbiAgICAgICAgICAgICAgICBlcnJvci5kYXRhID0gZS5kYXRhO1xuICAgICAgICAgICAgICAgIGVycm9yLnBheWxvYWQgPSBwYXlsb2FkO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVFaXAxMTkzRXJyb3JcIiwgZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldCBwcm92aWRlckluZm8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNwcm92aWRlckluZm87XG4gICAgfVxuICAgIGFzeW5jIHNlbmQobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fc3RhcnQoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHN1cGVyLnNlbmQobWV0aG9kLCBwYXJhbXMpO1xuICAgIH1cbiAgICBhc3luYyBfc2VuZChwYXlsb2FkKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KCFBcnJheS5pc0FycmF5KHBheWxvYWQpLCBcIkVJUC0xMTkzIGRvZXMgbm90IHN1cHBvcnQgYmF0Y2ggcmVxdWVzdFwiLCBcInBheWxvYWRcIiwgcGF5bG9hZCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNyZXF1ZXN0KHBheWxvYWQubWV0aG9kLCBwYXlsb2FkLnBhcmFtcyB8fCBbXSk7XG4gICAgICAgICAgICByZXR1cm4gW3sgaWQ6IHBheWxvYWQuaWQsIHJlc3VsdCB9XTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBwYXlsb2FkLmlkLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogeyBjb2RlOiBlLmNvZGUsIGRhdGE6IGUuZGF0YSwgbWVzc2FnZTogZS5tZXNzYWdlIH1cbiAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRScGNFcnJvcihwYXlsb2FkLCBlcnJvcikge1xuICAgICAgICBlcnJvciA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZXJyb3IpKTtcbiAgICAgICAgLy8gRUlQLTExOTMgZ2l2ZXMgdXMgc29tZSBtYWNoaW5lLXJlYWRhYmxlIGVycm9yIGNvZGVzLCBzbyByZXdyaXRlXG4gICAgICAgIC8vIHRoZW0gaW50byBFdGhlcnMgc3RhbmRhcmQgZXJyb3JzLlxuICAgICAgICBzd2l0Y2ggKGVycm9yLmVycm9yLmNvZGUgfHwgLTEpIHtcbiAgICAgICAgICAgIGNhc2UgNDAwMTpcbiAgICAgICAgICAgICAgICBlcnJvci5lcnJvci5tZXNzYWdlID0gYGV0aGVycy11c2VyLWRlbmllZDogJHtlcnJvci5lcnJvci5tZXNzYWdlfWA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQyMDA6XG4gICAgICAgICAgICAgICAgZXJyb3IuZXJyb3IubWVzc2FnZSA9IGBldGhlcnMtdW5zdXBwb3J0ZWQ6ICR7ZXJyb3IuZXJyb3IubWVzc2FnZX1gO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5nZXRScGNFcnJvcihwYXlsb2FkLCBlcnJvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byBgYHRydWVgYCBpZiB0aGUgcHJvdmlkZXIgbWFuYWdlcyB0aGUgJSVhZGRyZXNzJSUuXG4gICAgICovXG4gICAgYXN5bmMgaGFzU2lnbmVyKGFkZHJlc3MpIHtcbiAgICAgICAgaWYgKGFkZHJlc3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgYWRkcmVzcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCB0aGlzLnNlbmQoXCJldGhfYWNjb3VudHNcIiwgW10pO1xuICAgICAgICBpZiAodHlwZW9mIChhZGRyZXNzKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuIChhY2NvdW50cy5sZW5ndGggPiBhZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gYWNjb3VudHMuZmlsdGVyKChhKSA9PiAoYS50b0xvd2VyQ2FzZSgpID09PSBhZGRyZXNzKSkubGVuZ3RoICE9PSAwO1xuICAgIH1cbiAgICBhc3luYyBnZXRTaWduZXIoYWRkcmVzcykge1xuICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBhZGRyZXNzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShhd2FpdCB0aGlzLmhhc1NpZ25lcihhZGRyZXNzKSkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy4jcmVxdWVzdChcImV0aF9yZXF1ZXN0QWNjb3VudHNcIiwgW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGVycm9yLnBheWxvYWQ7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5nZXRScGNFcnJvcihwYXlsb2FkLCB7IGlkOiBwYXlsb2FkLmlkLCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgc3VwZXIuZ2V0U2lnbmVyKGFkZHJlc3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRGlzY292ZXIgYW5kIGNvbm5lY3QgdG8gYSBQcm92aWRlciBpbiB0aGUgQnJvd3NlciB1c2luZyB0aGVcbiAgICAgKiAgW1tsaW5rLWVpcC02OTYzXV0gZGlzY292ZXJ5IG1lY2hhbmlzbS4gSWYgbm8gcHJvdmlkZXJzIGFyZVxuICAgICAqICBwcmVzZW50LCBgYG51bGxgYCBpcyByZXNvbHZlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZGlzY292ZXIob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMucHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnJvd3NlclByb3ZpZGVyKG9wdGlvbnMucHJvdmlkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBvcHRpb25zLndpbmRvdyA/IG9wdGlvbnMud2luZG93IDpcbiAgICAgICAgICAgICh0eXBlb2YgKHdpbmRvdykgIT09IFwidW5kZWZpbmVkXCIpID8gd2luZG93IDogbnVsbDtcbiAgICAgICAgaWYgKGNvbnRleHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYW55UHJvdmlkZXIgPSBvcHRpb25zLmFueVByb3ZpZGVyO1xuICAgICAgICBpZiAoYW55UHJvdmlkZXIgJiYgY29udGV4dC5ldGhlcmV1bSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCcm93c2VyUHJvdmlkZXIoY29udGV4dC5ldGhlcmV1bSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoXCJhZGRFdmVudExpc3RlbmVyXCIgaW4gY29udGV4dCAmJiBcImRpc3BhdGNoRXZlbnRcIiBpbiBjb250ZXh0XG4gICAgICAgICAgICAmJiBcInJlbW92ZUV2ZW50TGlzdGVuZXJcIiBpbiBjb250ZXh0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGltZW91dCA9IG9wdGlvbnMudGltZW91dCA/IG9wdGlvbnMudGltZW91dCA6IDMwMDtcbiAgICAgICAgaWYgKHRpbWVvdXQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCAobmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gW107XG4gICAgICAgICAgICBjb25zdCBhZGRQcm92aWRlciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGZvdW5kLnB1c2goZXZlbnQuZGV0YWlsKTtcbiAgICAgICAgICAgICAgICBpZiAoYW55UHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZmluYWxpemUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgZmluYWxpemUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGZpbHRlcmluZyBpcyBwcm92aWRlZDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5maWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGwgZmlsdGVyLCB3aXRoIGEgY29waWVzIG9mIGZvdW5kIHByb3ZpZGVyIGluZm9zXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IG9wdGlvbnMuZmlsdGVyKGZvdW5kLm1hcChpID0+IE9iamVjdC5hc3NpZ24oe30sIChpLmluZm8pKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlcmVkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBwcm92aWRlciBzZWxlY3RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmaWx0ZXJlZCBpbnN0YW5jZW9mIEJyb3dzZXJQcm92aWRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEN1c3RvbSBwcm92aWRlciBjcmVhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShmaWx0ZXJlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBtYXRjaGluZyBwcm92aWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlcmVkLnV1aWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IGZvdW5kLmZpbHRlcihmID0+IChmaWx0ZXJlZC51dWlkID09PSBmLmluZm8udXVpZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAVE9ETzogV2hhdCBzaG91bGQgaGFwcGVuIGlmIG11bHRpcGxlIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgZm9yIHRoZSBzYW1lIFVVSUQ/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gbWF0Y2hlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcHJvdmlkZXIsIGluZm8gfSA9IG1hdGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG5ldyBCcm93c2VyUHJvdmlkZXIocHJvdmlkZXIsIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJJbmZvOiBpbmZvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChtYWtlRXJyb3IoXCJmaWx0ZXIgcmV0dXJuZWQgdW5rbm93biBpbmZvXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmaWx0ZXJlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGljayB0aGUgZmlyc3QgZm91bmQgcHJvdmlkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcHJvdmlkZXIsIGluZm8gfSA9IGZvdW5kWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShuZXcgQnJvd3NlclByb3ZpZGVyKHByb3ZpZGVyLCB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlckluZm86IGluZm9cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90aGluZyBmb3VuZFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlaXA2OTYzOmFubm91bmNlUHJvdmlkZXJcIiwgYWRkUHJvdmlkZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7IGZpbmFsaXplKCk7IH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgY29udGV4dC5hZGRFdmVudExpc3RlbmVyKFwiZWlwNjk2Mzphbm5vdW5jZVByb3ZpZGVyXCIsIGFkZFByb3ZpZGVyKTtcbiAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJlaXA2OTYzOnJlcXVlc3RQcm92aWRlclwiKSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci1icm93c2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJhc3NlcnRBcmd1bWVudCIsIm1ha2VFcnJvciIsIkpzb25ScGNBcGlQb2xsaW5nUHJvdmlkZXIiLCJCcm93c2VyUHJvdmlkZXIiLCJwcm92aWRlckluZm8iLCJzZW5kIiwibWV0aG9kIiwicGFyYW1zIiwiX3N0YXJ0IiwiX3NlbmQiLCJwYXlsb2FkIiwiQXJyYXkiLCJpc0FycmF5IiwicmVzdWx0IiwicmVxdWVzdCIsImlkIiwiZSIsImVycm9yIiwiY29kZSIsImRhdGEiLCJtZXNzYWdlIiwiZ2V0UnBjRXJyb3IiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJoYXNTaWduZXIiLCJhZGRyZXNzIiwiYWNjb3VudHMiLCJsZW5ndGgiLCJ0b0xvd2VyQ2FzZSIsImZpbHRlciIsImEiLCJnZXRTaWduZXIiLCJkaXNjb3ZlciIsIm9wdGlvbnMiLCJwcm92aWRlciIsImNvbnRleHQiLCJ3aW5kb3ciLCJhbnlQcm92aWRlciIsImV0aGVyZXVtIiwidGltZW91dCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZm91bmQiLCJhZGRQcm92aWRlciIsImV2ZW50IiwicHVzaCIsImRldGFpbCIsImZpbmFsaXplIiwiY2xlYXJUaW1lb3V0IiwidGltZXIiLCJmaWx0ZXJlZCIsIm1hcCIsImkiLCJPYmplY3QiLCJhc3NpZ24iLCJpbmZvIiwibWF0Y2giLCJ1dWlkIiwibWF0Y2hlcyIsImYiLCJ1bmRlZmluZWQiLCJ2YWx1ZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJzZXRUaW1lb3V0IiwiYWRkRXZlbnRMaXN0ZW5lciIsImRpc3BhdGNoRXZlbnQiLCJFdmVudCIsImNvbnN0cnVjdG9yIiwibmV0d29yayIsIl9vcHRpb25zIiwiYmF0Y2hNYXhDb3VudCIsImVtaXQiLCJhY3Rpb24iLCJFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/providers/provider-browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js":
/*!*******************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JsonRpcApiPollingProvider: function() { return /* binding */ JsonRpcApiPollingProvider; },\n/* harmony export */   JsonRpcApiProvider: function() { return /* binding */ JsonRpcApiProvider; },\n/* harmony export */   JsonRpcProvider: function() { return /* binding */ JsonRpcProvider; },\n/* harmony export */   JsonRpcSigner: function() { return /* binding */ JsonRpcSigner; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_get */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_get.js\");\n/* harmony import */ var _swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_init */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_init.js\");\n/* harmony import */ var _swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_set */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_set.js\");\n/* harmony import */ var _swc_helpers_class_private_field_update__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_update */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_update.js\");\n/* harmony import */ var _swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @swc/helpers/_/_class_private_method_get */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_method_get.js\");\n/* harmony import */ var _swc_helpers_class_private_method_init__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @swc/helpers/_/_class_private_method_init */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_method_init.js\");\n/* harmony import */ var _abi_index_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../abi/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/abi-coder.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../address/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/address/checks.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../address/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../hash/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/hash/typed-data.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../transaction/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/transaction/accesslist.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../transaction/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/transaction/authorization.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/fetch.js\");\n/* harmony import */ var _abstract_provider_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./abstract-provider.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/providers/abstract-provider.js\");\n/* harmony import */ var _abstract_signer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-signer.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/providers/abstract-signer.js\");\n/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./network.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/providers/network.js\");\n/* harmony import */ var _subscriber_filterid_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./subscriber-filterid.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/providers/subscriber-filterid.js\");\n/* harmony import */ var _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./subscriber-polling.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/providers/subscriber-polling.js\");\n/**\n *  One of the most common ways to interact with the blockchain is\n *  by a node running a JSON-RPC interface which can be connected to,\n *  based on the transport, using:\n *\n *  - HTTP or HTTPS - [[JsonRpcProvider]]\n *  - WebSocket - [[WebSocketProvider]]\n *  - IPC - [[IpcSocketProvider]]\n *\n * @_section: api/providers/jsonrpc:JSON-RPC Provider  [about-jsonrpcProvider]\n */ // @TODO:\n// - Add the batching API\n// https://playground.open-rpc.org/?schemaUrl=https://raw.githubusercontent.com/ethereum/eth1.0-apis/assembled-spec/openrpc.json&uiSchema%5BappBar%5D%5Bui:splitView%5D=true&uiSchema%5BappBar%5D%5Bui:input%5D=false&uiSchema%5BappBar%5D%5Bui:examplesDropdown%5D=false\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst Primitive = \"bigint,boolean,function,number,string,symbol\".split(/,/g);\n//const Methods = \"getAddress,then\".split(/,/g);\nfunction deepCopy(value) {\n    if (value == null || Primitive.indexOf(typeof value) >= 0) {\n        return value;\n    }\n    // Keep any Addressable\n    if (typeof value.getAddress === \"function\") {\n        return value;\n    }\n    if (Array.isArray(value)) {\n        return value.map(deepCopy);\n    }\n    if (typeof value === \"object\") {\n        return Object.keys(value).reduce((accum, key)=>{\n            accum[key] = value[key];\n            return accum;\n        }, {});\n    }\n    throw new Error(\"should not happen: \".concat(value, \" (\").concat(typeof value, \")\"));\n}\nfunction stall(duration) {\n    return new Promise((resolve)=>{\n        setTimeout(resolve, duration);\n    });\n}\nfunction getLowerCase(value) {\n    if (value) {\n        return value.toLowerCase();\n    }\n    return value;\n}\nfunction isPollable(value) {\n    return value && typeof value.pollingInterval === \"number\";\n}\nconst defaultOptions = {\n    polling: false,\n    staticNetwork: null,\n    batchStallTime: 10,\n    batchMaxSize: 1 << 20,\n    batchMaxCount: 100,\n    cacheTimeout: 250,\n    pollingInterval: 4000\n};\n// @TODO: Unchecked Signers\nclass JsonRpcSigner extends _abstract_signer_js__WEBPACK_IMPORTED_MODULE_0__.AbstractSigner {\n    connect(provider) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"cannot reconnect JsonRpcSigner\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"signer.connect\"\n        });\n    }\n    async getAddress() {\n        return this.address;\n    }\n    // JSON-RPC will automatially fill in nonce, etc. so we just check from\n    async populateTransaction(tx) {\n        return await this.populateCall(tx);\n    }\n    // Returns just the hash of the transaction after sent, which is what\n    // the bare JSON-RPC API does;\n    async sendUncheckedTransaction(_tx) {\n        const tx = deepCopy(_tx);\n        const promises = [];\n        // Make sure the from matches the sender\n        if (tx.from) {\n            const _from = tx.from;\n            promises.push((async ()=>{\n                const from = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(_from, this.provider);\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(from != null && from.toLowerCase() === this.address.toLowerCase(), \"from address mismatch\", \"transaction\", _tx);\n                tx.from = from;\n            })());\n        } else {\n            tx.from = this.address;\n        }\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n        // wishes to use this, it is easy to specify explicitly, otherwise\n        // we look it up for them.\n        if (tx.gasLimit == null) {\n            promises.push((async ()=>{\n                tx.gasLimit = await this.provider.estimateGas({\n                    ...tx,\n                    from: this.address\n                });\n            })());\n        }\n        // The address may be an ENS name or Addressable\n        if (tx.to != null) {\n            const _to = tx.to;\n            promises.push((async ()=>{\n                tx.to = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(_to, this.provider);\n            })());\n        }\n        // Wait until all of our properties are filled in\n        if (promises.length) {\n            await Promise.all(promises);\n        }\n        const hexTx = this.provider.getRpcTransaction(tx);\n        return this.provider.send(\"eth_sendTransaction\", [\n            hexTx\n        ]);\n    }\n    async sendTransaction(tx) {\n        // This cannot be mined any earlier than any recent block\n        const blockNumber = await this.provider.getBlockNumber();\n        // Send the transaction\n        const hash = await this.sendUncheckedTransaction(tx);\n        // Unfortunately, JSON-RPC only provides and opaque transaction hash\n        // for a response, and we need the actual transaction, so we poll\n        // for it; it should show up very quickly\n        return await new Promise((resolve, reject)=>{\n            const timeouts = [\n                1000,\n                100\n            ];\n            let invalids = 0;\n            const checkTx = async ()=>{\n                try {\n                    // Try getting the transaction\n                    const tx = await this.provider.getTransaction(hash);\n                    if (tx != null) {\n                        resolve(tx.replaceableTransaction(blockNumber));\n                        return;\n                    }\n                } catch (error) {\n                    // If we were cancelled: stop polling.\n                    // If the data is bad: the node returns bad transactions\n                    // If the network changed: calling again will also fail\n                    // If unsupported: likely destroyed\n                    if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isError)(error, \"CANCELLED\") || (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isError)(error, \"BAD_DATA\") || (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isError)(error, \"NETWORK_ERROR\") || (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isError)(error, \"UNSUPPORTED_OPERATION\")) {\n                        if (error.info == null) {\n                            error.info = {};\n                        }\n                        error.info.sendTransactionHash = hash;\n                        reject(error);\n                        return;\n                    }\n                    // Stop-gap for misbehaving backends; see #4513\n                    if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isError)(error, \"INVALID_ARGUMENT\")) {\n                        invalids++;\n                        if (error.info == null) {\n                            error.info = {};\n                        }\n                        error.info.sendTransactionHash = hash;\n                        if (invalids > 10) {\n                            reject(error);\n                            return;\n                        }\n                    }\n                    // Notify anyone that cares; but we will try again, since\n                    // it is likely an intermittent service error\n                    this.provider.emit(\"error\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.makeError)(\"failed to fetch transation after sending (will try again)\", \"UNKNOWN_ERROR\", {\n                        error\n                    }));\n                }\n                // Wait another 4 seconds\n                this.provider._setTimeout(()=>{\n                    checkTx();\n                }, timeouts.pop() || 4000);\n            };\n            checkTx();\n        });\n    }\n    async signTransaction(_tx) {\n        const tx = deepCopy(_tx);\n        // Make sure the from matches the sender\n        if (tx.from) {\n            const from = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(tx.from, this.provider);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(from != null && from.toLowerCase() === this.address.toLowerCase(), \"from address mismatch\", \"transaction\", _tx);\n            tx.from = from;\n        } else {\n            tx.from = this.address;\n        }\n        const hexTx = this.provider.getRpcTransaction(tx);\n        return await this.provider.send(\"eth_signTransaction\", [\n            hexTx\n        ]);\n    }\n    async signMessage(_message) {\n        const message = typeof _message === \"string\" ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(_message) : _message;\n        return await this.provider.send(\"personal_sign\", [\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.hexlify)(message),\n            this.address.toLowerCase()\n        ]);\n    }\n    async signTypedData(domain, types, _value) {\n        const value = deepCopy(_value);\n        // Populate any ENS names (in-place)\n        const populated = await _hash_index_js__WEBPACK_IMPORTED_MODULE_5__.TypedDataEncoder.resolveNames(domain, types, value, async (value)=>{\n            const address = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(value);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(address != null, \"TypedData does not support null address\", \"value\", value);\n            return address;\n        });\n        return await this.provider.send(\"eth_signTypedData_v4\", [\n            this.address.toLowerCase(),\n            JSON.stringify(_hash_index_js__WEBPACK_IMPORTED_MODULE_5__.TypedDataEncoder.getPayload(populated.domain, types, populated.value))\n        ]);\n    }\n    async unlock(password) {\n        return this.provider.send(\"personal_unlockAccount\", [\n            this.address.toLowerCase(),\n            password,\n            null\n        ]);\n    }\n    // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n    async _legacySignMessage(_message) {\n        const message = typeof _message === \"string\" ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(_message) : _message;\n        return await this.provider.send(\"eth_sign\", [\n            this.address.toLowerCase(),\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.hexlify)(message)\n        ]);\n    }\n    constructor(provider, address){\n        super(provider);\n        address = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_6__.getAddress)(address);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.defineProperties)(this, {\n            address\n        });\n    }\n}\nvar _options = /*#__PURE__*/ new WeakMap(), // The next ID to use for the JSON-RPC ID field\n_nextId = /*#__PURE__*/ new WeakMap(), // Payloads are queued and triggered in batches using the drainTimer\n_payloads = /*#__PURE__*/ new WeakMap(), _drainTimer = /*#__PURE__*/ new WeakMap(), _notReady = /*#__PURE__*/ new WeakMap(), _network = /*#__PURE__*/ new WeakMap(), _pendingDetectNetwork = /*#__PURE__*/ new WeakMap(), _scheduleDrain = /*#__PURE__*/ new WeakSet();\n/**\n *  The JsonRpcApiProvider is an abstract class and **MUST** be\n *  sub-classed.\n *\n *  It provides the base for all JSON-RPC-based Provider interaction.\n *\n *  Sub-classing Notes:\n *  - a sub-class MUST override _send\n *  - a sub-class MUST call the `_start()` method once connected\n */ class JsonRpcApiProvider extends _abstract_provider_js__WEBPACK_IMPORTED_MODULE_8__.AbstractProvider {\n    /**\n     *  Returns the value associated with the option %%key%%.\n     *\n     *  Sub-classes can use this to inquire about configuration options.\n     */ _getOption(key) {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_9__._)(this, _options)[key];\n    }\n    /**\n     *  Gets the [[Network]] this provider has committed to. On each call, the network\n     *  is detected, and if it has changed, the call will reject.\n     */ get _network() {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_9__._)(this, _network), \"network is not available yet\", \"NETWORK_ERROR\");\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_9__._)(this, _network);\n    }\n    /**\n     *  Resolves to the non-normalized value by performing %%req%%.\n     *\n     *  Sub-classes may override this to modify behavior of actions,\n     *  and should generally call ``super._perform`` as a fallback.\n     */ async _perform(req) {\n        // Legacy networks do not like the type field being passed along (which\n        // is fair), so we delete type if it is 0 and a non-EIP-1559 network\n        if (req.method === \"call\" || req.method === \"estimateGas\") {\n            let tx = req.transaction;\n            if (tx && tx.type != null && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.getBigInt)(tx.type)) {\n                // If there are no EIP-1559 or newer properties, it might be pre-EIP-1559\n                if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\n                    const feeData = await this.getFeeData();\n                    if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                        // Network doesn't know about EIP-1559 (and hence type)\n                        req = Object.assign({}, req, {\n                            transaction: Object.assign({}, tx, {\n                                type: undefined\n                            })\n                        });\n                    }\n                }\n            }\n        }\n        const request = this.getRpcRequest(req);\n        if (request != null) {\n            return await this.send(request.method, request.args);\n        }\n        return super._perform(req);\n    }\n    /**\n     *  Sub-classes may override this; it detects the *actual* network that\n     *  we are **currently** connected to.\n     *\n     *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the\n     *  _send primitive must be used instead.\n     */ async _detectNetwork() {\n        const network = this._getOption(\"staticNetwork\");\n        if (network) {\n            if (network === true) {\n                if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_9__._)(this, _network)) {\n                    return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_9__._)(this, _network);\n                }\n            } else {\n                return network;\n            }\n        }\n        if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_9__._)(this, _pendingDetectNetwork)) {\n            return await (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_9__._)(this, _pendingDetectNetwork);\n        }\n        // If we are ready, use ``send``, which enabled requests to be batched\n        if (this.ready) {\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _pendingDetectNetwork, (async ()=>{\n                try {\n                    const result = _network_js__WEBPACK_IMPORTED_MODULE_12__.Network.from((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.getBigInt)(await this.send(\"eth_chainId\", [])));\n                    (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _pendingDetectNetwork, null);\n                    return result;\n                } catch (error) {\n                    (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _pendingDetectNetwork, null);\n                    throw error;\n                }\n            })());\n            return await (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_9__._)(this, _pendingDetectNetwork);\n        }\n        // We are not ready yet; use the primitive _send\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _pendingDetectNetwork, (async ()=>{\n            const payload = {\n                id: (0,_swc_helpers_class_private_field_update__WEBPACK_IMPORTED_MODULE_13__._)(this, _nextId).value++,\n                method: \"eth_chainId\",\n                params: [],\n                jsonrpc: \"2.0\"\n            };\n            this.emit(\"debug\", {\n                action: \"sendRpcPayload\",\n                payload\n            });\n            let result;\n            try {\n                result = (await this._send(payload))[0];\n                (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _pendingDetectNetwork, null);\n            } catch (error) {\n                (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _pendingDetectNetwork, null);\n                this.emit(\"debug\", {\n                    action: \"receiveRpcError\",\n                    error\n                });\n                throw error;\n            }\n            this.emit(\"debug\", {\n                action: \"receiveRpcResult\",\n                result\n            });\n            if (\"result\" in result) {\n                return _network_js__WEBPACK_IMPORTED_MODULE_12__.Network.from((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.getBigInt)(result.result));\n            }\n            throw this.getRpcError(payload, result);\n        })());\n        return await (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_9__._)(this, _pendingDetectNetwork);\n    }\n    /**\n     *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls\n     *  will be passed to [[_send]] from [[send]]. If it is overridden, then\n     *  ``super._start()`` **MUST** be called.\n     *\n     *  Calling it multiple times is safe and has no effect.\n     */ _start() {\n        if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_9__._)(this, _notReady) == null || (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_9__._)(this, _notReady).resolve == null) {\n            return;\n        }\n        (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_9__._)(this, _notReady).resolve();\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _notReady, null);\n        (async ()=>{\n            // Bootstrap the network\n            while((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_9__._)(this, _network) == null && !this.destroyed){\n                try {\n                    (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _network, await this._detectNetwork());\n                } catch (error) {\n                    if (this.destroyed) {\n                        break;\n                    }\n                    console.log(\"JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)\");\n                    this.emit(\"error\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.makeError)(\"failed to bootstrap network detection\", \"NETWORK_ERROR\", {\n                        event: \"initial-network-discovery\",\n                        info: {\n                            error\n                        }\n                    }));\n                    await stall(1000);\n                }\n            }\n            // Start dispatching requests\n            (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_14__._)(this, _scheduleDrain, scheduleDrain).call(this);\n        })();\n    }\n    /**\n     *  Resolves once the [[_start]] has been called. This can be used in\n     *  sub-classes to defer sending data until the connection has been\n     *  established.\n     */ async _waitUntilReady() {\n        if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_9__._)(this, _notReady) == null) {\n            return;\n        }\n        return await (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_9__._)(this, _notReady).promise;\n    }\n    /**\n     *  Return a Subscriber that will manage the %%sub%%.\n     *\n     *  Sub-classes may override this to modify the behavior of\n     *  subscription management.\n     */ _getSubscriber(sub) {\n        // Pending Filters aren't availble via polling\n        if (sub.type === \"pending\") {\n            return new _subscriber_filterid_js__WEBPACK_IMPORTED_MODULE_15__.FilterIdPendingSubscriber(this);\n        }\n        if (sub.type === \"event\") {\n            if (this._getOption(\"polling\")) {\n                return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_16__.PollingEventSubscriber(this, sub.filter);\n            }\n            return new _subscriber_filterid_js__WEBPACK_IMPORTED_MODULE_15__.FilterIdEventSubscriber(this, sub.filter);\n        }\n        // Orphaned Logs are handled automatically, by the filter, since\n        // logs with removed are emitted by it\n        if (sub.type === \"orphan\" && sub.filter.orphan === \"drop-log\") {\n            return new _abstract_provider_js__WEBPACK_IMPORTED_MODULE_8__.UnmanagedSubscriber(\"orphan\");\n        }\n        return super._getSubscriber(sub);\n    }\n    /**\n     *  Returns true only if the [[_start]] has been called.\n     */ get ready() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_9__._)(this, _notReady) == null;\n    }\n    /**\n     *  Returns %%tx%% as a normalized JSON-RPC transaction request,\n     *  which has all values hexlified and any numeric values converted\n     *  to Quantity values.\n     */ getRpcTransaction(tx) {\n        const result = {};\n        // JSON-RPC now requires numeric values to be \"quantity\" values\n        [\n            \"chainId\",\n            \"gasLimit\",\n            \"gasPrice\",\n            \"type\",\n            \"maxFeePerGas\",\n            \"maxPriorityFeePerGas\",\n            \"nonce\",\n            \"value\"\n        ].forEach((key)=>{\n            if (tx[key] == null) {\n                return;\n            }\n            let dstKey = key;\n            if (key === \"gasLimit\") {\n                dstKey = \"gas\";\n            }\n            result[dstKey] = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.toQuantity)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.getBigInt)(tx[key], \"tx.\".concat(key)));\n        });\n        // Make sure addresses and data are lowercase\n        [\n            \"from\",\n            \"to\",\n            \"data\"\n        ].forEach((key)=>{\n            if (tx[key] == null) {\n                return;\n            }\n            result[key] = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.hexlify)(tx[key]);\n        });\n        // Normalize the access list object\n        if (tx.accessList) {\n            result[\"accessList\"] = (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_17__.accessListify)(tx.accessList);\n        }\n        if (tx.blobVersionedHashes) {\n            // @TODO: Remove this <any> case once EIP-4844 added to prepared tx\n            result[\"blobVersionedHashes\"] = tx.blobVersionedHashes.map((h)=>h.toLowerCase());\n        }\n        if (tx.authorizationList) {\n            result[\"authorizationList\"] = tx.authorizationList.map((_a)=>{\n                const a = (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_18__.authorizationify)(_a);\n                return {\n                    address: a.address,\n                    nonce: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.toQuantity)(a.nonce),\n                    chainId: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.toQuantity)(a.chainId),\n                    yParity: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.toQuantity)(a.signature.yParity),\n                    r: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.toQuantity)(a.signature.r),\n                    s: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.toQuantity)(a.signature.s)\n                };\n            });\n        }\n        // @TODO: blobs should probably also be copied over, optionally\n        // accounting for the kzg property to backfill blobVersionedHashes\n        // using the commitment. Or should that be left as an exercise to\n        // the caller?\n        return result;\n    }\n    /**\n     *  Returns the request method and arguments required to perform\n     *  %%req%%.\n     */ getRpcRequest(req) {\n        switch(req.method){\n            case \"chainId\":\n                return {\n                    method: \"eth_chainId\",\n                    args: []\n                };\n            case \"getBlockNumber\":\n                return {\n                    method: \"eth_blockNumber\",\n                    args: []\n                };\n            case \"getGasPrice\":\n                return {\n                    method: \"eth_gasPrice\",\n                    args: []\n                };\n            case \"getPriorityFee\":\n                return {\n                    method: \"eth_maxPriorityFeePerGas\",\n                    args: []\n                };\n            case \"getBalance\":\n                return {\n                    method: \"eth_getBalance\",\n                    args: [\n                        getLowerCase(req.address),\n                        req.blockTag\n                    ]\n                };\n            case \"getTransactionCount\":\n                return {\n                    method: \"eth_getTransactionCount\",\n                    args: [\n                        getLowerCase(req.address),\n                        req.blockTag\n                    ]\n                };\n            case \"getCode\":\n                return {\n                    method: \"eth_getCode\",\n                    args: [\n                        getLowerCase(req.address),\n                        req.blockTag\n                    ]\n                };\n            case \"getStorage\":\n                return {\n                    method: \"eth_getStorageAt\",\n                    args: [\n                        getLowerCase(req.address),\n                        \"0x\" + req.position.toString(16),\n                        req.blockTag\n                    ]\n                };\n            case \"broadcastTransaction\":\n                return {\n                    method: \"eth_sendRawTransaction\",\n                    args: [\n                        req.signedTransaction\n                    ]\n                };\n            case \"getBlock\":\n                if (\"blockTag\" in req) {\n                    return {\n                        method: \"eth_getBlockByNumber\",\n                        args: [\n                            req.blockTag,\n                            !!req.includeTransactions\n                        ]\n                    };\n                } else if (\"blockHash\" in req) {\n                    return {\n                        method: \"eth_getBlockByHash\",\n                        args: [\n                            req.blockHash,\n                            !!req.includeTransactions\n                        ]\n                    };\n                }\n                break;\n            case \"getTransaction\":\n                return {\n                    method: \"eth_getTransactionByHash\",\n                    args: [\n                        req.hash\n                    ]\n                };\n            case \"getTransactionReceipt\":\n                return {\n                    method: \"eth_getTransactionReceipt\",\n                    args: [\n                        req.hash\n                    ]\n                };\n            case \"call\":\n                return {\n                    method: \"eth_call\",\n                    args: [\n                        this.getRpcTransaction(req.transaction),\n                        req.blockTag\n                    ]\n                };\n            case \"estimateGas\":\n                {\n                    return {\n                        method: \"eth_estimateGas\",\n                        args: [\n                            this.getRpcTransaction(req.transaction)\n                        ]\n                    };\n                }\n            case \"getLogs\":\n                if (req.filter && req.filter.address != null) {\n                    if (Array.isArray(req.filter.address)) {\n                        req.filter.address = req.filter.address.map(getLowerCase);\n                    } else {\n                        req.filter.address = getLowerCase(req.filter.address);\n                    }\n                }\n                return {\n                    method: \"eth_getLogs\",\n                    args: [\n                        req.filter\n                    ]\n                };\n        }\n        return null;\n    }\n    /**\n     *  Returns an ethers-style Error for the given JSON-RPC error\n     *  %%payload%%, coalescing the various strings and error shapes\n     *  that different nodes return, coercing them into a machine-readable\n     *  standardized error.\n     */ getRpcError(payload, _error) {\n        const { method } = payload;\n        const { error } = _error;\n        if (method === \"eth_estimateGas\" && error.message) {\n            const msg = error.message;\n            if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.makeError)(\"insufficient funds\", \"INSUFFICIENT_FUNDS\", {\n                    transaction: payload.params[0],\n                    info: {\n                        payload,\n                        error\n                    }\n                });\n            } else if (msg.match(/nonce/i) && msg.match(/too low/i)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.makeError)(\"nonce has already been used\", \"NONCE_EXPIRED\", {\n                    transaction: payload.params[0],\n                    info: {\n                        payload,\n                        error\n                    }\n                });\n            }\n        }\n        if (method === \"eth_call\" || method === \"eth_estimateGas\") {\n            const result = spelunkData(error);\n            const e = _abi_index_js__WEBPACK_IMPORTED_MODULE_19__.AbiCoder.getBuiltinCallException(method === \"eth_call\" ? \"call\" : \"estimateGas\", payload.params[0], result ? result.data : null);\n            e.info = {\n                error,\n                payload\n            };\n            return e;\n        }\n        // Only estimateGas and call can return arbitrary contract-defined text, so now we\n        // we can process text safely.\n        const message = JSON.stringify(spelunkMessage(error));\n        if (typeof error.message === \"string\" && error.message.match(/user denied|ethers-user-denied/i)) {\n            const actionMap = {\n                eth_sign: \"signMessage\",\n                personal_sign: \"signMessage\",\n                eth_signTypedData_v4: \"signTypedData\",\n                eth_signTransaction: \"signTransaction\",\n                eth_sendTransaction: \"sendTransaction\",\n                eth_requestAccounts: \"requestAccess\",\n                wallet_requestAccounts: \"requestAccess\"\n            };\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.makeError)(\"user rejected action\", \"ACTION_REJECTED\", {\n                action: actionMap[method] || \"unknown\",\n                reason: \"rejected\",\n                info: {\n                    payload,\n                    error\n                }\n            });\n        }\n        if (method === \"eth_sendRawTransaction\" || method === \"eth_sendTransaction\") {\n            const transaction = payload.params[0];\n            if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.makeError)(\"insufficient funds for intrinsic transaction cost\", \"INSUFFICIENT_FUNDS\", {\n                    transaction,\n                    info: {\n                        error\n                    }\n                });\n            }\n            if (message.match(/nonce/i) && message.match(/too low/i)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.makeError)(\"nonce has already been used\", \"NONCE_EXPIRED\", {\n                    transaction,\n                    info: {\n                        error\n                    }\n                });\n            }\n            // \"replacement transaction underpriced\"\n            if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.makeError)(\"replacement fee too low\", \"REPLACEMENT_UNDERPRICED\", {\n                    transaction,\n                    info: {\n                        error\n                    }\n                });\n            }\n            if (message.match(/only replay-protected/i)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.makeError)(\"legacy pre-eip-155 transactions not supported\", \"UNSUPPORTED_OPERATION\", {\n                    operation: method,\n                    info: {\n                        transaction,\n                        info: {\n                            error\n                        }\n                    }\n                });\n            }\n        }\n        let unsupported = !!message.match(/the method .* does not exist/i);\n        if (!unsupported) {\n            if (error && error.details && error.details.startsWith(\"Unauthorized method:\")) {\n                unsupported = true;\n            }\n        }\n        if (unsupported) {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.makeError)(\"unsupported operation\", \"UNSUPPORTED_OPERATION\", {\n                operation: payload.method,\n                info: {\n                    error,\n                    payload\n                }\n            });\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.makeError)(\"could not coalesce error\", \"UNKNOWN_ERROR\", {\n            error,\n            payload\n        });\n    }\n    /**\n     *  Requests the %%method%% with %%params%% via the JSON-RPC protocol\n     *  over the underlying channel. This can be used to call methods\n     *  on the backend that do not have a high-level API within the Provider\n     *  API.\n     *\n     *  This method queues requests according to the batch constraints\n     *  in the options, assigns the request a unique ID.\n     *\n     *  **Do NOT override** this method in sub-classes; instead\n     *  override [[_send]] or force the options values in the\n     *  call to the constructor to modify this method's behavior.\n     */ send(method, params) {\n        // @TODO: cache chainId?? purge on switch_networks\n        // We have been destroyed; no operations are supported anymore\n        if (this.destroyed) {\n            return Promise.reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.makeError)(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", {\n                operation: method\n            }));\n        }\n        const id = (0,_swc_helpers_class_private_field_update__WEBPACK_IMPORTED_MODULE_13__._)(this, _nextId).value++;\n        const promise = new Promise((resolve, reject)=>{\n            (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_9__._)(this, _payloads).push({\n                resolve,\n                reject,\n                payload: {\n                    method,\n                    params,\n                    id,\n                    jsonrpc: \"2.0\"\n                }\n            });\n        });\n        // If there is not a pending drainTimer, set one\n        (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_14__._)(this, _scheduleDrain, scheduleDrain).call(this);\n        return promise;\n    }\n    /**\n     *  Resolves to the [[Signer]] account for  %%address%% managed by\n     *  the client.\n     *\n     *  If the %%address%% is a number, it is used as an index in the\n     *  the accounts from [[listAccounts]].\n     *\n     *  This can only be used on clients which manage accounts (such as\n     *  Geth with imported account or MetaMask).\n     *\n     *  Throws if the account doesn't exist.\n     */ async getSigner(address) {\n        if (address == null) {\n            address = 0;\n        }\n        const accountsPromise = this.send(\"eth_accounts\", []);\n        // Account index\n        if (typeof address === \"number\") {\n            const accounts = await accountsPromise;\n            if (address >= accounts.length) {\n                throw new Error(\"no such account\");\n            }\n            return new JsonRpcSigner(this, accounts[address]);\n        }\n        const { accounts } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.resolveProperties)({\n            network: this.getNetwork(),\n            accounts: accountsPromise\n        });\n        // Account address\n        address = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_6__.getAddress)(address);\n        for (const account of accounts){\n            if ((0,_address_index_js__WEBPACK_IMPORTED_MODULE_6__.getAddress)(account) === address) {\n                return new JsonRpcSigner(this, address);\n            }\n        }\n        throw new Error(\"invalid account\");\n    }\n    async listAccounts() {\n        const accounts = await this.send(\"eth_accounts\", []);\n        return accounts.map((a)=>new JsonRpcSigner(this, a));\n    }\n    destroy() {\n        // Stop processing requests\n        if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_9__._)(this, _drainTimer)) {\n            clearTimeout((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_9__._)(this, _drainTimer));\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _drainTimer, null);\n        }\n        // Cancel all pending requests\n        for (const { payload, reject } of (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_9__._)(this, _payloads)){\n            reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.makeError)(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", {\n                operation: payload.method\n            }));\n        }\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _payloads, []);\n        // Parent clean-up\n        super.destroy();\n    }\n    constructor(network, options){\n        super(network, options);\n        (0,_swc_helpers_class_private_method_init__WEBPACK_IMPORTED_MODULE_20__._)(this, _scheduleDrain);\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_21__._)(this, _options, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_21__._)(this, _nextId, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_21__._)(this, _payloads, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_21__._)(this, _drainTimer, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_21__._)(this, _notReady, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_21__._)(this, _network, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_21__._)(this, _pendingDetectNetwork, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _nextId, 1);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _options, Object.assign({}, defaultOptions, options || {}));\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _payloads, []);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _drainTimer, null);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _network, null);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _pendingDetectNetwork, null);\n        {\n            let resolve = null;\n            const promise = new Promise((_resolve)=>{\n                resolve = _resolve;\n            });\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _notReady, {\n                promise,\n                resolve\n            });\n        }\n        const staticNetwork = this._getOption(\"staticNetwork\");\n        if (typeof staticNetwork === \"boolean\") {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(!staticNetwork || network !== \"any\", \"staticNetwork cannot be used on special network 'any'\", \"options\", options);\n            if (staticNetwork && network != null) {\n                (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _network, _network_js__WEBPACK_IMPORTED_MODULE_12__.Network.from(network));\n            }\n        } else if (staticNetwork) {\n            // Make sure any static network is compatbile with the provided netwrok\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(network == null || staticNetwork.matches(network), \"staticNetwork MUST match network object\", \"options\", options);\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _network, staticNetwork);\n        }\n    }\n}\nfunction scheduleDrain() {\n    if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_9__._)(this, _drainTimer)) {\n        return;\n    }\n    // If we aren't using batching, no harm in sending it immediately\n    const stallTime = this._getOption(\"batchMaxCount\") === 1 ? 0 : this._getOption(\"batchStallTime\");\n    (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _drainTimer, setTimeout(()=>{\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _drainTimer, null);\n        const payloads = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_9__._)(this, _payloads);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _payloads, []);\n        while(payloads.length){\n            // Create payload batches that satisfy our batch constraints\n            const batch = [\n                payloads.shift()\n            ];\n            while(payloads.length){\n                if (batch.length === (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_9__._)(this, _options).batchMaxCount) {\n                    break;\n                }\n                batch.push(payloads.shift());\n                const bytes = JSON.stringify(batch.map((p)=>p.payload));\n                if (bytes.length > (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_9__._)(this, _options).batchMaxSize) {\n                    payloads.unshift(batch.pop());\n                    break;\n                }\n            }\n            // Process the result to each payload\n            (async ()=>{\n                const payload = batch.length === 1 ? batch[0].payload : batch.map((p)=>p.payload);\n                this.emit(\"debug\", {\n                    action: \"sendRpcPayload\",\n                    payload\n                });\n                try {\n                    const result = await this._send(payload);\n                    this.emit(\"debug\", {\n                        action: \"receiveRpcResult\",\n                        result\n                    });\n                    // Process results in batch order\n                    for (const { resolve, reject, payload } of batch){\n                        if (this.destroyed) {\n                            reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.makeError)(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", {\n                                operation: payload.method\n                            }));\n                            continue;\n                        }\n                        // Find the matching result\n                        const resp = result.filter((r)=>r.id === payload.id)[0];\n                        // No result; the node failed us in unexpected ways\n                        if (resp == null) {\n                            const error = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.makeError)(\"missing response for request\", \"BAD_DATA\", {\n                                value: result,\n                                info: {\n                                    payload\n                                }\n                            });\n                            this.emit(\"error\", error);\n                            reject(error);\n                            continue;\n                        }\n                        // The response is an error\n                        if (\"error\" in resp) {\n                            reject(this.getRpcError(payload, resp));\n                            continue;\n                        }\n                        // All good; send the result\n                        resolve(resp.result);\n                    }\n                } catch (error) {\n                    this.emit(\"debug\", {\n                        action: \"receiveRpcError\",\n                        error\n                    });\n                    for (const { reject } of batch){\n                        // @TODO: augment the error with the payload\n                        reject(error);\n                    }\n                }\n            })();\n        }\n    }, stallTime));\n}\nvar _pollingInterval = /*#__PURE__*/ new WeakMap();\n// @TODO: remove this in v7, it is not exported because this functionality\n// is exposed in the JsonRpcApiProvider by setting polling to true. It should\n// be safe to remove regardless, because it isn't reachable, but just in case.\n/**\n *  @_ignore:\n */ class JsonRpcApiPollingProvider extends JsonRpcApiProvider {\n    _getSubscriber(sub) {\n        const subscriber = super._getSubscriber(sub);\n        if (isPollable(subscriber)) {\n            subscriber.pollingInterval = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_9__._)(this, _pollingInterval);\n        }\n        return subscriber;\n    }\n    /**\n     *  The polling interval (default: 4000 ms)\n     */ get pollingInterval() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_9__._)(this, _pollingInterval);\n    }\n    set pollingInterval(value) {\n        if (!Number.isInteger(value) || value < 0) {\n            throw new Error(\"invalid interval\");\n        }\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _pollingInterval, value);\n        this._forEachSubscriber((sub)=>{\n            if (isPollable(sub)) {\n                sub.pollingInterval = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_9__._)(this, _pollingInterval);\n            }\n        });\n    }\n    constructor(network, options){\n        super(network, options);\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_21__._)(this, _pollingInterval, {\n            writable: true,\n            value: void 0\n        });\n        let pollingInterval = this._getOption(\"pollingInterval\");\n        if (pollingInterval == null) {\n            pollingInterval = defaultOptions.pollingInterval;\n        }\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _pollingInterval, pollingInterval);\n    }\n}\nvar _connect = /*#__PURE__*/ new WeakMap();\n/**\n *  The JsonRpcProvider is one of the most common Providers,\n *  which performs all operations over HTTP (or HTTPS) requests.\n *\n *  Events are processed by polling the backend for the current block\n *  number; when it advances, all block-base events are then checked\n *  for updates.\n */ class JsonRpcProvider extends JsonRpcApiPollingProvider {\n    _getConnection() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_9__._)(this, _connect).clone();\n    }\n    async send(method, params) {\n        // All requests are over HTTP, so we can just start handling requests\n        // We do this here rather than the constructor so that we don't send any\n        // requests to the network (i.e. eth_chainId) until we absolutely have to.\n        await this._start();\n        return await super.send(method, params);\n    }\n    async _send(payload) {\n        // Configure a POST connection for the requested method\n        const request = this._getConnection();\n        request.body = JSON.stringify(payload);\n        request.setHeader(\"content-type\", \"application/json\");\n        const response = await request.send();\n        response.assertOk();\n        let resp = response.bodyJson;\n        if (!Array.isArray(resp)) {\n            resp = [\n                resp\n            ];\n        }\n        return resp;\n    }\n    constructor(url, network, options){\n        if (url == null) {\n            url = \"http://localhost:8545\";\n        }\n        super(network, options);\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_21__._)(this, _connect, {\n            writable: true,\n            value: void 0\n        });\n        if (typeof url === \"string\") {\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _connect, new _utils_index_js__WEBPACK_IMPORTED_MODULE_22__.FetchRequest(url));\n        } else {\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _connect, url.clone());\n        }\n    }\n}\nfunction spelunkData(value) {\n    if (value == null) {\n        return null;\n    }\n    // These *are* the droids we're looking for.\n    if (typeof value.message === \"string\" && value.message.match(/revert/i) && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.isHexString)(value.data)) {\n        return {\n            message: value.message,\n            data: value.data\n        };\n    }\n    // Spelunk further...\n    if (typeof value === \"object\") {\n        for(const key in value){\n            const result = spelunkData(value[key]);\n            if (result) {\n                return result;\n            }\n        }\n        return null;\n    }\n    // Might be a JSON string we can further descend...\n    if (typeof value === \"string\") {\n        try {\n            return spelunkData(JSON.parse(value));\n        } catch (error) {}\n    }\n    return null;\n}\nfunction _spelunkMessage(value, result) {\n    if (value == null) {\n        return;\n    }\n    // These *are* the droids we're looking for.\n    if (typeof value.message === \"string\") {\n        result.push(value.message);\n    }\n    // Spelunk further...\n    if (typeof value === \"object\") {\n        for(const key in value){\n            _spelunkMessage(value[key], result);\n        }\n    }\n    // Might be a JSON string we can further descend...\n    if (typeof value === \"string\") {\n        try {\n            return _spelunkMessage(JSON.parse(value), result);\n        } catch (error) {}\n    }\n}\nfunction spelunkMessage(value) {\n    const result = [];\n    _spelunkMessage(value, result);\n    return result;\n} //# sourceMappingURL=provider-jsonrpc.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXItanNvbnJwYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7OztDQVVDLEdBQ0QsU0FBUztBQUNULHlCQUF5QjtBQUN6Qix5UUFBeVE7Ozs7Ozs7QUFDOU47QUFDc0I7QUFDYjtBQUNzQjtBQUNrSDtBQUM3RztBQUN6QjtBQUNmO0FBQ3VEO0FBQzdCO0FBQ2pFLE1BQU15QixZQUFZLCtDQUErQ0MsS0FBSyxDQUFDO0FBQ3ZFLGdEQUFnRDtBQUNoRCxTQUFTQyxTQUFTQyxLQUFLO0lBQ25CLElBQUlBLFNBQVMsUUFBUUgsVUFBVUksT0FBTyxDQUFDLE9BQVFELFVBQVcsR0FBRztRQUN6RCxPQUFPQTtJQUNYO0lBQ0EsdUJBQXVCO0lBQ3ZCLElBQUksT0FBUUEsTUFBTTNCLFVBQVUsS0FBTSxZQUFZO1FBQzFDLE9BQU8yQjtJQUNYO0lBQ0EsSUFBSUUsTUFBTUMsT0FBTyxDQUFDSCxRQUFRO1FBQ3RCLE9BQVFBLE1BQU1JLEdBQUcsQ0FBQ0w7SUFDdEI7SUFDQSxJQUFJLE9BQVFDLFVBQVcsVUFBVTtRQUM3QixPQUFPSyxPQUFPQyxJQUFJLENBQUNOLE9BQU9PLE1BQU0sQ0FBQyxDQUFDQyxPQUFPQztZQUNyQ0QsS0FBSyxDQUFDQyxJQUFJLEdBQUdULEtBQUssQ0FBQ1MsSUFBSTtZQUN2QixPQUFPRDtRQUNYLEdBQUcsQ0FBQztJQUNSO0lBQ0EsTUFBTSxJQUFJRSxNQUFNLHNCQUFnQyxPQUFWVixPQUFNLE1BQW1CLE9BQWYsT0FBUUEsT0FBTztBQUNuRTtBQUNBLFNBQVNXLE1BQU1DLFFBQVE7SUFDbkIsT0FBTyxJQUFJQyxRQUFRLENBQUNDO1FBQWNDLFdBQVdELFNBQVNGO0lBQVc7QUFDckU7QUFDQSxTQUFTSSxhQUFhaEIsS0FBSztJQUN2QixJQUFJQSxPQUFPO1FBQ1AsT0FBT0Es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TzdDLE9BQU8sQ0FBRTtJQUNwQjtBQUNKO0FBQ0EsU0FBUzhGLGVBQWUxSixLQUFLO0lBQ3pCLE1BQU15RyxTQUFTLEVBQUU7SUFDakJnRyxnQkFBZ0J6TSxPQUFPeUc7SUFDdkIsT0FBT0E7QUFDWCxFQUNBLDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3Byb3ZpZGVyLWpzb25ycGMuanM/N2U0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBPbmUgb2YgdGhlIG1vc3QgY29tbW9uIHdheXMgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgYmxvY2tjaGFpbiBpc1xuICogIGJ5IGEgbm9kZSBydW5uaW5nIGEgSlNPTi1SUEMgaW50ZXJmYWNlIHdoaWNoIGNhbiBiZSBjb25uZWN0ZWQgdG8sXG4gKiAgYmFzZWQgb24gdGhlIHRyYW5zcG9ydCwgdXNpbmc6XG4gKlxuICogIC0gSFRUUCBvciBIVFRQUyAtIFtbSnNvblJwY1Byb3ZpZGVyXV1cbiAqICAtIFdlYlNvY2tldCAtIFtbV2ViU29ja2V0UHJvdmlkZXJdXVxuICogIC0gSVBDIC0gW1tJcGNTb2NrZXRQcm92aWRlcl1dXG4gKlxuICogQF9zZWN0aW9uOiBhcGkvcHJvdmlkZXJzL2pzb25ycGM6SlNPTi1SUEMgUHJvdmlkZXIgIFthYm91dC1qc29ucnBjUHJvdmlkZXJdXG4gKi9cbi8vIEBUT0RPOlxuLy8gLSBBZGQgdGhlIGJhdGNoaW5nIEFQSVxuLy8gaHR0cHM6Ly9wbGF5Z3JvdW5kLm9wZW4tcnBjLm9yZy8/c2NoZW1hVXJsPWh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9ldGhlcmV1bS9ldGgxLjAtYXBpcy9hc3NlbWJsZWQtc3BlYy9vcGVucnBjLmpzb24mdWlTY2hlbWElNUJhcHBCYXIlNUQlNUJ1aTpzcGxpdFZpZXclNUQ9dHJ1ZSZ1aVNjaGVtYSU1QmFwcEJhciU1RCU1QnVpOmlucHV0JTVEPWZhbHNlJnVpU2NoZW1hJTVCYXBwQmFyJTVEJTVCdWk6ZXhhbXBsZXNEcm9wZG93biU1RD1mYWxzZVxuaW1wb3J0IHsgQWJpQ29kZXIgfSBmcm9tIFwiLi4vYWJpL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBnZXRBZGRyZXNzLCByZXNvbHZlQWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBUeXBlZERhdGFFbmNvZGVyIH0gZnJvbSBcIi4uL2hhc2gvaW5kZXguanNcIjtcbmltcG9ydCB7IGFjY2Vzc0xpc3RpZnksIGF1dGhvcml6YXRpb25pZnkgfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGdldEJpZ0ludCwgaGV4bGlmeSwgaXNIZXhTdHJpbmcsIHRvUXVhbnRpdHksIHRvVXRmOEJ5dGVzLCBpc0Vycm9yLCBtYWtlRXJyb3IsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQsIEZldGNoUmVxdWVzdCwgcmVzb2x2ZVByb3BlcnRpZXMgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IEFic3RyYWN0UHJvdmlkZXIsIFVubWFuYWdlZFN1YnNjcmliZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1wcm92aWRlci5qc1wiO1xuaW1wb3J0IHsgQWJzdHJhY3RTaWduZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1zaWduZXIuanNcIjtcbmltcG9ydCB7IE5ldHdvcmsgfSBmcm9tIFwiLi9uZXR3b3JrLmpzXCI7XG5pbXBvcnQgeyBGaWx0ZXJJZEV2ZW50U3Vic2NyaWJlciwgRmlsdGVySWRQZW5kaW5nU3Vic2NyaWJlciB9IGZyb20gXCIuL3N1YnNjcmliZXItZmlsdGVyaWQuanNcIjtcbmltcG9ydCB7IFBvbGxpbmdFdmVudFN1YnNjcmliZXIgfSBmcm9tIFwiLi9zdWJzY3JpYmVyLXBvbGxpbmcuanNcIjtcbmNvbnN0IFByaW1pdGl2ZSA9IFwiYmlnaW50LGJvb2xlYW4sZnVuY3Rpb24sbnVtYmVyLHN0cmluZyxzeW1ib2xcIi5zcGxpdCgvLC9nKTtcbi8vY29uc3QgTWV0aG9kcyA9IFwiZ2V0QWRkcmVzcyx0aGVuXCIuc3BsaXQoLywvZyk7XG5mdW5jdGlvbiBkZWVwQ29weSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IFByaW1pdGl2ZS5pbmRleE9mKHR5cGVvZiAodmFsdWUpKSA+PSAwKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgLy8gS2VlcCBhbnkgQWRkcmVzc2FibGVcbiAgICBpZiAodHlwZW9mICh2YWx1ZS5nZXRBZGRyZXNzKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUubWFwKGRlZXBDb3B5KSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpLnJlZHVjZSgoYWNjdW0sIGtleSkgPT4ge1xuICAgICAgICAgICAgYWNjdW1ba2V5XSA9IHZhbHVlW2tleV07XG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH0sIHt9KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBzaG91bGQgbm90IGhhcHBlbjogJHt2YWx1ZX0gKCR7dHlwZW9mICh2YWx1ZSl9KWApO1xufVxuZnVuY3Rpb24gc3RhbGwoZHVyYXRpb24pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHsgc2V0VGltZW91dChyZXNvbHZlLCBkdXJhdGlvbik7IH0pO1xufVxuZnVuY3Rpb24gZ2V0TG93ZXJDYXNlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBpc1BvbGxhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLnBvbGxpbmdJbnRlcnZhbCkgPT09IFwibnVtYmVyXCIpO1xufVxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgcG9sbGluZzogZmFsc2UsXG4gICAgc3RhdGljTmV0d29yazogbnVsbCxcbiAgICBiYXRjaFN0YWxsVGltZTogMTAsXG4gICAgYmF0Y2hNYXhTaXplOiAoMSA8PCAyMCksXG4gICAgYmF0Y2hNYXhDb3VudDogMTAwLFxuICAgIGNhY2hlVGltZW91dDogMjUwLFxuICAgIHBvbGxpbmdJbnRlcnZhbDogNDAwMFxufTtcbi8vIEBUT0RPOiBVbmNoZWNrZWQgU2lnbmVyc1xuZXhwb3J0IGNsYXNzIEpzb25ScGNTaWduZXIgZXh0ZW5kcyBBYnN0cmFjdFNpZ25lciB7XG4gICAgYWRkcmVzcztcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgYWRkcmVzcykge1xuICAgICAgICBzdXBlcihwcm92aWRlcik7XG4gICAgICAgIGFkZHJlc3MgPSBnZXRBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgYWRkcmVzcyB9KTtcbiAgICB9XG4gICAgY29ubmVjdChwcm92aWRlcikge1xuICAgICAgICBhc3NlcnQoZmFsc2UsIFwiY2Fubm90IHJlY29ubmVjdCBKc29uUnBjU2lnbmVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzaWduZXIuY29ubmVjdFwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBnZXRBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRyZXNzO1xuICAgIH1cbiAgICAvLyBKU09OLVJQQyB3aWxsIGF1dG9tYXRpYWxseSBmaWxsIGluIG5vbmNlLCBldGMuIHNvIHdlIGp1c3QgY2hlY2sgZnJvbVxuICAgIGFzeW5jIHBvcHVsYXRlVHJhbnNhY3Rpb24odHgpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucG9wdWxhdGVDYWxsKHR4KTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyBqdXN0IHRoZSBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiBhZnRlciBzZW50LCB3aGljaCBpcyB3aGF0XG4gICAgLy8gdGhlIGJhcmUgSlNPTi1SUEMgQVBJIGRvZXM7XG4gICAgYXN5bmMgc2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uKF90eCkge1xuICAgICAgICBjb25zdCB0eCA9IGRlZXBDb3B5KF90eCk7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgZnJvbSBtYXRjaGVzIHRoZSBzZW5kZXJcbiAgICAgICAgaWYgKHR4LmZyb20pIHtcbiAgICAgICAgICAgIGNvbnN0IF9mcm9tID0gdHguZnJvbTtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmcm9tID0gYXdhaXQgcmVzb2x2ZUFkZHJlc3MoX2Zyb20sIHRoaXMucHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZyb20gIT0gbnVsbCAmJiBmcm9tLnRvTG93ZXJDYXNlKCkgPT09IHRoaXMuYWRkcmVzcy50b0xvd2VyQ2FzZSgpLCBcImZyb20gYWRkcmVzcyBtaXNtYXRjaFwiLCBcInRyYW5zYWN0aW9uXCIsIF90eCk7XG4gICAgICAgICAgICAgICAgdHguZnJvbSA9IGZyb207XG4gICAgICAgICAgICB9KSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHR4LmZyb20gPSB0aGlzLmFkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIEpTT04tUlBDIGZvciBldGhfc2VuZFRyYW5zYWN0aW9uIHVzZXMgOTAwMDAgZ2FzOyBpZiB0aGUgdXNlclxuICAgICAgICAvLyB3aXNoZXMgdG8gdXNlIHRoaXMsIGl0IGlzIGVhc3kgdG8gc3BlY2lmeSBleHBsaWNpdGx5LCBvdGhlcndpc2VcbiAgICAgICAgLy8gd2UgbG9vayBpdCB1cCBmb3IgdGhlbS5cbiAgICAgICAgaWYgKHR4Lmdhc0xpbWl0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0eC5nYXNMaW1pdCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZXN0aW1hdGVHYXMoeyAuLi50eCwgZnJvbTogdGhpcy5hZGRyZXNzIH0pO1xuICAgICAgICAgICAgfSkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGFkZHJlc3MgbWF5IGJlIGFuIEVOUyBuYW1lIG9yIEFkZHJlc3NhYmxlXG4gICAgICAgIGlmICh0eC50byAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBfdG8gPSB0eC50bztcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0eC50byA9IGF3YWl0IHJlc29sdmVBZGRyZXNzKF90bywgdGhpcy5wcm92aWRlcik7XG4gICAgICAgICAgICB9KSgpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXYWl0IHVudGlsIGFsbCBvZiBvdXIgcHJvcGVydGllcyBhcmUgZmlsbGVkIGluXG4gICAgICAgIGlmIChwcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZXhUeCA9IHRoaXMucHJvdmlkZXIuZ2V0UnBjVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX3NlbmRUcmFuc2FjdGlvblwiLCBbaGV4VHhdKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZFRyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIC8vIFRoaXMgY2Fubm90IGJlIG1pbmVkIGFueSBlYXJsaWVyIHRoYW4gYW55IHJlY2VudCBibG9ja1xuICAgICAgICBjb25zdCBibG9ja051bWJlciA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKTtcbiAgICAgICAgLy8gU2VuZCB0aGUgdHJhbnNhY3Rpb25cbiAgICAgICAgY29uc3QgaGFzaCA9IGF3YWl0IHRoaXMuc2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uKHR4KTtcbiAgICAgICAgLy8gVW5mb3J0dW5hdGVseSwgSlNPTi1SUEMgb25seSBwcm92aWRlcyBhbmQgb3BhcXVlIHRyYW5zYWN0aW9uIGhhc2hcbiAgICAgICAgLy8gZm9yIGEgcmVzcG9uc2UsIGFuZCB3ZSBuZWVkIHRoZSBhY3R1YWwgdHJhbnNhY3Rpb24sIHNvIHdlIHBvbGxcbiAgICAgICAgLy8gZm9yIGl0OyBpdCBzaG91bGQgc2hvdyB1cCB2ZXJ5IHF1aWNrbHlcbiAgICAgICAgcmV0dXJuIGF3YWl0IChuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0cyA9IFsxMDAwLCAxMDBdO1xuICAgICAgICAgICAgbGV0IGludmFsaWRzID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrVHggPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IGdldHRpbmcgdGhlIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbihoYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodHgucmVwbGFjZWFibGVUcmFuc2FjdGlvbihibG9ja051bWJlcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSB3ZXJlIGNhbmNlbGxlZDogc3RvcCBwb2xsaW5nLlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZGF0YSBpcyBiYWQ6IHRoZSBub2RlIHJldHVybnMgYmFkIHRyYW5zYWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbmV0d29yayBjaGFuZ2VkOiBjYWxsaW5nIGFnYWluIHdpbGwgYWxzbyBmYWlsXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHVuc3VwcG9ydGVkOiBsaWtlbHkgZGVzdHJveWVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Vycm9yKGVycm9yLCBcIkNBTkNFTExFRFwiKSB8fCBpc0Vycm9yKGVycm9yLCBcIkJBRF9EQVRBXCIpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0Vycm9yKGVycm9yLCBcIk5FVFdPUktfRVJST1JcIikgfHwgaXNFcnJvcihlcnJvciwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5pbmZvID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5pbmZvID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5pbmZvLnNlbmRUcmFuc2FjdGlvbkhhc2ggPSBoYXNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBTdG9wLWdhcCBmb3IgbWlzYmVoYXZpbmcgYmFja2VuZHM7IHNlZSAjNDUxM1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNFcnJvcihlcnJvciwgXCJJTlZBTElEX0FSR1VNRU5UXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZhbGlkcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLmluZm8gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmluZm8gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmluZm8uc2VuZFRyYW5zYWN0aW9uSGFzaCA9IGhhc2g7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW52YWxpZHMgPiAxMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGlmeSBhbnlvbmUgdGhhdCBjYXJlczsgYnV0IHdlIHdpbGwgdHJ5IGFnYWluLCBzaW5jZVxuICAgICAgICAgICAgICAgICAgICAvLyBpdCBpcyBsaWtlbHkgYW4gaW50ZXJtaXR0ZW50IHNlcnZpY2UgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlci5lbWl0KFwiZXJyb3JcIiwgbWFrZUVycm9yKFwiZmFpbGVkIHRvIGZldGNoIHRyYW5zYXRpb24gYWZ0ZXIgc2VuZGluZyAod2lsbCB0cnkgYWdhaW4pXCIsIFwiVU5LTk9XTl9FUlJPUlwiLCB7IGVycm9yIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2FpdCBhbm90aGVyIDQgc2Vjb25kc1xuICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIuX3NldFRpbWVvdXQoKCkgPT4geyBjaGVja1R4KCk7IH0sIHRpbWVvdXRzLnBvcCgpIHx8IDQwMDApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNoZWNrVHgoKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBhc3luYyBzaWduVHJhbnNhY3Rpb24oX3R4KSB7XG4gICAgICAgIGNvbnN0IHR4ID0gZGVlcENvcHkoX3R4KTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBmcm9tIG1hdGNoZXMgdGhlIHNlbmRlclxuICAgICAgICBpZiAodHguZnJvbSkge1xuICAgICAgICAgICAgY29uc3QgZnJvbSA9IGF3YWl0IHJlc29sdmVBZGRyZXNzKHR4LmZyb20sIHRoaXMucHJvdmlkZXIpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZnJvbSAhPSBudWxsICYmIGZyb20udG9Mb3dlckNhc2UoKSA9PT0gdGhpcy5hZGRyZXNzLnRvTG93ZXJDYXNlKCksIFwiZnJvbSBhZGRyZXNzIG1pc21hdGNoXCIsIFwidHJhbnNhY3Rpb25cIiwgX3R4KTtcbiAgICAgICAgICAgIHR4LmZyb20gPSBmcm9tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHguZnJvbSA9IHRoaXMuYWRkcmVzcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZXhUeCA9IHRoaXMucHJvdmlkZXIuZ2V0UnBjVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX3NpZ25UcmFuc2FjdGlvblwiLCBbaGV4VHhdKTtcbiAgICB9XG4gICAgYXN5bmMgc2lnbk1lc3NhZ2UoX21lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICgodHlwZW9mIChfbWVzc2FnZSkgPT09IFwic3RyaW5nXCIpID8gdG9VdGY4Qnl0ZXMoX21lc3NhZ2UpIDogX21lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcm92aWRlci5zZW5kKFwicGVyc29uYWxfc2lnblwiLCBbXG4gICAgICAgICAgICBoZXhsaWZ5KG1lc3NhZ2UpLCB0aGlzLmFkZHJlc3MudG9Mb3dlckNhc2UoKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgYXN5bmMgc2lnblR5cGVkRGF0YShkb21haW4sIHR5cGVzLCBfdmFsdWUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBkZWVwQ29weShfdmFsdWUpO1xuICAgICAgICAvLyBQb3B1bGF0ZSBhbnkgRU5TIG5hbWVzIChpbi1wbGFjZSlcbiAgICAgICAgY29uc3QgcG9wdWxhdGVkID0gYXdhaXQgVHlwZWREYXRhRW5jb2Rlci5yZXNvbHZlTmFtZXMoZG9tYWluLCB0eXBlcywgdmFsdWUsIGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IHJlc29sdmVBZGRyZXNzKHZhbHVlKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGFkZHJlc3MgIT0gbnVsbCwgXCJUeXBlZERhdGEgZG9lcyBub3Qgc3VwcG9ydCBudWxsIGFkZHJlc3NcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByb3ZpZGVyLnNlbmQoXCJldGhfc2lnblR5cGVkRGF0YV92NFwiLCBbXG4gICAgICAgICAgICB0aGlzLmFkZHJlc3MudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KFR5cGVkRGF0YUVuY29kZXIuZ2V0UGF5bG9hZChwb3B1bGF0ZWQuZG9tYWluLCB0eXBlcywgcG9wdWxhdGVkLnZhbHVlKSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGFzeW5jIHVubG9jayhwYXNzd29yZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5zZW5kKFwicGVyc29uYWxfdW5sb2NrQWNjb3VudFwiLCBbXG4gICAgICAgICAgICB0aGlzLmFkZHJlc3MudG9Mb3dlckNhc2UoKSwgcGFzc3dvcmQsIG51bGxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvSlNPTi1SUEMjZXRoX3NpZ25cbiAgICBhc3luYyBfbGVnYWN5U2lnbk1lc3NhZ2UoX21lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICgodHlwZW9mIChfbWVzc2FnZSkgPT09IFwic3RyaW5nXCIpID8gdG9VdGY4Qnl0ZXMoX21lc3NhZ2UpIDogX21lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX3NpZ25cIiwgW1xuICAgICAgICAgICAgdGhpcy5hZGRyZXNzLnRvTG93ZXJDYXNlKCksIGhleGxpZnkobWVzc2FnZSlcbiAgICAgICAgXSk7XG4gICAgfVxufVxuLyoqXG4gKiAgVGhlIEpzb25ScGNBcGlQcm92aWRlciBpcyBhbiBhYnN0cmFjdCBjbGFzcyBhbmQgKipNVVNUKiogYmVcbiAqICBzdWItY2xhc3NlZC5cbiAqXG4gKiAgSXQgcHJvdmlkZXMgdGhlIGJhc2UgZm9yIGFsbCBKU09OLVJQQy1iYXNlZCBQcm92aWRlciBpbnRlcmFjdGlvbi5cbiAqXG4gKiAgU3ViLWNsYXNzaW5nIE5vdGVzOlxuICogIC0gYSBzdWItY2xhc3MgTVVTVCBvdmVycmlkZSBfc2VuZFxuICogIC0gYSBzdWItY2xhc3MgTVVTVCBjYWxsIHRoZSBgX3N0YXJ0KClgIG1ldGhvZCBvbmNlIGNvbm5lY3RlZFxuICovXG5leHBvcnQgY2xhc3MgSnNvblJwY0FwaVByb3ZpZGVyIGV4dGVuZHMgQWJzdHJhY3RQcm92aWRlciB7XG4gICAgI29wdGlvbnM7XG4gICAgLy8gVGhlIG5leHQgSUQgdG8gdXNlIGZvciB0aGUgSlNPTi1SUEMgSUQgZmllbGRcbiAgICAjbmV4dElkO1xuICAgIC8vIFBheWxvYWRzIGFyZSBxdWV1ZWQgYW5kIHRyaWdnZXJlZCBpbiBiYXRjaGVzIHVzaW5nIHRoZSBkcmFpblRpbWVyXG4gICAgI3BheWxvYWRzO1xuICAgICNkcmFpblRpbWVyO1xuICAgICNub3RSZWFkeTtcbiAgICAjbmV0d29yaztcbiAgICAjcGVuZGluZ0RldGVjdE5ldHdvcms7XG4gICAgI3NjaGVkdWxlRHJhaW4oKSB7XG4gICAgICAgIGlmICh0aGlzLiNkcmFpblRpbWVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgYXJlbid0IHVzaW5nIGJhdGNoaW5nLCBubyBoYXJtIGluIHNlbmRpbmcgaXQgaW1tZWRpYXRlbHlcbiAgICAgICAgY29uc3Qgc3RhbGxUaW1lID0gKHRoaXMuX2dldE9wdGlvbihcImJhdGNoTWF4Q291bnRcIikgPT09IDEpID8gMCA6IHRoaXMuX2dldE9wdGlvbihcImJhdGNoU3RhbGxUaW1lXCIpO1xuICAgICAgICB0aGlzLiNkcmFpblRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLiNkcmFpblRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWRzID0gdGhpcy4jcGF5bG9hZHM7XG4gICAgICAgICAgICB0aGlzLiNwYXlsb2FkcyA9IFtdO1xuICAgICAgICAgICAgd2hpbGUgKHBheWxvYWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBwYXlsb2FkIGJhdGNoZXMgdGhhdCBzYXRpc2Z5IG91ciBiYXRjaCBjb25zdHJhaW50c1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhdGNoID0gWyhwYXlsb2Fkcy5zaGlmdCgpKV07XG4gICAgICAgICAgICAgICAgd2hpbGUgKHBheWxvYWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmF0Y2gubGVuZ3RoID09PSB0aGlzLiNvcHRpb25zLmJhdGNoTWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJhdGNoLnB1c2goKHBheWxvYWRzLnNoaWZ0KCkpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBKU09OLnN0cmluZ2lmeShiYXRjaC5tYXAoKHApID0+IHAucGF5bG9hZCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID4gdGhpcy4jb3B0aW9ucy5iYXRjaE1heFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWRzLnVuc2hpZnQoKGJhdGNoLnBvcCgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIHRoZSByZXN1bHQgdG8gZWFjaCBwYXlsb2FkXG4gICAgICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9ICgoYmF0Y2gubGVuZ3RoID09PSAxKSA/IGJhdGNoWzBdLnBheWxvYWQgOiBiYXRjaC5tYXAoKHApID0+IHAucGF5bG9hZCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJzZW5kUnBjUGF5bG9hZFwiLCBwYXlsb2FkIH0pO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fc2VuZChwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVScGNSZXN1bHRcIiwgcmVzdWx0IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJvY2VzcyByZXN1bHRzIGluIGJhdGNoIG9yZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgcmVzb2x2ZSwgcmVqZWN0LCBwYXlsb2FkIH0gb2YgYmF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG1ha2VFcnJvcihcInByb3ZpZGVyIGRlc3Ryb3llZDsgY2FuY2VsbGVkIHJlcXVlc3RcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IHBheWxvYWQubWV0aG9kIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIG1hdGNoaW5nIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSByZXN1bHQuZmlsdGVyKChyKSA9PiAoci5pZCA9PT0gcGF5bG9hZC5pZCkpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIHJlc3VsdDsgdGhlIG5vZGUgZmFpbGVkIHVzIGluIHVuZXhwZWN0ZWQgd2F5c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBtYWtlRXJyb3IoXCJtaXNzaW5nIHJlc3BvbnNlIGZvciByZXF1ZXN0XCIsIFwiQkFEX0RBVEFcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdCwgaW5mbzogeyBwYXlsb2FkIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZXNwb25zZSBpcyBhbiBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImVycm9yXCIgaW4gcmVzcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QodGhpcy5nZXRScGNFcnJvcihwYXlsb2FkLCByZXNwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGwgZ29vZDsgc2VuZCB0aGUgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlUnBjRXJyb3JcIiwgZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgcmVqZWN0IH0gb2YgYmF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAVE9ETzogYXVnbWVudCB0aGUgZXJyb3Igd2l0aCB0aGUgcGF5bG9hZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBzdGFsbFRpbWUpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihuZXR3b3JrLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG5ldHdvcmssIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLiNuZXh0SWQgPSAxO1xuICAgICAgICB0aGlzLiNvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMgfHwge30pO1xuICAgICAgICB0aGlzLiNwYXlsb2FkcyA9IFtdO1xuICAgICAgICB0aGlzLiNkcmFpblRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy4jbmV0d29yayA9IG51bGw7XG4gICAgICAgIHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrID0gbnVsbDtcbiAgICAgICAge1xuICAgICAgICAgICAgbGV0IHJlc29sdmUgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChfcmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUgPSBfcmVzb2x2ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy4jbm90UmVhZHkgPSB7IHByb21pc2UsIHJlc29sdmUgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0aWNOZXR3b3JrID0gdGhpcy5fZ2V0T3B0aW9uKFwic3RhdGljTmV0d29ya1wiKTtcbiAgICAgICAgaWYgKHR5cGVvZiAoc3RhdGljTmV0d29yaykgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCghc3RhdGljTmV0d29yayB8fCBuZXR3b3JrICE9PSBcImFueVwiLCBcInN0YXRpY05ldHdvcmsgY2Fubm90IGJlIHVzZWQgb24gc3BlY2lhbCBuZXR3b3JrICdhbnknXCIsIFwib3B0aW9uc1wiLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChzdGF0aWNOZXR3b3JrICYmIG5ldHdvcmsgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuI25ldHdvcmsgPSBOZXR3b3JrLmZyb20obmV0d29yayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGljTmV0d29yaykge1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGFueSBzdGF0aWMgbmV0d29yayBpcyBjb21wYXRiaWxlIHdpdGggdGhlIHByb3ZpZGVkIG5ldHdyb2tcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KG5ldHdvcmsgPT0gbnVsbCB8fCBzdGF0aWNOZXR3b3JrLm1hdGNoZXMobmV0d29yayksIFwic3RhdGljTmV0d29yayBNVVNUIG1hdGNoIG5ldHdvcmsgb2JqZWN0XCIsIFwib3B0aW9uc1wiLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuI25ldHdvcmsgPSBzdGF0aWNOZXR3b3JrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIG9wdGlvbiAlJWtleSUlLlxuICAgICAqXG4gICAgICogIFN1Yi1jbGFzc2VzIGNhbiB1c2UgdGhpcyB0byBpbnF1aXJlIGFib3V0IGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICAgKi9cbiAgICBfZ2V0T3B0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy4jb3B0aW9uc1trZXldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0cyB0aGUgW1tOZXR3b3JrXV0gdGhpcyBwcm92aWRlciBoYXMgY29tbWl0dGVkIHRvLiBPbiBlYWNoIGNhbGwsIHRoZSBuZXR3b3JrXG4gICAgICogIGlzIGRldGVjdGVkLCBhbmQgaWYgaXQgaGFzIGNoYW5nZWQsIHRoZSBjYWxsIHdpbGwgcmVqZWN0LlxuICAgICAqL1xuICAgIGdldCBfbmV0d29yaygpIHtcbiAgICAgICAgYXNzZXJ0KHRoaXMuI25ldHdvcmssIFwibmV0d29yayBpcyBub3QgYXZhaWxhYmxlIHlldFwiLCBcIk5FVFdPUktfRVJST1JcIik7XG4gICAgICAgIHJldHVybiB0aGlzLiNuZXR3b3JrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIG5vbi1ub3JtYWxpemVkIHZhbHVlIGJ5IHBlcmZvcm1pbmcgJSVyZXElJS5cbiAgICAgKlxuICAgICAqICBTdWItY2xhc3NlcyBtYXkgb3ZlcnJpZGUgdGhpcyB0byBtb2RpZnkgYmVoYXZpb3Igb2YgYWN0aW9ucyxcbiAgICAgKiAgYW5kIHNob3VsZCBnZW5lcmFsbHkgY2FsbCBgYHN1cGVyLl9wZXJmb3JtYGAgYXMgYSBmYWxsYmFjay5cbiAgICAgKi9cbiAgICBhc3luYyBfcGVyZm9ybShyZXEpIHtcbiAgICAgICAgLy8gTGVnYWN5IG5ldHdvcmtzIGRvIG5vdCBsaWtlIHRoZSB0eXBlIGZpZWxkIGJlaW5nIHBhc3NlZCBhbG9uZyAod2hpY2hcbiAgICAgICAgLy8gaXMgZmFpciksIHNvIHdlIGRlbGV0ZSB0eXBlIGlmIGl0IGlzIDAgYW5kIGEgbm9uLUVJUC0xNTU5IG5ldHdvcmtcbiAgICAgICAgaWYgKHJlcS5tZXRob2QgPT09IFwiY2FsbFwiIHx8IHJlcS5tZXRob2QgPT09IFwiZXN0aW1hdGVHYXNcIikge1xuICAgICAgICAgICAgbGV0IHR4ID0gcmVxLnRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgaWYgKHR4ICYmIHR4LnR5cGUgIT0gbnVsbCAmJiBnZXRCaWdJbnQodHgudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gRUlQLTE1NTkgb3IgbmV3ZXIgcHJvcGVydGllcywgaXQgbWlnaHQgYmUgcHJlLUVJUC0xNTU5XG4gICAgICAgICAgICAgICAgaWYgKHR4Lm1heEZlZVBlckdhcyA9PSBudWxsICYmIHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmVlRGF0YSA9IGF3YWl0IHRoaXMuZ2V0RmVlRGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmVlRGF0YS5tYXhGZWVQZXJHYXMgPT0gbnVsbCAmJiBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5ldHdvcmsgZG9lc24ndCBrbm93IGFib3V0IEVJUC0xNTU5IChhbmQgaGVuY2UgdHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcSA9IE9iamVjdC5hc3NpZ24oe30sIHJlcSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiBPYmplY3QuYXNzaWduKHt9LCB0eCwgeyB0eXBlOiB1bmRlZmluZWQgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmdldFJwY1JlcXVlc3QocmVxKTtcbiAgICAgICAgaWYgKHJlcXVlc3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VuZChyZXF1ZXN0Lm1ldGhvZCwgcmVxdWVzdC5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuX3BlcmZvcm0ocmVxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzIG1heSBvdmVycmlkZSB0aGlzOyBpdCBkZXRlY3RzIHRoZSAqYWN0dWFsKiBuZXR3b3JrIHRoYXRcbiAgICAgKiAgd2UgYXJlICoqY3VycmVudGx5KiogY29ubmVjdGVkIHRvLlxuICAgICAqXG4gICAgICogIEtlZXAgaW4gbWluZCB0aGF0IFtbc2VuZF1dIG1heSBvbmx5IGJlIHVzZWQgb25jZSBbW3JlYWR5XV0sIG90aGVyd2lzZSB0aGVcbiAgICAgKiAgX3NlbmQgcHJpbWl0aXZlIG11c3QgYmUgdXNlZCBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGFzeW5jIF9kZXRlY3ROZXR3b3JrKCkge1xuICAgICAgICBjb25zdCBuZXR3b3JrID0gdGhpcy5fZ2V0T3B0aW9uKFwic3RhdGljTmV0d29ya1wiKTtcbiAgICAgICAgaWYgKG5ldHdvcmspIHtcbiAgICAgICAgICAgIGlmIChuZXR3b3JrID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI25ldHdvcmspIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuI25ldHdvcms7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldHdvcms7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jcGVuZGluZ0RldGVjdE5ldHdvcms7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgYXJlIHJlYWR5LCB1c2UgYGBzZW5kYGAsIHdoaWNoIGVuYWJsZWQgcmVxdWVzdHMgdG8gYmUgYmF0Y2hlZFxuICAgICAgICBpZiAodGhpcy5yZWFkeSkge1xuICAgICAgICAgICAgdGhpcy4jcGVuZGluZ0RldGVjdE5ldHdvcmsgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IE5ldHdvcmsuZnJvbShnZXRCaWdJbnQoYXdhaXQgdGhpcy5zZW5kKFwiZXRoX2NoYWluSWRcIiwgW10pKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yaztcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBhcmUgbm90IHJlYWR5IHlldDsgdXNlIHRoZSBwcmltaXRpdmUgX3NlbmRcbiAgICAgICAgdGhpcy4jcGVuZGluZ0RldGVjdE5ldHdvcmsgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICBpZDogdGhpcy4jbmV4dElkKyssIG1ldGhvZDogXCJldGhfY2hhaW5JZFwiLCBwYXJhbXM6IFtdLCBqc29ucnBjOiBcIjIuMFwiXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwic2VuZFJwY1BheWxvYWRcIiwgcGF5bG9hZCB9KTtcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IChhd2FpdCB0aGlzLl9zZW5kKHBheWxvYWQpKVswXTtcbiAgICAgICAgICAgICAgICB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yayA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yayA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZVJwY0Vycm9yXCIsIGVycm9yIH0pO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZVJwY1Jlc3VsdFwiLCByZXN1bHQgfSk7XG4gICAgICAgICAgICBpZiAoXCJyZXN1bHRcIiBpbiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTmV0d29yay5mcm9tKGdldEJpZ0ludChyZXN1bHQucmVzdWx0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmdldFJwY0Vycm9yKHBheWxvYWQsIHJlc3VsdCk7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzICoqTVVTVCoqIGNhbGwgdGhpcy4gVW50aWwgW1tfc3RhcnRdXSBoYXMgYmVlbiBjYWxsZWQsIG5vIGNhbGxzXG4gICAgICogIHdpbGwgYmUgcGFzc2VkIHRvIFtbX3NlbmRdXSBmcm9tIFtbc2VuZF1dLiBJZiBpdCBpcyBvdmVycmlkZGVuLCB0aGVuXG4gICAgICogIGBgc3VwZXIuX3N0YXJ0KClgYCAqKk1VU1QqKiBiZSBjYWxsZWQuXG4gICAgICpcbiAgICAgKiAgQ2FsbGluZyBpdCBtdWx0aXBsZSB0aW1lcyBpcyBzYWZlIGFuZCBoYXMgbm8gZWZmZWN0LlxuICAgICAqL1xuICAgIF9zdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI25vdFJlYWR5ID09IG51bGwgfHwgdGhpcy4jbm90UmVhZHkucmVzb2x2ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbm90UmVhZHkucmVzb2x2ZSgpO1xuICAgICAgICB0aGlzLiNub3RSZWFkeSA9IG51bGw7XG4gICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAvLyBCb290c3RyYXAgdGhlIG5ldHdvcmtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLiNuZXR3b3JrID09IG51bGwgJiYgIXRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jbmV0d29yayA9IGF3YWl0IHRoaXMuX2RldGVjdE5ldHdvcmsoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJKc29uUnBjUHJvdmlkZXIgZmFpbGVkIHRvIGRldGVjdCBuZXR3b3JrIGFuZCBjYW5ub3Qgc3RhcnQgdXA7IHJldHJ5IGluIDFzIChwZXJoYXBzIHRoZSBVUkwgaXMgd3Jvbmcgb3IgdGhlIG5vZGUgaXMgbm90IHN0YXJ0ZWQpXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBtYWtlRXJyb3IoXCJmYWlsZWQgdG8gYm9vdHN0cmFwIG5ldHdvcmsgZGV0ZWN0aW9uXCIsIFwiTkVUV09SS19FUlJPUlwiLCB7IGV2ZW50OiBcImluaXRpYWwtbmV0d29yay1kaXNjb3ZlcnlcIiwgaW5mbzogeyBlcnJvciB9IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgc3RhbGwoMTAwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RhcnQgZGlzcGF0Y2hpbmcgcmVxdWVzdHNcbiAgICAgICAgICAgIHRoaXMuI3NjaGVkdWxlRHJhaW4oKTtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIG9uY2UgdGhlIFtbX3N0YXJ0XV0gaGFzIGJlZW4gY2FsbGVkLiBUaGlzIGNhbiBiZSB1c2VkIGluXG4gICAgICogIHN1Yi1jbGFzc2VzIHRvIGRlZmVyIHNlbmRpbmcgZGF0YSB1bnRpbCB0aGUgY29ubmVjdGlvbiBoYXMgYmVlblxuICAgICAqICBlc3RhYmxpc2hlZC5cbiAgICAgKi9cbiAgICBhc3luYyBfd2FpdFVudGlsUmVhZHkoKSB7XG4gICAgICAgIGlmICh0aGlzLiNub3RSZWFkeSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI25vdFJlYWR5LnByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBTdWJzY3JpYmVyIHRoYXQgd2lsbCBtYW5hZ2UgdGhlICUlc3ViJSUuXG4gICAgICpcbiAgICAgKiAgU3ViLWNsYXNzZXMgbWF5IG92ZXJyaWRlIHRoaXMgdG8gbW9kaWZ5IHRoZSBiZWhhdmlvciBvZlxuICAgICAqICBzdWJzY3JpcHRpb24gbWFuYWdlbWVudC5cbiAgICAgKi9cbiAgICBfZ2V0U3Vic2NyaWJlcihzdWIpIHtcbiAgICAgICAgLy8gUGVuZGluZyBGaWx0ZXJzIGFyZW4ndCBhdmFpbGJsZSB2aWEgcG9sbGluZ1xuICAgICAgICBpZiAoc3ViLnR5cGUgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZpbHRlcklkUGVuZGluZ1N1YnNjcmliZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1Yi50eXBlID09PSBcImV2ZW50XCIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9nZXRPcHRpb24oXCJwb2xsaW5nXCIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nRXZlbnRTdWJzY3JpYmVyKHRoaXMsIHN1Yi5maWx0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGaWx0ZXJJZEV2ZW50U3Vic2NyaWJlcih0aGlzLCBzdWIuZmlsdGVyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPcnBoYW5lZCBMb2dzIGFyZSBoYW5kbGVkIGF1dG9tYXRpY2FsbHksIGJ5IHRoZSBmaWx0ZXIsIHNpbmNlXG4gICAgICAgIC8vIGxvZ3Mgd2l0aCByZW1vdmVkIGFyZSBlbWl0dGVkIGJ5IGl0XG4gICAgICAgIGlmIChzdWIudHlwZSA9PT0gXCJvcnBoYW5cIiAmJiBzdWIuZmlsdGVyLm9ycGhhbiA9PT0gXCJkcm9wLWxvZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVubWFuYWdlZFN1YnNjcmliZXIoXCJvcnBoYW5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLl9nZXRTdWJzY3JpYmVyKHN1Yik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgb25seSBpZiB0aGUgW1tfc3RhcnRdXSBoYXMgYmVlbiBjYWxsZWQuXG4gICAgICovXG4gICAgZ2V0IHJlYWR5KCkgeyByZXR1cm4gdGhpcy4jbm90UmVhZHkgPT0gbnVsbDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zICUldHglJSBhcyBhIG5vcm1hbGl6ZWQgSlNPTi1SUEMgdHJhbnNhY3Rpb24gcmVxdWVzdCxcbiAgICAgKiAgd2hpY2ggaGFzIGFsbCB2YWx1ZXMgaGV4bGlmaWVkIGFuZCBhbnkgbnVtZXJpYyB2YWx1ZXMgY29udmVydGVkXG4gICAgICogIHRvIFF1YW50aXR5IHZhbHVlcy5cbiAgICAgKi9cbiAgICBnZXRScGNUcmFuc2FjdGlvbih0eCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgLy8gSlNPTi1SUEMgbm93IHJlcXVpcmVzIG51bWVyaWMgdmFsdWVzIHRvIGJlIFwicXVhbnRpdHlcIiB2YWx1ZXNcbiAgICAgICAgW1wiY2hhaW5JZFwiLCBcImdhc0xpbWl0XCIsIFwiZ2FzUHJpY2VcIiwgXCJ0eXBlXCIsIFwibWF4RmVlUGVyR2FzXCIsIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIiwgXCJub25jZVwiLCBcInZhbHVlXCJdLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR4W2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkc3RLZXkgPSBrZXk7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcImdhc0xpbWl0XCIpIHtcbiAgICAgICAgICAgICAgICBkc3RLZXkgPSBcImdhc1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2RzdEtleV0gPSB0b1F1YW50aXR5KGdldEJpZ0ludCh0eFtrZXldLCBgdHguJHtrZXl9YCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIGFkZHJlc3NlcyBhbmQgZGF0YSBhcmUgbG93ZXJjYXNlXG4gICAgICAgIFtcImZyb21cIiwgXCJ0b1wiLCBcImRhdGFcIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAodHhba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBoZXhsaWZ5KHR4W2tleV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBhY2Nlc3MgbGlzdCBvYmplY3RcbiAgICAgICAgaWYgKHR4LmFjY2Vzc0xpc3QpIHtcbiAgICAgICAgICAgIHJlc3VsdFtcImFjY2Vzc0xpc3RcIl0gPSBhY2Nlc3NMaXN0aWZ5KHR4LmFjY2Vzc0xpc3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5ibG9iVmVyc2lvbmVkSGFzaGVzKSB7XG4gICAgICAgICAgICAvLyBAVE9ETzogUmVtb3ZlIHRoaXMgPGFueT4gY2FzZSBvbmNlIEVJUC00ODQ0IGFkZGVkIHRvIHByZXBhcmVkIHR4XG4gICAgICAgICAgICByZXN1bHRbXCJibG9iVmVyc2lvbmVkSGFzaGVzXCJdID0gdHguYmxvYlZlcnNpb25lZEhhc2hlcy5tYXAoaCA9PiBoLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5hdXRob3JpemF0aW9uTGlzdCkge1xuICAgICAgICAgICAgcmVzdWx0W1wiYXV0aG9yaXphdGlvbkxpc3RcIl0gPSB0eC5hdXRob3JpemF0aW9uTGlzdC5tYXAoKF9hKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYSA9IGF1dGhvcml6YXRpb25pZnkoX2EpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IGEuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgbm9uY2U6IHRvUXVhbnRpdHkoYS5ub25jZSksXG4gICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IHRvUXVhbnRpdHkoYS5jaGFpbklkKSxcbiAgICAgICAgICAgICAgICAgICAgeVBhcml0eTogdG9RdWFudGl0eShhLnNpZ25hdHVyZS55UGFyaXR5KSxcbiAgICAgICAgICAgICAgICAgICAgcjogdG9RdWFudGl0eShhLnNpZ25hdHVyZS5yKSxcbiAgICAgICAgICAgICAgICAgICAgczogdG9RdWFudGl0eShhLnNpZ25hdHVyZS5zKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQFRPRE86IGJsb2JzIHNob3VsZCBwcm9iYWJseSBhbHNvIGJlIGNvcGllZCBvdmVyLCBvcHRpb25hbGx5XG4gICAgICAgIC8vIGFjY291bnRpbmcgZm9yIHRoZSBremcgcHJvcGVydHkgdG8gYmFja2ZpbGwgYmxvYlZlcnNpb25lZEhhc2hlc1xuICAgICAgICAvLyB1c2luZyB0aGUgY29tbWl0bWVudC4gT3Igc2hvdWxkIHRoYXQgYmUgbGVmdCBhcyBhbiBleGVyY2lzZSB0b1xuICAgICAgICAvLyB0aGUgY2FsbGVyP1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgcmVxdWVzdCBtZXRob2QgYW5kIGFyZ3VtZW50cyByZXF1aXJlZCB0byBwZXJmb3JtXG4gICAgICogICUlcmVxJSUuXG4gICAgICovXG4gICAgZ2V0UnBjUmVxdWVzdChyZXEpIHtcbiAgICAgICAgc3dpdGNoIChyZXEubWV0aG9kKSB7XG4gICAgICAgICAgICBjYXNlIFwiY2hhaW5JZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7IG1ldGhvZDogXCJldGhfY2hhaW5JZFwiLCBhcmdzOiBbXSB9O1xuICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrTnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWV0aG9kOiBcImV0aF9ibG9ja051bWJlclwiLCBhcmdzOiBbXSB9O1xuICAgICAgICAgICAgY2FzZSBcImdldEdhc1ByaWNlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWV0aG9kOiBcImV0aF9nYXNQcmljZVwiLCBhcmdzOiBbXSB9O1xuICAgICAgICAgICAgY2FzZSBcImdldFByaW9yaXR5RmVlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWV0aG9kOiBcImV0aF9tYXhQcmlvcml0eUZlZVBlckdhc1wiLCBhcmdzOiBbXSB9O1xuICAgICAgICAgICAgY2FzZSBcImdldEJhbGFuY2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2dldEJhbGFuY2VcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW2dldExvd2VyQ2FzZShyZXEuYWRkcmVzcyksIHJlcS5ibG9ja1RhZ11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uQ291bnRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2dldFRyYW5zYWN0aW9uQ291bnRcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW2dldExvd2VyQ2FzZShyZXEuYWRkcmVzcyksIHJlcS5ibG9ja1RhZ11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBcImdldENvZGVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2dldENvZGVcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW2dldExvd2VyQ2FzZShyZXEuYWRkcmVzcyksIHJlcS5ibG9ja1RhZ11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBcImdldFN0b3JhZ2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2dldFN0b3JhZ2VBdFwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRMb3dlckNhc2UocmVxLmFkZHJlc3MpLFxuICAgICAgICAgICAgICAgICAgICAgICAgKFwiMHhcIiArIHJlcS5wb3NpdGlvbi50b1N0cmluZygxNikpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLmJsb2NrVGFnXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBcImJyb2FkY2FzdFRyYW5zYWN0aW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9zZW5kUmF3VHJhbnNhY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW3JlcS5zaWduZWRUcmFuc2FjdGlvbl1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrXCI6XG4gICAgICAgICAgICAgICAgaWYgKFwiYmxvY2tUYWdcIiBpbiByZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0QmxvY2tCeU51bWJlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW3JlcS5ibG9ja1RhZywgISFyZXEuaW5jbHVkZVRyYW5zYWN0aW9uc11cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoXCJibG9ja0hhc2hcIiBpbiByZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0QmxvY2tCeUhhc2hcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtyZXEuYmxvY2tIYXNoLCAhIXJlcS5pbmNsdWRlVHJhbnNhY3Rpb25zXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0VHJhbnNhY3Rpb25CeUhhc2hcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW3JlcS5oYXNoXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHRcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW3JlcS5oYXNoXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiY2FsbFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfY2FsbFwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbdGhpcy5nZXRScGNUcmFuc2FjdGlvbihyZXEudHJhbnNhY3Rpb24pLCByZXEuYmxvY2tUYWddXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgXCJlc3RpbWF0ZUdhc1wiOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9lc3RpbWF0ZUdhc1wiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbdGhpcy5nZXRScGNUcmFuc2FjdGlvbihyZXEudHJhbnNhY3Rpb24pXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiZ2V0TG9nc1wiOlxuICAgICAgICAgICAgICAgIGlmIChyZXEuZmlsdGVyICYmIHJlcS5maWx0ZXIuYWRkcmVzcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlcS5maWx0ZXIuYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5maWx0ZXIuYWRkcmVzcyA9IHJlcS5maWx0ZXIuYWRkcmVzcy5tYXAoZ2V0TG93ZXJDYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5maWx0ZXIuYWRkcmVzcyA9IGdldExvd2VyQ2FzZShyZXEuZmlsdGVyLmFkZHJlc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IG1ldGhvZDogXCJldGhfZ2V0TG9nc1wiLCBhcmdzOiBbcmVxLmZpbHRlcl0gfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYW4gZXRoZXJzLXN0eWxlIEVycm9yIGZvciB0aGUgZ2l2ZW4gSlNPTi1SUEMgZXJyb3JcbiAgICAgKiAgJSVwYXlsb2FkJSUsIGNvYWxlc2NpbmcgdGhlIHZhcmlvdXMgc3RyaW5ncyBhbmQgZXJyb3Igc2hhcGVzXG4gICAgICogIHRoYXQgZGlmZmVyZW50IG5vZGVzIHJldHVybiwgY29lcmNpbmcgdGhlbSBpbnRvIGEgbWFjaGluZS1yZWFkYWJsZVxuICAgICAqICBzdGFuZGFyZGl6ZWQgZXJyb3IuXG4gICAgICovXG4gICAgZ2V0UnBjRXJyb3IocGF5bG9hZCwgX2Vycm9yKSB7XG4gICAgICAgIGNvbnN0IHsgbWV0aG9kIH0gPSBwYXlsb2FkO1xuICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBfZXJyb3I7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwiZXRoX2VzdGltYXRlR2FzXCIgJiYgZXJyb3IubWVzc2FnZSkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgIGlmICghbXNnLm1hdGNoKC9yZXZlcnQvaSkgJiYgbXNnLm1hdGNoKC9pbnN1ZmZpY2llbnQgZnVuZHMvaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZUVycm9yKFwiaW5zdWZmaWNpZW50IGZ1bmRzXCIsIFwiSU5TVUZGSUNJRU5UX0ZVTkRTXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IChwYXlsb2FkLnBhcmFtc1swXSksXG4gICAgICAgICAgICAgICAgICAgIGluZm86IHsgcGF5bG9hZCwgZXJyb3IgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobXNnLm1hdGNoKC9ub25jZS9pKSAmJiBtc2cubWF0Y2goL3RvbyBsb3cvaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZUVycm9yKFwibm9uY2UgaGFzIGFscmVhZHkgYmVlbiB1c2VkXCIsIFwiTk9OQ0VfRVhQSVJFRFwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiAocGF5bG9hZC5wYXJhbXNbMF0pLFxuICAgICAgICAgICAgICAgICAgICBpbmZvOiB7IHBheWxvYWQsIGVycm9yIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0aG9kID09PSBcImV0aF9jYWxsXCIgfHwgbWV0aG9kID09PSBcImV0aF9lc3RpbWF0ZUdhc1wiKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBzcGVsdW5rRGF0YShlcnJvcik7XG4gICAgICAgICAgICBjb25zdCBlID0gQWJpQ29kZXIuZ2V0QnVpbHRpbkNhbGxFeGNlcHRpb24oKG1ldGhvZCA9PT0gXCJldGhfY2FsbFwiKSA/IFwiY2FsbFwiIDogXCJlc3RpbWF0ZUdhc1wiLCAocGF5bG9hZC5wYXJhbXNbMF0pLCAocmVzdWx0ID8gcmVzdWx0LmRhdGEgOiBudWxsKSk7XG4gICAgICAgICAgICBlLmluZm8gPSB7IGVycm9yLCBwYXlsb2FkIH07XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IGVzdGltYXRlR2FzIGFuZCBjYWxsIGNhbiByZXR1cm4gYXJiaXRyYXJ5IGNvbnRyYWN0LWRlZmluZWQgdGV4dCwgc28gbm93IHdlXG4gICAgICAgIC8vIHdlIGNhbiBwcm9jZXNzIHRleHQgc2FmZWx5LlxuICAgICAgICBjb25zdCBtZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkoc3BlbHVua01lc3NhZ2UoZXJyb3IpKTtcbiAgICAgICAgaWYgKHR5cGVvZiAoZXJyb3IubWVzc2FnZSkgPT09IFwic3RyaW5nXCIgJiYgZXJyb3IubWVzc2FnZS5tYXRjaCgvdXNlciBkZW5pZWR8ZXRoZXJzLXVzZXItZGVuaWVkL2kpKSB7XG4gICAgICAgICAgICBjb25zdCBhY3Rpb25NYXAgPSB7XG4gICAgICAgICAgICAgICAgZXRoX3NpZ246IFwic2lnbk1lc3NhZ2VcIixcbiAgICAgICAgICAgICAgICBwZXJzb25hbF9zaWduOiBcInNpZ25NZXNzYWdlXCIsXG4gICAgICAgICAgICAgICAgZXRoX3NpZ25UeXBlZERhdGFfdjQ6IFwic2lnblR5cGVkRGF0YVwiLFxuICAgICAgICAgICAgICAgIGV0aF9zaWduVHJhbnNhY3Rpb246IFwic2lnblRyYW5zYWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgZXRoX3NlbmRUcmFuc2FjdGlvbjogXCJzZW5kVHJhbnNhY3Rpb25cIixcbiAgICAgICAgICAgICAgICBldGhfcmVxdWVzdEFjY291bnRzOiBcInJlcXVlc3RBY2Nlc3NcIixcbiAgICAgICAgICAgICAgICB3YWxsZXRfcmVxdWVzdEFjY291bnRzOiBcInJlcXVlc3RBY2Nlc3NcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbWFrZUVycm9yKGB1c2VyIHJlamVjdGVkIGFjdGlvbmAsIFwiQUNUSU9OX1JFSkVDVEVEXCIsIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IChhY3Rpb25NYXBbbWV0aG9kXSB8fCBcInVua25vd25cIiksXG4gICAgICAgICAgICAgICAgcmVhc29uOiBcInJlamVjdGVkXCIsXG4gICAgICAgICAgICAgICAgaW5mbzogeyBwYXlsb2FkLCBlcnJvciB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0aG9kID09PSBcImV0aF9zZW5kUmF3VHJhbnNhY3Rpb25cIiB8fCBtZXRob2QgPT09IFwiZXRoX3NlbmRUcmFuc2FjdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IChwYXlsb2FkLnBhcmFtc1swXSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tYXRjaCgvaW5zdWZmaWNpZW50IGZ1bmRzfGJhc2UgZmVlIGV4Y2VlZHMgZ2FzIGxpbWl0L2kpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VFcnJvcihcImluc3VmZmljaWVudCBmdW5kcyBmb3IgaW50cmluc2ljIHRyYW5zYWN0aW9uIGNvc3RcIiwgXCJJTlNVRkZJQ0lFTlRfRlVORFNcIiwge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbiwgaW5mbzogeyBlcnJvciB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tYXRjaCgvbm9uY2UvaSkgJiYgbWVzc2FnZS5tYXRjaCgvdG9vIGxvdy9pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlRXJyb3IoXCJub25jZSBoYXMgYWxyZWFkeSBiZWVuIHVzZWRcIiwgXCJOT05DRV9FWFBJUkVEXCIsIHsgdHJhbnNhY3Rpb24sIGluZm86IHsgZXJyb3IgfSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFwicmVwbGFjZW1lbnQgdHJhbnNhY3Rpb24gdW5kZXJwcmljZWRcIlxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWF0Y2goL3JlcGxhY2VtZW50IHRyYW5zYWN0aW9uL2kpICYmIG1lc3NhZ2UubWF0Y2goL3VuZGVycHJpY2VkL2kpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VFcnJvcihcInJlcGxhY2VtZW50IGZlZSB0b28gbG93XCIsIFwiUkVQTEFDRU1FTlRfVU5ERVJQUklDRURcIiwgeyB0cmFuc2FjdGlvbiwgaW5mbzogeyBlcnJvciB9IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWF0Y2goL29ubHkgcmVwbGF5LXByb3RlY3RlZC9pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlRXJyb3IoXCJsZWdhY3kgcHJlLWVpcC0xNTUgdHJhbnNhY3Rpb25zIG5vdCBzdXBwb3J0ZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IG1ldGhvZCwgaW5mbzogeyB0cmFuc2FjdGlvbiwgaW5mbzogeyBlcnJvciB9IH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdW5zdXBwb3J0ZWQgPSAhIW1lc3NhZ2UubWF0Y2goL3RoZSBtZXRob2QgLiogZG9lcyBub3QgZXhpc3QvaSk7XG4gICAgICAgIGlmICghdW5zdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIGlmIChlcnJvciAmJiBlcnJvci5kZXRhaWxzICYmIGVycm9yLmRldGFpbHMuc3RhcnRzV2l0aChcIlVuYXV0aG9yaXplZCBtZXRob2Q6XCIpKSB7XG4gICAgICAgICAgICAgICAgdW5zdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh1bnN1cHBvcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VFcnJvcihcInVuc3VwcG9ydGVkIG9wZXJhdGlvblwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBwYXlsb2FkLm1ldGhvZCwgaW5mbzogeyBlcnJvciwgcGF5bG9hZCB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFrZUVycm9yKFwiY291bGQgbm90IGNvYWxlc2NlIGVycm9yXCIsIFwiVU5LTk9XTl9FUlJPUlwiLCB7IGVycm9yLCBwYXlsb2FkIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVxdWVzdHMgdGhlICUlbWV0aG9kJSUgd2l0aCAlJXBhcmFtcyUlIHZpYSB0aGUgSlNPTi1SUEMgcHJvdG9jb2xcbiAgICAgKiAgb3ZlciB0aGUgdW5kZXJseWluZyBjaGFubmVsLiBUaGlzIGNhbiBiZSB1c2VkIHRvIGNhbGwgbWV0aG9kc1xuICAgICAqICBvbiB0aGUgYmFja2VuZCB0aGF0IGRvIG5vdCBoYXZlIGEgaGlnaC1sZXZlbCBBUEkgd2l0aGluIHRoZSBQcm92aWRlclxuICAgICAqICBBUEkuXG4gICAgICpcbiAgICAgKiAgVGhpcyBtZXRob2QgcXVldWVzIHJlcXVlc3RzIGFjY29yZGluZyB0byB0aGUgYmF0Y2ggY29uc3RyYWludHNcbiAgICAgKiAgaW4gdGhlIG9wdGlvbnMsIGFzc2lnbnMgdGhlIHJlcXVlc3QgYSB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiAgKipEbyBOT1Qgb3ZlcnJpZGUqKiB0aGlzIG1ldGhvZCBpbiBzdWItY2xhc3NlczsgaW5zdGVhZFxuICAgICAqICBvdmVycmlkZSBbW19zZW5kXV0gb3IgZm9yY2UgdGhlIG9wdGlvbnMgdmFsdWVzIGluIHRoZVxuICAgICAqICBjYWxsIHRvIHRoZSBjb25zdHJ1Y3RvciB0byBtb2RpZnkgdGhpcyBtZXRob2QncyBiZWhhdmlvci5cbiAgICAgKi9cbiAgICBzZW5kKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIC8vIEBUT0RPOiBjYWNoZSBjaGFpbklkPz8gcHVyZ2Ugb24gc3dpdGNoX25ldHdvcmtzXG4gICAgICAgIC8vIFdlIGhhdmUgYmVlbiBkZXN0cm95ZWQ7IG5vIG9wZXJhdGlvbnMgYXJlIHN1cHBvcnRlZCBhbnltb3JlXG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG1ha2VFcnJvcihcInByb3ZpZGVyIGRlc3Ryb3llZDsgY2FuY2VsbGVkIHJlcXVlc3RcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IG1ldGhvZCB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWQgPSB0aGlzLiNuZXh0SWQrKztcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuI3BheWxvYWRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHJlc29sdmUsIHJlamVjdCxcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiB7IG1ldGhvZCwgcGFyYW1zLCBpZCwganNvbnJwYzogXCIyLjBcIiB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vdCBhIHBlbmRpbmcgZHJhaW5UaW1lciwgc2V0IG9uZVxuICAgICAgICB0aGlzLiNzY2hlZHVsZURyYWluKCk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIFtbU2lnbmVyXV0gYWNjb3VudCBmb3IgICUlYWRkcmVzcyUlIG1hbmFnZWQgYnlcbiAgICAgKiAgdGhlIGNsaWVudC5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgJSVhZGRyZXNzJSUgaXMgYSBudW1iZXIsIGl0IGlzIHVzZWQgYXMgYW4gaW5kZXggaW4gdGhlXG4gICAgICogIHRoZSBhY2NvdW50cyBmcm9tIFtbbGlzdEFjY291bnRzXV0uXG4gICAgICpcbiAgICAgKiAgVGhpcyBjYW4gb25seSBiZSB1c2VkIG9uIGNsaWVudHMgd2hpY2ggbWFuYWdlIGFjY291bnRzIChzdWNoIGFzXG4gICAgICogIEdldGggd2l0aCBpbXBvcnRlZCBhY2NvdW50IG9yIE1ldGFNYXNrKS5cbiAgICAgKlxuICAgICAqICBUaHJvd3MgaWYgdGhlIGFjY291bnQgZG9lc24ndCBleGlzdC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRTaWduZXIoYWRkcmVzcykge1xuICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBhZGRyZXNzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhY2NvdW50c1Byb21pc2UgPSB0aGlzLnNlbmQoXCJldGhfYWNjb3VudHNcIiwgW10pO1xuICAgICAgICAvLyBBY2NvdW50IGluZGV4XG4gICAgICAgIGlmICh0eXBlb2YgKGFkZHJlc3MpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBjb25zdCBhY2NvdW50cyA9IChhd2FpdCBhY2NvdW50c1Byb21pc2UpO1xuICAgICAgICAgICAgaWYgKGFkZHJlc3MgPj0gYWNjb3VudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gc3VjaCBhY2NvdW50XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBKc29uUnBjU2lnbmVyKHRoaXMsIGFjY291bnRzW2FkZHJlc3NdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGFjY291bnRzIH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcbiAgICAgICAgICAgIGFjY291bnRzOiBhY2NvdW50c1Byb21pc2VcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEFjY291bnQgYWRkcmVzc1xuICAgICAgICBhZGRyZXNzID0gZ2V0QWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgZm9yIChjb25zdCBhY2NvdW50IG9mIGFjY291bnRzKSB7XG4gICAgICAgICAgICBpZiAoZ2V0QWRkcmVzcyhhY2NvdW50KSA9PT0gYWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSnNvblJwY1NpZ25lcih0aGlzLCBhZGRyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGFjY291bnRcIik7XG4gICAgfVxuICAgIGFzeW5jIGxpc3RBY2NvdW50cygpIHtcbiAgICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCB0aGlzLnNlbmQoXCJldGhfYWNjb3VudHNcIiwgW10pO1xuICAgICAgICByZXR1cm4gYWNjb3VudHMubWFwKChhKSA9PiBuZXcgSnNvblJwY1NpZ25lcih0aGlzLCBhKSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIC8vIFN0b3AgcHJvY2Vzc2luZyByZXF1ZXN0c1xuICAgICAgICBpZiAodGhpcy4jZHJhaW5UaW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI2RyYWluVGltZXIpO1xuICAgICAgICAgICAgdGhpcy4jZHJhaW5UaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FuY2VsIGFsbCBwZW5kaW5nIHJlcXVlc3RzXG4gICAgICAgIGZvciAoY29uc3QgeyBwYXlsb2FkLCByZWplY3QgfSBvZiB0aGlzLiNwYXlsb2Fkcykge1xuICAgICAgICAgICAgcmVqZWN0KG1ha2VFcnJvcihcInByb3ZpZGVyIGRlc3Ryb3llZDsgY2FuY2VsbGVkIHJlcXVlc3RcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IHBheWxvYWQubWV0aG9kIH0pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwYXlsb2FkcyA9IFtdO1xuICAgICAgICAvLyBQYXJlbnQgY2xlYW4tdXBcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIH1cbn1cbi8vIEBUT0RPOiByZW1vdmUgdGhpcyBpbiB2NywgaXQgaXMgbm90IGV4cG9ydGVkIGJlY2F1c2UgdGhpcyBmdW5jdGlvbmFsaXR5XG4vLyBpcyBleHBvc2VkIGluIHRoZSBKc29uUnBjQXBpUHJvdmlkZXIgYnkgc2V0dGluZyBwb2xsaW5nIHRvIHRydWUuIEl0IHNob3VsZFxuLy8gYmUgc2FmZSB0byByZW1vdmUgcmVnYXJkbGVzcywgYmVjYXVzZSBpdCBpc24ndCByZWFjaGFibGUsIGJ1dCBqdXN0IGluIGNhc2UuXG4vKipcbiAqICBAX2lnbm9yZTpcbiAqL1xuZXhwb3J0IGNsYXNzIEpzb25ScGNBcGlQb2xsaW5nUHJvdmlkZXIgZXh0ZW5kcyBKc29uUnBjQXBpUHJvdmlkZXIge1xuICAgICNwb2xsaW5nSW50ZXJ2YWw7XG4gICAgY29uc3RydWN0b3IobmV0d29yaywgb3B0aW9ucykge1xuICAgICAgICBzdXBlcihuZXR3b3JrLCBvcHRpb25zKTtcbiAgICAgICAgbGV0IHBvbGxpbmdJbnRlcnZhbCA9IHRoaXMuX2dldE9wdGlvbihcInBvbGxpbmdJbnRlcnZhbFwiKTtcbiAgICAgICAgaWYgKHBvbGxpbmdJbnRlcnZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICBwb2xsaW5nSW50ZXJ2YWwgPSBkZWZhdWx0T3B0aW9ucy5wb2xsaW5nSW50ZXJ2YWw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcG9sbGluZ0ludGVydmFsID0gcG9sbGluZ0ludGVydmFsO1xuICAgIH1cbiAgICBfZ2V0U3Vic2NyaWJlcihzdWIpIHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaWJlciA9IHN1cGVyLl9nZXRTdWJzY3JpYmVyKHN1Yik7XG4gICAgICAgIGlmIChpc1BvbGxhYmxlKHN1YnNjcmliZXIpKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLnBvbGxpbmdJbnRlcnZhbCA9IHRoaXMuI3BvbGxpbmdJbnRlcnZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3Vic2NyaWJlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBwb2xsaW5nIGludGVydmFsIChkZWZhdWx0OiA0MDAwIG1zKVxuICAgICAqL1xuICAgIGdldCBwb2xsaW5nSW50ZXJ2YWwoKSB7IHJldHVybiB0aGlzLiNwb2xsaW5nSW50ZXJ2YWw7IH1cbiAgICBzZXQgcG9sbGluZ0ludGVydmFsKHZhbHVlKSB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgfHwgdmFsdWUgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGludGVydmFsXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3BvbGxpbmdJbnRlcnZhbCA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9mb3JFYWNoU3Vic2NyaWJlcigoc3ViKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNQb2xsYWJsZShzdWIpKSB7XG4gICAgICAgICAgICAgICAgc3ViLnBvbGxpbmdJbnRlcnZhbCA9IHRoaXMuI3BvbGxpbmdJbnRlcnZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiAgVGhlIEpzb25ScGNQcm92aWRlciBpcyBvbmUgb2YgdGhlIG1vc3QgY29tbW9uIFByb3ZpZGVycyxcbiAqICB3aGljaCBwZXJmb3JtcyBhbGwgb3BlcmF0aW9ucyBvdmVyIEhUVFAgKG9yIEhUVFBTKSByZXF1ZXN0cy5cbiAqXG4gKiAgRXZlbnRzIGFyZSBwcm9jZXNzZWQgYnkgcG9sbGluZyB0aGUgYmFja2VuZCBmb3IgdGhlIGN1cnJlbnQgYmxvY2tcbiAqICBudW1iZXI7IHdoZW4gaXQgYWR2YW5jZXMsIGFsbCBibG9jay1iYXNlIGV2ZW50cyBhcmUgdGhlbiBjaGVja2VkXG4gKiAgZm9yIHVwZGF0ZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBKc29uUnBjUHJvdmlkZXIgZXh0ZW5kcyBKc29uUnBjQXBpUG9sbGluZ1Byb3ZpZGVyIHtcbiAgICAjY29ubmVjdDtcbiAgICBjb25zdHJ1Y3Rvcih1cmwsIG5ldHdvcmssIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHVybCA9PSBudWxsKSB7XG4gICAgICAgICAgICB1cmwgPSBcImh0dHA6L1xcL2xvY2FsaG9zdDo4NTQ1XCI7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIobmV0d29yaywgb3B0aW9ucyk7XG4gICAgICAgIGlmICh0eXBlb2YgKHVybCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRoaXMuI2Nvbm5lY3QgPSBuZXcgRmV0Y2hSZXF1ZXN0KHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiNjb25uZWN0ID0gdXJsLmNsb25lKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2dldENvbm5lY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNjb25uZWN0LmNsb25lKCk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmQobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgLy8gQWxsIHJlcXVlc3RzIGFyZSBvdmVyIEhUVFAsIHNvIHdlIGNhbiBqdXN0IHN0YXJ0IGhhbmRsaW5nIHJlcXVlc3RzXG4gICAgICAgIC8vIFdlIGRvIHRoaXMgaGVyZSByYXRoZXIgdGhhbiB0aGUgY29uc3RydWN0b3Igc28gdGhhdCB3ZSBkb24ndCBzZW5kIGFueVxuICAgICAgICAvLyByZXF1ZXN0cyB0byB0aGUgbmV0d29yayAoaS5lLiBldGhfY2hhaW5JZCkgdW50aWwgd2UgYWJzb2x1dGVseSBoYXZlIHRvLlxuICAgICAgICBhd2FpdCB0aGlzLl9zdGFydCgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgc3VwZXIuc2VuZChtZXRob2QsIHBhcmFtcyk7XG4gICAgfVxuICAgIGFzeW5jIF9zZW5kKHBheWxvYWQpIHtcbiAgICAgICAgLy8gQ29uZmlndXJlIGEgUE9TVCBjb25uZWN0aW9uIGZvciB0aGUgcmVxdWVzdGVkIG1ldGhvZFxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5fZ2V0Q29ubmVjdGlvbigpO1xuICAgICAgICByZXF1ZXN0LmJvZHkgPSBKU09OLnN0cmluZ2lmeShwYXlsb2FkKTtcbiAgICAgICAgcmVxdWVzdC5zZXRIZWFkZXIoXCJjb250ZW50LXR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3Quc2VuZCgpO1xuICAgICAgICByZXNwb25zZS5hc3NlcnRPaygpO1xuICAgICAgICBsZXQgcmVzcCA9IHJlc3BvbnNlLmJvZHlKc29uO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVzcCkpIHtcbiAgICAgICAgICAgIHJlc3AgPSBbcmVzcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgfVxufVxuZnVuY3Rpb24gc3BlbHVua0RhdGEodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gVGhlc2UgKmFyZSogdGhlIGRyb2lkcyB3ZSdyZSBsb29raW5nIGZvci5cbiAgICBpZiAodHlwZW9mICh2YWx1ZS5tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5tZXNzYWdlLm1hdGNoKC9yZXZlcnQvaSkgJiYgaXNIZXhTdHJpbmcodmFsdWUuZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogdmFsdWUubWVzc2FnZSwgZGF0YTogdmFsdWUuZGF0YSB9O1xuICAgIH1cbiAgICAvLyBTcGVsdW5rIGZ1cnRoZXIuLi5cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHNwZWx1bmtEYXRhKHZhbHVlW2tleV0pO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIE1pZ2h0IGJlIGEgSlNPTiBzdHJpbmcgd2UgY2FuIGZ1cnRoZXIgZGVzY2VuZC4uLlxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHNwZWx1bmtEYXRhKEpTT04ucGFyc2UodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIF9zcGVsdW5rTWVzc2FnZSh2YWx1ZSwgcmVzdWx0KSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBUaGVzZSAqYXJlKiB0aGUgZHJvaWRzIHdlJ3JlIGxvb2tpbmcgZm9yLlxuICAgIGlmICh0eXBlb2YgKHZhbHVlLm1lc3NhZ2UpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlLm1lc3NhZ2UpO1xuICAgIH1cbiAgICAvLyBTcGVsdW5rIGZ1cnRoZXIuLi5cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIF9zcGVsdW5rTWVzc2FnZSh2YWx1ZVtrZXldLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE1pZ2h0IGJlIGEgSlNPTiBzdHJpbmcgd2UgY2FuIGZ1cnRoZXIgZGVzY2VuZC4uLlxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIF9zcGVsdW5rTWVzc2FnZShKU09OLnBhcnNlKHZhbHVlKSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHNwZWx1bmtNZXNzYWdlKHZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgX3NwZWx1bmtNZXNzYWdlKHZhbHVlLCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci1qc29ucnBjLmpzLm1hcCJdLCJuYW1lcyI6WyJBYmlDb2RlciIsImdldEFkZHJlc3MiLCJyZXNvbHZlQWRkcmVzcyIsIlR5cGVkRGF0YUVuY29kZXIiLCJhY2Nlc3NMaXN0aWZ5IiwiYXV0aG9yaXphdGlvbmlmeSIsImRlZmluZVByb3BlcnRpZXMiLCJnZXRCaWdJbnQiLCJoZXhsaWZ5IiwiaXNIZXhTdHJpbmciLCJ0b1F1YW50aXR5IiwidG9VdGY4Qnl0ZXMiLCJpc0Vycm9yIiwibWFrZUVycm9yIiwiYXNzZXJ0IiwiYXNzZXJ0QXJndW1lbnQiLCJGZXRjaFJlcXVlc3QiLCJyZXNvbHZlUHJvcGVydGllcyIsIkFic3RyYWN0UHJvdmlkZXIiLCJVbm1hbmFnZWRTdWJzY3JpYmVyIiwiQWJzdHJhY3RTaWduZXIiLCJOZXR3b3JrIiwiRmlsdGVySWRFdmVudFN1YnNjcmliZXIiLCJGaWx0ZXJJZFBlbmRpbmdTdWJzY3JpYmVyIiwiUG9sbGluZ0V2ZW50U3Vic2NyaWJlciIsIlByaW1pdGl2ZSIsInNwbGl0IiwiZGVlcENvcHkiLCJ2YWx1ZSIsImluZGV4T2YiLCJBcnJheSIsImlzQXJyYXkiLCJtYXAiLCJPYmplY3QiLCJrZXlzIiwicmVkdWNlIiwiYWNjdW0iLCJrZXkiLCJFcnJvciIsInN0YWxsIiwiZHVyYXRpb24iLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJnZXRMb3dlckNhc2UiLCJ0b0xvd2VyQ2FzZSIsImlzUG9sbGFibGUiLCJwb2xsaW5nSW50ZXJ2YWwiLCJkZWZhdWx0T3B0aW9ucyIsInBvbGxpbmciLCJzdGF0aWNOZXR3b3JrIiwiYmF0Y2hTdGFsbFRpbWUiLCJiYXRjaE1heFNpemUiLCJiYXRjaE1heENvdW50IiwiY2FjaGVUaW1lb3V0IiwiSnNvblJwY1NpZ25lciIsImNvbm5lY3QiLCJwcm92aWRlciIsIm9wZXJhdGlvbiIsImFkZHJlc3MiLCJwb3B1bGF0ZVRyYW5zYWN0aW9uIiwidHgiLCJwb3B1bGF0ZUNhbGwiLCJzZW5kVW5jaGVja2VkVHJhbnNhY3Rpb24iLCJfdHgiLCJwcm9taXNlcyIsImZyb20iLCJfZnJvbSIsInB1c2giLCJnYXNMaW1pdCIsImVzdGltYXRlR2FzIiwidG8iLCJfdG8iLCJsZW5ndGgiLCJhbGwiLCJoZXhUeCIsImdldFJwY1RyYW5zYWN0aW9uIiwic2VuZCIsInNlbmRUcmFuc2FjdGlvbiIsImJsb2NrTnVtYmVyIiwiZ2V0QmxvY2tOdW1iZXIiLCJoYXNoIiwicmVqZWN0IiwidGltZW91dHMiLCJpbnZhbGlkcyIsImNoZWNrVHgiLCJnZXRUcmFuc2FjdGlvbiIsInJlcGxhY2VhYmxlVHJhbnNhY3Rpb24iLCJlcnJvciIsImluZm8iLCJzZW5kVHJhbnNhY3Rpb25IYXNoIiwiZW1pdCIsIl9zZXRUaW1lb3V0IiwicG9wIiwic2lnblRyYW5zYWN0aW9uIiwic2lnbk1lc3NhZ2UiLCJfbWVzc2FnZSIsIm1lc3NhZ2UiLCJzaWduVHlwZWREYXRhIiwiZG9tYWluIiwidHlwZXMiLCJfdmFsdWUiLCJwb3B1bGF0ZWQiLCJyZXNvbHZlTmFtZXMiLCJKU09OIiwic3RyaW5naWZ5IiwiZ2V0UGF5bG9hZCIsInVubG9jayIsInBhc3N3b3JkIiwiX2xlZ2FjeVNpZ25NZXNzYWdlIiwiY29uc3RydWN0b3IiLCJKc29uUnBjQXBpUHJvdmlkZXIiLCJfZ2V0T3B0aW9uIiwib3B0aW9ucyIsIl9uZXR3b3JrIiwibmV0d29yayIsIl9wZXJmb3JtIiwicmVxIiwibWV0aG9kIiwidHJhbnNhY3Rpb24iLCJ0eXBlIiwibWF4RmVlUGVyR2FzIiwibWF4UHJpb3JpdHlGZWVQZXJHYXMiLCJmZWVEYXRhIiwiZ2V0RmVlRGF0YSIsImFzc2lnbiIsInVuZGVmaW5lZCIsInJlcXVlc3QiLCJnZXRScGNSZXF1ZXN0IiwiYXJncyIsIl9kZXRlY3ROZXR3b3JrIiwicGVuZGluZ0RldGVjdE5ldHdvcmsiLCJyZWFkeSIsInJlc3VsdCIsInBheWxvYWQiLCJpZCIsIm5leHRJZCIsInBhcmFtcyIsImpzb25ycGMiLCJhY3Rpb24iLCJfc2VuZCIsImdldFJwY0Vycm9yIiwiX3N0YXJ0Iiwibm90UmVhZHkiLCJkZXN0cm95ZWQiLCJjb25zb2xlIiwibG9nIiwiZXZlbnQiLCJzY2hlZHVsZURyYWluIiwiX3dhaXRVbnRpbFJlYWR5IiwicHJvbWlzZSIsIl9nZXRTdWJzY3JpYmVyIiwic3ViIiwiZmlsdGVyIiwib3JwaGFuIiwiZm9yRWFjaCIsImRzdEtleSIsImFjY2Vzc0xpc3QiLCJibG9iVmVyc2lvbmVkSGFzaGVzIiwiaCIsImF1dGhvcml6YXRpb25MaXN0IiwiX2EiLCJhIiwibm9uY2UiLCJjaGFpbklkIiwieVBhcml0eSIsInNpZ25hdHVyZSIsInIiLCJzIiwiYmxvY2tUYWciLCJwb3NpdGlvbiIsInRvU3RyaW5nIiwic2lnbmVkVHJhbnNhY3Rpb24iLCJpbmNsdWRlVHJhbnNhY3Rpb25zIiwiYmxvY2tIYXNoIiwiX2Vycm9yIiwibXNnIiwibWF0Y2giLCJzcGVsdW5rRGF0YSIsImUiLCJnZXRCdWlsdGluQ2FsbEV4Y2VwdGlvbiIsImRhdGEiLCJzcGVsdW5rTWVzc2FnZSIsImFjdGlvbk1hcCIsImV0aF9zaWduIiwicGVyc29uYWxfc2lnbiIsImV0aF9zaWduVHlwZWREYXRhX3Y0IiwiZXRoX3NpZ25UcmFuc2FjdGlvbiIsImV0aF9zZW5kVHJhbnNhY3Rpb24iLCJldGhfcmVxdWVzdEFjY291bnRzIiwid2FsbGV0X3JlcXVlc3RBY2NvdW50cyIsInJlYXNvbiIsInVuc3VwcG9ydGVkIiwiZGV0YWlscyIsInN0YXJ0c1dpdGgiLCJwYXlsb2FkcyIsImdldFNpZ25lciIsImFjY291bnRzUHJvbWlzZSIsImFjY291bnRzIiwiZ2V0TmV0d29yayIsImFjY291bnQiLCJsaXN0QWNjb3VudHMiLCJkZXN0cm95IiwiZHJhaW5UaW1lciIsImNsZWFyVGltZW91dCIsIl9yZXNvbHZlIiwibWF0Y2hlcyIsInN0YWxsVGltZSIsImJhdGNoIiwic2hpZnQiLCJieXRlcyIsInAiLCJ1bnNoaWZ0IiwicmVzcCIsIkpzb25ScGNBcGlQb2xsaW5nUHJvdmlkZXIiLCJzdWJzY3JpYmVyIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiX2ZvckVhY2hTdWJzY3JpYmVyIiwiSnNvblJwY1Byb3ZpZGVyIiwiX2dldENvbm5lY3Rpb24iLCJjbG9uZSIsImJvZHkiLCJzZXRIZWFkZXIiLCJyZXNwb25zZSIsImFzc2VydE9rIiwiYm9keUpzb24iLCJ1cmwiLCJwYXJzZSIsIl9zcGVsdW5rTWVzc2FnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/providers/provider.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/provider.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Block: function() { return /* binding */ Block; },\n/* harmony export */   FeeData: function() { return /* binding */ FeeData; },\n/* harmony export */   Log: function() { return /* binding */ Log; },\n/* harmony export */   TransactionReceipt: function() { return /* binding */ TransactionReceipt; },\n/* harmony export */   TransactionResponse: function() { return /* binding */ TransactionResponse; },\n/* harmony export */   copyRequest: function() { return /* binding */ copyRequest; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_get */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_get.js\");\n/* harmony import */ var _swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_init */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_init.js\");\n/* harmony import */ var _swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_set */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_set.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../transaction/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/transaction/accesslist.js\");\n//import { resolveAddress } from \"@ethersproject/address\";\n\n\n\n\n\nconst BN_0 = BigInt(0);\n// -----------------------\nfunction getValue(value) {\n    if (value == null) {\n        return null;\n    }\n    return value;\n}\nfunction toJson(value) {\n    if (value == null) {\n        return null;\n    }\n    return value.toString();\n}\n// @TODO? <T extends FeeData = { }> implements Required<T>\n/**\n *  A **FeeData** wraps all the fee-related values associated with\n *  the network.\n */ class FeeData {\n    /**\n     *  Returns a JSON-friendly value.\n     */ toJSON() {\n        const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = this;\n        return {\n            _type: \"FeeData\",\n            gasPrice: toJson(gasPrice),\n            maxFeePerGas: toJson(maxFeePerGas),\n            maxPriorityFeePerGas: toJson(maxPriorityFeePerGas)\n        };\n    }\n    /**\n     *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and\n     *  %%maxPriorityFeePerGas%%.\n     */ constructor(gasPrice, maxFeePerGas, maxPriorityFeePerGas){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            gasPrice: getValue(gasPrice),\n            maxFeePerGas: getValue(maxFeePerGas),\n            maxPriorityFeePerGas: getValue(maxPriorityFeePerGas)\n        });\n    }\n}\n;\n/**\n *  Returns a copy of %%req%% with all properties coerced to their strict\n *  types.\n */ function copyRequest(req) {\n    const result = {};\n    // These could be addresses, ENS names or Addressables\n    if (req.to) {\n        result.to = req.to;\n    }\n    if (req.from) {\n        result.from = req.from;\n    }\n    if (req.data) {\n        result.data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(req.data);\n    }\n    const bigIntKeys = \"chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value\".split(/,/);\n    for (const key of bigIntKeys){\n        if (!(key in req) || req[key] == null) {\n            continue;\n        }\n        result[key] = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBigInt)(req[key], \"request.\".concat(key));\n    }\n    const numberKeys = \"type,nonce\".split(/,/);\n    for (const key of numberKeys){\n        if (!(key in req) || req[key] == null) {\n            continue;\n        }\n        result[key] = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getNumber)(req[key], \"request.\".concat(key));\n    }\n    if (req.accessList) {\n        result.accessList = (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_3__.accessListify)(req.accessList);\n    }\n    if (req.authorizationList) {\n        result.authorizationList = req.authorizationList.slice();\n    }\n    if (\"blockTag\" in req) {\n        result.blockTag = req.blockTag;\n    }\n    if (\"enableCcipRead\" in req) {\n        result.enableCcipRead = !!req.enableCcipRead;\n    }\n    if (\"customData\" in req) {\n        result.customData = req.customData;\n    }\n    if (\"blobVersionedHashes\" in req && req.blobVersionedHashes) {\n        result.blobVersionedHashes = req.blobVersionedHashes.slice();\n    }\n    if (\"kzg\" in req) {\n        result.kzg = req.kzg;\n    }\n    if (\"blobWrapperVersion\" in req) {\n        result.blobWrapperVersion = req.blobWrapperVersion;\n    }\n    if (\"blobs\" in req && req.blobs) {\n        result.blobs = req.blobs.map((b)=>{\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isBytesLike)(b)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(b);\n            }\n            return Object.assign({}, b);\n        });\n    }\n    return result;\n}\nvar _transactions = /*#__PURE__*/ new WeakMap();\nlet _Symbol_iterator = Symbol.iterator;\n/**\n *  A **Block** represents the data associated with a full block on\n *  Ethereum.\n */ class Block {\n    /**\n     *  Returns the list of transaction hashes, in the order\n     *  they were executed within the block.\n     */ get transactions() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _transactions).map((tx)=>{\n            if (typeof tx === \"string\") {\n                return tx;\n            }\n            return tx.hash;\n        });\n    }\n    /**\n     *  Returns the complete transactions, in the order they\n     *  were executed within the block.\n     *\n     *  This is only available for blocks which prefetched\n     *  transactions, by passing ``true`` to %%prefetchTxs%%\n     *  into [[Provider-getBlock]].\n     */ get prefetchedTransactions() {\n        const txs = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _transactions).slice();\n        // Doesn't matter...\n        if (txs.length === 0) {\n            return [];\n        }\n        // Make sure we prefetched the transactions\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.assert)(typeof txs[0] === \"object\", \"transactions were not prefetched with block request\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"transactionResponses()\"\n        });\n        return txs;\n    }\n    /**\n     *  Returns a JSON-friendly value.\n     */ toJSON() {\n        const { baseFeePerGas, difficulty, extraData, gasLimit, gasUsed, hash, miner, prevRandao, nonce, number, parentHash, parentBeaconBlockRoot, stateRoot, receiptsRoot, timestamp, transactions } = this;\n        return {\n            _type: \"Block\",\n            baseFeePerGas: toJson(baseFeePerGas),\n            difficulty: toJson(difficulty),\n            extraData,\n            gasLimit: toJson(gasLimit),\n            gasUsed: toJson(gasUsed),\n            blobGasUsed: toJson(this.blobGasUsed),\n            excessBlobGas: toJson(this.excessBlobGas),\n            hash,\n            miner,\n            prevRandao,\n            nonce,\n            number,\n            parentHash,\n            timestamp,\n            parentBeaconBlockRoot,\n            stateRoot,\n            receiptsRoot,\n            transactions\n        };\n    }\n    [_Symbol_iterator]() {\n        let index = 0;\n        const txs = this.transactions;\n        return {\n            next: ()=>{\n                if (index < this.length) {\n                    return {\n                        value: txs[index++],\n                        done: false\n                    };\n                }\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n        };\n    }\n    /**\n     *  The number of transactions in this block.\n     */ get length() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _transactions).length;\n    }\n    /**\n     *  The [[link-js-date]] this block was included at.\n     */ get date() {\n        if (this.timestamp == null) {\n            return null;\n        }\n        return new Date(this.timestamp * 1000);\n    }\n    /**\n     *  Get the transaction at %%indexe%% within this block.\n     */ async getTransaction(indexOrHash) {\n        // Find the internal value by its index or hash\n        let tx = undefined;\n        if (typeof indexOrHash === \"number\") {\n            tx = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _transactions)[indexOrHash];\n        } else {\n            const hash = indexOrHash.toLowerCase();\n            for (const v of (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _transactions)){\n                if (typeof v === \"string\") {\n                    if (v !== hash) {\n                        continue;\n                    }\n                    tx = v;\n                    break;\n                } else {\n                    if (v.hash !== hash) {\n                        continue;\n                    }\n                    tx = v;\n                    break;\n                }\n            }\n        }\n        if (tx == null) {\n            throw new Error(\"no such tx\");\n        }\n        if (typeof tx === \"string\") {\n            return await this.provider.getTransaction(tx);\n        } else {\n            return tx;\n        }\n    }\n    /**\n     *  If a **Block** was fetched with a request to include the transactions\n     *  this will allow synchronous access to those transactions.\n     *\n     *  If the transactions were not prefetched, this will throw.\n     */ getPrefetchedTransaction(indexOrHash) {\n        const txs = this.prefetchedTransactions;\n        if (typeof indexOrHash === \"number\") {\n            return txs[indexOrHash];\n        }\n        indexOrHash = indexOrHash.toLowerCase();\n        for (const tx of txs){\n            if (tx.hash === indexOrHash) {\n                return tx;\n            }\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.assertArgument)(false, \"no matching transaction\", \"indexOrHash\", indexOrHash);\n    }\n    /**\n     *  Returns true if this block been mined. This provides a type guard\n     *  for all properties on a [[MinedBlock]].\n     */ isMined() {\n        return !!this.hash;\n    }\n    /**\n     *  Returns true if this block is an [[link-eip-2930]] block.\n     */ isLondon() {\n        return !!this.baseFeePerGas;\n    }\n    /**\n     *  @_ignore:\n     */ orphanedEvent() {\n        if (!this.isMined()) {\n            throw new Error(\"\");\n        }\n        return createOrphanedBlockFilter(this);\n    }\n    /**\n     *  Create a new **Block** object.\n     *\n     *  This should generally not be necessary as the unless implementing a\n     *  low-level library.\n     */ constructor(block, provider){\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_6__._)(this, _transactions, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_7__._)(this, _transactions, block.transactions.map((tx)=>{\n            if (typeof tx !== \"string\") {\n                return new TransactionResponse(tx, provider);\n            }\n            return tx;\n        }));\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            provider,\n            hash: getValue(block.hash),\n            number: block.number,\n            timestamp: block.timestamp,\n            parentHash: block.parentHash,\n            parentBeaconBlockRoot: block.parentBeaconBlockRoot,\n            nonce: block.nonce,\n            difficulty: block.difficulty,\n            gasLimit: block.gasLimit,\n            gasUsed: block.gasUsed,\n            blobGasUsed: block.blobGasUsed,\n            excessBlobGas: block.excessBlobGas,\n            miner: block.miner,\n            prevRandao: getValue(block.prevRandao),\n            extraData: block.extraData,\n            baseFeePerGas: getValue(block.baseFeePerGas),\n            stateRoot: block.stateRoot,\n            receiptsRoot: block.receiptsRoot\n        });\n    }\n}\n//////////////////////\n// Log\n/**\n *  A **Log** in Ethereum represents an event that has been included in a\n *  transaction using the ``LOG*`` opcodes, which are most commonly used by\n *  Solidity's emit for announcing events.\n */ class Log {\n    /**\n     *  Returns a JSON-compatible object.\n     */ toJSON() {\n        const { address, blockHash, blockNumber, data, index, removed, topics, transactionHash, transactionIndex } = this;\n        return {\n            _type: \"log\",\n            address,\n            blockHash,\n            blockNumber,\n            data,\n            index,\n            removed,\n            topics,\n            transactionHash,\n            transactionIndex\n        };\n    }\n    /**\n     *  Returns the block that this log occurred in.\n     */ async getBlock() {\n        const block = await this.provider.getBlock(this.blockHash);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.assert)(!!block, \"failed to find transaction\", \"UNKNOWN_ERROR\", {});\n        return block;\n    }\n    /**\n     *  Returns the transaction that this log occurred in.\n     */ async getTransaction() {\n        const tx = await this.provider.getTransaction(this.transactionHash);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.assert)(!!tx, \"failed to find transaction\", \"UNKNOWN_ERROR\", {});\n        return tx;\n    }\n    /**\n     *  Returns the transaction receipt fot the transaction that this\n     *  log occurred in.\n     */ async getTransactionReceipt() {\n        const receipt = await this.provider.getTransactionReceipt(this.transactionHash);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.assert)(!!receipt, \"failed to find transaction receipt\", \"UNKNOWN_ERROR\", {});\n        return receipt;\n    }\n    /**\n     *  @_ignore:\n     */ removedEvent() {\n        return createRemovedLogFilter(this);\n    }\n    /**\n     *  @_ignore:\n     */ constructor(log, provider){\n        this.provider = provider;\n        const topics = Object.freeze(log.topics.slice());\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            transactionHash: log.transactionHash,\n            blockHash: log.blockHash,\n            blockNumber: log.blockNumber,\n            removed: log.removed,\n            address: log.address,\n            data: log.data,\n            topics,\n            index: log.index,\n            transactionIndex: log.transactionIndex\n        });\n    }\n}\nvar _logs = /*#__PURE__*/ new WeakMap();\nlet _Symbol_iterator1 = Symbol.iterator;\n//////////////////////\n// Transaction Receipt\n/*\nexport interface LegacyTransactionReceipt {\n    byzantium: false;\n    status: null;\n    root: string;\n}\n\nexport interface ByzantiumTransactionReceipt {\n    byzantium: true;\n    status: number;\n    root: null;\n}\n*/ /**\n *  A **TransactionReceipt** includes additional information about a\n *  transaction that is only available after it has been mined.\n */ class TransactionReceipt {\n    /**\n     *  The logs for this transaction.\n     */ get logs() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _logs);\n    }\n    /**\n     *  Returns a JSON-compatible representation.\n     */ toJSON() {\n        const { to, from, contractAddress, hash, index, blockHash, blockNumber, logsBloom, logs, status, root } = this;\n        return {\n            _type: \"TransactionReceipt\",\n            blockHash,\n            blockNumber,\n            //byzantium, \n            contractAddress,\n            cumulativeGasUsed: toJson(this.cumulativeGasUsed),\n            from,\n            gasPrice: toJson(this.gasPrice),\n            blobGasUsed: toJson(this.blobGasUsed),\n            blobGasPrice: toJson(this.blobGasPrice),\n            gasUsed: toJson(this.gasUsed),\n            hash,\n            index,\n            logs,\n            logsBloom,\n            root,\n            status,\n            to\n        };\n    }\n    /**\n     *  @_ignore:\n     */ get length() {\n        return this.logs.length;\n    }\n    [_Symbol_iterator1]() {\n        let index = 0;\n        return {\n            next: ()=>{\n                if (index < this.length) {\n                    return {\n                        value: this.logs[index++],\n                        done: false\n                    };\n                }\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n        };\n    }\n    /**\n     *  The total fee for this transaction, in wei.\n     */ get fee() {\n        return this.gasUsed * this.gasPrice;\n    }\n    /**\n     *  Resolves to the block this transaction occurred in.\n     */ async getBlock() {\n        const block = await this.provider.getBlock(this.blockHash);\n        if (block == null) {\n            throw new Error(\"TODO\");\n        }\n        return block;\n    }\n    /**\n     *  Resolves to the transaction this transaction occurred in.\n     */ async getTransaction() {\n        const tx = await this.provider.getTransaction(this.hash);\n        if (tx == null) {\n            throw new Error(\"TODO\");\n        }\n        return tx;\n    }\n    /**\n     *  Resolves to the return value of the execution of this transaction.\n     *\n     *  Support for this feature is limited, as it requires an archive node\n     *  with the ``debug_`` or ``trace_`` API enabled.\n     */ async getResult() {\n        return await this.provider.getTransactionResult(this.hash);\n    }\n    /**\n     *  Resolves to the number of confirmations this transaction has.\n     */ async confirmations() {\n        return await this.provider.getBlockNumber() - this.blockNumber + 1;\n    }\n    /**\n     *  @_ignore:\n     */ removedEvent() {\n        return createRemovedTransactionFilter(this);\n    }\n    /**\n     *  @_ignore:\n     */ reorderedEvent(other) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.assert)(!other || other.isMined(), \"unmined 'other' transction cannot be orphaned\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"reorderedEvent(other)\"\n        });\n        return createReorderedTransactionFilter(this, other);\n    }\n    /**\n     *  @_ignore:\n     */ constructor(tx, provider){\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_6__._)(this, _logs, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_7__._)(this, _logs, Object.freeze(tx.logs.map((log)=>{\n            return new Log(log, provider);\n        })));\n        let gasPrice = BN_0;\n        if (tx.effectiveGasPrice != null) {\n            gasPrice = tx.effectiveGasPrice;\n        } else if (tx.gasPrice != null) {\n            gasPrice = tx.gasPrice;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            provider,\n            to: tx.to,\n            from: tx.from,\n            contractAddress: tx.contractAddress,\n            hash: tx.hash,\n            index: tx.index,\n            blockHash: tx.blockHash,\n            blockNumber: tx.blockNumber,\n            logsBloom: tx.logsBloom,\n            gasUsed: tx.gasUsed,\n            cumulativeGasUsed: tx.cumulativeGasUsed,\n            blobGasUsed: tx.blobGasUsed,\n            gasPrice,\n            blobGasPrice: tx.blobGasPrice,\n            type: tx.type,\n            //byzantium: tx.byzantium,\n            status: tx.status,\n            root: tx.root\n        });\n    }\n}\nvar _startBlock = /*#__PURE__*/ new WeakMap();\n/**\n *  A **TransactionResponse** includes all properties about a transaction\n *  that was sent to the network, which may or may not be included in a\n *  block.\n *\n *  The [[TransactionResponse-isMined]] can be used to check if the\n *  transaction has been mined as well as type guard that the otherwise\n *  possibly ``null`` properties are defined.\n */ class TransactionResponse {\n    /**\n     *  Returns a JSON-compatible representation of this transaction.\n     */ toJSON() {\n        const { blockNumber, blockHash, index, hash, type, to, from, nonce, data, signature, accessList, blobVersionedHashes } = this;\n        return {\n            _type: \"TransactionResponse\",\n            accessList,\n            blockNumber,\n            blockHash,\n            blobVersionedHashes,\n            chainId: toJson(this.chainId),\n            data,\n            from,\n            gasLimit: toJson(this.gasLimit),\n            gasPrice: toJson(this.gasPrice),\n            hash,\n            maxFeePerGas: toJson(this.maxFeePerGas),\n            maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),\n            maxFeePerBlobGas: toJson(this.maxFeePerBlobGas),\n            nonce,\n            signature,\n            to,\n            index,\n            type,\n            value: toJson(this.value)\n        };\n    }\n    /**\n     *  Resolves to the Block that this transaction was included in.\n     *\n     *  This will return null if the transaction has not been included yet.\n     */ async getBlock() {\n        let blockNumber = this.blockNumber;\n        if (blockNumber == null) {\n            const tx = await this.getTransaction();\n            if (tx) {\n                blockNumber = tx.blockNumber;\n            }\n        }\n        if (blockNumber == null) {\n            return null;\n        }\n        const block = this.provider.getBlock(blockNumber);\n        if (block == null) {\n            throw new Error(\"TODO\");\n        }\n        return block;\n    }\n    /**\n     *  Resolves to this transaction being re-requested from the\n     *  provider. This can be used if you have an unmined transaction\n     *  and wish to get an up-to-date populated instance.\n     */ async getTransaction() {\n        return this.provider.getTransaction(this.hash);\n    }\n    /**\n     *  Resolve to the number of confirmations this transaction has.\n     */ async confirmations() {\n        if (this.blockNumber == null) {\n            const { tx, blockNumber } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n                tx: this.getTransaction(),\n                blockNumber: this.provider.getBlockNumber()\n            });\n            // Not mined yet...\n            if (tx == null || tx.blockNumber == null) {\n                return 0;\n            }\n            return blockNumber - tx.blockNumber + 1;\n        }\n        const blockNumber = await this.provider.getBlockNumber();\n        return blockNumber - this.blockNumber + 1;\n    }\n    /**\n     *  Resolves once this transaction has been mined and has\n     *  %%confirms%% blocks including it (default: ``1``) with an\n     *  optional %%timeout%%.\n     *\n     *  This can resolve to ``null`` only if %%confirms%% is ``0``\n     *  and the transaction has not been mined, otherwise this will\n     *  wait until enough confirmations have completed.\n     */ async wait(_confirms, _timeout) {\n        const confirms = _confirms == null ? 1 : _confirms;\n        const timeout = _timeout == null ? 0 : _timeout;\n        let startBlock = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _startBlock);\n        let nextScan = -1;\n        let stopScanning = startBlock === -1 ? true : false;\n        const checkReplacement = async ()=>{\n            // Get the current transaction count for this sender\n            if (stopScanning) {\n                return null;\n            }\n            const { blockNumber, nonce } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n                blockNumber: this.provider.getBlockNumber(),\n                nonce: this.provider.getTransactionCount(this.from)\n            });\n            // No transaction or our nonce has not been mined yet; but we\n            // can start scanning later when we do start\n            if (nonce < this.nonce) {\n                startBlock = blockNumber;\n                return;\n            }\n            // We were mined; no replacement\n            if (stopScanning) {\n                return null;\n            }\n            const mined = await this.getTransaction();\n            if (mined && mined.blockNumber != null) {\n                return;\n            }\n            // We were replaced; start scanning for that transaction\n            // Starting to scan; look back a few extra blocks for safety\n            if (nextScan === -1) {\n                nextScan = startBlock - 3;\n                if (nextScan < (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _startBlock)) {\n                    nextScan = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _startBlock);\n                }\n            }\n            while(nextScan <= blockNumber){\n                // Get the next block to scan\n                if (stopScanning) {\n                    return null;\n                }\n                const block = await this.provider.getBlock(nextScan, true);\n                // This should not happen; but we'll try again shortly\n                if (block == null) {\n                    return;\n                }\n                // We were mined; no replacement\n                for (const hash of block){\n                    if (hash === this.hash) {\n                        return;\n                    }\n                }\n                // Search for the transaction that replaced us\n                for(let i = 0; i < block.length; i++){\n                    const tx = await block.getTransaction(i);\n                    if (tx.from === this.from && tx.nonce === this.nonce) {\n                        // Get the receipt\n                        if (stopScanning) {\n                            return null;\n                        }\n                        const receipt = await this.provider.getTransactionReceipt(tx.hash);\n                        // This should not happen; but we'll try again shortly\n                        if (receipt == null) {\n                            return;\n                        }\n                        // We will retry this on the next block (this case could be optimized)\n                        if (blockNumber - receipt.blockNumber + 1 < confirms) {\n                            return;\n                        }\n                        // The reason we were replaced\n                        let reason = \"replaced\";\n                        if (tx.data === this.data && tx.to === this.to && tx.value === this.value) {\n                            reason = \"repriced\";\n                        } else if (tx.data === \"0x\" && tx.from === tx.to && tx.value === BN_0) {\n                            reason = \"cancelled\";\n                        }\n                        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.assert)(false, \"transaction was replaced\", \"TRANSACTION_REPLACED\", {\n                            cancelled: reason === \"replaced\" || reason === \"cancelled\",\n                            reason,\n                            replacement: tx.replaceableTransaction(startBlock),\n                            hash: tx.hash,\n                            receipt\n                        });\n                    }\n                }\n                nextScan++;\n            }\n            return;\n        };\n        const checkReceipt = (receipt)=>{\n            if (receipt == null || receipt.status !== 0) {\n                return receipt;\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.assert)(false, \"transaction execution reverted\", \"CALL_EXCEPTION\", {\n                action: \"sendTransaction\",\n                data: null,\n                reason: null,\n                invocation: null,\n                revert: null,\n                transaction: {\n                    to: receipt.to,\n                    from: receipt.from,\n                    data: \"\" // @TODO: in v7, split out sendTransaction properties\n                },\n                receipt\n            });\n        };\n        const receipt = await this.provider.getTransactionReceipt(this.hash);\n        if (confirms === 0) {\n            return checkReceipt(receipt);\n        }\n        if (receipt) {\n            if (confirms === 1 || await receipt.confirmations() >= confirms) {\n                return checkReceipt(receipt);\n            }\n        } else {\n            // Check for a replacement; throws if a replacement was found\n            await checkReplacement();\n            // Allow null only when the confirms is 0\n            if (confirms === 0) {\n                return null;\n            }\n        }\n        const waiter = new Promise((resolve, reject)=>{\n            // List of things to cancel when we have a result (one way or the other)\n            const cancellers = [];\n            const cancel = ()=>{\n                cancellers.forEach((c)=>c());\n            };\n            // On cancel, stop scanning for replacements\n            cancellers.push(()=>{\n                stopScanning = true;\n            });\n            // Set up any timeout requested\n            if (timeout > 0) {\n                const timer = setTimeout(()=>{\n                    cancel();\n                    reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.makeError)(\"wait for transaction timeout\", \"TIMEOUT\"));\n                }, timeout);\n                cancellers.push(()=>{\n                    clearTimeout(timer);\n                });\n            }\n            const txListener = async (receipt)=>{\n                // Done; return it!\n                if (await receipt.confirmations() >= confirms) {\n                    cancel();\n                    try {\n                        resolve(checkReceipt(receipt));\n                    } catch (error) {\n                        reject(error);\n                    }\n                }\n            };\n            cancellers.push(()=>{\n                this.provider.off(this.hash, txListener);\n            });\n            this.provider.on(this.hash, txListener);\n            // We support replacement detection; start checking\n            if (startBlock >= 0) {\n                const replaceListener = async ()=>{\n                    try {\n                        // Check for a replacement; this throws only if one is found\n                        await checkReplacement();\n                    } catch (error) {\n                        // We were replaced (with enough confirms); re-throw the error\n                        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.isError)(error, \"TRANSACTION_REPLACED\")) {\n                            cancel();\n                            reject(error);\n                            return;\n                        }\n                    }\n                    // Rescheudle a check on the next block\n                    if (!stopScanning) {\n                        this.provider.once(\"block\", replaceListener);\n                    }\n                };\n                cancellers.push(()=>{\n                    this.provider.off(\"block\", replaceListener);\n                });\n                this.provider.once(\"block\", replaceListener);\n            }\n        });\n        return await waiter;\n    }\n    /**\n     *  Returns ``true`` if this transaction has been included.\n     *\n     *  This is effective only as of the time the TransactionResponse\n     *  was instantiated. To get up-to-date information, use\n     *  [[getTransaction]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  non-null property values for properties that are null for\n     *  unmined transactions.\n     */ isMined() {\n        return this.blockHash != null;\n    }\n    /**\n     *  Returns true if the transaction is a legacy (i.e. ``type == 0``)\n     *  transaction.\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */ isLegacy() {\n        return this.type === 0;\n    }\n    /**\n     *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)\n     *  transaction. See [[link-eip-2070]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */ isBerlin() {\n        return this.type === 1;\n    }\n    /**\n     *  Returns true if the transaction is a London (i.e. ``type == 2``)\n     *  transaction. See [[link-eip-1559]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */ isLondon() {\n        return this.type === 2;\n    }\n    /**\n     *  Returns true if hte transaction is a Cancun (i.e. ``type == 3``)\n     *  transaction. See [[link-eip-4844]].\n     */ isCancun() {\n        return this.type === 3;\n    }\n    /**\n     *  Returns a filter which can be used to listen for orphan events\n     *  that evict this transaction.\n     */ removedEvent() {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.assert)(this.isMined(), \"unmined transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"removeEvent()\"\n        });\n        return createRemovedTransactionFilter(this);\n    }\n    /**\n     *  Returns a filter which can be used to listen for orphan events\n     *  that re-order this event against %%other%%.\n     */ reorderedEvent(other) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.assert)(this.isMined(), \"unmined transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"removeEvent()\"\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.assert)(!other || other.isMined(), \"unmined 'other' transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"removeEvent()\"\n        });\n        return createReorderedTransactionFilter(this, other);\n    }\n    /**\n     *  Returns a new TransactionResponse instance which has the ability to\n     *  detect (and throw an error) if the transaction is replaced, which\n     *  will begin scanning at %%startBlock%%.\n     *\n     *  This should generally not be used by developers and is intended\n     *  primarily for internal use. Setting an incorrect %%startBlock%% can\n     *  have devastating performance consequences if used incorrectly.\n     */ replaceableTransaction(startBlock) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.assertArgument)(Number.isInteger(startBlock) && startBlock >= 0, \"invalid startBlock\", \"startBlock\", startBlock);\n        const tx = new TransactionResponse(this, this.provider);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_7__._)(tx, _startBlock, startBlock);\n        return tx;\n    }\n    /**\n     *  @_ignore:\n     */ constructor(tx, provider){\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_6__._)(this, _startBlock, {\n            writable: true,\n            value: void 0\n        });\n        this.provider = provider;\n        this.blockNumber = tx.blockNumber != null ? tx.blockNumber : null;\n        this.blockHash = tx.blockHash != null ? tx.blockHash : null;\n        this.hash = tx.hash;\n        this.index = tx.index;\n        this.type = tx.type;\n        this.from = tx.from;\n        this.to = tx.to || null;\n        this.gasLimit = tx.gasLimit;\n        this.nonce = tx.nonce;\n        this.data = tx.data;\n        this.value = tx.value;\n        this.gasPrice = tx.gasPrice;\n        this.maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? tx.maxPriorityFeePerGas : null;\n        this.maxFeePerGas = tx.maxFeePerGas != null ? tx.maxFeePerGas : null;\n        this.maxFeePerBlobGas = tx.maxFeePerBlobGas != null ? tx.maxFeePerBlobGas : null;\n        this.chainId = tx.chainId;\n        this.signature = tx.signature;\n        this.accessList = tx.accessList != null ? tx.accessList : null;\n        this.blobVersionedHashes = tx.blobVersionedHashes != null ? tx.blobVersionedHashes : null;\n        this.authorizationList = tx.authorizationList != null ? tx.authorizationList : null;\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_7__._)(this, _startBlock, -1);\n    }\n}\nfunction createOrphanedBlockFilter(block) {\n    return {\n        orphan: \"drop-block\",\n        hash: block.hash,\n        number: block.number\n    };\n}\nfunction createReorderedTransactionFilter(tx, other) {\n    return {\n        orphan: \"reorder-transaction\",\n        tx,\n        other\n    };\n}\nfunction createRemovedTransactionFilter(tx) {\n    return {\n        orphan: \"drop-transaction\",\n        tx\n    };\n}\nfunction createRemovedLogFilter(log) {\n    return {\n        orphan: \"drop-log\",\n        log: {\n            transactionHash: log.transactionHash,\n            blockHash: log.blockHash,\n            blockNumber: log.blockNumber,\n            address: log.address,\n            data: log.data,\n            topics: Object.freeze(log.topics.slice()),\n            index: log.index\n        }\n    };\n} //# sourceMappingURL=provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwwREFBMEQ7Ozs7QUFDc0c7QUFDeEc7QUFDeEQsTUFBTVcsT0FBT0MsT0FBTztBQUNwQiwwQkFBMEI7QUFDMUIsU0FBU0MsU0FBU0MsS0FBSztJQUNuQixJQUFJQSxTQUFTLE1BQU07UUFDZixPQUFPO0lBQ1g7SUFDQSxPQUFPQTtBQUNYO0FBQ0EsU0FBU0MsT0FBT0QsS0FBSztJQUNqQixJQUFJQSxTQUFTLE1BQU07UUFDZixPQUFPO0lBQ1g7SUFDQSxPQUFPQSxNQUFNRSxRQUFRO0FBQ3pCO0FBQ0EsMERBQTBEO0FBQzFEOzs7Q0FHQyxHQUNNLE1BQU1DO0lBdUNUOztLQUVDLEdBQ0RDLFNBQVM7UUFDTCxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsWUFBWSxFQUFFQyxvQkFBb0IsRUFBRSxHQUFHLElBQUk7UUFDN0QsT0FBTztZQUNIQyxPQUFPO1lBQ1BILFVBQVVKLE9BQU9JO1lBQ2pCQyxjQUFjTCxPQUFPSztZQUNyQkMsc0JBQXNCTixPQUFPTTtRQUNqQztJQUNKO0lBdEJBOzs7S0FHQyxHQUNERSxZQUFZSixRQUFRLEVBQUVDLFlBQVksRUFBRUMsb0JBQW9CLENBQUU7UUFDdERyQixpRUFBZ0JBLENBQUMsSUFBSSxFQUFFO1lBQ25CbUIsVUFBVU4sU0FBU007WUFDbkJDLGNBQWNQLFNBQVNPO1lBQ3ZCQyxzQkFBc0JSLFNBQVNRO1FBQ25DO0lBQ0o7QUFhSjs7QUFFQTs7O0NBR0MsR0FDTSxTQUFTRyxZQUFZQyxHQUFHO0lBQzNCLE1BQU1DLFNBQVMsQ0FBQztJQUNoQixzREFBc0Q7SUFDdEQsSUFBSUQsSUFBSUUsRUFBRSxFQUFFO1FBQ1JELE9BQU9DLEVBQUUsR0FBR0YsSUFBSUUsRUFBRTtJQUN0QjtJQUNBLElBQUlGLElBQUlHLElBQUksRUFBRTtRQUNWRixPQUFP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V1csSUFBSVgsU0FBUztZQUN4QkMsYUFBYVUsSUFBSVYsV0FBVztZQUM1QkYsU0FBU1ksSUFBSVosT0FBTztZQUNwQmpFLE1BQU02RSxJQUFJN0UsSUFBSTtZQUNkcUUsUUFBUXBELE9BQU82RCxNQUFNLENBQUNELElBQUlSLE1BQU0sQ0FBQzlELEtBQUs7WUFDdENzQyxPQUFPZ0MsSUFBSWhDLEtBQUs7UUFDcEI7SUFBRTtBQUNWLEVBQ0Esb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXIuanM/NjhhNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvL2ltcG9ydCB7IHJlc29sdmVBZGRyZXNzIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2FkZHJlc3NcIjtcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGdldEJpZ0ludCwgZ2V0TnVtYmVyLCBoZXhsaWZ5LCBpc0J5dGVzTGlrZSwgcmVzb2x2ZVByb3BlcnRpZXMsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQsIGlzRXJyb3IsIG1ha2VFcnJvciB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgYWNjZXNzTGlzdGlmeSB9IGZyb20gXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBnZXRWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiB0b0pzb24odmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG59XG4vLyBAVE9ETz8gPFQgZXh0ZW5kcyBGZWVEYXRhID0geyB9PiBpbXBsZW1lbnRzIFJlcXVpcmVkPFQ+XG4vKipcbiAqICBBICoqRmVlRGF0YSoqIHdyYXBzIGFsbCB0aGUgZmVlLXJlbGF0ZWQgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aFxuICogIHRoZSBuZXR3b3JrLlxuICovXG5leHBvcnQgY2xhc3MgRmVlRGF0YSB7XG4gICAgLyoqXG4gICAgICogIFRoZSBnYXMgcHJpY2UgZm9yIGxlZ2FjeSBuZXR3b3Jrcy5cbiAgICAgKi9cbiAgICBnYXNQcmljZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIG1heGltdW0gZmVlIHRvIHBheSBwZXIgZ2FzLlxuICAgICAqXG4gICAgICogIFRoZSBiYXNlIGZlZSBwZXIgZ2FzIGlzIGRlZmluZWQgYnkgdGhlIG5ldHdvcmsgYW5kIGJhc2VkIG9uXG4gICAgICogIGNvbmdlc3Rpb24sIGluY3JlYXNpbmcgdGhlIGNvc3QgZHVyaW5nIHRpbWVzIG9mIGhlYXZ5IGxvYWRcbiAgICAgKiAgYW5kIGxvd2VyaW5nIHdoZW4gbGVzcyBidXN5LlxuICAgICAqXG4gICAgICogIFRoZSBhY3R1YWwgZmVlIHBlciBnYXMgd2lsbCBiZSB0aGUgYmFzZSBmZWUgZm9yIHRoZSBibG9ja1xuICAgICAqICBhbmQgdGhlIHByaW9yaXR5IGZlZSwgdXAgdG8gdGhlIG1heCBmZWUgcGVyIGdhcy5cbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgYmUgYGBudWxsYGAgb24gbGVnYWN5IG5ldHdvcmtzIChpLmUuIFtwcmUtRUlQLTE1NTldKGxpbmstZWlwLTE1NTkpKVxuICAgICAqL1xuICAgIG1heEZlZVBlckdhcztcbiAgICAvKipcbiAgICAgKiAgVGhlIGFkZGl0aW9uYWwgYW1vdXQgdG8gcGF5IHBlciBnYXMgdG8gZW5jb3VyYWdlIGEgdmFsaWRhdG9yXG4gICAgICogIHRvIGluY2x1ZGUgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIFRoZSBwdXJwb3NlIG9mIHRoaXMgaXMgdG8gY29tcGVuc2F0ZSB0aGUgdmFsaWRhdG9yIGZvciB0aGVcbiAgICAgKiAgYWRqdXN0ZWQgcmlzayBmb3IgaW5jbHVkaW5nIGEgZ2l2ZW4gdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIGJlIGBgbnVsbGBgIG9uIGxlZ2FjeSBuZXR3b3JrcyAoaS5lLiBbcHJlLUVJUC0xNTU5XShsaW5rLWVpcC0xNTU5KSlcbiAgICAgKi9cbiAgICBtYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBGZWVEYXRhIGZvciAlJWdhc1ByaWNlJSUsICUlbWF4RmVlUGVyR2FzJSUgYW5kXG4gICAgICogICUlbWF4UHJpb3JpdHlGZWVQZXJHYXMlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihnYXNQcmljZSwgbWF4RmVlUGVyR2FzLCBtYXhQcmlvcml0eUZlZVBlckdhcykge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIGdhc1ByaWNlOiBnZXRWYWx1ZShnYXNQcmljZSksXG4gICAgICAgICAgICBtYXhGZWVQZXJHYXM6IGdldFZhbHVlKG1heEZlZVBlckdhcyksXG4gICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogZ2V0VmFsdWUobWF4UHJpb3JpdHlGZWVQZXJHYXMpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIEpTT04tZnJpZW5kbHkgdmFsdWUuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCB7IGdhc1ByaWNlLCBtYXhGZWVQZXJHYXMsIG1heFByaW9yaXR5RmVlUGVyR2FzIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX3R5cGU6IFwiRmVlRGF0YVwiLFxuICAgICAgICAgICAgZ2FzUHJpY2U6IHRvSnNvbihnYXNQcmljZSksXG4gICAgICAgICAgICBtYXhGZWVQZXJHYXM6IHRvSnNvbihtYXhGZWVQZXJHYXMpLFxuICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHRvSnNvbihtYXhQcmlvcml0eUZlZVBlckdhcyksXG4gICAgICAgIH07XG4gICAgfVxufVxuO1xuLyoqXG4gKiAgUmV0dXJucyBhIGNvcHkgb2YgJSVyZXElJSB3aXRoIGFsbCBwcm9wZXJ0aWVzIGNvZXJjZWQgdG8gdGhlaXIgc3RyaWN0XG4gKiAgdHlwZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb3B5UmVxdWVzdChyZXEpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAvLyBUaGVzZSBjb3VsZCBiZSBhZGRyZXNzZXMsIEVOUyBuYW1lcyBvciBBZGRyZXNzYWJsZXNcbiAgICBpZiAocmVxLnRvKSB7XG4gICAgICAgIHJlc3VsdC50byA9IHJlcS50bztcbiAgICB9XG4gICAgaWYgKHJlcS5mcm9tKSB7XG4gICAgICAgIHJlc3VsdC5mcm9tID0gcmVxLmZyb207XG4gICAgfVxuICAgIGlmIChyZXEuZGF0YSkge1xuICAgICAgICByZXN1bHQuZGF0YSA9IGhleGxpZnkocmVxLmRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBiaWdJbnRLZXlzID0gXCJjaGFpbklkLGdhc0xpbWl0LGdhc1ByaWNlLG1heEZlZVBlckJsb2JHYXMsbWF4RmVlUGVyR2FzLG1heFByaW9yaXR5RmVlUGVyR2FzLHZhbHVlXCIuc3BsaXQoLywvKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBiaWdJbnRLZXlzKSB7XG4gICAgICAgIGlmICghKGtleSBpbiByZXEpIHx8IHJlcVtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtrZXldID0gZ2V0QmlnSW50KHJlcVtrZXldLCBgcmVxdWVzdC4ke2tleX1gKTtcbiAgICB9XG4gICAgY29uc3QgbnVtYmVyS2V5cyA9IFwidHlwZSxub25jZVwiLnNwbGl0KC8sLyk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgbnVtYmVyS2V5cykge1xuICAgICAgICBpZiAoIShrZXkgaW4gcmVxKSB8fCByZXFba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRba2V5XSA9IGdldE51bWJlcihyZXFba2V5XSwgYHJlcXVlc3QuJHtrZXl9YCk7XG4gICAgfVxuICAgIGlmIChyZXEuYWNjZXNzTGlzdCkge1xuICAgICAgICByZXN1bHQuYWNjZXNzTGlzdCA9IGFjY2Vzc0xpc3RpZnkocmVxLmFjY2Vzc0xpc3QpO1xuICAgIH1cbiAgICBpZiAocmVxLmF1dGhvcml6YXRpb25MaXN0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRob3JpemF0aW9uTGlzdCA9IHJlcS5hdXRob3JpemF0aW9uTGlzdC5zbGljZSgpO1xuICAgIH1cbiAgICBpZiAoXCJibG9ja1RhZ1wiIGluIHJlcSkge1xuICAgICAgICByZXN1bHQuYmxvY2tUYWcgPSByZXEuYmxvY2tUYWc7XG4gICAgfVxuICAgIGlmIChcImVuYWJsZUNjaXBSZWFkXCIgaW4gcmVxKSB7XG4gICAgICAgIHJlc3VsdC5lbmFibGVDY2lwUmVhZCA9ICEhcmVxLmVuYWJsZUNjaXBSZWFkO1xuICAgIH1cbiAgICBpZiAoXCJjdXN0b21EYXRhXCIgaW4gcmVxKSB7XG4gICAgICAgIHJlc3VsdC5jdXN0b21EYXRhID0gcmVxLmN1c3RvbURhdGE7XG4gICAgfVxuICAgIGlmIChcImJsb2JWZXJzaW9uZWRIYXNoZXNcIiBpbiByZXEgJiYgcmVxLmJsb2JWZXJzaW9uZWRIYXNoZXMpIHtcbiAgICAgICAgcmVzdWx0LmJsb2JWZXJzaW9uZWRIYXNoZXMgPSByZXEuYmxvYlZlcnNpb25lZEhhc2hlcy5zbGljZSgpO1xuICAgIH1cbiAgICBpZiAoXCJremdcIiBpbiByZXEpIHtcbiAgICAgICAgcmVzdWx0Lmt6ZyA9IHJlcS5remc7XG4gICAgfVxuICAgIGlmIChcImJsb2JXcmFwcGVyVmVyc2lvblwiIGluIHJlcSkge1xuICAgICAgICByZXN1bHQuYmxvYldyYXBwZXJWZXJzaW9uID0gcmVxLmJsb2JXcmFwcGVyVmVyc2lvbjtcbiAgICB9XG4gICAgaWYgKFwiYmxvYnNcIiBpbiByZXEgJiYgcmVxLmJsb2JzKSB7XG4gICAgICAgIHJlc3VsdC5ibG9icyA9IHJlcS5ibG9icy5tYXAoKGIpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0J5dGVzTGlrZShiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoZXhsaWZ5KGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogIEEgKipCbG9jayoqIHJlcHJlc2VudHMgdGhlIGRhdGEgYXNzb2NpYXRlZCB3aXRoIGEgZnVsbCBibG9jayBvblxuICogIEV0aGVyZXVtLlxuICovXG5leHBvcnQgY2xhc3MgQmxvY2sge1xuICAgIC8qKlxuICAgICAqICBUaGUgcHJvdmlkZXIgY29ubmVjdGVkIHRvIHRoZSBibG9jayB1c2VkIHRvIGZldGNoIGFkZGl0aW9uYWwgZGV0YWlsc1xuICAgICAqICBpZiBuZWNlc3NhcnkuXG4gICAgICovXG4gICAgcHJvdmlkZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBudW1iZXIsIHNvbWV0aW1lcyBjYWxsZWQgdGhlIGJsb2NrIGhlaWdodC4gVGhpcyBpcyBhXG4gICAgICogIHNlcXVlbnRpYWwgbnVtYmVyIHRoYXQgaXMgb25lIGhpZ2hlciB0aGFuIHRoZSBwYXJlbnQgYmxvY2suXG4gICAgICovXG4gICAgbnVtYmVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgaGFzaC5cbiAgICAgKlxuICAgICAqICBUaGlzIGhhc2ggaW5jbHVkZXMgYWxsIHByb3BlcnRpZXMsIHNvIGNhbiBiZSBzYWZlbHkgdXNlZCB0byBpZGVudGlmeVxuICAgICAqICBhbiBleGFjdCBzZXQgb2YgYmxvY2sgcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICBoYXNoO1xuICAgIC8qKlxuICAgICAqICBUaGUgdGltZXN0YW1wIGZvciB0aGlzIGJsb2NrLCB3aGljaCBpcyB0aGUgbnVtYmVyIG9mIHNlY29uZHMgc2luY2VcbiAgICAgKiAgZXBvY2ggdGhhdCB0aGlzIGJsb2NrIHdhcyBpbmNsdWRlZC5cbiAgICAgKi9cbiAgICB0aW1lc3RhbXA7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBoYXNoIG9mIHRoZSBwYXJlbnQgYmxvY2suXG4gICAgICovXG4gICAgcGFyZW50SGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGhhc2ggdHJlZSByb290IG9mIHRoZSBwYXJlbnQgYmVhY29uIGJsb2NrIGZvciB0aGUgZ2l2ZW5cbiAgICAgKiAgZXhlY3V0aW9uIGJsb2NrLiBTZWUgW1tsaW5rLWVpcC00Nzg4XV0uXG4gICAgICovXG4gICAgcGFyZW50QmVhY29uQmxvY2tSb290O1xuICAgIC8qKlxuICAgICAqICBUaGUgbm9uY2UuXG4gICAgICpcbiAgICAgKiAgT24gbGVnYWN5IG5ldHdvcmtzLCB0aGlzIGlzIHRoZSByYW5kb20gbnVtYmVyIGluc2VydGVkIHdoaWNoXG4gICAgICogIHBlcm1pdHRlZCB0aGUgZGlmZmljdWx0eSB0YXJnZXQgdG8gYmUgcmVhY2hlZC5cbiAgICAgKi9cbiAgICBub25jZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGRpZmZpY3VsdHkgdGFyZ2V0LlxuICAgICAqXG4gICAgICogIE9uIGxlZ2FjeSBuZXR3b3JrcywgdGhpcyBpcyB0aGUgcHJvb2Ytb2Ytd29yayB0YXJnZXQgcmVxdWlyZWRcbiAgICAgKiAgZm9yIGEgYmxvY2sgdG8gbWVldCB0aGUgcHJvdG9jb2wgcnVsZXMgdG8gYmUgaW5jbHVkZWQuXG4gICAgICpcbiAgICAgKiAgT24gbW9kZXJuIG5ldHdvcmtzLCB0aGlzIGlzIGEgcmFuZG9tIG51bWJlciBhcnJpdmVkIGF0IHVzaW5nXG4gICAgICogIHJhbmRhby4gIEBUT0RPOiBGaW5kIGxpbmtzP1xuICAgICAqL1xuICAgIGRpZmZpY3VsdHk7XG4gICAgLyoqXG4gICAgICogIFRoZSB0b3RhbCBnYXMgbGltaXQgZm9yIHRoaXMgYmxvY2suXG4gICAgICovXG4gICAgZ2FzTGltaXQ7XG4gICAgLyoqXG4gICAgICogIFRoZSB0b3RhbCBnYXMgdXNlZCBpbiB0aGlzIGJsb2NrLlxuICAgICAqL1xuICAgIGdhc1VzZWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSByb290IGhhc2ggZm9yIHRoZSBnbG9iYWwgc3RhdGUgYWZ0ZXIgYXBwbHlpbmcgY2hhbmdlc1xuICAgICAqICBpbiB0aGlzIGJsb2NrLlxuICAgICAqL1xuICAgIHN0YXRlUm9vdDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGhhc2ggb2YgdGhlIHRyYW5zYWN0aW9uIHJlY2VpcHRzIHRyaWUuXG4gICAgICovXG4gICAgcmVjZWlwdHNSb290O1xuICAgIC8qKlxuICAgICAqICBUaGUgdG90YWwgYW1vdW50IG9mIGJsb2IgZ2FzIGNvbnN1bWVkIGJ5IHRoZSB0cmFuc2FjdGlvbnNcbiAgICAgKiAgd2l0aGluIHRoZSBibG9jay4gU2VlIFtbbGluay1laXAtNDg0NF1dLlxuICAgICAqL1xuICAgIGJsb2JHYXNVc2VkO1xuICAgIC8qKlxuICAgICAqICBUaGUgcnVubmluZyB0b3RhbCBvZiBibG9iIGdhcyBjb25zdW1lZCBpbiBleGNlc3Mgb2YgdGhlXG4gICAgICogIHRhcmdldCwgcHJpb3IgdG8gdGhlIGJsb2NrLiBTZWUgW1tsaW5rLWVpcC00ODQ0XV0uXG4gICAgICovXG4gICAgZXhjZXNzQmxvYkdhcztcbiAgICAvKipcbiAgICAgKiAgVGhlIG1pbmVyIGNvaW5iYXNlIGFkZHJlc3MsIHdpaGNoIHJlY2VpdmVzIGFueSBzdWJzaWRpZXMgZm9yXG4gICAgICogIGluY2x1ZGluZyB0aGlzIGJsb2NrLlxuICAgICAqL1xuICAgIG1pbmVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgbGF0ZXN0IFJBTkRBTyBtaXggb2YgdGhlIHBvc3QgYmVhY29uIHN0YXRlIG9mXG4gICAgICogIHRoZSBwcmV2aW91cyBibG9jay5cbiAgICAgKi9cbiAgICBwcmV2UmFuZGFvO1xuICAgIC8qKlxuICAgICAqICBBbnkgZXh0cmEgZGF0YSB0aGUgdmFsaWRhdG9yIHdpc2hlZCB0byBpbmNsdWRlLlxuICAgICAqL1xuICAgIGV4dHJhRGF0YTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJhc2UgZmVlIHBlciBnYXMgdGhhdCBhbGwgdHJhbnNhY3Rpb25zIGluIHRoaXMgYmxvY2sgd2VyZVxuICAgICAqICBjaGFyZ2VkLlxuICAgICAqXG4gICAgICogIFRoaXMgYWRqdXN0cyBhZnRlciBlYWNoIGJsb2NrLCBkZXBlbmRpbmcgb24gaG93IGNvbmdlc3RlZCB0aGUgbmV0d29ya1xuICAgICAqICBpcy5cbiAgICAgKi9cbiAgICBiYXNlRmVlUGVyR2FzO1xuICAgICN0cmFuc2FjdGlvbnM7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKkJsb2NrKiogb2JqZWN0LlxuICAgICAqXG4gICAgICogIFRoaXMgc2hvdWxkIGdlbmVyYWxseSBub3QgYmUgbmVjZXNzYXJ5IGFzIHRoZSB1bmxlc3MgaW1wbGVtZW50aW5nIGFcbiAgICAgKiAgbG93LWxldmVsIGxpYnJhcnkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYmxvY2ssIHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuI3RyYW5zYWN0aW9ucyA9IGJsb2NrLnRyYW5zYWN0aW9ucy5tYXAoKHR4KSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mICh0eCkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uUmVzcG9uc2UodHgsIHByb3ZpZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eDtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgICAgICBoYXNoOiBnZXRWYWx1ZShibG9jay5oYXNoKSxcbiAgICAgICAgICAgIG51bWJlcjogYmxvY2subnVtYmVyLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBibG9jay50aW1lc3RhbXAsXG4gICAgICAgICAgICBwYXJlbnRIYXNoOiBibG9jay5wYXJlbnRIYXNoLFxuICAgICAgICAgICAgcGFyZW50QmVhY29uQmxvY2tSb290OiBibG9jay5wYXJlbnRCZWFjb25CbG9ja1Jvb3QsXG4gICAgICAgICAgICBub25jZTogYmxvY2subm9uY2UsXG4gICAgICAgICAgICBkaWZmaWN1bHR5OiBibG9jay5kaWZmaWN1bHR5LFxuICAgICAgICAgICAgZ2FzTGltaXQ6IGJsb2NrLmdhc0xpbWl0LFxuICAgICAgICAgICAgZ2FzVXNlZDogYmxvY2suZ2FzVXNlZCxcbiAgICAgICAgICAgIGJsb2JHYXNVc2VkOiBibG9jay5ibG9iR2FzVXNlZCxcbiAgICAgICAgICAgIGV4Y2Vzc0Jsb2JHYXM6IGJsb2NrLmV4Y2Vzc0Jsb2JHYXMsXG4gICAgICAgICAgICBtaW5lcjogYmxvY2subWluZXIsXG4gICAgICAgICAgICBwcmV2UmFuZGFvOiBnZXRWYWx1ZShibG9jay5wcmV2UmFuZGFvKSxcbiAgICAgICAgICAgIGV4dHJhRGF0YTogYmxvY2suZXh0cmFEYXRhLFxuICAgICAgICAgICAgYmFzZUZlZVBlckdhczogZ2V0VmFsdWUoYmxvY2suYmFzZUZlZVBlckdhcyksXG4gICAgICAgICAgICBzdGF0ZVJvb3Q6IGJsb2NrLnN0YXRlUm9vdCxcbiAgICAgICAgICAgIHJlY2VpcHRzUm9vdDogYmxvY2sucmVjZWlwdHNSb290LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIGxpc3Qgb2YgdHJhbnNhY3Rpb24gaGFzaGVzLCBpbiB0aGUgb3JkZXJcbiAgICAgKiAgdGhleSB3ZXJlIGV4ZWN1dGVkIHdpdGhpbiB0aGUgYmxvY2suXG4gICAgICovXG4gICAgZ2V0IHRyYW5zYWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3RyYW5zYWN0aW9ucy5tYXAoKHR4KSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mICh0eCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHguaGFzaDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBjb21wbGV0ZSB0cmFuc2FjdGlvbnMsIGluIHRoZSBvcmRlciB0aGV5XG4gICAgICogIHdlcmUgZXhlY3V0ZWQgd2l0aGluIHRoZSBibG9jay5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIG9ubHkgYXZhaWxhYmxlIGZvciBibG9ja3Mgd2hpY2ggcHJlZmV0Y2hlZFxuICAgICAqICB0cmFuc2FjdGlvbnMsIGJ5IHBhc3NpbmcgYGB0cnVlYGAgdG8gJSVwcmVmZXRjaFR4cyUlXG4gICAgICogIGludG8gW1tQcm92aWRlci1nZXRCbG9ja11dLlxuICAgICAqL1xuICAgIGdldCBwcmVmZXRjaGVkVHJhbnNhY3Rpb25zKCkge1xuICAgICAgICBjb25zdCB0eHMgPSB0aGlzLiN0cmFuc2FjdGlvbnMuc2xpY2UoKTtcbiAgICAgICAgLy8gRG9lc24ndCBtYXR0ZXIuLi5cbiAgICAgICAgaWYgKHR4cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgcHJlZmV0Y2hlZCB0aGUgdHJhbnNhY3Rpb25zXG4gICAgICAgIGFzc2VydCh0eXBlb2YgKHR4c1swXSkgPT09IFwib2JqZWN0XCIsIFwidHJhbnNhY3Rpb25zIHdlcmUgbm90IHByZWZldGNoZWQgd2l0aCBibG9jayByZXF1ZXN0XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJ0cmFuc2FjdGlvblJlc3BvbnNlcygpXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0eHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgSlNPTi1mcmllbmRseSB2YWx1ZS5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IHsgYmFzZUZlZVBlckdhcywgZGlmZmljdWx0eSwgZXh0cmFEYXRhLCBnYXNMaW1pdCwgZ2FzVXNlZCwgaGFzaCwgbWluZXIsIHByZXZSYW5kYW8sIG5vbmNlLCBudW1iZXIsIHBhcmVudEhhc2gsIHBhcmVudEJlYWNvbkJsb2NrUm9vdCwgc3RhdGVSb290LCByZWNlaXB0c1Jvb3QsIHRpbWVzdGFtcCwgdHJhbnNhY3Rpb25zIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX3R5cGU6IFwiQmxvY2tcIixcbiAgICAgICAgICAgIGJhc2VGZWVQZXJHYXM6IHRvSnNvbihiYXNlRmVlUGVyR2FzKSxcbiAgICAgICAgICAgIGRpZmZpY3VsdHk6IHRvSnNvbihkaWZmaWN1bHR5KSxcbiAgICAgICAgICAgIGV4dHJhRGF0YSxcbiAgICAgICAgICAgIGdhc0xpbWl0OiB0b0pzb24oZ2FzTGltaXQpLFxuICAgICAgICAgICAgZ2FzVXNlZDogdG9Kc29uKGdhc1VzZWQpLFxuICAgICAgICAgICAgYmxvYkdhc1VzZWQ6IHRvSnNvbih0aGlzLmJsb2JHYXNVc2VkKSxcbiAgICAgICAgICAgIGV4Y2Vzc0Jsb2JHYXM6IHRvSnNvbih0aGlzLmV4Y2Vzc0Jsb2JHYXMpLFxuICAgICAgICAgICAgaGFzaCwgbWluZXIsIHByZXZSYW5kYW8sIG5vbmNlLCBudW1iZXIsIHBhcmVudEhhc2gsIHRpbWVzdGFtcCxcbiAgICAgICAgICAgIHBhcmVudEJlYWNvbkJsb2NrUm9vdCwgc3RhdGVSb290LCByZWNlaXB0c1Jvb3QsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbnMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICBjb25zdCB0eHMgPSB0aGlzLnRyYW5zYWN0aW9ucztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHR4c1tpbmRleCsrXSwgZG9uZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG51bWJlciBvZiB0cmFuc2FjdGlvbnMgaW4gdGhpcyBibG9jay5cbiAgICAgKi9cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy4jdHJhbnNhY3Rpb25zLmxlbmd0aDsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgW1tsaW5rLWpzLWRhdGVdXSB0aGlzIGJsb2NrIHdhcyBpbmNsdWRlZCBhdC5cbiAgICAgKi9cbiAgICBnZXQgZGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZXN0YW1wID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnRpbWVzdGFtcCAqIDEwMDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSB0cmFuc2FjdGlvbiBhdCAlJWluZGV4ZSUlIHdpdGhpbiB0aGlzIGJsb2NrLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKGluZGV4T3JIYXNoKSB7XG4gICAgICAgIC8vIEZpbmQgdGhlIGludGVybmFsIHZhbHVlIGJ5IGl0cyBpbmRleCBvciBoYXNoXG4gICAgICAgIGxldCB0eCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHR5cGVvZiAoaW5kZXhPckhhc2gpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0eCA9IHRoaXMuI3RyYW5zYWN0aW9uc1tpbmRleE9ySGFzaF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBoYXNoID0gaW5kZXhPckhhc2gudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiB0aGlzLiN0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mICh2KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodiAhPT0gaGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHggPSB2O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2Lmhhc2ggIT09IGhhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHR4ID0gdjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBzdWNoIHR4XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHR4KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKHR4KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIElmIGEgKipCbG9jayoqIHdhcyBmZXRjaGVkIHdpdGggYSByZXF1ZXN0IHRvIGluY2x1ZGUgdGhlIHRyYW5zYWN0aW9uc1xuICAgICAqICB0aGlzIHdpbGwgYWxsb3cgc3luY2hyb25vdXMgYWNjZXNzIHRvIHRob3NlIHRyYW5zYWN0aW9ucy5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgdHJhbnNhY3Rpb25zIHdlcmUgbm90IHByZWZldGNoZWQsIHRoaXMgd2lsbCB0aHJvdy5cbiAgICAgKi9cbiAgICBnZXRQcmVmZXRjaGVkVHJhbnNhY3Rpb24oaW5kZXhPckhhc2gpIHtcbiAgICAgICAgY29uc3QgdHhzID0gdGhpcy5wcmVmZXRjaGVkVHJhbnNhY3Rpb25zO1xuICAgICAgICBpZiAodHlwZW9mIChpbmRleE9ySGFzaCkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0eHNbaW5kZXhPckhhc2hdO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4T3JIYXNoID0gaW5kZXhPckhhc2gudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgZm9yIChjb25zdCB0eCBvZiB0eHMpIHtcbiAgICAgICAgICAgIGlmICh0eC5oYXNoID09PSBpbmRleE9ySGFzaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJubyBtYXRjaGluZyB0cmFuc2FjdGlvblwiLCBcImluZGV4T3JIYXNoXCIsIGluZGV4T3JIYXNoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGJsb2NrIGJlZW4gbWluZWQuIFRoaXMgcHJvdmlkZXMgYSB0eXBlIGd1YXJkXG4gICAgICogIGZvciBhbGwgcHJvcGVydGllcyBvbiBhIFtbTWluZWRCbG9ja11dLlxuICAgICAqL1xuICAgIGlzTWluZWQoKSB7IHJldHVybiAhIXRoaXMuaGFzaDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyBibG9jayBpcyBhbiBbW2xpbmstZWlwLTI5MzBdXSBibG9jay5cbiAgICAgKi9cbiAgICBpc0xvbmRvbigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5iYXNlRmVlUGVyR2FzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgb3JwaGFuZWRFdmVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzTWluZWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVPcnBoYW5lZEJsb2NrRmlsdGVyKHRoaXMpO1xuICAgIH1cbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIExvZ1xuLyoqXG4gKiAgQSAqKkxvZyoqIGluIEV0aGVyZXVtIHJlcHJlc2VudHMgYW4gZXZlbnQgdGhhdCBoYXMgYmVlbiBpbmNsdWRlZCBpbiBhXG4gKiAgdHJhbnNhY3Rpb24gdXNpbmcgdGhlIGBgTE9HKmBgIG9wY29kZXMsIHdoaWNoIGFyZSBtb3N0IGNvbW1vbmx5IHVzZWQgYnlcbiAqICBTb2xpZGl0eSdzIGVtaXQgZm9yIGFubm91bmNpbmcgZXZlbnRzLlxuICovXG5leHBvcnQgY2xhc3MgTG9nIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHByb3ZpZGVyIGNvbm5lY3RlZCB0byB0aGUgbG9nIHVzZWQgdG8gZmV0Y2ggYWRkaXRpb25hbCBkZXRhaWxzXG4gICAgICogIGlmIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBwcm92aWRlcjtcbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIGhhc2ggb2YgdGhlIHRyYW5zYWN0aW9uIHRoaXMgbG9nIG9jY3VycmVkIGluLiBVc2UgdGhlXG4gICAgICogIFtbTG9nLWdldFRyYW5zYWN0aW9uXV0gdG8gZ2V0IHRoZSBbW1RyYW5zYWN0aW9uUmVzcG9uc2VdXS5cbiAgICAgKi9cbiAgICB0cmFuc2FjdGlvbkhhc2g7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBoYXNoIG9mIHRoZSBibG9jayB0aGlzIGxvZyBvY2N1cnJlZCBpbi4gVXNlIHRoZVxuICAgICAqICBbW0xvZy1nZXRCbG9ja11dIHRvIGdldCB0aGUgW1tCbG9ja11dLlxuICAgICAqL1xuICAgIGJsb2NrSGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb2NrIG51bWJlciBvZiB0aGUgYmxvY2sgdGhpcyBsb2cgb2NjdXJyZWQgaW4uIEl0IGlzIHByZWZlcnJlZFxuICAgICAqICB0byB1c2UgdGhlIFtbQmxvY2staGFzaF1dIHdoZW4gZmV0Y2hpbmcgdGhlIHJlbGF0ZWQgW1tCbG9ja11dLFxuICAgICAqICBzaW5jZSBpbiB0aGUgY2FzZSBvZiBhbiBvcnBoYW5lZCBibG9jaywgdGhlIGJsb2NrIGF0IHRoYXQgaGVpZ2h0IG1heVxuICAgICAqICBoYXZlIGNoYW5nZWQuXG4gICAgICovXG4gICAgYmxvY2tOdW1iZXI7XG4gICAgLyoqXG4gICAgICogIElmIHRoZSAqKkxvZyoqIHJlcHJlc2VudHMgYSBibG9jayB0aGF0IHdhcyByZW1vdmVkIGR1ZSB0byBhbiBvcnBoYW5lZFxuICAgICAqICBibG9jaywgdGhpcyB3aWxsIGJlIHRydWUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBjYW4gb25seSBoYXBwZW4gd2l0aGluIGFuIG9ycGhhbiBldmVudCBsaXN0ZW5lci5cbiAgICAgKi9cbiAgICByZW1vdmVkO1xuICAgIC8qKlxuICAgICAqICBUaGUgYWRkcmVzcyBvZiB0aGUgY29udHJhY3QgdGhhdCBlbWl0dGVkIHRoaXMgbG9nLlxuICAgICAqL1xuICAgIGFkZHJlc3M7XG4gICAgLyoqXG4gICAgICogIFRoZSBkYXRhIGluY2x1ZGVkIGluIHRoaXMgbG9nIHdoZW4gaXQgd2FzIGVtaXR0ZWQuXG4gICAgICovXG4gICAgZGF0YTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGluZGV4ZWQgdG9waWNzIGluY2x1ZGVkIGluIHRoaXMgbG9nIHdoZW4gaXQgd2FzIGVtaXR0ZWQuXG4gICAgICpcbiAgICAgKiAgQWxsIHRvcGljcyBhcmUgaW5jbHVkZWQgaW4gdGhlIGJsb29tIGZpbHRlcnMsIHNvIHRoZXkgY2FuIGJlXG4gICAgICogIGVmZmljaWVudGx5IGZpbHRlcmVkIHVzaW5nIHRoZSBbW1Byb3ZpZGVyLWdldExvZ3NdXSBtZXRob2QuXG4gICAgICovXG4gICAgdG9waWNzO1xuICAgIC8qKlxuICAgICAqICBUaGUgaW5kZXggd2l0aGluIHRoZSBibG9jayB0aGlzIGxvZyBvY2N1cnJlZCBhdC4gVGhpcyBpcyBnZW5lcmFsbHlcbiAgICAgKiAgbm90IHVzZWZ1bCB0byBkZXZlbG9wZXJzLCBidXQgY2FuIGJlIHVzZWQgd2l0aCB0aGUgdmFyaW91cyByb290c1xuICAgICAqICB0byBwcm9vZiBpbmNsdXNpb24gd2l0aGluIGEgYmxvY2suXG4gICAgICovXG4gICAgaW5kZXg7XG4gICAgLyoqXG4gICAgICogIFRoZSBpbmRleCB3aXRoaW4gdGhlIHRyYW5zYWN0aW9uIG9mIHRoaXMgbG9nLlxuICAgICAqL1xuICAgIHRyYW5zYWN0aW9uSW5kZXg7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxvZywgcHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICBjb25zdCB0b3BpY3MgPSBPYmplY3QuZnJlZXplKGxvZy50b3BpY3Muc2xpY2UoKSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoOiBsb2cudHJhbnNhY3Rpb25IYXNoLFxuICAgICAgICAgICAgYmxvY2tIYXNoOiBsb2cuYmxvY2tIYXNoLFxuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IGxvZy5ibG9ja051bWJlcixcbiAgICAgICAgICAgIHJlbW92ZWQ6IGxvZy5yZW1vdmVkLFxuICAgICAgICAgICAgYWRkcmVzczogbG9nLmFkZHJlc3MsXG4gICAgICAgICAgICBkYXRhOiBsb2cuZGF0YSxcbiAgICAgICAgICAgIHRvcGljcyxcbiAgICAgICAgICAgIGluZGV4OiBsb2cuaW5kZXgsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbkluZGV4OiBsb2cudHJhbnNhY3Rpb25JbmRleCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgSlNPTi1jb21wYXRpYmxlIG9iamVjdC5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IHsgYWRkcmVzcywgYmxvY2tIYXNoLCBibG9ja051bWJlciwgZGF0YSwgaW5kZXgsIHJlbW92ZWQsIHRvcGljcywgdHJhbnNhY3Rpb25IYXNoLCB0cmFuc2FjdGlvbkluZGV4IH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX3R5cGU6IFwibG9nXCIsXG4gICAgICAgICAgICBhZGRyZXNzLCBibG9ja0hhc2gsIGJsb2NrTnVtYmVyLCBkYXRhLCBpbmRleCxcbiAgICAgICAgICAgIHJlbW92ZWQsIHRvcGljcywgdHJhbnNhY3Rpb25IYXNoLCB0cmFuc2FjdGlvbkluZGV4XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBibG9jayB0aGF0IHRoaXMgbG9nIG9jY3VycmVkIGluLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEJsb2NrKCkge1xuICAgICAgICBjb25zdCBibG9jayA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2sodGhpcy5ibG9ja0hhc2gpO1xuICAgICAgICBhc3NlcnQoISFibG9jaywgXCJmYWlsZWQgdG8gZmluZCB0cmFuc2FjdGlvblwiLCBcIlVOS05PV05fRVJST1JcIiwge30pO1xuICAgICAgICByZXR1cm4gYmxvY2s7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSB0cmFuc2FjdGlvbiB0aGF0IHRoaXMgbG9nIG9jY3VycmVkIGluLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKCkge1xuICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb24odGhpcy50cmFuc2FjdGlvbkhhc2gpO1xuICAgICAgICBhc3NlcnQoISF0eCwgXCJmYWlsZWQgdG8gZmluZCB0cmFuc2FjdGlvblwiLCBcIlVOS05PV05fRVJST1JcIiwge30pO1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSB0cmFuc2FjdGlvbiByZWNlaXB0IGZvdCB0aGUgdHJhbnNhY3Rpb24gdGhhdCB0aGlzXG4gICAgICogIGxvZyBvY2N1cnJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvblJlY2VpcHQoKSB7XG4gICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0aGlzLnRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICAgIGFzc2VydCghIXJlY2VpcHQsIFwiZmFpbGVkIHRvIGZpbmQgdHJhbnNhY3Rpb24gcmVjZWlwdFwiLCBcIlVOS05PV05fRVJST1JcIiwge30pO1xuICAgICAgICByZXR1cm4gcmVjZWlwdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIHJlbW92ZWRFdmVudCgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlbW92ZWRMb2dGaWx0ZXIodGhpcyk7XG4gICAgfVxufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gVHJhbnNhY3Rpb24gUmVjZWlwdFxuLypcbmV4cG9ydCBpbnRlcmZhY2UgTGVnYWN5VHJhbnNhY3Rpb25SZWNlaXB0IHtcbiAgICBieXphbnRpdW06IGZhbHNlO1xuICAgIHN0YXR1czogbnVsbDtcbiAgICByb290OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQnl6YW50aXVtVHJhbnNhY3Rpb25SZWNlaXB0IHtcbiAgICBieXphbnRpdW06IHRydWU7XG4gICAgc3RhdHVzOiBudW1iZXI7XG4gICAgcm9vdDogbnVsbDtcbn1cbiovXG4vKipcbiAqICBBICoqVHJhbnNhY3Rpb25SZWNlaXB0KiogaW5jbHVkZXMgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCBhXG4gKiAgdHJhbnNhY3Rpb24gdGhhdCBpcyBvbmx5IGF2YWlsYWJsZSBhZnRlciBpdCBoYXMgYmVlbiBtaW5lZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFRyYW5zYWN0aW9uUmVjZWlwdCB7XG4gICAgLyoqXG4gICAgICogIFRoZSBwcm92aWRlciBjb25uZWN0ZWQgdG8gdGhlIGxvZyB1c2VkIHRvIGZldGNoIGFkZGl0aW9uYWwgZGV0YWlsc1xuICAgICAqICBpZiBuZWNlc3NhcnkuXG4gICAgICovXG4gICAgcHJvdmlkZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBhZGRyZXNzIHRoZSB0cmFuc2FjdGlvbiB3YXMgc2VudCB0by5cbiAgICAgKi9cbiAgICB0bztcbiAgICAvKipcbiAgICAgKiAgVGhlIHNlbmRlciBvZiB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgZnJvbTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFkZHJlc3Mgb2YgdGhlIGNvbnRyYWN0IGlmIHRoZSB0cmFuc2FjdGlvbiB3YXMgZGlyZWN0bHlcbiAgICAgKiAgcmVzcG9uc2libGUgZm9yIGRlcGxveWluZyBvbmUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBub24tbnVsbCAqKm9ubHkqKiBpZiB0aGUgYGB0b2BgIGlzIGVtcHR5IGFuZCB0aGUgYGBkYXRhYGBcbiAgICAgKiAgd2FzIHN1Y2Nlc3NmdWxseSBleGVjdXRlZCBhcyBpbml0Y29kZS5cbiAgICAgKi9cbiAgICBjb250cmFjdEFkZHJlc3M7XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBoYXNoLlxuICAgICAqL1xuICAgIGhhc2g7XG4gICAgLyoqXG4gICAgICogIFRoZSBpbmRleCBvZiB0aGlzIHRyYW5zYWN0aW9uIHdpdGhpbiB0aGUgYmxvY2sgdHJhbnNhY3Rpb25zLlxuICAgICAqL1xuICAgIGluZGV4O1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgaGFzaCBvZiB0aGUgW1tCbG9ja11dIHRoaXMgdHJhbnNhY3Rpb24gd2FzIGluY2x1ZGVkIGluLlxuICAgICAqL1xuICAgIGJsb2NrSGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb2NrIG51bWJlciBvZiB0aGUgW1tCbG9ja11dIHRoaXMgdHJhbnNhY3Rpb24gd2FzIGluY2x1ZGVkIGluLlxuICAgICAqL1xuICAgIGJsb2NrTnVtYmVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvb20gZmlsdGVyIGJ5dGVzIHRoYXQgcmVwcmVzZW50IGFsbCBsb2dzIHRoYXQgb2NjdXJyZWQgd2l0aGluXG4gICAgICogIHRoaXMgdHJhbnNhY3Rpb24uIFRoaXMgaXMgZ2VuZXJhbGx5IG5vdCB1c2VmdWwgZm9yIG1vc3QgZGV2ZWxvcGVycyxcbiAgICAgKiAgYnV0IGNhbiBiZSB1c2VkIHRvIHZhbGlkYXRlIHRoZSBpbmNsdWRlZCBsb2dzLlxuICAgICAqL1xuICAgIGxvZ3NCbG9vbTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFjdHVhbCBhbW91bnQgb2YgZ2FzIHVzZWQgYnkgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBXaGVuIGNyZWF0aW5nIGEgdHJhbnNhY3Rpb24sIHRoZSBhbW91bnQgb2YgZ2FzIHRoYXQgd2lsbCBiZSB1c2VkIGNhblxuICAgICAqICBvbmx5IGJlIGFwcHJveGltYXRlZCwgYnV0IHRoZSBzZW5kZXIgbXVzdCBwYXkgdGhlIGdhcyBmZWUgZm9yIHRoZVxuICAgICAqICBlbnRpcmUgZ2FzIGxpbWl0LiBBZnRlciB0aGUgdHJhbnNhY3Rpb24sIHRoZSBkaWZmZXJlbmNlIGlzIHJlZnVuZGVkLlxuICAgICAqL1xuICAgIGdhc1VzZWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBnYXMgdXNlZCBmb3IgQkxPYnMuIFNlZSBbW2xpbmstZWlwLTQ4NDRdXS5cbiAgICAgKi9cbiAgICBibG9iR2FzVXNlZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFtb3VudCBvZiBnYXMgdXNlZCBieSBhbGwgdHJhbnNhY3Rpb25zIHdpdGhpbiB0aGUgYmxvY2sgZm9yIHRoaXNcbiAgICAgKiAgYW5kIGFsbCB0cmFuc2FjdGlvbnMgd2l0aCBhIGxvd2VyIGBgaW5kZXhgYC5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIGdlbmVyYWxseSBub3QgdXNlZnVsIGZvciBkZXZlbG9wZXJzIGJ1dCBjYW4gYmUgdXNlZCB0b1xuICAgICAqICB2YWxpZGF0ZSBjZXJ0YWluIGFzcGVjdHMgb2YgZXhlY3V0aW9uLlxuICAgICAqL1xuICAgIGN1bXVsYXRpdmVHYXNVc2VkO1xuICAgIC8qKlxuICAgICAqICBUaGUgYWN0dWFsIGdhcyBwcmljZSB1c2VkIGR1cmluZyBleGVjdXRpb24uXG4gICAgICpcbiAgICAgKiAgRHVlIHRvIHRoZSBjb21wbGV4aXR5IG9mIFtbbGluay1laXAtMTU1OV1dIHRoaXMgdmFsdWUgY2FuIG9ubHlcbiAgICAgKiAgYmUgY2FsdWNsYXRlZCBhZnRlciB0aGUgdHJhbnNhY3Rpb24gaGFzIGJlZW4gbWluZWQsIHNuY2UgdGhlIGJhc2VcbiAgICAgKiAgZmVlIGlzIHByb3RvY29sLWVuZm9yY2VkLlxuICAgICAqL1xuICAgIGdhc1ByaWNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgcHJpY2UgcGFpZCBwZXIgQkxPQiBpbiBnYXMuIFNlZSBbW2xpbmstZWlwLTQ4NDRdXS5cbiAgICAgKi9cbiAgICBibG9iR2FzUHJpY2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTI3MThdXSB0cmFuc2FjdGlvbiB0eXBlLlxuICAgICAqL1xuICAgIHR5cGU7XG4gICAgLy9yZWFkb25seSBieXphbnRpdW0hOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqICBUaGUgc3RhdHVzIG9mIHRoaXMgdHJhbnNhY3Rpb24sIGluZGljYXRpbmcgc3VjY2VzcyAoaS5lLiBgYDFgYCkgb3JcbiAgICAgKiAgYSByZXZlcnQgKGkuZS4gYGAwYGApLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgYXZhaWxhYmxlIGluIHBvc3QtYnl6YW50aXVtIGJsb2NrcywgYnV0IHNvbWUgYmFja2VuZHMgbWF5XG4gICAgICogIGJhY2tmaWxsIHRoaXMgdmFsdWUuXG4gICAgICovXG4gICAgc3RhdHVzO1xuICAgIC8qKlxuICAgICAqICBUaGUgcm9vdCBoYXNoIG9mIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBubyBwcmVzZW50IGFuZCB3YXMgb25seSBpbmNsdWRlZCBpbiBwcmUtYnl6YW50aXVtIGJsb2NrcywgYnV0XG4gICAgICogIGNvdWxkIGJlIHVzZWQgdG8gdmFsaWRhdGUgY2VydGFpbiBwYXJ0cyBvZiB0aGUgcmVjZWlwdC5cbiAgICAgKi9cbiAgICByb290O1xuICAgICNsb2dzO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0eCwgcHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy4jbG9ncyA9IE9iamVjdC5mcmVlemUodHgubG9ncy5tYXAoKGxvZykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMb2cobG9nLCBwcm92aWRlcik7XG4gICAgICAgIH0pKTtcbiAgICAgICAgbGV0IGdhc1ByaWNlID0gQk5fMDtcbiAgICAgICAgaWYgKHR4LmVmZmVjdGl2ZUdhc1ByaWNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGdhc1ByaWNlID0gdHguZWZmZWN0aXZlR2FzUHJpY2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHguZ2FzUHJpY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgZ2FzUHJpY2UgPSB0eC5nYXNQcmljZTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIHByb3ZpZGVyLFxuICAgICAgICAgICAgdG86IHR4LnRvLFxuICAgICAgICAgICAgZnJvbTogdHguZnJvbSxcbiAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogdHguY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgaGFzaDogdHguaGFzaCxcbiAgICAgICAgICAgIGluZGV4OiB0eC5pbmRleCxcbiAgICAgICAgICAgIGJsb2NrSGFzaDogdHguYmxvY2tIYXNoLFxuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IHR4LmJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgbG9nc0Jsb29tOiB0eC5sb2dzQmxvb20sXG4gICAgICAgICAgICBnYXNVc2VkOiB0eC5nYXNVc2VkLFxuICAgICAgICAgICAgY3VtdWxhdGl2ZUdhc1VzZWQ6IHR4LmN1bXVsYXRpdmVHYXNVc2VkLFxuICAgICAgICAgICAgYmxvYkdhc1VzZWQ6IHR4LmJsb2JHYXNVc2VkLFxuICAgICAgICAgICAgZ2FzUHJpY2UsXG4gICAgICAgICAgICBibG9iR2FzUHJpY2U6IHR4LmJsb2JHYXNQcmljZSxcbiAgICAgICAgICAgIHR5cGU6IHR4LnR5cGUsXG4gICAgICAgICAgICAvL2J5emFudGl1bTogdHguYnl6YW50aXVtLFxuICAgICAgICAgICAgc3RhdHVzOiB0eC5zdGF0dXMsXG4gICAgICAgICAgICByb290OiB0eC5yb290XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGxvZ3MgZm9yIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgZ2V0IGxvZ3MoKSB7IHJldHVybiB0aGlzLiNsb2dzOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBKU09OLWNvbXBhdGlibGUgcmVwcmVzZW50YXRpb24uXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCB7IHRvLCBmcm9tLCBjb250cmFjdEFkZHJlc3MsIGhhc2gsIGluZGV4LCBibG9ja0hhc2gsIGJsb2NrTnVtYmVyLCBsb2dzQmxvb20sIGxvZ3MsIC8vYnl6YW50aXVtLCBcbiAgICAgICAgc3RhdHVzLCByb290IH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX3R5cGU6IFwiVHJhbnNhY3Rpb25SZWNlaXB0XCIsXG4gICAgICAgICAgICBibG9ja0hhc2gsIGJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgLy9ieXphbnRpdW0sIFxuICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgY3VtdWxhdGl2ZUdhc1VzZWQ6IHRvSnNvbih0aGlzLmN1bXVsYXRpdmVHYXNVc2VkKSxcbiAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICBnYXNQcmljZTogdG9Kc29uKHRoaXMuZ2FzUHJpY2UpLFxuICAgICAgICAgICAgYmxvYkdhc1VzZWQ6IHRvSnNvbih0aGlzLmJsb2JHYXNVc2VkKSxcbiAgICAgICAgICAgIGJsb2JHYXNQcmljZTogdG9Kc29uKHRoaXMuYmxvYkdhc1ByaWNlKSxcbiAgICAgICAgICAgIGdhc1VzZWQ6IHRvSnNvbih0aGlzLmdhc1VzZWQpLFxuICAgICAgICAgICAgaGFzaCwgaW5kZXgsIGxvZ3MsIGxvZ3NCbG9vbSwgcm9vdCwgc3RhdHVzLCB0b1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMubG9ncy5sZW5ndGg7IH1cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdGhpcy5sb2dzW2luZGV4KytdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdG90YWwgZmVlIGZvciB0aGlzIHRyYW5zYWN0aW9uLCBpbiB3ZWkuXG4gICAgICovXG4gICAgZ2V0IGZlZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2FzVXNlZCAqIHRoaXMuZ2FzUHJpY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgYmxvY2sgdGhpcyB0cmFuc2FjdGlvbiBvY2N1cnJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRCbG9jaygpIHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldEJsb2NrKHRoaXMuYmxvY2tIYXNoKTtcbiAgICAgICAgaWYgKGJsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRPRE9cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIHRyYW5zYWN0aW9uIHRoaXMgdHJhbnNhY3Rpb24gb2NjdXJyZWQgaW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbih0aGlzLmhhc2gpO1xuICAgICAgICBpZiAodHggPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVE9ET1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBleGVjdXRpb24gb2YgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBTdXBwb3J0IGZvciB0aGlzIGZlYXR1cmUgaXMgbGltaXRlZCwgYXMgaXQgcmVxdWlyZXMgYW4gYXJjaGl2ZSBub2RlXG4gICAgICogIHdpdGggdGhlIGBgZGVidWdfYGAgb3IgYGB0cmFjZV9gYCBBUEkgZW5hYmxlZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRSZXN1bHQoKSB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvblJlc3VsdCh0aGlzLmhhc2gpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBudW1iZXIgb2YgY29uZmlybWF0aW9ucyB0aGlzIHRyYW5zYWN0aW9uIGhhcy5cbiAgICAgKi9cbiAgICBhc3luYyBjb25maXJtYXRpb25zKCkge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKSkgLSB0aGlzLmJsb2NrTnVtYmVyICsgMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIHJlbW92ZWRFdmVudCgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlbW92ZWRUcmFuc2FjdGlvbkZpbHRlcih0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIHJlb3JkZXJlZEV2ZW50KG90aGVyKSB7XG4gICAgICAgIGFzc2VydCghb3RoZXIgfHwgb3RoZXIuaXNNaW5lZCgpLCBcInVubWluZWQgJ290aGVyJyB0cmFuc2N0aW9uIGNhbm5vdCBiZSBvcnBoYW5lZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJyZW9yZGVyZWRFdmVudChvdGhlcilcIiB9KTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlb3JkZXJlZFRyYW5zYWN0aW9uRmlsdGVyKHRoaXMsIG90aGVyKTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqVHJhbnNhY3Rpb25SZXNwb25zZSoqIGluY2x1ZGVzIGFsbCBwcm9wZXJ0aWVzIGFib3V0IGEgdHJhbnNhY3Rpb25cbiAqICB0aGF0IHdhcyBzZW50IHRvIHRoZSBuZXR3b3JrLCB3aGljaCBtYXkgb3IgbWF5IG5vdCBiZSBpbmNsdWRlZCBpbiBhXG4gKiAgYmxvY2suXG4gKlxuICogIFRoZSBbW1RyYW5zYWN0aW9uUmVzcG9uc2UtaXNNaW5lZF1dIGNhbiBiZSB1c2VkIHRvIGNoZWNrIGlmIHRoZVxuICogIHRyYW5zYWN0aW9uIGhhcyBiZWVuIG1pbmVkIGFzIHdlbGwgYXMgdHlwZSBndWFyZCB0aGF0IHRoZSBvdGhlcndpc2VcbiAqICBwb3NzaWJseSBgYG51bGxgYCBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkLlxuICovXG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb25SZXNwb25zZSB7XG4gICAgLyoqXG4gICAgICogIFRoZSBwcm92aWRlciB0aGlzIGlzIGNvbm5lY3RlZCB0bywgd2hpY2ggd2lsbCBpbmZsdWVuY2UgaG93IGl0c1xuICAgICAqICBtZXRob2RzIHdpbGwgcmVzb2x2ZSBpdHMgYXN5bmMgaW5zcGVjdGlvbiBtZXRob2RzLlxuICAgICAqL1xuICAgIHByb3ZpZGVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgbnVtYmVyIG9mIHRoZSBibG9jayB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2FzIGluY2x1ZGVkIGluLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgYGBudWxsYGAgZm9yIHBlbmRpbmcgdHJhbnNhY3Rpb25zLlxuICAgICAqL1xuICAgIGJsb2NrTnVtYmVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2tIYXNoIG9mIHRoZSBibG9jayB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2FzIGluY2x1ZGVkIGluLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgYGBudWxsYGAgZm9yIHBlbmRpbmcgdHJhbnNhY3Rpb25zLlxuICAgICAqL1xuICAgIGJsb2NrSGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGluZGV4IHdpdGhpbiB0aGUgYmxvY2sgdGhhdCB0aGlzIHRyYW5zYWN0aW9uIHJlc2lkZXMgYXQuXG4gICAgICovXG4gICAgaW5kZXg7XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBoYXNoLlxuICAgICAqL1xuICAgIGhhc2g7XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTI3MThdXSB0cmFuc2FjdGlvbiBlbnZlbG9wZSB0eXBlLiBUaGlzIGlzXG4gICAgICogIGBgMGBgIGZvciBsZWdhY3kgdHJhbnNhY3Rpb25zIHR5cGVzLlxuICAgICAqL1xuICAgIHR5cGU7XG4gICAgLyoqXG4gICAgICogIFRoZSByZWNlaXZlciBvZiB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIElmIGBgbnVsbGBgLCB0aGVuIHRoZSB0cmFuc2FjdGlvbiBpcyBhbiBpbml0Y29kZSB0cmFuc2FjdGlvbi5cbiAgICAgKiAgVGhpcyBtZWFucyB0aGUgcmVzdWx0IG9mIGV4ZWN1dGluZyB0aGUgW1tkYXRhXV0gd2lsbCBiZSBkZXBsb3llZFxuICAgICAqICBhcyBhIG5ldyBjb250cmFjdCBvbiBjaGFpbiAoYXNzdW1pbmcgaXQgZG9lcyBub3QgcmV2ZXJ0KSBhbmQgdGhlXG4gICAgICogIGFkZHJlc3MgbWF5IGJlIGNvbXB1dGVkIHVzaW5nIFtbZ2V0Q3JlYXRlQWRkcmVzc11dLlxuICAgICAqL1xuICAgIHRvO1xuICAgIC8qKlxuICAgICAqICBUaGUgc2VuZGVyIG9mIHRoaXMgdHJhbnNhY3Rpb24uIEl0IGlzIGltcGxpY2l0bHkgY29tcHV0ZWRcbiAgICAgKiAgZnJvbSB0aGUgdHJhbnNhY3Rpb24gcHJlLWltYWdlIGhhc2ggKGFzIHRoZSBkaWdlc3QpIGFuZCB0aGVcbiAgICAgKiAgW1tzaWduYXR1cmVdXSB1c2luZyBlY3JlY292ZXIuXG4gICAgICovXG4gICAgZnJvbTtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5vbmNlLCB3aGljaCBpcyB1c2VkIHRvIHByZXZlbnQgcmVwbGF5IGF0dGFja3MgYW5kIG9mZmVyXG4gICAgICogIGEgbWV0aG9kIHRvIGVuc3VyZSB0cmFuc2FjdGlvbnMgZnJvbSBhIGdpdmVuIHNlbmRlciBhcmUgZXhwbGljaXRseVxuICAgICAqICBvcmRlcmVkLlxuICAgICAqXG4gICAgICogIFdoZW4gc2VuZGluZyBhIHRyYW5zYWN0aW9uLCB0aGlzIG11c3QgYmUgZXF1YWwgdG8gdGhlIG51bWJlciBvZlxuICAgICAqICB0cmFuc2FjdGlvbnMgZXZlciBzZW50IGJ5IFtbZnJvbV1dLlxuICAgICAqL1xuICAgIG5vbmNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSB1bml0cyBvZiBnYXMgdGhpcyB0cmFuc2FjdGlvbiBjYW4gY29uc3VtZS4gSWYgZXhlY3V0aW9uXG4gICAgICogIGV4Y2VlZHMgdGhpcywgdGhlIGVudHJpZXMgdHJhbnNhY3Rpb24gaXMgcmV2ZXJ0ZWQgYW5kIHRoZSBzZW5kZXJcbiAgICAgKiAgaXMgY2hhcmdlZCBmb3IgdGhlIGZ1bGwgYW1vdW50LCBkZXNwaXRlIG5vdCBzdGF0ZSBjaGFuZ2VzIGJlaW5nIG1hZGUuXG4gICAgICovXG4gICAgZ2FzTGltaXQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBnYXMgcHJpY2UgY2FuIGhhdmUgdmFyaW91cyB2YWx1ZXMsIGRlcGVuZGluZyBvbiB0aGUgbmV0d29yay5cbiAgICAgKlxuICAgICAqICBJbiBtb2Rlcm4gbmV0d29ya3MsIGZvciB0cmFuc2FjdGlvbnMgdGhhdCBhcmUgaW5jbHVkZWQgdGhpcyBpc1xuICAgICAqICB0aGUgLy9lZmZlY3RpdmUgZ2FzIHByaWNlLy8gKHRoZSBmZWUgcGVyIGdhcyB0aGF0IHdhcyBhY3R1YWxseVxuICAgICAqICBjaGFyZ2VkKSwgd2hpbGUgZm9yIHRyYW5zYWN0aW9ucyB0aGF0IGhhdmUgbm90IGJlZW4gaW5jbHVkZWQgeWV0XG4gICAgICogIGlzIHRoZSBbW21heEZlZVBlckdhc11dLlxuICAgICAqXG4gICAgICogIEZvciBsZWdhY3kgdHJhbnNhY3Rpb25zLCBvciB0cmFuc2FjdGlvbnMgb24gbGVnYWN5IG5ldHdvcmtzLCB0aGlzXG4gICAgICogIGlzIHRoZSBmZWUgdGhhdCB3aWxsIGJlIGNoYXJnZWQgcGVyIHVuaXQgb2YgZ2FzIHRoZSB0cmFuc2FjdGlvblxuICAgICAqICBjb25zdW1lcy5cbiAgICAgKi9cbiAgICBnYXNQcmljZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIG1heGltdW0gcHJpb3JpdHkgZmVlIChwZXIgdW5pdCBvZiBnYXMpIHRvIGFsbG93IGFcbiAgICAgKiAgdmFsaWRhdG9yIHRvIGNoYXJnZSB0aGUgc2VuZGVyLiBUaGlzIGlzIGluY2x1c2l2ZSBvZiB0aGVcbiAgICAgKiAgW1ttYXhGZWVGZWVQZXJHYXNdXS5cbiAgICAgKi9cbiAgICBtYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAvKipcbiAgICAgKiAgVGhlIG1heGltdW0gZmVlIChwZXIgdW5pdCBvZiBnYXMpIHRvIGFsbG93IHRoaXMgdHJhbnNhY3Rpb25cbiAgICAgKiAgdG8gY2hhcmdlIHRoZSBzZW5kZXIuXG4gICAgICovXG4gICAgbWF4RmVlUGVyR2FzO1xuICAgIC8qKlxuICAgICAqICBUaGUgW1tsaW5rLWVpcC00ODQ0XV0gbWF4IGZlZSBwZXIgQkxPYiBnYXMuXG4gICAgICovXG4gICAgbWF4RmVlUGVyQmxvYkdhcztcbiAgICAvKipcbiAgICAgKiAgVGhlIGRhdGEuXG4gICAgICovXG4gICAgZGF0YTtcbiAgICAvKipcbiAgICAgKiAgVGhlIHZhbHVlLCBpbiB3ZWkuIFVzZSBbW2Zvcm1hdEV0aGVyXV0gdG8gZm9ybWF0IHRoaXMgdmFsdWVcbiAgICAgKiAgYXMgZXRoZXIuXG4gICAgICovXG4gICAgdmFsdWU7XG4gICAgLyoqXG4gICAgICogIFRoZSBjaGFpbiBJRC5cbiAgICAgKi9cbiAgICBjaGFpbklkO1xuICAgIC8qKlxuICAgICAqICBUaGUgc2lnbmF0dXJlLlxuICAgICAqL1xuICAgIHNpZ25hdHVyZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIFtbbGluay1laXAtMjkzMF1dIGFjY2VzcyBsaXN0IGZvciB0cmFuc2FjdGlvbiB0eXBlcyB0aGF0XG4gICAgICogIHN1cHBvcnQgaXQsIG90aGVyd2lzZSBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBhY2Nlc3NMaXN0O1xuICAgIC8qKlxuICAgICAqICBUaGUgW1tsaW5rLWVpcC00ODQ0XV0gQkxPYiB2ZXJzaW9uZWQgaGFzaGVzLlxuICAgICAqL1xuICAgIGJsb2JWZXJzaW9uZWRIYXNoZXM7XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTc3MDJdXSBhdXRob3JpemF0aW9ucyAoaWYgYW55KS5cbiAgICAgKi9cbiAgICBhdXRob3JpemF0aW9uTGlzdDtcbiAgICAjc3RhcnRCbG9jaztcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IodHgsIHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgdGhpcy5ibG9ja051bWJlciA9ICh0eC5ibG9ja051bWJlciAhPSBudWxsKSA/IHR4LmJsb2NrTnVtYmVyIDogbnVsbDtcbiAgICAgICAgdGhpcy5ibG9ja0hhc2ggPSAodHguYmxvY2tIYXNoICE9IG51bGwpID8gdHguYmxvY2tIYXNoIDogbnVsbDtcbiAgICAgICAgdGhpcy5oYXNoID0gdHguaGFzaDtcbiAgICAgICAgdGhpcy5pbmRleCA9IHR4LmluZGV4O1xuICAgICAgICB0aGlzLnR5cGUgPSB0eC50eXBlO1xuICAgICAgICB0aGlzLmZyb20gPSB0eC5mcm9tO1xuICAgICAgICB0aGlzLnRvID0gdHgudG8gfHwgbnVsbDtcbiAgICAgICAgdGhpcy5nYXNMaW1pdCA9IHR4Lmdhc0xpbWl0O1xuICAgICAgICB0aGlzLm5vbmNlID0gdHgubm9uY2U7XG4gICAgICAgIHRoaXMuZGF0YSA9IHR4LmRhdGE7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0eC52YWx1ZTtcbiAgICAgICAgdGhpcy5nYXNQcmljZSA9IHR4Lmdhc1ByaWNlO1xuICAgICAgICB0aGlzLm1heFByaW9yaXR5RmVlUGVyR2FzID0gKHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpID8gdHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgOiBudWxsO1xuICAgICAgICB0aGlzLm1heEZlZVBlckdhcyA9ICh0eC5tYXhGZWVQZXJHYXMgIT0gbnVsbCkgPyB0eC5tYXhGZWVQZXJHYXMgOiBudWxsO1xuICAgICAgICB0aGlzLm1heEZlZVBlckJsb2JHYXMgPSAodHgubWF4RmVlUGVyQmxvYkdhcyAhPSBudWxsKSA/IHR4Lm1heEZlZVBlckJsb2JHYXMgOiBudWxsO1xuICAgICAgICB0aGlzLmNoYWluSWQgPSB0eC5jaGFpbklkO1xuICAgICAgICB0aGlzLnNpZ25hdHVyZSA9IHR4LnNpZ25hdHVyZTtcbiAgICAgICAgdGhpcy5hY2Nlc3NMaXN0ID0gKHR4LmFjY2Vzc0xpc3QgIT0gbnVsbCkgPyB0eC5hY2Nlc3NMaXN0IDogbnVsbDtcbiAgICAgICAgdGhpcy5ibG9iVmVyc2lvbmVkSGFzaGVzID0gKHR4LmJsb2JWZXJzaW9uZWRIYXNoZXMgIT0gbnVsbCkgPyB0eC5ibG9iVmVyc2lvbmVkSGFzaGVzIDogbnVsbDtcbiAgICAgICAgdGhpcy5hdXRob3JpemF0aW9uTGlzdCA9ICh0eC5hdXRob3JpemF0aW9uTGlzdCAhPSBudWxsKSA/IHR4LmF1dGhvcml6YXRpb25MaXN0IDogbnVsbDtcbiAgICAgICAgdGhpcy4jc3RhcnRCbG9jayA9IC0xO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIEpTT04tY29tcGF0aWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgeyBibG9ja051bWJlciwgYmxvY2tIYXNoLCBpbmRleCwgaGFzaCwgdHlwZSwgdG8sIGZyb20sIG5vbmNlLCBkYXRhLCBzaWduYXR1cmUsIGFjY2Vzc0xpc3QsIGJsb2JWZXJzaW9uZWRIYXNoZXMgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfdHlwZTogXCJUcmFuc2FjdGlvblJlc3BvbnNlXCIsXG4gICAgICAgICAgICBhY2Nlc3NMaXN0LCBibG9ja051bWJlciwgYmxvY2tIYXNoLFxuICAgICAgICAgICAgYmxvYlZlcnNpb25lZEhhc2hlcyxcbiAgICAgICAgICAgIGNoYWluSWQ6IHRvSnNvbih0aGlzLmNoYWluSWQpLFxuICAgICAgICAgICAgZGF0YSwgZnJvbSxcbiAgICAgICAgICAgIGdhc0xpbWl0OiB0b0pzb24odGhpcy5nYXNMaW1pdCksXG4gICAgICAgICAgICBnYXNQcmljZTogdG9Kc29uKHRoaXMuZ2FzUHJpY2UpLFxuICAgICAgICAgICAgaGFzaCxcbiAgICAgICAgICAgIG1heEZlZVBlckdhczogdG9Kc29uKHRoaXMubWF4RmVlUGVyR2FzKSxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiB0b0pzb24odGhpcy5tYXhQcmlvcml0eUZlZVBlckdhcyksXG4gICAgICAgICAgICBtYXhGZWVQZXJCbG9iR2FzOiB0b0pzb24odGhpcy5tYXhGZWVQZXJCbG9iR2FzKSxcbiAgICAgICAgICAgIG5vbmNlLCBzaWduYXR1cmUsIHRvLCBpbmRleCwgdHlwZSxcbiAgICAgICAgICAgIHZhbHVlOiB0b0pzb24odGhpcy52YWx1ZSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgQmxvY2sgdGhhdCB0aGlzIHRyYW5zYWN0aW9uIHdhcyBpbmNsdWRlZCBpbi5cbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgcmV0dXJuIG51bGwgaWYgdGhlIHRyYW5zYWN0aW9uIGhhcyBub3QgYmVlbiBpbmNsdWRlZCB5ZXQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QmxvY2soKSB7XG4gICAgICAgIGxldCBibG9ja051bWJlciA9IHRoaXMuYmxvY2tOdW1iZXI7XG4gICAgICAgIGlmIChibG9ja051bWJlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHRoaXMuZ2V0VHJhbnNhY3Rpb24oKTtcbiAgICAgICAgICAgIGlmICh0eCkge1xuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gdHguYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJsb2NrTnVtYmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2NrID0gdGhpcy5wcm92aWRlci5nZXRCbG9jayhibG9ja051bWJlcik7XG4gICAgICAgIGlmIChibG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUT0RPXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoaXMgdHJhbnNhY3Rpb24gYmVpbmcgcmUtcmVxdWVzdGVkIGZyb20gdGhlXG4gICAgICogIHByb3ZpZGVyLiBUaGlzIGNhbiBiZSB1c2VkIGlmIHlvdSBoYXZlIGFuIHVubWluZWQgdHJhbnNhY3Rpb25cbiAgICAgKiAgYW5kIHdpc2ggdG8gZ2V0IGFuIHVwLXRvLWRhdGUgcG9wdWxhdGVkIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbih0aGlzLmhhc2gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZSB0byB0aGUgbnVtYmVyIG9mIGNvbmZpcm1hdGlvbnMgdGhpcyB0cmFuc2FjdGlvbiBoYXMuXG4gICAgICovXG4gICAgYXN5bmMgY29uZmlybWF0aW9ucygpIHtcbiAgICAgICAgaWYgKHRoaXMuYmxvY2tOdW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgeyB0eCwgYmxvY2tOdW1iZXIgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICB0eDogdGhpcy5nZXRUcmFuc2FjdGlvbigpLFxuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiB0aGlzLnByb3ZpZGVyLmdldEJsb2NrTnVtYmVyKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gTm90IG1pbmVkIHlldC4uLlxuICAgICAgICAgICAgaWYgKHR4ID09IG51bGwgfHwgdHguYmxvY2tOdW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJsb2NrTnVtYmVyIC0gdHguYmxvY2tOdW1iZXIgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRCbG9ja051bWJlcigpO1xuICAgICAgICByZXR1cm4gYmxvY2tOdW1iZXIgLSB0aGlzLmJsb2NrTnVtYmVyICsgMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIG9uY2UgdGhpcyB0cmFuc2FjdGlvbiBoYXMgYmVlbiBtaW5lZCBhbmQgaGFzXG4gICAgICogICUlY29uZmlybXMlJSBibG9ja3MgaW5jbHVkaW5nIGl0IChkZWZhdWx0OiBgYDFgYCkgd2l0aCBhblxuICAgICAqICBvcHRpb25hbCAlJXRpbWVvdXQlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIGNhbiByZXNvbHZlIHRvIGBgbnVsbGBgIG9ubHkgaWYgJSVjb25maXJtcyUlIGlzIGBgMGBgXG4gICAgICogIGFuZCB0aGUgdHJhbnNhY3Rpb24gaGFzIG5vdCBiZWVuIG1pbmVkLCBvdGhlcndpc2UgdGhpcyB3aWxsXG4gICAgICogIHdhaXQgdW50aWwgZW5vdWdoIGNvbmZpcm1hdGlvbnMgaGF2ZSBjb21wbGV0ZWQuXG4gICAgICovXG4gICAgYXN5bmMgd2FpdChfY29uZmlybXMsIF90aW1lb3V0KSB7XG4gICAgICAgIGNvbnN0IGNvbmZpcm1zID0gKF9jb25maXJtcyA9PSBudWxsKSA/IDEgOiBfY29uZmlybXM7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSAoX3RpbWVvdXQgPT0gbnVsbCkgPyAwIDogX3RpbWVvdXQ7XG4gICAgICAgIGxldCBzdGFydEJsb2NrID0gdGhpcy4jc3RhcnRCbG9jaztcbiAgICAgICAgbGV0IG5leHRTY2FuID0gLTE7XG4gICAgICAgIGxldCBzdG9wU2Nhbm5pbmcgPSAoc3RhcnRCbG9jayA9PT0gLTEpID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICBjb25zdCBjaGVja1JlcGxhY2VtZW50ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHRyYW5zYWN0aW9uIGNvdW50IGZvciB0aGlzIHNlbmRlclxuICAgICAgICAgICAgaWYgKHN0b3BTY2FubmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBibG9ja051bWJlciwgbm9uY2UgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICBibG9ja051bWJlcjogdGhpcy5wcm92aWRlci5nZXRCbG9ja051bWJlcigpLFxuICAgICAgICAgICAgICAgIG5vbmNlOiB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uQ291bnQodGhpcy5mcm9tKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBObyB0cmFuc2FjdGlvbiBvciBvdXIgbm9uY2UgaGFzIG5vdCBiZWVuIG1pbmVkIHlldDsgYnV0IHdlXG4gICAgICAgICAgICAvLyBjYW4gc3RhcnQgc2Nhbm5pbmcgbGF0ZXIgd2hlbiB3ZSBkbyBzdGFydFxuICAgICAgICAgICAgaWYgKG5vbmNlIDwgdGhpcy5ub25jZSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0QmxvY2sgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSB3ZXJlIG1pbmVkOyBubyByZXBsYWNlbWVudFxuICAgICAgICAgICAgaWYgKHN0b3BTY2FubmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWluZWQgPSBhd2FpdCB0aGlzLmdldFRyYW5zYWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAobWluZWQgJiYgbWluZWQuYmxvY2tOdW1iZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIHdlcmUgcmVwbGFjZWQ7IHN0YXJ0IHNjYW5uaW5nIGZvciB0aGF0IHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAvLyBTdGFydGluZyB0byBzY2FuOyBsb29rIGJhY2sgYSBmZXcgZXh0cmEgYmxvY2tzIGZvciBzYWZldHlcbiAgICAgICAgICAgIGlmIChuZXh0U2NhbiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBuZXh0U2NhbiA9IHN0YXJ0QmxvY2sgLSAzO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0U2NhbiA8IHRoaXMuI3N0YXJ0QmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFNjYW4gPSB0aGlzLiNzdGFydEJsb2NrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChuZXh0U2NhbiA8PSBibG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgbmV4dCBibG9jayB0byBzY2FuXG4gICAgICAgICAgICAgICAgaWYgKHN0b3BTY2FubmluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldEJsb2NrKG5leHRTY2FuLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBub3QgaGFwcGVuOyBidXQgd2UnbGwgdHJ5IGFnYWluIHNob3J0bHlcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdlIHdlcmUgbWluZWQ7IG5vIHJlcGxhY2VtZW50XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBoYXNoIG9mIGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNoID09PSB0aGlzLmhhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTZWFyY2ggZm9yIHRoZSB0cmFuc2FjdGlvbiB0aGF0IHJlcGxhY2VkIHVzXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9jay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eCA9IGF3YWl0IGJsb2NrLmdldFRyYW5zYWN0aW9uKGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHguZnJvbSA9PT0gdGhpcy5mcm9tICYmIHR4Lm5vbmNlID09PSB0aGlzLm5vbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHJlY2VpcHRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdG9wU2Nhbm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eC5oYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5vdCBoYXBwZW47IGJ1dCB3ZSdsbCB0cnkgYWdhaW4gc2hvcnRseVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlY2VpcHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHdpbGwgcmV0cnkgdGhpcyBvbiB0aGUgbmV4dCBibG9jayAodGhpcyBjYXNlIGNvdWxkIGJlIG9wdGltaXplZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoYmxvY2tOdW1iZXIgLSByZWNlaXB0LmJsb2NrTnVtYmVyICsgMSkgPCBjb25maXJtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZWFzb24gd2Ugd2VyZSByZXBsYWNlZFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlYXNvbiA9IFwicmVwbGFjZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5kYXRhID09PSB0aGlzLmRhdGEgJiYgdHgudG8gPT09IHRoaXMudG8gJiYgdHgudmFsdWUgPT09IHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb24gPSBcInJlcHJpY2VkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eC5kYXRhID09PSBcIjB4XCIgJiYgdHguZnJvbSA9PT0gdHgudG8gJiYgdHgudmFsdWUgPT09IEJOXzApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb24gPSBcImNhbmNlbGxlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInRyYW5zYWN0aW9uIHdhcyByZXBsYWNlZFwiLCBcIlRSQU5TQUNUSU9OX1JFUExBQ0VEXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxsZWQ6IChyZWFzb24gPT09IFwicmVwbGFjZWRcIiB8fCByZWFzb24gPT09IFwiY2FuY2VsbGVkXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudDogdHgucmVwbGFjZWFibGVUcmFuc2FjdGlvbihzdGFydEJsb2NrKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNoOiB0eC5oYXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpcHRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHRTY2FuKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNoZWNrUmVjZWlwdCA9IChyZWNlaXB0KSA9PiB7XG4gICAgICAgICAgICBpZiAocmVjZWlwdCA9PSBudWxsIHx8IHJlY2VpcHQuc3RhdHVzICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY2VpcHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UsIFwidHJhbnNhY3Rpb24gZXhlY3V0aW9uIHJldmVydGVkXCIsIFwiQ0FMTF9FWENFUFRJT05cIiwge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJzZW5kVHJhbnNhY3Rpb25cIixcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLCByZWFzb246IG51bGwsIGludm9jYXRpb246IG51bGwsIHJldmVydDogbnVsbCxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICB0bzogcmVjZWlwdC50byxcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogcmVjZWlwdC5mcm9tLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBcIlwiIC8vIEBUT0RPOiBpbiB2Nywgc3BsaXQgb3V0IHNlbmRUcmFuc2FjdGlvbiBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgfSwgcmVjZWlwdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0aGlzLmhhc2gpO1xuICAgICAgICBpZiAoY29uZmlybXMgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVja1JlY2VpcHQocmVjZWlwdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlY2VpcHQpIHtcbiAgICAgICAgICAgIGlmIChjb25maXJtcyA9PT0gMSB8fCAoYXdhaXQgcmVjZWlwdC5jb25maXJtYXRpb25zKCkpID49IGNvbmZpcm1zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrUmVjZWlwdChyZWNlaXB0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBhIHJlcGxhY2VtZW50OyB0aHJvd3MgaWYgYSByZXBsYWNlbWVudCB3YXMgZm91bmRcbiAgICAgICAgICAgIGF3YWl0IGNoZWNrUmVwbGFjZW1lbnQoKTtcbiAgICAgICAgICAgIC8vIEFsbG93IG51bGwgb25seSB3aGVuIHRoZSBjb25maXJtcyBpcyAwXG4gICAgICAgICAgICBpZiAoY29uZmlybXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3YWl0ZXIgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAvLyBMaXN0IG9mIHRoaW5ncyB0byBjYW5jZWwgd2hlbiB3ZSBoYXZlIGEgcmVzdWx0IChvbmUgd2F5IG9yIHRoZSBvdGhlcilcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbGxlcnMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbCA9ICgpID0+IHsgY2FuY2VsbGVycy5mb3JFYWNoKChjKSA9PiBjKCkpOyB9O1xuICAgICAgICAgICAgLy8gT24gY2FuY2VsLCBzdG9wIHNjYW5uaW5nIGZvciByZXBsYWNlbWVudHNcbiAgICAgICAgICAgIGNhbmNlbGxlcnMucHVzaCgoKSA9PiB7IHN0b3BTY2FubmluZyA9IHRydWU7IH0pO1xuICAgICAgICAgICAgLy8gU2V0IHVwIGFueSB0aW1lb3V0IHJlcXVlc3RlZFxuICAgICAgICAgICAgaWYgKHRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChtYWtlRXJyb3IoXCJ3YWl0IGZvciB0cmFuc2FjdGlvbiB0aW1lb3V0XCIsIFwiVElNRU9VVFwiKSk7XG4gICAgICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgY2FuY2VsbGVycy5wdXNoKCgpID0+IHsgY2xlYXJUaW1lb3V0KHRpbWVyKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0eExpc3RlbmVyID0gYXN5bmMgKHJlY2VpcHQpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBEb25lOyByZXR1cm4gaXQhXG4gICAgICAgICAgICAgICAgaWYgKChhd2FpdCByZWNlaXB0LmNvbmZpcm1hdGlvbnMoKSkgPj0gY29uZmlybXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGNoZWNrUmVjZWlwdChyZWNlaXB0KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhbmNlbGxlcnMucHVzaCgoKSA9PiB7IHRoaXMucHJvdmlkZXIub2ZmKHRoaXMuaGFzaCwgdHhMaXN0ZW5lcik7IH0pO1xuICAgICAgICAgICAgdGhpcy5wcm92aWRlci5vbih0aGlzLmhhc2gsIHR4TGlzdGVuZXIpO1xuICAgICAgICAgICAgLy8gV2Ugc3VwcG9ydCByZXBsYWNlbWVudCBkZXRlY3Rpb247IHN0YXJ0IGNoZWNraW5nXG4gICAgICAgICAgICBpZiAoc3RhcnRCbG9jayA+PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVwbGFjZUxpc3RlbmVyID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGEgcmVwbGFjZW1lbnQ7IHRoaXMgdGhyb3dzIG9ubHkgaWYgb25lIGlzIGZvdW5kXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBjaGVja1JlcGxhY2VtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSB3ZXJlIHJlcGxhY2VkICh3aXRoIGVub3VnaCBjb25maXJtcyk7IHJlLXRocm93IHRoZSBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRXJyb3IoZXJyb3IsIFwiVFJBTlNBQ1RJT05fUkVQTEFDRURcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBSZXNjaGV1ZGxlIGEgY2hlY2sgb24gdGhlIG5leHQgYmxvY2tcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG9wU2Nhbm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIub25jZShcImJsb2NrXCIsIHJlcGxhY2VMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNhbmNlbGxlcnMucHVzaCgoKSA9PiB7IHRoaXMucHJvdmlkZXIub2ZmKFwiYmxvY2tcIiwgcmVwbGFjZUxpc3RlbmVyKTsgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlci5vbmNlKFwiYmxvY2tcIiwgcmVwbGFjZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhd2FpdCB3YWl0ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGlmIHRoaXMgdHJhbnNhY3Rpb24gaGFzIGJlZW4gaW5jbHVkZWQuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBlZmZlY3RpdmUgb25seSBhcyBvZiB0aGUgdGltZSB0aGUgVHJhbnNhY3Rpb25SZXNwb25zZVxuICAgICAqICB3YXMgaW5zdGFudGlhdGVkLiBUbyBnZXQgdXAtdG8tZGF0ZSBpbmZvcm1hdGlvbiwgdXNlXG4gICAgICogIFtbZ2V0VHJhbnNhY3Rpb25dXS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2lsbCBoYXZlXG4gICAgICogIG5vbi1udWxsIHByb3BlcnR5IHZhbHVlcyBmb3IgcHJvcGVydGllcyB0aGF0IGFyZSBudWxsIGZvclxuICAgICAqICB1bm1pbmVkIHRyYW5zYWN0aW9ucy5cbiAgICAgKi9cbiAgICBpc01pbmVkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuYmxvY2tIYXNoICE9IG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBhIGxlZ2FjeSAoaS5lLiBgYHR5cGUgPT0gMGBgKVxuICAgICAqICB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2lsbCBoYXZlXG4gICAgICogIHRoZSBgYG51bGxgYC1uZXNzIGZvciBoYXJkZm9yay1zcGVjaWZpYyBwcm9wZXJ0aWVzIHNldCBjb3JyZWN0bHkuXG4gICAgICovXG4gICAgaXNMZWdhY3koKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgYSBCZXJsaW4gKGkuZS4gYGB0eXBlID09IDFgYClcbiAgICAgKiAgdHJhbnNhY3Rpb24uIFNlZSBbW2xpbmstZWlwLTIwNzBdXS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2lsbCBoYXZlXG4gICAgICogIHRoZSBgYG51bGxgYC1uZXNzIGZvciBoYXJkZm9yay1zcGVjaWZpYyBwcm9wZXJ0aWVzIHNldCBjb3JyZWN0bHkuXG4gICAgICovXG4gICAgaXNCZXJsaW4oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgYSBMb25kb24gKGkuZS4gYGB0eXBlID09IDJgYClcbiAgICAgKiAgdHJhbnNhY3Rpb24uIFNlZSBbW2xpbmstZWlwLTE1NTldXS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2lsbCBoYXZlXG4gICAgICogIHRoZSBgYG51bGxgYC1uZXNzIGZvciBoYXJkZm9yay1zcGVjaWZpYyBwcm9wZXJ0aWVzIHNldCBjb3JyZWN0bHkuXG4gICAgICovXG4gICAgaXNMb25kb24oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiBodGUgdHJhbnNhY3Rpb24gaXMgYSBDYW5jdW4gKGkuZS4gYGB0eXBlID09IDNgYClcbiAgICAgKiAgdHJhbnNhY3Rpb24uIFNlZSBbW2xpbmstZWlwLTQ4NDRdXS5cbiAgICAgKi9cbiAgICBpc0NhbmN1bigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IDMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIGZpbHRlciB3aGljaCBjYW4gYmUgdXNlZCB0byBsaXN0ZW4gZm9yIG9ycGhhbiBldmVudHNcbiAgICAgKiAgdGhhdCBldmljdCB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIHJlbW92ZWRFdmVudCgpIHtcbiAgICAgICAgYXNzZXJ0KHRoaXMuaXNNaW5lZCgpLCBcInVubWluZWQgdHJhbnNhY3Rpb24gY2Fub3QgYmUgb3JwaGFuZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicmVtb3ZlRXZlbnQoKVwiIH0pO1xuICAgICAgICByZXR1cm4gY3JlYXRlUmVtb3ZlZFRyYW5zYWN0aW9uRmlsdGVyKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIGZpbHRlciB3aGljaCBjYW4gYmUgdXNlZCB0byBsaXN0ZW4gZm9yIG9ycGhhbiBldmVudHNcbiAgICAgKiAgdGhhdCByZS1vcmRlciB0aGlzIGV2ZW50IGFnYWluc3QgJSVvdGhlciUlLlxuICAgICAqL1xuICAgIHJlb3JkZXJlZEV2ZW50KG90aGVyKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLmlzTWluZWQoKSwgXCJ1bm1pbmVkIHRyYW5zYWN0aW9uIGNhbm90IGJlIG9ycGhhbmVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInJlbW92ZUV2ZW50KClcIiB9KTtcbiAgICAgICAgYXNzZXJ0KCFvdGhlciB8fCBvdGhlci5pc01pbmVkKCksIFwidW5taW5lZCAnb3RoZXInIHRyYW5zYWN0aW9uIGNhbm90IGJlIG9ycGhhbmVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInJlbW92ZUV2ZW50KClcIiB9KTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlb3JkZXJlZFRyYW5zYWN0aW9uRmlsdGVyKHRoaXMsIG90aGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgVHJhbnNhY3Rpb25SZXNwb25zZSBpbnN0YW5jZSB3aGljaCBoYXMgdGhlIGFiaWxpdHkgdG9cbiAgICAgKiAgZGV0ZWN0IChhbmQgdGhyb3cgYW4gZXJyb3IpIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyByZXBsYWNlZCwgd2hpY2hcbiAgICAgKiAgd2lsbCBiZWdpbiBzY2FubmluZyBhdCAlJXN0YXJ0QmxvY2slJS5cbiAgICAgKlxuICAgICAqICBUaGlzIHNob3VsZCBnZW5lcmFsbHkgbm90IGJlIHVzZWQgYnkgZGV2ZWxvcGVycyBhbmQgaXMgaW50ZW5kZWRcbiAgICAgKiAgcHJpbWFyaWx5IGZvciBpbnRlcm5hbCB1c2UuIFNldHRpbmcgYW4gaW5jb3JyZWN0ICUlc3RhcnRCbG9jayUlIGNhblxuICAgICAqICBoYXZlIGRldmFzdGF0aW5nIHBlcmZvcm1hbmNlIGNvbnNlcXVlbmNlcyBpZiB1c2VkIGluY29ycmVjdGx5LlxuICAgICAqL1xuICAgIHJlcGxhY2VhYmxlVHJhbnNhY3Rpb24oc3RhcnRCbG9jaykge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChOdW1iZXIuaXNJbnRlZ2VyKHN0YXJ0QmxvY2spICYmIHN0YXJ0QmxvY2sgPj0gMCwgXCJpbnZhbGlkIHN0YXJ0QmxvY2tcIiwgXCJzdGFydEJsb2NrXCIsIHN0YXJ0QmxvY2spO1xuICAgICAgICBjb25zdCB0eCA9IG5ldyBUcmFuc2FjdGlvblJlc3BvbnNlKHRoaXMsIHRoaXMucHJvdmlkZXIpO1xuICAgICAgICB0eC4jc3RhcnRCbG9jayA9IHN0YXJ0QmxvY2s7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVPcnBoYW5lZEJsb2NrRmlsdGVyKGJsb2NrKSB7XG4gICAgcmV0dXJuIHsgb3JwaGFuOiBcImRyb3AtYmxvY2tcIiwgaGFzaDogYmxvY2suaGFzaCwgbnVtYmVyOiBibG9jay5udW1iZXIgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlb3JkZXJlZFRyYW5zYWN0aW9uRmlsdGVyKHR4LCBvdGhlcikge1xuICAgIHJldHVybiB7IG9ycGhhbjogXCJyZW9yZGVyLXRyYW5zYWN0aW9uXCIsIHR4LCBvdGhlciB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUmVtb3ZlZFRyYW5zYWN0aW9uRmlsdGVyKHR4KSB7XG4gICAgcmV0dXJuIHsgb3JwaGFuOiBcImRyb3AtdHJhbnNhY3Rpb25cIiwgdHggfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlbW92ZWRMb2dGaWx0ZXIobG9nKSB7XG4gICAgcmV0dXJuIHsgb3JwaGFuOiBcImRyb3AtbG9nXCIsIGxvZzoge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoOiBsb2cudHJhbnNhY3Rpb25IYXNoLFxuICAgICAgICAgICAgYmxvY2tIYXNoOiBsb2cuYmxvY2tIYXNoLFxuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IGxvZy5ibG9ja051bWJlcixcbiAgICAgICAgICAgIGFkZHJlc3M6IGxvZy5hZGRyZXNzLFxuICAgICAgICAgICAgZGF0YTogbG9nLmRhdGEsXG4gICAgICAgICAgICB0b3BpY3M6IE9iamVjdC5mcmVlemUobG9nLnRvcGljcy5zbGljZSgpKSxcbiAgICAgICAgICAgIGluZGV4OiBsb2cuaW5kZXhcbiAgICAgICAgfSB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbImRlZmluZVByb3BlcnRpZXMiLCJnZXRCaWdJbnQiLCJnZXROdW1iZXIiLCJoZXhsaWZ5IiwiaXNCeXRlc0xpa2UiLCJyZXNvbHZlUHJvcGVydGllcyIsImFzc2VydCIsImFzc2VydEFyZ3VtZW50IiwiaXNFcnJvciIsIm1ha2VFcnJvciIsImFjY2Vzc0xpc3RpZnkiLCJCTl8wIiwiQmlnSW50IiwiZ2V0VmFsdWUiLCJ2YWx1ZSIsInRvSnNvbiIsInRvU3RyaW5nIiwiRmVlRGF0YSIsInRvSlNPTiIsImdhc1ByaWNlIiwibWF4RmVlUGVyR2FzIiwibWF4UHJpb3JpdHlGZWVQZXJHYXMiLCJfdHlwZSIsImNvbnN0cnVjdG9yIiwiY29weVJlcXVlc3QiLCJyZXEiLCJyZXN1bHQiLCJ0byIsImZyb20iLCJkYXRhIiwiYmlnSW50S2V5cyIsInNwbGl0Iiwia2V5IiwibnVtYmVyS2V5cyIsImFjY2Vzc0xpc3QiLCJhdXRob3JpemF0aW9uTGlzdCIsInNsaWNlIiwiYmxvY2tUYWciLCJlbmFibGVDY2lwUmVhZCIsImN1c3RvbURhdGEiLCJibG9iVmVyc2lvbmVkSGFzaGVzIiwia3pnIiwiYmxvYldyYXBwZXJWZXJzaW9uIiwiYmxvYnMiLCJtYXAiLCJiIiwiT2JqZWN0IiwiYXNzaWduIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJCbG9jayIsInRyYW5zYWN0aW9ucyIsInR4IiwiaGFzaCIsInByZWZldGNoZWRUcmFuc2FjdGlvbnMiLCJ0eHMiLCJsZW5ndGgiLCJvcGVyYXRpb24iLCJiYXNlRmVlUGVyR2FzIiwiZGlmZmljdWx0eSIsImV4dHJhRGF0YSIsImdhc0xpbWl0IiwiZ2FzVXNlZCIsIm1pbmVyIiwicHJldlJhbmRhbyIsIm5vbmNlIiwibnVtYmVyIiwicGFyZW50SGFzaCIsInBhcmVudEJlYWNvbkJsb2NrUm9vdCIsInN0YXRlUm9vdCIsInJlY2VpcHRzUm9vdCIsInRpbWVzdGFtcCIsImJsb2JHYXNVc2VkIiwiZXhjZXNzQmxvYkdhcyIsImluZGV4IiwibmV4dCIsImRvbmUiLCJ1bmRlZmluZWQiLCJkYXRlIiwiRGF0ZSIsImdldFRyYW5zYWN0aW9uIiwiaW5kZXhPckhhc2giLCJ0b0xvd2VyQ2FzZSIsInYiLCJFcnJvciIsInByb3ZpZGVyIiwiZ2V0UHJlZmV0Y2hlZFRyYW5zYWN0aW9uIiwiaXNNaW5lZCIsImlzTG9uZG9uIiwib3JwaGFuZWRFdmVudCIsImNyZWF0ZU9ycGhhbmVkQmxvY2tGaWx0ZXIiLCJibG9jayIsIlRyYW5zYWN0aW9uUmVzcG9uc2UiLCJMb2ciLCJhZGRyZXNzIiwiYmxvY2tIYXNoIiwiYmxvY2tOdW1iZXIiLCJyZW1vdmVkIiwidG9waWNzIiwidHJhbnNhY3Rpb25IYXNoIiwidHJhbnNhY3Rpb25JbmRleCIsImdldEJsb2NrIiwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0IiwicmVjZWlwdCIsInJlbW92ZWRFdmVudCIsImNyZWF0ZVJlbW92ZWRMb2dGaWx0ZXIiLCJsb2ciLCJmcmVlemUiLCJUcmFuc2FjdGlvblJlY2VpcHQiLCJsb2dzIiwiY29udHJhY3RBZGRyZXNzIiwibG9nc0Jsb29tIiwic3RhdHVzIiwicm9vdCIsImN1bXVsYXRpdmVHYXNVc2VkIiwiYmxvYkdhc1ByaWNlIiwiZmVlIiwiZ2V0UmVzdWx0IiwiZ2V0VHJhbnNhY3Rpb25SZXN1bHQiLCJjb25maXJtYXRpb25zIiwiZ2V0QmxvY2tOdW1iZXIiLCJjcmVhdGVSZW1vdmVkVHJhbnNhY3Rpb25GaWx0ZXIiLCJyZW9yZGVyZWRFdmVudCIsIm90aGVyIiwiY3JlYXRlUmVvcmRlcmVkVHJhbnNhY3Rpb25GaWx0ZXIiLCJlZmZlY3RpdmVHYXNQcmljZSIsInR5cGUiLCJzaWduYXR1cmUiLCJjaGFpbklkIiwibWF4RmVlUGVyQmxvYkdhcyIsIndhaXQiLCJfY29uZmlybXMiLCJfdGltZW91dCIsImNvbmZpcm1zIiwidGltZW91dCIsInN0YXJ0QmxvY2siLCJuZXh0U2NhbiIsInN0b3BTY2FubmluZyIsImNoZWNrUmVwbGFjZW1lbnQiLCJnZXRUcmFuc2FjdGlvbkNvdW50IiwibWluZWQiLCJpIiwicmVhc29uIiwiY2FuY2VsbGVkIiwicmVwbGFjZW1lbnQiLCJyZXBsYWNlYWJsZVRyYW5zYWN0aW9uIiwiY2hlY2tSZWNlaXB0IiwiYWN0aW9uIiwiaW52b2NhdGlvbiIsInJldmVydCIsInRyYW5zYWN0aW9uIiwid2FpdGVyIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJjYW5jZWxsZXJzIiwiY2FuY2VsIiwiZm9yRWFjaCIsImMiLCJwdXNoIiwidGltZXIiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwidHhMaXN0ZW5lciIsImVycm9yIiwib2ZmIiwib24iLCJyZXBsYWNlTGlzdGVuZXIiLCJvbmNlIiwiaXNMZWdhY3kiLCJpc0JlcmxpbiIsImlzQ2FuY3VuIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwib3JwaGFuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/providers/provider.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/providers/subscriber-filterid.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/subscriber-filterid.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FilterIdEventSubscriber: function() { return /* binding */ FilterIdEventSubscriber; },\n/* harmony export */   FilterIdPendingSubscriber: function() { return /* binding */ FilterIdPendingSubscriber; },\n/* harmony export */   FilterIdSubscriber: function() { return /* binding */ FilterIdSubscriber; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_get */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_get.js\");\n/* harmony import */ var _swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_init */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_init.js\");\n/* harmony import */ var _swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_set */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_set.js\");\n/* harmony import */ var _swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @swc/helpers/_/_class_private_method_get */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_method_get.js\");\n/* harmony import */ var _swc_helpers_class_private_method_init__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @swc/helpers/_/_class_private_method_init */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_method_init.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./subscriber-polling.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/providers/subscriber-polling.js\");\n\n\n\n\n\n\n\nfunction copy(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\nvar _provider = /*#__PURE__*/ new WeakMap(), _filterIdPromise = /*#__PURE__*/ new WeakMap(), _poller = /*#__PURE__*/ new WeakMap(), _running = /*#__PURE__*/ new WeakMap(), _network = /*#__PURE__*/ new WeakMap(), _hault = /*#__PURE__*/ new WeakMap(), _poll = /*#__PURE__*/ new WeakSet(), _teardown = /*#__PURE__*/ new WeakSet();\n/**\n *  Some backends support subscribing to events using a Filter ID.\n *\n *  When subscribing with this technique, the node issues a unique\n *  //Filter ID//. At this point the node dedicates resources to\n *  the filter, so that periodic calls to follow up on the //Filter ID//\n *  will receive any events since the last call.\n *\n *  @_docloc: api/providers/abstract-provider\n */ class FilterIdSubscriber {\n    /**\n     *  Sub-classes **must** override this to begin the subscription.\n     */ _subscribe(provider) {\n        throw new Error(\"subclasses must override this\");\n    }\n    /**\n     *  Sub-classes **must** override this handle the events.\n     */ _emitResults(provider, result) {\n        throw new Error(\"subclasses must override this\");\n    }\n    /**\n     *  Sub-classes **must** override this handle recovery on errors.\n     */ _recover(provider) {\n        throw new Error(\"subclasses must override this\");\n    }\n    start() {\n        if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _running)) {\n            return;\n        }\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_1__._)(this, _running, true);\n        (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _poll, poll).call(this, -2);\n    }\n    stop() {\n        if (!(0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _running)) {\n            return;\n        }\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_1__._)(this, _running, false);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_1__._)(this, _hault, true);\n        (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _teardown, teardown).call(this);\n        (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _provider).off(\"block\", (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _poller));\n    }\n    pause(dropWhilePaused) {\n        if (dropWhilePaused) {\n            (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _teardown, teardown).call(this);\n        }\n        (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _provider).off(\"block\", (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _poller));\n    }\n    resume() {\n        this.start();\n    }\n    /**\n     *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]\n     *  and [[_emitResults]] to setup the subscription and provide the event\n     *  to the %%provider%%.\n     */ constructor(provider){\n        (0,_swc_helpers_class_private_method_init__WEBPACK_IMPORTED_MODULE_3__._)(this, _poll);\n        (0,_swc_helpers_class_private_method_init__WEBPACK_IMPORTED_MODULE_3__._)(this, _teardown);\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_4__._)(this, _provider, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_4__._)(this, _filterIdPromise, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_4__._)(this, _poller, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_4__._)(this, _running, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_4__._)(this, _network, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_4__._)(this, _hault, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_1__._)(this, _provider, provider);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_1__._)(this, _filterIdPromise, null);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_1__._)(this, _poller, (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _poll, poll).bind(this));\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_1__._)(this, _running, false);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_1__._)(this, _network, null);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_1__._)(this, _hault, false);\n    }\n}\nasync function poll(blockNumber) {\n    try {\n        // Subscribe if necessary\n        if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _filterIdPromise) == null) {\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_1__._)(this, _filterIdPromise, this._subscribe((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _provider)));\n        }\n        // Get the Filter ID\n        let filterId = null;\n        try {\n            filterId = await (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _filterIdPromise);\n        } catch (error) {\n            if (!(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.isError)(error, \"UNSUPPORTED_OPERATION\") || error.operation !== \"eth_newFilter\") {\n                throw error;\n            }\n        }\n        // The backend does not support Filter ID; downgrade to\n        // polling\n        if (filterId == null) {\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_1__._)(this, _filterIdPromise, null);\n            (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _provider)._recoverSubscriber(this, this._recover((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _provider)));\n            return;\n        }\n        const network = await (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _provider).getNetwork();\n        if (!(0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _network)) {\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_1__._)(this, _network, network);\n        }\n        if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _network).chainId !== network.chainId) {\n            throw new Error(\"chaid changed\");\n        }\n        if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _hault)) {\n            return;\n        }\n        const result = await (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _provider).send(\"eth_getFilterChanges\", [\n            filterId\n        ]);\n        await this._emitResults((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _provider), result);\n    } catch (error) {\n        console.log(\"@TODO\", error);\n    }\n    (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _provider).once(\"block\", (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _poller));\n}\nfunction teardown() {\n    const filterIdPromise = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _filterIdPromise);\n    if (filterIdPromise) {\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_1__._)(this, _filterIdPromise, null);\n        filterIdPromise.then((filterId)=>{\n            if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _provider).destroyed) {\n                return;\n            }\n            (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _provider).send(\"eth_uninstallFilter\", [\n                filterId\n            ]);\n        });\n    }\n}\nvar _event = /*#__PURE__*/ new WeakMap();\n/**\n *  A **FilterIdSubscriber** for receiving contract events.\n *\n *  @_docloc: api/providers/abstract-provider\n */ class FilterIdEventSubscriber extends FilterIdSubscriber {\n    _recover(provider) {\n        return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_6__.PollingEventSubscriber(provider, (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _event));\n    }\n    async _subscribe(provider) {\n        const filterId = await provider.send(\"eth_newFilter\", [\n            (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _event)\n        ]);\n        return filterId;\n    }\n    async _emitResults(provider, results) {\n        for (const result of results){\n            provider.emit((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _event), provider._wrapLog(result, provider._network));\n        }\n    }\n    /**\n     *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%\n     *  listening for %%filter%%.\n     */ constructor(provider, filter){\n        super(provider);\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_4__._)(this, _event, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_1__._)(this, _event, copy(filter));\n    }\n}\n/**\n *  A **FilterIdSubscriber** for receiving pending transactions events.\n *\n *  @_docloc: api/providers/abstract-provider\n */ class FilterIdPendingSubscriber extends FilterIdSubscriber {\n    async _subscribe(provider) {\n        return await provider.send(\"eth_newPendingTransactionFilter\", []);\n    }\n    async _emitResults(provider, results) {\n        for (const result of results){\n            provider.emit(\"pending\", result);\n        }\n    }\n} //# sourceMappingURL=subscriber-filterid.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvc3Vic2NyaWJlci1maWx0ZXJpZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNEM7QUFDcUI7QUFDakUsU0FBU0UsS0FBS0MsR0FBRztJQUNiLE9BQU9DLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsU0FBUyxDQUFDSDtBQUNyQztJQVlJLHlDQUNBLGdEQUNBLHVDQUNBLHdDQUNBLHdDQUNBLHNDQWdDTSxxQ0F5Q047QUF6Rko7Ozs7Ozs7OztDQVNDLEdBQ00sTUFBTUk7SUFvQlQ7O0tBRUMsR0FDREMsV0FBV0MsUUFBUSxFQUFFO1FBQ2pCLE1BQU0sSUFBSUMsTUFBTTtJQUNwQjtJQUNBOztLQUVDLEdBQ0RDLGFBQWFGLFFBQVEsRUFBRUcsTUFBTSxFQUFFO1FBQzNCLE1BQU0sSUFBSUYsTUFBTTtJQUNwQjtJQUNBOztLQUVDLEdBQ0RHLFNBQVNKLFFBQVEsRUFBRTtRQUNmLE1BQU0sSUFBSUMsTUFBTTtJQUNwQjtJQXNEQUksUUFBUTtRQUNKLElBQUksNEVBQUksRUFBRUMsV0FBUztZQUNmO1FBQ0o7c0ZBQ01BLFVBQVU7UUFDaEIsNkVBQUksRUFBRUMsT0FBQUEsV0FBTixJQUFJLEVBQU8sQ0FBQztJQUNoQjtJQUNBQyxPQUFPO1FBQ0gsSUFBSSxDQUFDLDRFQUFJLEVBQUVGLFdBQVM7WUFDaEI7UUFDSjtzRkFDTUEsVUFBVTtzRkFDVkcsUUFBUTtRQUNkLDZFQUFJLEVBQUVDLFdBQUFBLGVBQU4sSUFBSTtRQUNKLDRFQUFJLEVBQUVWLFdBQVNXLEdBQUcsQ0FBQyxTQUFTLDRFQUFJLEVBQUVDO0lBQ3RDO0lBQ0FDLE1BQU1DLGVBQWUsRUFBRTtRQUNuQixJQUFJQSxpQkFBaUI7WUFDakIsNkVBQUksRUFBRUosV0FBQUEsZUFBTixJQUFJO1FBQ1I7UUFDQSw0RUFBSSxFQUFFVixXQUFTVyxHQUFHLENBQUMsU0FBUyw0RUFBSSxFQUFF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NEVBQUksRUFBRUYsU0FBT2xDLFNBQVNxQyxRQUFRLENBQUNsQyxRQUFRSCxTQUFTc0MsUUFBUTtRQUMxRTtJQUNKO0lBbkJBOzs7S0FHQyxHQUNEdEIsWUFBWWhCLFFBQVEsRUFBRXVDLE1BQU0sQ0FBRTtRQUMxQixLQUFLLENBQUN2QztRQU5WOzttQkFBQTs7c0ZBT1VrQyxRQUFRekMsS0FBSzhDO0lBQ3ZCO0FBYUo7QUFDQTs7OztDQUlDLEdBQ00sTUFBTUMsa0NBQWtDMUM7SUFDM0MsTUFBTUMsV0FBV0MsUUFBUSxFQUFFO1FBQ3ZCLE9BQU8sTUFBTUEsU0FBUzJCLElBQUksQ0FBQyxtQ0FBbUMsRUFBRTtJQUNwRTtJQUNBLE1BQU16QixhQUFhRixRQUFRLEVBQUVtQyxPQUFPLEVBQUU7UUFDbEMsS0FBSyxNQUFNaEMsVUFBVWdDLFFBQVM7WUFDMUJuQyxTQUFTb0MsSUFBSSxDQUFDLFdBQVdqQztRQUM3QjtJQUNKO0FBQ0osRUFDQSwrQ0FBK0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9zdWJzY3JpYmVyLWZpbHRlcmlkLmpzPzljMjMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNFcnJvciB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgUG9sbGluZ0V2ZW50U3Vic2NyaWJlciB9IGZyb20gXCIuL3N1YnNjcmliZXItcG9sbGluZy5qc1wiO1xuZnVuY3Rpb24gY29weShvYmopIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbn1cbi8qKlxuICogIFNvbWUgYmFja2VuZHMgc3VwcG9ydCBzdWJzY3JpYmluZyB0byBldmVudHMgdXNpbmcgYSBGaWx0ZXIgSUQuXG4gKlxuICogIFdoZW4gc3Vic2NyaWJpbmcgd2l0aCB0aGlzIHRlY2huaXF1ZSwgdGhlIG5vZGUgaXNzdWVzIGEgdW5pcXVlXG4gKiAgLy9GaWx0ZXIgSUQvLy4gQXQgdGhpcyBwb2ludCB0aGUgbm9kZSBkZWRpY2F0ZXMgcmVzb3VyY2VzIHRvXG4gKiAgdGhlIGZpbHRlciwgc28gdGhhdCBwZXJpb2RpYyBjYWxscyB0byBmb2xsb3cgdXAgb24gdGhlIC8vRmlsdGVyIElELy9cbiAqICB3aWxsIHJlY2VpdmUgYW55IGV2ZW50cyBzaW5jZSB0aGUgbGFzdCBjYWxsLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxuICovXG5leHBvcnQgY2xhc3MgRmlsdGVySWRTdWJzY3JpYmVyIHtcbiAgICAjcHJvdmlkZXI7XG4gICAgI2ZpbHRlcklkUHJvbWlzZTtcbiAgICAjcG9sbGVyO1xuICAgICNydW5uaW5nO1xuICAgICNuZXR3b3JrO1xuICAgICNoYXVsdDtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkZpbHRlcklkU3Vic2NyaWJlcioqIHdoaWNoIHdpbGwgdXNlZCBbW19zdWJzY3JpYmVdXVxuICAgICAqICBhbmQgW1tfZW1pdFJlc3VsdHNdXSB0byBzZXR1cCB0aGUgc3Vic2NyaXB0aW9uIGFuZCBwcm92aWRlIHRoZSBldmVudFxuICAgICAqICB0byB0aGUgJSVwcm92aWRlciUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIHRoaXMuI2ZpbHRlcklkUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHRoaXMuI3BvbGxlciA9IHRoaXMuI3BvbGwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy4jcnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNuZXR3b3JrID0gbnVsbDtcbiAgICAgICAgdGhpcy4jaGF1bHQgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzICoqbXVzdCoqIG92ZXJyaWRlIHRoaXMgdG8gYmVnaW4gdGhlIHN1YnNjcmlwdGlvbi5cbiAgICAgKi9cbiAgICBfc3Vic2NyaWJlKHByb3ZpZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInN1YmNsYXNzZXMgbXVzdCBvdmVycmlkZSB0aGlzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU3ViLWNsYXNzZXMgKiptdXN0Kiogb3ZlcnJpZGUgdGhpcyBoYW5kbGUgdGhlIGV2ZW50cy5cbiAgICAgKi9cbiAgICBfZW1pdFJlc3VsdHMocHJvdmlkZXIsIHJlc3VsdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgdGhpc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzICoqbXVzdCoqIG92ZXJyaWRlIHRoaXMgaGFuZGxlIHJlY292ZXJ5IG9uIGVycm9ycy5cbiAgICAgKi9cbiAgICBfcmVjb3Zlcihwcm92aWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgdGhpc1wiKTtcbiAgICB9XG4gICAgYXN5bmMgI3BvbGwoYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFN1YnNjcmliZSBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgIGlmICh0aGlzLiNmaWx0ZXJJZFByb21pc2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuI2ZpbHRlcklkUHJvbWlzZSA9IHRoaXMuX3N1YnNjcmliZSh0aGlzLiNwcm92aWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgdGhlIEZpbHRlciBJRFxuICAgICAgICAgICAgbGV0IGZpbHRlcklkID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZmlsdGVySWQgPSBhd2FpdCB0aGlzLiNmaWx0ZXJJZFByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRXJyb3IoZXJyb3IsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIpIHx8IGVycm9yLm9wZXJhdGlvbiAhPT0gXCJldGhfbmV3RmlsdGVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlIGJhY2tlbmQgZG9lcyBub3Qgc3VwcG9ydCBGaWx0ZXIgSUQ7IGRvd25ncmFkZSB0b1xuICAgICAgICAgICAgLy8gcG9sbGluZ1xuICAgICAgICAgICAgaWYgKGZpbHRlcklkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNmaWx0ZXJJZFByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuI3Byb3ZpZGVyLl9yZWNvdmVyU3Vic2NyaWJlcih0aGlzLCB0aGlzLl9yZWNvdmVyKHRoaXMuI3Byb3ZpZGVyKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IHRoaXMuI3Byb3ZpZGVyLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy4jbmV0d29yaykge1xuICAgICAgICAgICAgICAgIHRoaXMuI25ldHdvcmsgPSBuZXR3b3JrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuI25ldHdvcmsuY2hhaW5JZCAhPT0gbmV0d29yay5jaGFpbklkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2hhaWQgY2hhbmdlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLiNoYXVsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuI3Byb3ZpZGVyLnNlbmQoXCJldGhfZ2V0RmlsdGVyQ2hhbmdlc1wiLCBbZmlsdGVySWRdKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2VtaXRSZXN1bHRzKHRoaXMuI3Byb3ZpZGVyLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJAVE9ET1wiLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcHJvdmlkZXIub25jZShcImJsb2NrXCIsIHRoaXMuI3BvbGxlcik7XG4gICAgfVxuICAgICN0ZWFyZG93bigpIHtcbiAgICAgICAgY29uc3QgZmlsdGVySWRQcm9taXNlID0gdGhpcy4jZmlsdGVySWRQcm9taXNlO1xuICAgICAgICBpZiAoZmlsdGVySWRQcm9taXNlKSB7XG4gICAgICAgICAgICB0aGlzLiNmaWx0ZXJJZFByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgZmlsdGVySWRQcm9taXNlLnRoZW4oKGZpbHRlcklkKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI3Byb3ZpZGVyLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuI3Byb3ZpZGVyLnNlbmQoXCJldGhfdW5pbnN0YWxsRmlsdGVyXCIsIFtmaWx0ZXJJZF0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLiNydW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcnVubmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuI3BvbGwoLTIpO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAoIXRoaXMuI3J1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI2hhdWx0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4jdGVhcmRvd24oKTtcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIub2ZmKFwiYmxvY2tcIiwgdGhpcy4jcG9sbGVyKTtcbiAgICB9XG4gICAgcGF1c2UoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgIGlmIChkcm9wV2hpbGVQYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuI3RlYXJkb3duKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcHJvdmlkZXIub2ZmKFwiYmxvY2tcIiwgdGhpcy4jcG9sbGVyKTtcbiAgICB9XG4gICAgcmVzdW1lKCkgeyB0aGlzLnN0YXJ0KCk7IH1cbn1cbi8qKlxuICogIEEgKipGaWx0ZXJJZFN1YnNjcmliZXIqKiBmb3IgcmVjZWl2aW5nIGNvbnRyYWN0IGV2ZW50cy5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuZXhwb3J0IGNsYXNzIEZpbHRlcklkRXZlbnRTdWJzY3JpYmVyIGV4dGVuZHMgRmlsdGVySWRTdWJzY3JpYmVyIHtcbiAgICAjZXZlbnQ7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipGaWx0ZXJJZEV2ZW50U3Vic2NyaWJlcioqIGF0dGFjaGVkIHRvICUlcHJvdmlkZXIlJVxuICAgICAqICBsaXN0ZW5pbmcgZm9yICUlZmlsdGVyJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGZpbHRlcikge1xuICAgICAgICBzdXBlcihwcm92aWRlcik7XG4gICAgICAgIHRoaXMuI2V2ZW50ID0gY29weShmaWx0ZXIpO1xuICAgIH1cbiAgICBfcmVjb3Zlcihwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gbmV3IFBvbGxpbmdFdmVudFN1YnNjcmliZXIocHJvdmlkZXIsIHRoaXMuI2V2ZW50KTtcbiAgICB9XG4gICAgYXN5bmMgX3N1YnNjcmliZShwcm92aWRlcikge1xuICAgICAgICBjb25zdCBmaWx0ZXJJZCA9IGF3YWl0IHByb3ZpZGVyLnNlbmQoXCJldGhfbmV3RmlsdGVyXCIsIFt0aGlzLiNldmVudF0pO1xuICAgICAgICByZXR1cm4gZmlsdGVySWQ7XG4gICAgfVxuICAgIGFzeW5jIF9lbWl0UmVzdWx0cyhwcm92aWRlciwgcmVzdWx0cykge1xuICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICBwcm92aWRlci5lbWl0KHRoaXMuI2V2ZW50LCBwcm92aWRlci5fd3JhcExvZyhyZXN1bHQsIHByb3ZpZGVyLl9uZXR3b3JrKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqICBBICoqRmlsdGVySWRTdWJzY3JpYmVyKiogZm9yIHJlY2VpdmluZyBwZW5kaW5nIHRyYW5zYWN0aW9ucyBldmVudHMuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBGaWx0ZXJJZFBlbmRpbmdTdWJzY3JpYmVyIGV4dGVuZHMgRmlsdGVySWRTdWJzY3JpYmVyIHtcbiAgICBhc3luYyBfc3Vic2NyaWJlKHByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5zZW5kKFwiZXRoX25ld1BlbmRpbmdUcmFuc2FjdGlvbkZpbHRlclwiLCBbXSk7XG4gICAgfVxuICAgIGFzeW5jIF9lbWl0UmVzdWx0cyhwcm92aWRlciwgcmVzdWx0cykge1xuICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICBwcm92aWRlci5lbWl0KFwicGVuZGluZ1wiLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3Vic2NyaWJlci1maWx0ZXJpZC5qcy5tYXAiXSwibmFtZXMiOlsiaXNFcnJvciIsIlBvbGxpbmdFdmVudFN1YnNjcmliZXIiLCJjb3B5Iiwib2JqIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwiRmlsdGVySWRTdWJzY3JpYmVyIiwiX3N1YnNjcmliZSIsInByb3ZpZGVyIiwiRXJyb3IiLCJfZW1pdFJlc3VsdHMiLCJyZXN1bHQiLCJfcmVjb3ZlciIsInN0YXJ0IiwicnVubmluZyIsInBvbGwiLCJzdG9wIiwiaGF1bHQiLCJ0ZWFyZG93biIsIm9mZiIsInBvbGxlciIsInBhdXNlIiwiZHJvcFdoaWxlUGF1c2VkIiwicmVzdW1lIiwiY29uc3RydWN0b3IiLCJmaWx0ZXJJZFByb21pc2UiLCJiaW5kIiwibmV0d29yayIsImJsb2NrTnVtYmVyIiwiZmlsdGVySWQiLCJlcnJvciIsIm9wZXJhdGlvbiIsIl9yZWNvdmVyU3Vic2NyaWJlciIsImdldE5ldHdvcmsiLCJjaGFpbklkIiwic2VuZCIsImNvbnNvbGUiLCJsb2ciLCJvbmNlIiwidGhlbiIsImRlc3Ryb3llZCIsIkZpbHRlcklkRXZlbnRTdWJzY3JpYmVyIiwiZXZlbnQiLCJyZXN1bHRzIiwiZW1pdCIsIl93cmFwTG9nIiwiX25ldHdvcmsiLCJmaWx0ZXIiLCJGaWx0ZXJJZFBlbmRpbmdTdWJzY3JpYmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/providers/subscriber-filterid.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/providers/subscriber-polling.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/subscriber-polling.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OnBlockSubscriber: function() { return /* binding */ OnBlockSubscriber; },\n/* harmony export */   PollingBlockSubscriber: function() { return /* binding */ PollingBlockSubscriber; },\n/* harmony export */   PollingBlockTagSubscriber: function() { return /* binding */ PollingBlockTagSubscriber; },\n/* harmony export */   PollingEventSubscriber: function() { return /* binding */ PollingEventSubscriber; },\n/* harmony export */   PollingOrphanSubscriber: function() { return /* binding */ PollingOrphanSubscriber; },\n/* harmony export */   PollingTransactionSubscriber: function() { return /* binding */ PollingTransactionSubscriber; },\n/* harmony export */   getPollingSubscriber: function() { return /* binding */ getPollingSubscriber; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_get */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_get.js\");\n/* harmony import */ var _swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_init */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_init.js\");\n/* harmony import */ var _swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_set */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_set.js\");\n/* harmony import */ var _swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @swc/helpers/_/_class_private_method_get */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_method_get.js\");\n/* harmony import */ var _swc_helpers_class_private_method_init__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @swc/helpers/_/_class_private_method_init */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_method_init.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n\n\n\n\n\n\nfunction copy(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\n/**\n *  Return the polling subscriber for common events.\n *\n *  @_docloc: api/providers/abstract-provider\n */ function getPollingSubscriber(provider, event) {\n    if (event === \"block\") {\n        return new PollingBlockSubscriber(provider);\n    }\n    if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(event, 32)) {\n        return new PollingTransactionSubscriber(provider, event);\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"unsupported polling event\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"getPollingSubscriber\",\n        info: {\n            event\n        }\n    });\n}\nvar _provider = /*#__PURE__*/ new WeakMap(), _poller = /*#__PURE__*/ new WeakMap(), _interval = /*#__PURE__*/ new WeakMap(), // The most recent block we have scanned for events. The value -2\n// indicates we still need to fetch an initial block number\n_blockNumber = /*#__PURE__*/ new WeakMap(), _poll = /*#__PURE__*/ new WeakSet();\n// @TODO: refactor this\n/**\n *  A **PollingBlockSubscriber** polls at a regular interval for a change\n *  in the block number.\n *\n *  @_docloc: api/providers/abstract-provider\n */ class PollingBlockSubscriber {\n    /**\n     *  The polling interval.\n     */ get pollingInterval() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _interval);\n    }\n    set pollingInterval(value) {\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_3__._)(this, _interval, value);\n    }\n    start() {\n        if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _poller)) {\n            return;\n        }\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_3__._)(this, _poller, (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _provider)._setTimeout((0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _poll, poll).bind(this), (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _interval)));\n        (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _poll, poll).call(this);\n    }\n    stop() {\n        if (!(0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _poller)) {\n            return;\n        }\n        (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _provider)._clearTimeout((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _poller));\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_3__._)(this, _poller, null);\n    }\n    pause(dropWhilePaused) {\n        this.stop();\n        if (dropWhilePaused) {\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_3__._)(this, _blockNumber, -2);\n        }\n    }\n    resume() {\n        this.start();\n    }\n    /**\n     *  Create a new **PollingBlockSubscriber** attached to %%provider%%.\n     */ constructor(provider){\n        (0,_swc_helpers_class_private_method_init__WEBPACK_IMPORTED_MODULE_5__._)(this, _poll);\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_6__._)(this, _provider, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_6__._)(this, _poller, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_6__._)(this, _interval, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_6__._)(this, _blockNumber, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_3__._)(this, _provider, provider);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_3__._)(this, _poller, null);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_3__._)(this, _interval, 4000);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_3__._)(this, _blockNumber, -2);\n    }\n}\nasync function poll() {\n    try {\n        const blockNumber = await (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _provider).getBlockNumber();\n        // Bootstrap poll to setup our initial block number\n        if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _blockNumber) === -2) {\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_3__._)(this, _blockNumber, blockNumber);\n            return;\n        }\n        // @TODO: Put a cap on the maximum number of events per loop?\n        if (blockNumber !== (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _blockNumber)) {\n            for(let b = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _blockNumber) + 1; b <= blockNumber; b++){\n                // We have been stopped\n                if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _poller) == null) {\n                    return;\n                }\n                await (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _provider).emit(\"block\", b);\n            }\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_3__._)(this, _blockNumber, blockNumber);\n        }\n    } catch (error) {\n    // @TODO: Minor bump, add an \"error\" event to let subscribers\n    //        know things went awry.\n    //console.log(error);\n    }\n    // We have been stopped\n    if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _poller) == null) {\n        return;\n    }\n    (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_3__._)(this, _poller, (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _provider)._setTimeout((0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _poll, poll).bind(this), (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _interval)));\n}\nvar _provider1 = /*#__PURE__*/ new WeakMap(), _poll1 = /*#__PURE__*/ new WeakMap(), _running = /*#__PURE__*/ new WeakMap();\n/**\n *  An **OnBlockSubscriber** can be sub-classed, with a [[_poll]]\n *  implmentation which will be called on every new block.\n *\n *  @_docloc: api/providers/abstract-provider\n */ class OnBlockSubscriber {\n    /**\n     *  Called on every new block.\n     */ async _poll(blockNumber, provider) {\n        throw new Error(\"sub-classes must override this\");\n    }\n    start() {\n        if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _running)) {\n            return;\n        }\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_3__._)(this, _running, true);\n        (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _poll1).call(this, -2);\n        (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _provider1).on(\"block\", (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _poll1));\n    }\n    stop() {\n        if (!(0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _running)) {\n            return;\n        }\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_3__._)(this, _running, false);\n        (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _provider1).off(\"block\", (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _poll1));\n    }\n    pause(dropWhilePaused) {\n        this.stop();\n    }\n    resume() {\n        this.start();\n    }\n    /**\n     *  Create a new **OnBlockSubscriber** attached to %%provider%%.\n     */ constructor(provider){\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_6__._)(this, _provider1, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_6__._)(this, _poll1, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_6__._)(this, _running, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_3__._)(this, _provider1, provider);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_3__._)(this, _running, false);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_3__._)(this, _poll1, (blockNumber)=>{\n            this._poll(blockNumber, (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _provider1));\n        });\n    }\n}\nvar _tag = /*#__PURE__*/ new WeakMap(), _lastBlock = /*#__PURE__*/ new WeakMap();\nclass PollingBlockTagSubscriber extends OnBlockSubscriber {\n    pause(dropWhilePaused) {\n        if (dropWhilePaused) {\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_3__._)(this, _lastBlock, -2);\n        }\n        super.pause(dropWhilePaused);\n    }\n    async _poll(blockNumber, provider) {\n        const block = await provider.getBlock((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _tag));\n        if (block == null) {\n            return;\n        }\n        if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _lastBlock) === -2) {\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_3__._)(this, _lastBlock, block.number);\n        } else if (block.number > (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _lastBlock)) {\n            provider.emit((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _tag), block.number);\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_3__._)(this, _lastBlock, block.number);\n        }\n    }\n    constructor(provider, tag){\n        super(provider);\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_6__._)(this, _tag, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_6__._)(this, _lastBlock, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_3__._)(this, _tag, tag);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_3__._)(this, _lastBlock, -2);\n    }\n}\nvar _filter = /*#__PURE__*/ new WeakMap();\n/**\n *  @_ignore:\n *\n *  @_docloc: api/providers/abstract-provider\n */ class PollingOrphanSubscriber extends OnBlockSubscriber {\n    async _poll(blockNumber, provider) {\n        throw new Error(\"@TODO\");\n        console.log((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _filter));\n    }\n    constructor(provider, filter){\n        super(provider);\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_6__._)(this, _filter, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_3__._)(this, _filter, copy(filter));\n    }\n}\nvar _hash = /*#__PURE__*/ new WeakMap();\n/**\n *  A **PollingTransactionSubscriber** will poll for a given transaction\n *  hash for its receipt.\n *\n *  @_docloc: api/providers/abstract-provider\n */ class PollingTransactionSubscriber extends OnBlockSubscriber {\n    async _poll(blockNumber, provider) {\n        const tx = await provider.getTransactionReceipt((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _hash));\n        if (tx) {\n            provider.emit((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _hash), tx);\n        }\n    }\n    /**\n     *  Create a new **PollingTransactionSubscriber** attached to\n     *  %%provider%%, listening for %%hash%%.\n     */ constructor(provider, hash){\n        super(provider);\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_6__._)(this, _hash, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_3__._)(this, _hash, hash);\n    }\n}\nvar _provider2 = /*#__PURE__*/ new WeakMap(), _filter1 = /*#__PURE__*/ new WeakMap(), _poller1 = /*#__PURE__*/ new WeakMap(), _running1 = /*#__PURE__*/ new WeakMap(), // The most recent block we have scanned for events. The value -2\n// indicates we still need to fetch an initial block number\n_blockNumber1 = /*#__PURE__*/ new WeakMap(), _poll2 = /*#__PURE__*/ new WeakSet();\n/**\n *  A **PollingEventSubscriber** will poll for a given filter for its logs.\n *\n *  @_docloc: api/providers/abstract-provider\n */ class PollingEventSubscriber {\n    start() {\n        if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _running1)) {\n            return;\n        }\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_3__._)(this, _running1, true);\n        if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _blockNumber1) === -2) {\n            (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _provider2).getBlockNumber().then((blockNumber)=>{\n                (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_3__._)(this, _blockNumber1, blockNumber);\n            });\n        }\n        (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _provider2).on(\"block\", (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _poller1));\n    }\n    stop() {\n        if (!(0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _running1)) {\n            return;\n        }\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_3__._)(this, _running1, false);\n        (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _provider2).off(\"block\", (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _poller1));\n    }\n    pause(dropWhilePaused) {\n        this.stop();\n        if (dropWhilePaused) {\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_3__._)(this, _blockNumber1, -2);\n        }\n    }\n    resume() {\n        this.start();\n    }\n    /**\n     *  Create a new **PollingTransactionSubscriber** attached to\n     *  %%provider%%, listening for %%filter%%.\n     */ constructor(provider, filter){\n        (0,_swc_helpers_class_private_method_init__WEBPACK_IMPORTED_MODULE_5__._)(this, _poll2);\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_6__._)(this, _provider2, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_6__._)(this, _filter1, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_6__._)(this, _poller1, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_6__._)(this, _running1, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_6__._)(this, _blockNumber1, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_3__._)(this, _provider2, provider);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_3__._)(this, _filter1, copy(filter));\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_3__._)(this, _poller1, (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_4__._)(this, _poll2, poll1).bind(this));\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_3__._)(this, _running1, false);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_3__._)(this, _blockNumber1, -2);\n    }\n} //# sourceMappingURL=subscriber-polling.js.map\nasync function poll1(blockNumber) {\n    // The initial block hasn't been determined yet\n    if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _blockNumber1) === -2) {\n        return;\n    }\n    const filter = copy((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _filter1));\n    filter.fromBlock = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _blockNumber1) + 1;\n    filter.toBlock = blockNumber;\n    const logs = await (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _provider2).getLogs(filter);\n    // No logs could just mean the node has not indexed them yet,\n    // so we keep a sliding window of 60 blocks to keep scanning\n    if (logs.length === 0) {\n        if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _blockNumber1) < blockNumber - 60) {\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_3__._)(this, _blockNumber1, blockNumber - 60);\n        }\n        return;\n    }\n    for (const log of logs){\n        (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _provider2).emit((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_2__._)(this, _filter1), log);\n        // Only advance the block number when logs were found to\n        // account for networks (like BNB and Polygon) which may\n        // sacrifice event consistency for block event speed\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_3__._)(this, _blockNumber1, log.blockNumber);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvc3Vic2NyaWJlci1wb2xsaW5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0Q7QUFDeEQsU0FBU0UsS0FBS0MsR0FBRztJQUNiLE9BQU9DLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsU0FBUyxDQUFDSDtBQUNyQztBQUNBOzs7O0NBSUMsR0FDTSxTQUFTSSxxQkFBcUJDLFFBQVEsRUFBRUMsS0FBSztJQUNoRCxJQUFJQSxVQUFVLFNBQVM7UUFDbkIsT0FBTyxJQUFJQyx1QkFBdUJGO0lBQ3RDO0lBQ0EsSUFBSVAsNERBQVdBLENBQUNRLE9BQU8sS0FBSztRQUN4QixPQUFPLElBQUlFLDZCQUE2QkgsVUFBVUM7SUFDdEQ7SUFDQVQsdURBQU1BLENBQUMsT0FBTyw2QkFBNkIseUJBQXlCO1FBQ2hFWSxXQUFXO1FBQXdCQyxNQUFNO1lBQUVKO1FBQU07SUFDckQ7QUFDSjtJQVNJLHlDQUNBLHVDQUNBLHlDQUNBLGlFQUFpRTtBQUNqRSwyREFBMkQ7QUFDM0QsNENBZU07QUE1QlYsdUJBQXVCO0FBQ3ZCOzs7OztDQUtDLEdBQ00sTUFBTUM7SUFnQlQ7O0tBRUMsR0FDRCxJQUFJSSxrQkFBa0I7UUFBRSxPQUFPLDRFQUFJLEVBQUVDO0lBQVU7SUFDL0MsSUFBSUQsZ0JBQWdCRSxLQUFLLEVBQUU7c0ZBQVFELFdBQVdDO0lBQU87SUFnQ3JEQyxRQUFRO1FBQ0osSUFBSSw0RUFBSSxFQUFFQyxVQUFRO1lBQ2Q7UUFDSjtzRkFDTUEsU0FBUyw0RUFBSSxFQUFFVixXQUFTVyxXQUFXLENBQUMsNkVBQUksRUFBRUMsT0FBQUEsTUFBS0MsSUFBSSxDQUFDLElBQUksR0FBRyw0RUFBSSxFQUFFTjtRQUN2RSw2RUFBSSxFQUFFSyxPQUFBQSxXQUFOLElBQUk7SUFDUjtJQUNBRSxPQUFPO1FBQ0gsSUFBSSxDQUFDLDRFQUFJLEVBQUVKLFVBQVE7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QUM3QmUsV0FBVTtzRkFDVlYsZUFBYyxDQUFDO0lBQ3pCO0FBc0RKLEVBQ0EsOENBQThDO0FBdEQxQyxxQkFBWUEsV0FBVztJQUNuQiwrQ0FBK0M7SUFDL0MsSUFBSSw0RUFBSSxFQUFFQSxtQkFBZ0IsQ0FBQyxHQUFHO1FBQzFCO0lBQ0o7SUFDQSxNQUFNc0IsU0FBUzlDLEtBQUtBLHVFQUFBQSxDQUFBLElBQUksRUFBRThDO0lBQzFCQSxPQUFPTSxTQUFTLEdBQUcsNEVBQUksRUFBRTVCLGlCQUFjO0lBQ3ZDc0IsT0FBT08sT0FBTyxHQUFHN0I7SUFDakIsTUFBTThCLE9BQU8sTUFBTSw0RUFBSSxFQUFFaEQsWUFBU2lELE9BQU8sQ0FBQ1Q7SUFDMUMsNkRBQTZEO0lBQzdELDREQUE0RDtJQUM1RCxJQUFJUSxLQUFLRSxNQUFNLEtBQUssR0FBRztRQUNuQixJQUFJLDRFQUFJLEVBQUVoQyxpQkFBY0EsY0FBYyxJQUFJOzBGQUNoQ0EsZUFBY0EsY0FBYztRQUN0QztRQUNBO0lBQ0o7SUFDQSxLQUFLLE1BQU1xQixPQUFPUyxLQUFNO1FBQ3BCLDRFQUFJLEVBQUVoRCxZQUFTdUIsSUFBSSxDQUFDLDRFQUFJLEVBQUVpQixXQUFRRDtRQUNsQyx3REFBd0Q7UUFDeEQsd0RBQXdEO1FBQ3hELG9EQUFvRDtzRkFDOUNyQixlQUFjcUIsSUFBSXJCLFdBQVc7SUFDdkM7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3N1YnNjcmliZXItcG9sbGluZy5qcz9iNmM2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFzc2VydCwgaXNIZXhTdHJpbmcgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmZ1bmN0aW9uIGNvcHkob2JqKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG59XG4vKipcbiAqICBSZXR1cm4gdGhlIHBvbGxpbmcgc3Vic2NyaWJlciBmb3IgY29tbW9uIGV2ZW50cy5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFBvbGxpbmdTdWJzY3JpYmVyKHByb3ZpZGVyLCBldmVudCkge1xuICAgIGlmIChldmVudCA9PT0gXCJibG9ja1wiKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9sbGluZ0Jsb2NrU3Vic2NyaWJlcihwcm92aWRlcik7XG4gICAgfVxuICAgIGlmIChpc0hleFN0cmluZyhldmVudCwgMzIpKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9sbGluZ1RyYW5zYWN0aW9uU3Vic2NyaWJlcihwcm92aWRlciwgZXZlbnQpO1xuICAgIH1cbiAgICBhc3NlcnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgcG9sbGluZyBldmVudFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgIG9wZXJhdGlvbjogXCJnZXRQb2xsaW5nU3Vic2NyaWJlclwiLCBpbmZvOiB7IGV2ZW50IH1cbiAgICB9KTtcbn1cbi8vIEBUT0RPOiByZWZhY3RvciB0aGlzXG4vKipcbiAqICBBICoqUG9sbGluZ0Jsb2NrU3Vic2NyaWJlcioqIHBvbGxzIGF0IGEgcmVndWxhciBpbnRlcnZhbCBmb3IgYSBjaGFuZ2VcbiAqICBpbiB0aGUgYmxvY2sgbnVtYmVyLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxuICovXG5leHBvcnQgY2xhc3MgUG9sbGluZ0Jsb2NrU3Vic2NyaWJlciB7XG4gICAgI3Byb3ZpZGVyO1xuICAgICNwb2xsZXI7XG4gICAgI2ludGVydmFsO1xuICAgIC8vIFRoZSBtb3N0IHJlY2VudCBibG9jayB3ZSBoYXZlIHNjYW5uZWQgZm9yIGV2ZW50cy4gVGhlIHZhbHVlIC0yXG4gICAgLy8gaW5kaWNhdGVzIHdlIHN0aWxsIG5lZWQgdG8gZmV0Y2ggYW4gaW5pdGlhbCBibG9jayBudW1iZXJcbiAgICAjYmxvY2tOdW1iZXI7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKlBvbGxpbmdCbG9ja1N1YnNjcmliZXIqKiBhdHRhY2hlZCB0byAlJXByb3ZpZGVyJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgdGhpcy4jcG9sbGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy4jaW50ZXJ2YWwgPSA0MDAwO1xuICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IC0yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHBvbGxpbmcgaW50ZXJ2YWwuXG4gICAgICovXG4gICAgZ2V0IHBvbGxpbmdJbnRlcnZhbCgpIHsgcmV0dXJuIHRoaXMuI2ludGVydmFsOyB9XG4gICAgc2V0IHBvbGxpbmdJbnRlcnZhbCh2YWx1ZSkgeyB0aGlzLiNpbnRlcnZhbCA9IHZhbHVlOyB9XG4gICAgYXN5bmMgI3BvbGwoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBibG9ja051bWJlciA9IGF3YWl0IHRoaXMuI3Byb3ZpZGVyLmdldEJsb2NrTnVtYmVyKCk7XG4gICAgICAgICAgICAvLyBCb290c3RyYXAgcG9sbCB0byBzZXR1cCBvdXIgaW5pdGlhbCBibG9jayBudW1iZXJcbiAgICAgICAgICAgIGlmICh0aGlzLiNibG9ja051bWJlciA9PT0gLTIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEBUT0RPOiBQdXQgYSBjYXAgb24gdGhlIG1heGltdW0gbnVtYmVyIG9mIGV2ZW50cyBwZXIgbG9vcD9cbiAgICAgICAgICAgIGlmIChibG9ja051bWJlciAhPT0gdGhpcy4jYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBiID0gdGhpcy4jYmxvY2tOdW1iZXIgKyAxOyBiIDw9IGJsb2NrTnVtYmVyOyBiKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBiZWVuIHN0b3BwZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuI3BvbGxlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy4jcHJvdmlkZXIuZW1pdChcImJsb2NrXCIsIGIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gQFRPRE86IE1pbm9yIGJ1bXAsIGFkZCBhbiBcImVycm9yXCIgZXZlbnQgdG8gbGV0IHN1YnNjcmliZXJzXG4gICAgICAgICAgICAvLyAgICAgICAga25vdyB0aGluZ3Mgd2VudCBhd3J5LlxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgaGF2ZSBiZWVuIHN0b3BwZWRcbiAgICAgICAgaWYgKHRoaXMuI3BvbGxlciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcG9sbGVyID0gdGhpcy4jcHJvdmlkZXIuX3NldFRpbWVvdXQodGhpcy4jcG9sbC5iaW5kKHRoaXMpLCB0aGlzLiNpbnRlcnZhbCk7XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy4jcG9sbGVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcG9sbGVyID0gdGhpcy4jcHJvdmlkZXIuX3NldFRpbWVvdXQodGhpcy4jcG9sbC5iaW5kKHRoaXMpLCB0aGlzLiNpbnRlcnZhbCk7XG4gICAgICAgIHRoaXMuI3BvbGwoKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLiNwb2xsZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwcm92aWRlci5fY2xlYXJUaW1lb3V0KHRoaXMuI3BvbGxlcik7XG4gICAgICAgIHRoaXMuI3BvbGxlciA9IG51bGw7XG4gICAgfVxuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgaWYgKGRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSAtMjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICB9XG59XG4vKipcbiAqICBBbiAqKk9uQmxvY2tTdWJzY3JpYmVyKiogY2FuIGJlIHN1Yi1jbGFzc2VkLCB3aXRoIGEgW1tfcG9sbF1dXG4gKiAgaW1wbG1lbnRhdGlvbiB3aGljaCB3aWxsIGJlIGNhbGxlZCBvbiBldmVyeSBuZXcgYmxvY2suXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBPbkJsb2NrU3Vic2NyaWJlciB7XG4gICAgI3Byb3ZpZGVyO1xuICAgICNwb2xsO1xuICAgICNydW5uaW5nO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipPbkJsb2NrU3Vic2NyaWJlcioqIGF0dGFjaGVkIHRvICUlcHJvdmlkZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcikge1xuICAgICAgICB0aGlzLiNwcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLiNydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI3BvbGwgPSAoYmxvY2tOdW1iZXIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3BvbGwoYmxvY2tOdW1iZXIsIHRoaXMuI3Byb3ZpZGVyKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENhbGxlZCBvbiBldmVyeSBuZXcgYmxvY2suXG4gICAgICovXG4gICAgYXN5bmMgX3BvbGwoYmxvY2tOdW1iZXIsIHByb3ZpZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInN1Yi1jbGFzc2VzIG11c3Qgb3ZlcnJpZGUgdGhpc1wiKTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLiNydW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcnVubmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuI3BvbGwoLTIpO1xuICAgICAgICB0aGlzLiNwcm92aWRlci5vbihcImJsb2NrXCIsIHRoaXMuI3BvbGwpO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAoIXRoaXMuI3J1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9mZihcImJsb2NrXCIsIHRoaXMuI3BvbGwpO1xuICAgIH1cbiAgICBwYXVzZShkcm9wV2hpbGVQYXVzZWQpIHsgdGhpcy5zdG9wKCk7IH1cbiAgICByZXN1bWUoKSB7IHRoaXMuc3RhcnQoKTsgfVxufVxuZXhwb3J0IGNsYXNzIFBvbGxpbmdCbG9ja1RhZ1N1YnNjcmliZXIgZXh0ZW5kcyBPbkJsb2NrU3Vic2NyaWJlciB7XG4gICAgI3RhZztcbiAgICAjbGFzdEJsb2NrO1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyLCB0YWcpIHtcbiAgICAgICAgc3VwZXIocHJvdmlkZXIpO1xuICAgICAgICB0aGlzLiN0YWcgPSB0YWc7XG4gICAgICAgIHRoaXMuI2xhc3RCbG9jayA9IC0yO1xuICAgIH1cbiAgICBwYXVzZShkcm9wV2hpbGVQYXVzZWQpIHtcbiAgICAgICAgaWYgKGRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy4jbGFzdEJsb2NrID0gLTI7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIucGF1c2UoZHJvcFdoaWxlUGF1c2VkKTtcbiAgICB9XG4gICAgYXN5bmMgX3BvbGwoYmxvY2tOdW1iZXIsIHByb3ZpZGVyKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgcHJvdmlkZXIuZ2V0QmxvY2sodGhpcy4jdGFnKTtcbiAgICAgICAgaWYgKGJsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4jbGFzdEJsb2NrID09PSAtMikge1xuICAgICAgICAgICAgdGhpcy4jbGFzdEJsb2NrID0gYmxvY2subnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJsb2NrLm51bWJlciA+IHRoaXMuI2xhc3RCbG9jaykge1xuICAgICAgICAgICAgcHJvdmlkZXIuZW1pdCh0aGlzLiN0YWcsIGJsb2NrLm51bWJlcik7XG4gICAgICAgICAgICB0aGlzLiNsYXN0QmxvY2sgPSBibG9jay5udW1iZXI7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqICBAX2lnbm9yZTpcbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuZXhwb3J0IGNsYXNzIFBvbGxpbmdPcnBoYW5TdWJzY3JpYmVyIGV4dGVuZHMgT25CbG9ja1N1YnNjcmliZXIge1xuICAgICNmaWx0ZXI7XG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGZpbHRlcikge1xuICAgICAgICBzdXBlcihwcm92aWRlcik7XG4gICAgICAgIHRoaXMuI2ZpbHRlciA9IGNvcHkoZmlsdGVyKTtcbiAgICB9XG4gICAgYXN5bmMgX3BvbGwoYmxvY2tOdW1iZXIsIHByb3ZpZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBUT0RPXCIpO1xuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLiNmaWx0ZXIpO1xuICAgIH1cbn1cbi8qKlxuICogIEEgKipQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyKiogd2lsbCBwb2xsIGZvciBhIGdpdmVuIHRyYW5zYWN0aW9uXG4gKiAgaGFzaCBmb3IgaXRzIHJlY2VpcHQuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyIGV4dGVuZHMgT25CbG9ja1N1YnNjcmliZXIge1xuICAgICNoYXNoO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyKiogYXR0YWNoZWQgdG9cbiAgICAgKiAgJSVwcm92aWRlciUlLCBsaXN0ZW5pbmcgZm9yICUlaGFzaCUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyLCBoYXNoKSB7XG4gICAgICAgIHN1cGVyKHByb3ZpZGVyKTtcbiAgICAgICAgdGhpcy4jaGFzaCA9IGhhc2g7XG4gICAgfVxuICAgIGFzeW5jIF9wb2xsKGJsb2NrTnVtYmVyLCBwcm92aWRlcikge1xuICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0aGlzLiNoYXNoKTtcbiAgICAgICAgaWYgKHR4KSB7XG4gICAgICAgICAgICBwcm92aWRlci5lbWl0KHRoaXMuI2hhc2gsIHR4KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogIEEgKipQb2xsaW5nRXZlbnRTdWJzY3JpYmVyKiogd2lsbCBwb2xsIGZvciBhIGdpdmVuIGZpbHRlciBmb3IgaXRzIGxvZ3MuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBQb2xsaW5nRXZlbnRTdWJzY3JpYmVyIHtcbiAgICAjcHJvdmlkZXI7XG4gICAgI2ZpbHRlcjtcbiAgICAjcG9sbGVyO1xuICAgICNydW5uaW5nO1xuICAgIC8vIFRoZSBtb3N0IHJlY2VudCBibG9jayB3ZSBoYXZlIHNjYW5uZWQgZm9yIGV2ZW50cy4gVGhlIHZhbHVlIC0yXG4gICAgLy8gaW5kaWNhdGVzIHdlIHN0aWxsIG5lZWQgdG8gZmV0Y2ggYW4gaW5pdGlhbCBibG9jayBudW1iZXJcbiAgICAjYmxvY2tOdW1iZXI7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKlBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXIqKiBhdHRhY2hlZCB0b1xuICAgICAqICAlJXByb3ZpZGVyJSUsIGxpc3RlbmluZyBmb3IgJSVmaWx0ZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgZmlsdGVyKSB7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIHRoaXMuI2ZpbHRlciA9IGNvcHkoZmlsdGVyKTtcbiAgICAgICAgdGhpcy4jcG9sbGVyID0gdGhpcy4jcG9sbC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLiNydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gLTI7XG4gICAgfVxuICAgIGFzeW5jICNwb2xsKGJsb2NrTnVtYmVyKSB7XG4gICAgICAgIC8vIFRoZSBpbml0aWFsIGJsb2NrIGhhc24ndCBiZWVuIGRldGVybWluZWQgeWV0XG4gICAgICAgIGlmICh0aGlzLiNibG9ja051bWJlciA9PT0gLTIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWx0ZXIgPSBjb3B5KHRoaXMuI2ZpbHRlcik7XG4gICAgICAgIGZpbHRlci5mcm9tQmxvY2sgPSB0aGlzLiNibG9ja051bWJlciArIDE7XG4gICAgICAgIGZpbHRlci50b0Jsb2NrID0gYmxvY2tOdW1iZXI7XG4gICAgICAgIGNvbnN0IGxvZ3MgPSBhd2FpdCB0aGlzLiNwcm92aWRlci5nZXRMb2dzKGZpbHRlcik7XG4gICAgICAgIC8vIE5vIGxvZ3MgY291bGQganVzdCBtZWFuIHRoZSBub2RlIGhhcyBub3QgaW5kZXhlZCB0aGVtIHlldCxcbiAgICAgICAgLy8gc28gd2Uga2VlcCBhIHNsaWRpbmcgd2luZG93IG9mIDYwIGJsb2NrcyB0byBrZWVwIHNjYW5uaW5nXG4gICAgICAgIGlmIChsb2dzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2Jsb2NrTnVtYmVyIDwgYmxvY2tOdW1iZXIgLSA2MCkge1xuICAgICAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXIgLSA2MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGxvZyBvZiBsb2dzKSB7XG4gICAgICAgICAgICB0aGlzLiNwcm92aWRlci5lbWl0KHRoaXMuI2ZpbHRlciwgbG9nKTtcbiAgICAgICAgICAgIC8vIE9ubHkgYWR2YW5jZSB0aGUgYmxvY2sgbnVtYmVyIHdoZW4gbG9ncyB3ZXJlIGZvdW5kIHRvXG4gICAgICAgICAgICAvLyBhY2NvdW50IGZvciBuZXR3b3JrcyAobGlrZSBCTkIgYW5kIFBvbHlnb24pIHdoaWNoIG1heVxuICAgICAgICAgICAgLy8gc2FjcmlmaWNlIGV2ZW50IGNvbnNpc3RlbmN5IGZvciBibG9jayBldmVudCBzcGVlZFxuICAgICAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSBsb2cuYmxvY2tOdW1iZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLiNydW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcnVubmluZyA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLiNibG9ja051bWJlciA9PT0gLTIpIHtcbiAgICAgICAgICAgIHRoaXMuI3Byb3ZpZGVyLmdldEJsb2NrTnVtYmVyKCkudGhlbigoYmxvY2tOdW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcHJvdmlkZXIub24oXCJibG9ja1wiLCB0aGlzLiNwb2xsZXIpO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAoIXRoaXMuI3J1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9mZihcImJsb2NrXCIsIHRoaXMuI3BvbGxlcik7XG4gICAgfVxuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgaWYgKGRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSAtMjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJzY3JpYmVyLXBvbGxpbmcuanMubWFwIl0sIm5hbWVzIjpbImFzc2VydCIsImlzSGV4U3RyaW5nIiwiY29weSIsIm9iaiIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsImdldFBvbGxpbmdTdWJzY3JpYmVyIiwicHJvdmlkZXIiLCJldmVudCIsIlBvbGxpbmdCbG9ja1N1YnNjcmliZXIiLCJQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyIiwib3BlcmF0aW9uIiwiaW5mbyIsInBvbGxpbmdJbnRlcnZhbCIsImludGVydmFsIiwidmFsdWUiLCJzdGFydCIsInBvbGxlciIsIl9zZXRUaW1lb3V0IiwicG9sbCIsImJpbmQiLCJzdG9wIiwiX2NsZWFyVGltZW91dCIsInBhdXNlIiwiZHJvcFdoaWxlUGF1c2VkIiwiYmxvY2tOdW1iZXIiLCJyZXN1bWUiLCJjb25zdHJ1Y3RvciIsImdldEJsb2NrTnVtYmVyIiwiYiIsImVtaXQiLCJlcnJvciIsIk9uQmxvY2tTdWJzY3JpYmVyIiwiX3BvbGwiLCJFcnJvciIsInJ1bm5pbmciLCJvbiIsIm9mZiIsIlBvbGxpbmdCbG9ja1RhZ1N1YnNjcmliZXIiLCJsYXN0QmxvY2siLCJibG9jayIsImdldEJsb2NrIiwidGFnIiwibnVtYmVyIiwiUG9sbGluZ09ycGhhblN1YnNjcmliZXIiLCJjb25zb2xlIiwibG9nIiwiZmlsdGVyIiwidHgiLCJnZXRUcmFuc2FjdGlvblJlY2VpcHQiLCJoYXNoIiwiUG9sbGluZ0V2ZW50U3Vic2NyaWJlciIsInRoZW4iLCJmcm9tQmxvY2siLCJ0b0Jsb2NrIiwibG9ncyIsImdldExvZ3MiLCJsZW5ndGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/providers/subscriber-polling.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/transaction/accesslist.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/transaction/accesslist.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   accessListify: function() { return /* binding */ accessListify; }\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../address/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n\n\nfunction accessSetify(addr, storageKeys) {\n    return {\n        address: (0,_address_index_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(addr),\n        storageKeys: storageKeys.map((storageKey, index)=>{\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.isHexString)(storageKey, 32), \"invalid slot\", \"storageKeys[\".concat(index, \"]\"), storageKey);\n            return storageKey.toLowerCase();\n        })\n    };\n}\n/**\n *  Returns a [[AccessList]] from any ethers-supported access-list structure.\n */ function accessListify(value) {\n    if (Array.isArray(value)) {\n        return value.map((set, index)=>{\n            if (Array.isArray(set)) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(set.length === 2, \"invalid slot set\", \"value[\".concat(index, \"]\"), set);\n                return accessSetify(set[0], set[1]);\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(set != null && typeof set === \"object\", \"invalid address-slot set\", \"value\", value);\n            return accessSetify(set.address, set.storageKeys);\n        });\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(value != null && typeof value === \"object\", \"invalid access list\", \"value\", value);\n    const result = Object.keys(value).map((addr)=>{\n        const storageKeys = value[addr].reduce((accum, storageKey)=>{\n            accum[storageKey] = true;\n            return accum;\n        }, {});\n        return accessSetify(addr, Object.keys(storageKeys).sort());\n    });\n    result.sort((a, b)=>a.address.localeCompare(b.address));\n    return result;\n} //# sourceMappingURL=accesslist.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS90cmFuc2FjdGlvbi9hY2Nlc3NsaXN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBaUQ7QUFDZTtBQUNoRSxTQUFTRyxhQUFhQyxJQUFJLEVBQUVDLFdBQVc7SUFDbkMsT0FBTztRQUNIQyxTQUFTTiw2REFBVUEsQ0FBQ0k7UUFDcEJDLGFBQWFBLFlBQVlFLEdBQUcsQ0FBQyxDQUFDQyxZQUFZQztZQUN0Q1IsK0RBQWNBLENBQUNDLDREQUFXQSxDQUFDTSxZQUFZLEtBQUssZ0JBQWdCLGVBQXFCLE9BQU5DLE9BQU0sTUFBSUQ7WUFDckYsT0FBT0EsV0FBV0UsV0FBVztRQUNqQztJQUNKO0FBQ0o7QUFDQTs7Q0FFQyxHQUNNLFNBQVNDLGNBQWNDLEtBQUs7SUFDL0IsSUFBSUMsTUFBTUMsT0FBTyxDQUFDRixRQUFRO1FBQ3RCLE9BQU9BLE1BQU1MLEdBQUcsQ0FBQyxDQUFDUSxLQUFLTjtZQUNuQixJQUFJSSxNQUFNQyxPQUFPLENBQUNDLE1BQU07Z0JBQ3BCZCwrREFBY0EsQ0FBQ2MsSUFBSUMsTUFBTSxLQUFLLEdBQUcsb0JBQW9CLFNBQWUsT0FBTlAsT0FBTSxNQUFJTTtnQkFDeEUsT0FBT1osYUFBYVksR0FBRyxDQUFDLEVBQUUsRUFBRUEsR0FBRyxDQUFDLEVBQUU7WUFDdEM7WUFDQWQsK0RBQWNBLENBQUNjLE9BQU8sUUFBUSxPQUFRQSxRQUFTLFVBQVUsNEJBQTRCLFNBQVNIO1lBQzlGLE9BQU9ULGFBQWFZLElBQUlULE9BQU8sRUFBRVMsSUFBSVYsV0FBVztRQUNwRDtJQUNKO0lBQ0FKLCtEQUFjQSxDQUFDVyxTQUFTLFFBQVEsT0FBUUEsVUFBVyxVQUFVLHVCQUF1QixTQUFTQTtJQUM3RixNQUFNSyxTQUFTQyxPQUFPQyxJQUFJLENBQUNQLE9BQU9MLEdBQUcsQ0FBQyxDQUFDSDtRQUNuQyxNQUFNQyxjQUFjTyxLQUFLLENBQUNSLEtBQUssQ0FBQ2dCLE1BQU0sQ0FBQyxDQUFDQyxPQUFPYjtZQUMzQ2EsS0FBSyxDQUFDYixXQUFXLEdBQUc7WUFDcEIsT0FBT2E7UUFDWCxHQUFHLENBQUM7UUFDSixPQUFPbEIsYUFBYUMsTUFBTWMsT0FBT0MsSUFBSSxDQUFDZCxhQUFhaUIsSUFBSTtJQUMzRDtJQUNBTCxPQUFPSyxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBT0QsRUFBRWpCLE9BQU8sQ0FBQ21CLGFBQWEsQ0FBQ0QsRUFBRWxCLE9BQU87SUFDeEQsT0FBT1c7QUFDWCxFQUNBLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdHJhbnNhY3Rpb24vYWNjZXNzbGlzdC5qcz9lZTUxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0QXJndW1lbnQsIGlzSGV4U3RyaW5nIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5mdW5jdGlvbiBhY2Nlc3NTZXRpZnkoYWRkciwgc3RvcmFnZUtleXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzOiBnZXRBZGRyZXNzKGFkZHIpLFxuICAgICAgICBzdG9yYWdlS2V5czogc3RvcmFnZUtleXMubWFwKChzdG9yYWdlS2V5LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoaXNIZXhTdHJpbmcoc3RvcmFnZUtleSwgMzIpLCBcImludmFsaWQgc2xvdFwiLCBgc3RvcmFnZUtleXNbJHtpbmRleH1dYCwgc3RvcmFnZUtleSk7XG4gICAgICAgICAgICByZXR1cm4gc3RvcmFnZUtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9KVxuICAgIH07XG59XG4vKipcbiAqICBSZXR1cm5zIGEgW1tBY2Nlc3NMaXN0XV0gZnJvbSBhbnkgZXRoZXJzLXN1cHBvcnRlZCBhY2Nlc3MtbGlzdCBzdHJ1Y3R1cmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhY2Nlc3NMaXN0aWZ5KHZhbHVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXAoKHNldCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNldCkpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChzZXQubGVuZ3RoID09PSAyLCBcImludmFsaWQgc2xvdCBzZXRcIiwgYHZhbHVlWyR7aW5kZXh9XWAsIHNldCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY2Vzc1NldGlmeShzZXRbMF0sIHNldFsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChzZXQgIT0gbnVsbCAmJiB0eXBlb2YgKHNldCkgPT09IFwib2JqZWN0XCIsIFwiaW52YWxpZCBhZGRyZXNzLXNsb3Qgc2V0XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIGFjY2Vzc1NldGlmeShzZXQuYWRkcmVzcywgc2V0LnN0b3JhZ2VLZXlzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlICE9IG51bGwgJiYgdHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIsIFwiaW52YWxpZCBhY2Nlc3MgbGlzdFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICBjb25zdCByZXN1bHQgPSBPYmplY3Qua2V5cyh2YWx1ZSkubWFwKChhZGRyKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2VLZXlzID0gdmFsdWVbYWRkcl0ucmVkdWNlKChhY2N1bSwgc3RvcmFnZUtleSkgPT4ge1xuICAgICAgICAgICAgYWNjdW1bc3RvcmFnZUtleV0gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHJldHVybiBhY2Nlc3NTZXRpZnkoYWRkciwgT2JqZWN0LmtleXMoc3RvcmFnZUtleXMpLnNvcnQoKSk7XG4gICAgfSk7XG4gICAgcmVzdWx0LnNvcnQoKGEsIGIpID0+IChhLmFkZHJlc3MubG9jYWxlQ29tcGFyZShiLmFkZHJlc3MpKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjY2Vzc2xpc3QuanMubWFwIl0sIm5hbWVzIjpbImdldEFkZHJlc3MiLCJhc3NlcnRBcmd1bWVudCIsImlzSGV4U3RyaW5nIiwiYWNjZXNzU2V0aWZ5IiwiYWRkciIsInN0b3JhZ2VLZXlzIiwiYWRkcmVzcyIsIm1hcCIsInN0b3JhZ2VLZXkiLCJpbmRleCIsInRvTG93ZXJDYXNlIiwiYWNjZXNzTGlzdGlmeSIsInZhbHVlIiwiQXJyYXkiLCJpc0FycmF5Iiwic2V0IiwibGVuZ3RoIiwicmVzdWx0IiwiT2JqZWN0Iiwia2V5cyIsInJlZHVjZSIsImFjY3VtIiwic29ydCIsImEiLCJiIiwibG9jYWxlQ29tcGFyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/transaction/accesslist.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/transaction/address.js":
/*!************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/transaction/address.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeAddress: function() { return /* binding */ computeAddress; },\n/* harmony export */   recoverAddress: function() { return /* binding */ recoverAddress; }\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../address/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../crypto/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/crypto/signing-key.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../crypto/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/crypto/keccak.js\");\n\n\n/**\n *  Returns the address for the %%key%%.\n *\n *  The key may be any standard form of public key or a private key.\n */ function computeAddress(key) {\n    let pubkey;\n    if (typeof key === \"string\") {\n        pubkey = _crypto_index_js__WEBPACK_IMPORTED_MODULE_0__.SigningKey.computePublicKey(key, false);\n    } else {\n        pubkey = key.publicKey;\n    }\n    return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.keccak256)(\"0x\" + pubkey.substring(4)).substring(26));\n}\n/**\n *  Returns the recovered address for the private key that was\n *  used to sign %%digest%% that resulted in %%signature%%.\n */ function recoverAddress(digest, signature) {\n    return computeAddress(_crypto_index_js__WEBPACK_IMPORTED_MODULE_0__.SigningKey.recoverPublicKey(digest, signature));\n} //# sourceMappingURL=address.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS90cmFuc2FjdGlvbi9hZGRyZXNzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWlEO0FBQ1U7QUFDM0Q7Ozs7Q0FJQyxHQUNNLFNBQVNHLGVBQWVDLEdBQUc7SUFDOUIsSUFBSUM7SUFDSixJQUFJLE9BQVFELFFBQVMsVUFBVTtRQUMzQkMsU0FBU0gsd0RBQVVBLENBQUNJLGdCQUFnQixDQUFDRixLQUFLO0lBQzlDLE9BQ0s7UUFDREMsU0FBU0QsSUFBSUcsU0FBUztJQUMxQjtJQUNBLE9BQU9QLDZEQUFVQSxDQUFDQywyREFBU0EsQ0FBQyxPQUFPSSxPQUFPRyxTQUFTLENBQUMsSUFBSUEsU0FBUyxDQUFDO0FBQ3RFO0FBQ0E7OztDQUdDLEdBQ00sU0FBU0MsZUFBZUMsTUFBTSxFQUFFQyxTQUFTO0lBQzVDLE9BQU9SLGVBQWVELHdEQUFVQSxDQUFDVSxnQkFBZ0IsQ0FBQ0YsUUFBUUM7QUFDOUQsRUFDQSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3RyYW5zYWN0aW9uL2FkZHJlc3MuanM/MGQwYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IGtlY2NhazI1NiwgU2lnbmluZ0tleSB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbi8qKlxuICogIFJldHVybnMgdGhlIGFkZHJlc3MgZm9yIHRoZSAlJWtleSUlLlxuICpcbiAqICBUaGUga2V5IG1heSBiZSBhbnkgc3RhbmRhcmQgZm9ybSBvZiBwdWJsaWMga2V5IG9yIGEgcHJpdmF0ZSBrZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlQWRkcmVzcyhrZXkpIHtcbiAgICBsZXQgcHVia2V5O1xuICAgIGlmICh0eXBlb2YgKGtleSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcHVia2V5ID0gU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KGtleSwgZmFsc2UpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcHVia2V5ID0ga2V5LnB1YmxpY0tleTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEFkZHJlc3Moa2VjY2FrMjU2KFwiMHhcIiArIHB1YmtleS5zdWJzdHJpbmcoNCkpLnN1YnN0cmluZygyNikpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgcmVjb3ZlcmVkIGFkZHJlc3MgZm9yIHRoZSBwcml2YXRlIGtleSB0aGF0IHdhc1xuICogIHVzZWQgdG8gc2lnbiAlJWRpZ2VzdCUlIHRoYXQgcmVzdWx0ZWQgaW4gJSVzaWduYXR1cmUlJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlY292ZXJBZGRyZXNzKGRpZ2VzdCwgc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIGNvbXB1dGVBZGRyZXNzKFNpZ25pbmdLZXkucmVjb3ZlclB1YmxpY0tleShkaWdlc3QsIHNpZ25hdHVyZSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkcmVzcy5qcy5tYXAiXSwibmFtZXMiOlsiZ2V0QWRkcmVzcyIsImtlY2NhazI1NiIsIlNpZ25pbmdLZXkiLCJjb21wdXRlQWRkcmVzcyIsImtleSIsInB1YmtleSIsImNvbXB1dGVQdWJsaWNLZXkiLCJwdWJsaWNLZXkiLCJzdWJzdHJpbmciLCJyZWNvdmVyQWRkcmVzcyIsImRpZ2VzdCIsInNpZ25hdHVyZSIsInJlY292ZXJQdWJsaWNLZXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/transaction/address.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/transaction/authorization.js":
/*!******************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/transaction/authorization.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   authorizationify: function() { return /* binding */ authorizationify; }\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../address/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../crypto/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/crypto/signature.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/maths.js\");\n\n\n\nfunction authorizationify(auth) {\n    return {\n        address: (0,_address_index_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(auth.address),\n        nonce: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(auth.nonce != null ? auth.nonce : 0),\n        chainId: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(auth.chainId != null ? auth.chainId : 0),\n        signature: _crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.Signature.from(auth.signature)\n    };\n} //# sourceMappingURL=authorization.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS90cmFuc2FjdGlvbi9hdXRob3JpemF0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBaUQ7QUFDRjtBQUNEO0FBQ3ZDLFNBQVNHLGlCQUFpQkMsSUFBSTtJQUNqQyxPQUFPO1FBQ0hDLFNBQVNMLDZEQUFVQSxDQUFDSSxLQUFLQyxPQUFPO1FBQ2hDQyxPQUFPSiwwREFBU0EsQ0FBQyxLQUFNSSxLQUFLLElBQUksT0FBUUYsS0FBS0UsS0FBSyxHQUFHO1FBQ3JEQyxTQUFTTCwwREFBU0EsQ0FBQyxLQUFNSyxPQUFPLElBQUksT0FBUUgsS0FBS0csT0FBTyxHQUFHO1FBQzNEQyxXQUFXUCx1REFBU0EsQ0FBQ1EsSUFBSSxDQUFDTCxLQUFLSSxTQUFTO0lBQzVDO0FBQ0osRUFDQSx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3RyYW5zYWN0aW9uL2F1dGhvcml6YXRpb24uanM/YzQxNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbmltcG9ydCB7IGdldEJpZ0ludCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGF1dGhvcml6YXRpb25pZnkoYXV0aCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3M6IGdldEFkZHJlc3MoYXV0aC5hZGRyZXNzKSxcbiAgICAgICAgbm9uY2U6IGdldEJpZ0ludCgoYXV0aC5ub25jZSAhPSBudWxsKSA/IGF1dGgubm9uY2UgOiAwKSxcbiAgICAgICAgY2hhaW5JZDogZ2V0QmlnSW50KChhdXRoLmNoYWluSWQgIT0gbnVsbCkgPyBhdXRoLmNoYWluSWQgOiAwKSxcbiAgICAgICAgc2lnbmF0dXJlOiBTaWduYXR1cmUuZnJvbShhdXRoLnNpZ25hdHVyZSlcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0aG9yaXphdGlvbi5qcy5tYXAiXSwibmFtZXMiOlsiZ2V0QWRkcmVzcyIsIlNpZ25hdHVyZSIsImdldEJpZ0ludCIsImF1dGhvcml6YXRpb25pZnkiLCJhdXRoIiwiYWRkcmVzcyIsIm5vbmNlIiwiY2hhaW5JZCIsInNpZ25hdHVyZSIsImZyb20iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/transaction/authorization.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/transaction/transaction.js":
/*!****************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/transaction/transaction.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Transaction: function() { return /* binding */ Transaction; },\n/* harmony export */   splitBlobCells: function() { return /* binding */ splitBlobCells; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_get */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_get.js\");\n/* harmony import */ var _swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_init */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_init.js\");\n/* harmony import */ var _swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_set */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_set.js\");\n/* harmony import */ var _swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @swc/helpers/_/_class_private_method_get */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_method_get.js\");\n/* harmony import */ var _swc_helpers_class_private_method_init__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @swc/helpers/_/_class_private_method_init */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_method_init.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../address/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _constants_addresses_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../constants/addresses.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/constants/addresses.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../crypto/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/crypto/sha2.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../crypto/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/crypto/signature.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../crypto/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../crypto/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/crypto/signing-key.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/rlp-decode.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/index.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/rlp-encode.js\");\n/* harmony import */ var _accesslist_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./accesslist.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/transaction/accesslist.js\");\n/* harmony import */ var _authorization_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./authorization.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/transaction/authorization.js\");\n/* harmony import */ var _address_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./address.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/transaction/address.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nconst BN_0 = BigInt(0);\nconst BN_2 = BigInt(2);\nconst BN_27 = BigInt(27);\nconst BN_28 = BigInt(28);\nconst BN_35 = BigInt(35);\nconst BN_MAX_UINT = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nconst inspect = Symbol.for(\"nodejs.util.inspect.custom\");\nconst BLOB_SIZE = 4096 * 32;\nconst CELL_COUNT = 128;\n/**\n *  Returns a BLOb proof as its cells for [[link-eip-7594]] BLOb.\n *\n *  The default %%cellCount%% is 128.\n */ function splitBlobCells(_proof, cellCount) {\n    if (cellCount == null) {\n        cellCount = CELL_COUNT;\n    }\n    const cellProofs = [];\n    const proof = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(_proof);\n    const cellSize = proof.length / cellCount;\n    for(let i = 0; i < proof.length; i += cellSize){\n        cellProofs.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(proof.subarray(i, i + cellSize)));\n    }\n    return cellProofs;\n}\nfunction getKzgLibrary(kzg) {\n    const blobToKzgCommitment = (blob)=>{\n        if (\"computeBlobProof\" in kzg) {\n            // micro-ecc-signer; check for computeBlobProof since this API\n            // expects a string while the kzg-wasm below expects a Unit8Array\n            if (\"blobToKzgCommitment\" in kzg && typeof kzg.blobToKzgCommitment === \"function\") {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(kzg.blobToKzgCommitment((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(blob)));\n            }\n        } else if (\"blobToKzgCommitment\" in kzg && typeof kzg.blobToKzgCommitment === \"function\") {\n            // kzg-wasm <0.5.0; blobToKzgCommitment(Uint8Array) => Uint8Array\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(kzg.blobToKzgCommitment(blob));\n        }\n        // kzg-wasm >= 0.5.0; blobToKZGCommitment(string) => string\n        if (\"blobToKZGCommitment\" in kzg && typeof kzg.blobToKZGCommitment === \"function\") {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(kzg.blobToKZGCommitment((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(blob)));\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"unsupported KZG library\", \"kzg\", kzg);\n    };\n    const computeBlobKzgProof = (blob, commitment)=>{\n        // micro-ecc-signer\n        if (\"computeBlobProof\" in kzg && typeof kzg.computeBlobProof === \"function\") {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(kzg.computeBlobProof((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(blob), (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(commitment)));\n        }\n        // kzg-wasm <0.5.0; computeBlobKzgProof(Uint8Array, Uint8Array) => Uint8Array\n        if (\"computeBlobKzgProof\" in kzg && typeof kzg.computeBlobKzgProof === \"function\") {\n            return kzg.computeBlobKzgProof(blob, commitment);\n        }\n        // kzg-wasm >= 0.5.0; computeBlobKZGProof(string, string) => string\n        if (\"computeBlobKZGProof\" in kzg && typeof kzg.computeBlobKZGProof === \"function\") {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(kzg.computeBlobKZGProof((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(blob), (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(commitment)));\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"unsupported KZG library\", \"kzg\", kzg);\n    };\n    return {\n        blobToKzgCommitment,\n        computeBlobKzgProof\n    };\n}\nfunction getVersionedHash(version, hash) {\n    let versioned = version.toString(16);\n    while(versioned.length < 2){\n        versioned = \"0\" + versioned;\n    }\n    versioned += (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.sha256)(hash).substring(4);\n    return \"0x\" + versioned;\n}\nfunction handleAddress(value) {\n    if (value === \"0x\") {\n        return null;\n    }\n    return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_3__.getAddress)(value);\n}\nfunction handleAccessList(value, param) {\n    try {\n        return (0,_accesslist_js__WEBPACK_IMPORTED_MODULE_4__.accessListify)(value);\n    } catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, error.message, param, value);\n    }\n}\nfunction handleAuthorizationList(value, param) {\n    try {\n        if (!Array.isArray(value)) {\n            throw new Error(\"authorizationList: invalid array\");\n        }\n        const result = [];\n        for(let i = 0; i < value.length; i++){\n            const auth = value[i];\n            if (!Array.isArray(auth)) {\n                throw new Error(\"authorization[\".concat(i, \"]: invalid array\"));\n            }\n            if (auth.length !== 6) {\n                throw new Error(\"authorization[\".concat(i, \"]: wrong length\"));\n            }\n            if (!auth[1]) {\n                throw new Error(\"authorization[\".concat(i, \"]: null address\"));\n            }\n            result.push({\n                address: handleAddress(auth[1]),\n                nonce: handleUint(auth[2], \"nonce\"),\n                chainId: handleUint(auth[0], \"chainId\"),\n                signature: _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.Signature.from({\n                    yParity: handleNumber(auth[3], \"yParity\"),\n                    r: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)(auth[4], 32),\n                    s: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)(auth[5], 32)\n                })\n            });\n        }\n        return result;\n    } catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, error.message, param, value);\n    }\n}\nfunction handleNumber(_value, param) {\n    if (_value === \"0x\") {\n        return 0;\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getNumber)(_value, param);\n}\nfunction handleUint(_value, param) {\n    if (_value === \"0x\") {\n        return BN_0;\n    }\n    const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBigInt)(_value, param);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(value <= BN_MAX_UINT, \"value exceeds uint size\", param, value);\n    return value;\n}\nfunction formatNumber(_value, name) {\n    const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBigInt)(_value, \"value\");\n    const result = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(value);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(result.length <= 32, \"value too large\", \"tx.\".concat(name), value);\n    return result;\n}\nfunction formatAccessList(value) {\n    return (0,_accesslist_js__WEBPACK_IMPORTED_MODULE_4__.accessListify)(value).map((set)=>[\n            set.address,\n            set.storageKeys\n        ]);\n}\nfunction formatAuthorizationList(value) {\n    return value.map((a)=>{\n        return [\n            formatNumber(a.chainId, \"chainId\"),\n            a.address,\n            formatNumber(a.nonce, \"nonce\"),\n            formatNumber(a.signature.yParity, \"yParity\"),\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(a.signature.r),\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(a.signature._s)\n        ];\n    });\n}\nfunction formatHashes(value, param) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(value), \"invalid \".concat(param), \"value\", value);\n    for(let i = 0; i < value.length; i++){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(value[i], 32), \"invalid ${ param } hash\", \"value[\".concat(i, \"]\"), value[i]);\n    }\n    return value;\n}\nfunction _parseLegacy(data) {\n    const fields = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.decodeRlp)(data);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), \"invalid field count for legacy transaction\", \"data\", data);\n    const tx = {\n        type: 0,\n        nonce: handleNumber(fields[0], \"nonce\"),\n        gasPrice: handleUint(fields[1], \"gasPrice\"),\n        gasLimit: handleUint(fields[2], \"gasLimit\"),\n        to: handleAddress(fields[3]),\n        value: handleUint(fields[4], \"value\"),\n        data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(fields[5]),\n        chainId: BN_0\n    };\n    // Legacy unsigned transaction\n    if (fields.length === 6) {\n        return tx;\n    }\n    const v = handleUint(fields[6], \"v\");\n    const r = handleUint(fields[7], \"r\");\n    const s = handleUint(fields[8], \"s\");\n    if (r === BN_0 && s === BN_0) {\n        // EIP-155 unsigned transaction\n        tx.chainId = v;\n    } else {\n        // Compute the EIP-155 chain ID (or 0 for legacy)\n        let chainId = (v - BN_35) / BN_2;\n        if (chainId < BN_0) {\n            chainId = BN_0;\n        }\n        tx.chainId = chainId;\n        // Signed Legacy Transaction\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(chainId !== BN_0 || v === BN_27 || v === BN_28, \"non-canonical legacy v\", \"v\", fields[6]);\n        tx.signature = _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.Signature.from({\n            r: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)(fields[7], 32),\n            s: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)(fields[8], 32),\n            v\n        });\n    //tx.hash = keccak256(data);\n    }\n    return tx;\n}\nfunction _serializeLegacy(tx, sig) {\n    const fields = [\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.gasPrice || 0, \"gasPrice\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        tx.to || \"0x\",\n        formatNumber(tx.value, \"value\"),\n        tx.data\n    ];\n    let chainId = BN_0;\n    if (tx.chainId != BN_0) {\n        // A chainId was provided; if non-zero we'll use EIP-155\n        chainId = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBigInt)(tx.chainId, \"tx.chainId\");\n        // We have a chainId in the tx and an EIP-155 v in the signature,\n        // make sure they agree with each other\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(!sig || sig.networkV == null || sig.legacyChainId === chainId, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n    } else if (tx.signature) {\n        // No explicit chainId, but EIP-155 have a derived implicit chainId\n        const legacy = tx.signature.legacyChainId;\n        if (legacy != null) {\n            chainId = legacy;\n        }\n    }\n    // Requesting an unsigned transaction\n    if (!sig) {\n        // We have an EIP-155 transaction (chainId was specified and non-zero)\n        if (chainId !== BN_0) {\n            fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(chainId));\n            fields.push(\"0x\");\n            fields.push(\"0x\");\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.encodeRlp)(fields);\n    }\n    // @TODO: We should probably check that tx.signature, chainId, and sig\n    //        match but that logic could break existing code, so schedule\n    //        this for the next major bump.\n    // Compute the EIP-155 v\n    let v = BigInt(27 + sig.yParity);\n    if (chainId !== BN_0) {\n        v = _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.Signature.getChainIdV(chainId, sig.v);\n    } else if (BigInt(sig.v) !== v) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n    }\n    // Add the signature\n    fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(v));\n    fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(sig.r));\n    fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(sig._s));\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.encodeRlp)(fields);\n}\nfunction _parseEipSignature(tx, fields) {\n    let yParity;\n    try {\n        yParity = handleNumber(fields[0], \"yParity\");\n        if (yParity !== 0 && yParity !== 1) {\n            throw new Error(\"bad yParity\");\n        }\n    } catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid yParity\", \"yParity\", fields[0]);\n    }\n    const r = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)(fields[1], 32);\n    const s = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)(fields[2], 32);\n    const signature = _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.Signature.from({\n        r,\n        s,\n        yParity\n    });\n    tx.signature = signature;\n}\nfunction _parseEip1559(data) {\n    const fields = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.decodeRlp)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(data).slice(1));\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), \"invalid field count for transaction type: 2\", \"data\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(data));\n    const tx = {\n        type: 2,\n        chainId: handleUint(fields[0], \"chainId\"),\n        nonce: handleNumber(fields[1], \"nonce\"),\n        maxPriorityFeePerGas: handleUint(fields[2], \"maxPriorityFeePerGas\"),\n        maxFeePerGas: handleUint(fields[3], \"maxFeePerGas\"),\n        gasPrice: null,\n        gasLimit: handleUint(fields[4], \"gasLimit\"),\n        to: handleAddress(fields[5]),\n        value: handleUint(fields[6], \"value\"),\n        data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(fields[7]),\n        accessList: handleAccessList(fields[8], \"accessList\")\n    };\n    // Unsigned EIP-1559 Transaction\n    if (fields.length === 9) {\n        return tx;\n    }\n    //tx.hash = keccak256(data);\n    _parseEipSignature(tx, fields.slice(9));\n    return tx;\n}\nfunction _serializeEip1559(tx, sig) {\n    const fields = [\n        formatNumber(tx.chainId, \"chainId\"),\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        tx.to || \"0x\",\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n        formatAccessList(tx.accessList || [])\n    ];\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"yParity\"));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(sig.r));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(sig.s));\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n        \"0x02\",\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.encodeRlp)(fields)\n    ]);\n}\nfunction _parseEip2930(data) {\n    const fields = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.decodeRlp)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(data).slice(1));\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), \"invalid field count for transaction type: 1\", \"data\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(data));\n    const tx = {\n        type: 1,\n        chainId: handleUint(fields[0], \"chainId\"),\n        nonce: handleNumber(fields[1], \"nonce\"),\n        gasPrice: handleUint(fields[2], \"gasPrice\"),\n        gasLimit: handleUint(fields[3], \"gasLimit\"),\n        to: handleAddress(fields[4]),\n        value: handleUint(fields[5], \"value\"),\n        data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(fields[6]),\n        accessList: handleAccessList(fields[7], \"accessList\")\n    };\n    // Unsigned EIP-2930 Transaction\n    if (fields.length === 8) {\n        return tx;\n    }\n    //tx.hash = keccak256(data);\n    _parseEipSignature(tx, fields.slice(8));\n    return tx;\n}\nfunction _serializeEip2930(tx, sig) {\n    const fields = [\n        formatNumber(tx.chainId, \"chainId\"),\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.gasPrice || 0, \"gasPrice\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        tx.to || \"0x\",\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n        formatAccessList(tx.accessList || [])\n    ];\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"recoveryParam\"));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(sig.r));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(sig.s));\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n        \"0x01\",\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.encodeRlp)(fields)\n    ]);\n}\nfunction _parseEip4844(data) {\n    let fields = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.decodeRlp)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(data).slice(1));\n    let typeName = \"3\";\n    let blobWrapperVersion = null;\n    let blobs = null;\n    // Parse the network format\n    if (fields.length === 4 && Array.isArray(fields[0])) {\n        // EIP-4844 format with sidecar\n        typeName = \"3 (network format)\";\n        const fBlobs = fields[1], fCommits = fields[2], fProofs = fields[3];\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(fBlobs), \"invalid network format: blobs not an array\", \"fields[1]\", fBlobs);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(fCommits), \"invalid network format: commitments not an array\", \"fields[2]\", fCommits);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(fProofs), \"invalid network format: proofs not an array\", \"fields[3]\", fProofs);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(fBlobs.length === fCommits.length, \"invalid network format: blobs/commitments length mismatch\", \"fields\", fields);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(fBlobs.length === fProofs.length, \"invalid network format: blobs/proofs length mismatch\", \"fields\", fields);\n        blobs = [];\n        for(let i = 0; i < fields[1].length; i++){\n            blobs.push({\n                data: fBlobs[i],\n                commitment: fCommits[i],\n                proof: fProofs[i]\n            });\n        }\n        fields = fields[0];\n    } else if (fields.length === 5 && Array.isArray(fields[0])) {\n        // EIP-7594 format with sidecar\n        typeName = \"3 (EIP-7594 network format)\";\n        blobWrapperVersion = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getNumber)(fields[1]);\n        const fBlobs = fields[2], fCommits = fields[3], fProofs = fields[4];\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(blobWrapperVersion === 1, \"unsupported EIP-7594 network format version: \".concat(blobWrapperVersion), \"fields[1]\", blobWrapperVersion);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(fBlobs), \"invalid EIP-7594 network format: blobs not an array\", \"fields[2]\", fBlobs);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(fCommits), \"invalid EIP-7594 network format: commitments not an array\", \"fields[3]\", fCommits);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(fProofs), \"invalid EIP-7594 network format: proofs not an array\", \"fields[4]\", fProofs);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(fBlobs.length === fCommits.length, \"invalid network format: blobs/commitments length mismatch\", \"fields\", fields);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(fBlobs.length * CELL_COUNT === fProofs.length, \"invalid network format: blobs/proofs length mismatch\", \"fields\", fields);\n        blobs = [];\n        for(let i = 0; i < fBlobs.length; i++){\n            const proof = [];\n            for(let j = 0; j < CELL_COUNT; j++){\n                proof.push(fProofs[i * CELL_COUNT + j]);\n            }\n            blobs.push({\n                data: fBlobs[i],\n                commitment: fCommits[i],\n                proof: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)(proof)\n            });\n        }\n        fields = fields[0];\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(fields) && (fields.length === 11 || fields.length === 14), \"invalid field count for transaction type: \".concat(typeName), \"data\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(data));\n    const tx = {\n        type: 3,\n        chainId: handleUint(fields[0], \"chainId\"),\n        nonce: handleNumber(fields[1], \"nonce\"),\n        maxPriorityFeePerGas: handleUint(fields[2], \"maxPriorityFeePerGas\"),\n        maxFeePerGas: handleUint(fields[3], \"maxFeePerGas\"),\n        gasPrice: null,\n        gasLimit: handleUint(fields[4], \"gasLimit\"),\n        to: handleAddress(fields[5]),\n        value: handleUint(fields[6], \"value\"),\n        data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(fields[7]),\n        accessList: handleAccessList(fields[8], \"accessList\"),\n        maxFeePerBlobGas: handleUint(fields[9], \"maxFeePerBlobGas\"),\n        blobVersionedHashes: fields[10],\n        blobWrapperVersion\n    };\n    if (blobs) {\n        tx.blobs = blobs;\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(tx.to != null, \"invalid address for transaction type: \".concat(typeName), \"data\", data);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(tx.blobVersionedHashes), \"invalid blobVersionedHashes: must be an array\", \"data\", data);\n    for(let i = 0; i < tx.blobVersionedHashes.length; i++){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(tx.blobVersionedHashes[i], 32), \"invalid blobVersionedHash at index \".concat(i, \": must be length 32\"), \"data\", data);\n    }\n    // Unsigned EIP-4844 Transaction\n    if (fields.length === 11) {\n        return tx;\n    }\n    // @TODO: Do we need to do this? This is only called internally\n    // and used to verify hashes; it might save time to not do this\n    //tx.hash = keccak256(concat([ \"0x03\", encodeRlp(fields) ]));\n    _parseEipSignature(tx, fields.slice(11));\n    return tx;\n}\nfunction _serializeEip4844(tx, sig, blobs) {\n    const fields = [\n        formatNumber(tx.chainId, \"chainId\"),\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        tx.to || _constants_addresses_js__WEBPACK_IMPORTED_MODULE_9__.ZeroAddress,\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n        formatAccessList(tx.accessList || []),\n        formatNumber(tx.maxFeePerBlobGas || 0, \"maxFeePerBlobGas\"),\n        formatHashes(tx.blobVersionedHashes || [], \"blobVersionedHashes\")\n    ];\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"yParity\"));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(sig.r));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(sig.s));\n        // We have blobs; return the network wrapped format\n        if (blobs) {\n            // Use EIP-7594\n            if (tx.blobWrapperVersion != null) {\n                const wrapperVersion = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(tx.blobWrapperVersion);\n                const cellProofs = [];\n                for (const { proof } of blobs){\n                    const p = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(proof);\n                    const cellSize = p.length / CELL_COUNT;\n                    for(let i = 0; i < p.length; i += cellSize){\n                        cellProofs.push(p.subarray(i, i + cellSize));\n                    }\n                }\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n                    \"0x03\",\n                    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.encodeRlp)([\n                        fields,\n                        wrapperVersion,\n                        blobs.map((b)=>b.data),\n                        blobs.map((b)=>b.commitment),\n                        cellProofs\n                    ])\n                ]);\n            }\n            // Fall back onto classic EIP-4844 behavior\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n                \"0x03\",\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.encodeRlp)([\n                    fields,\n                    blobs.map((b)=>b.data),\n                    blobs.map((b)=>b.commitment),\n                    blobs.map((b)=>b.proof)\n                ])\n            ]);\n        }\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n        \"0x03\",\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.encodeRlp)(fields)\n    ]);\n}\nfunction _parseEip7702(data) {\n    const fields = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.decodeRlp)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(data).slice(1));\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(fields) && (fields.length === 10 || fields.length === 13), \"invalid field count for transaction type: 4\", \"data\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(data));\n    const tx = {\n        type: 4,\n        chainId: handleUint(fields[0], \"chainId\"),\n        nonce: handleNumber(fields[1], \"nonce\"),\n        maxPriorityFeePerGas: handleUint(fields[2], \"maxPriorityFeePerGas\"),\n        maxFeePerGas: handleUint(fields[3], \"maxFeePerGas\"),\n        gasPrice: null,\n        gasLimit: handleUint(fields[4], \"gasLimit\"),\n        to: handleAddress(fields[5]),\n        value: handleUint(fields[6], \"value\"),\n        data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(fields[7]),\n        accessList: handleAccessList(fields[8], \"accessList\"),\n        authorizationList: handleAuthorizationList(fields[9], \"authorizationList\")\n    };\n    // Unsigned EIP-7702 Transaction\n    if (fields.length === 10) {\n        return tx;\n    }\n    _parseEipSignature(tx, fields.slice(10));\n    return tx;\n}\nfunction _serializeEip7702(tx, sig) {\n    const fields = [\n        formatNumber(tx.chainId, \"chainId\"),\n        formatNumber(tx.nonce, \"nonce\"),\n        formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(tx.gasLimit, \"gasLimit\"),\n        tx.to || \"0x\",\n        formatNumber(tx.value, \"value\"),\n        tx.data,\n        formatAccessList(tx.accessList || []),\n        formatAuthorizationList(tx.authorizationList || [])\n    ];\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"yParity\"));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(sig.r));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.toBeArray)(sig.s));\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n        \"0x04\",\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.encodeRlp)(fields)\n    ]);\n}\nvar _type = /*#__PURE__*/ new WeakMap(), _to = /*#__PURE__*/ new WeakMap(), _data = /*#__PURE__*/ new WeakMap(), _nonce = /*#__PURE__*/ new WeakMap(), _gasLimit = /*#__PURE__*/ new WeakMap(), _gasPrice = /*#__PURE__*/ new WeakMap(), _maxPriorityFeePerGas = /*#__PURE__*/ new WeakMap(), _maxFeePerGas = /*#__PURE__*/ new WeakMap(), _value = /*#__PURE__*/ new WeakMap(), _chainId = /*#__PURE__*/ new WeakMap(), _sig = /*#__PURE__*/ new WeakMap(), _accessList = /*#__PURE__*/ new WeakMap(), _maxFeePerBlobGas = /*#__PURE__*/ new WeakMap(), _blobVersionedHashes = /*#__PURE__*/ new WeakMap(), _kzg = /*#__PURE__*/ new WeakMap(), _blobs = /*#__PURE__*/ new WeakMap(), _auths = /*#__PURE__*/ new WeakMap(), _blobWrapperVersion = /*#__PURE__*/ new WeakMap(), _getSerialized = /*#__PURE__*/ new WeakSet();\nlet _inspect = inspect;\n/**\n *  A **Transaction** describes an operation to be executed on\n *  Ethereum by an Externally Owned Account (EOA). It includes\n *  who (the [[to]] address), what (the [[data]]) and how much (the\n *  [[value]] in ether) the operation should entail.\n *\n *  @example:\n *    tx = new Transaction()\n *    //_result:\n *\n *    tx.data = \"0x1234\";\n *    //_result:\n */ class Transaction {\n    /**\n     *  The transaction type.\n     *\n     *  If null, the type will be automatically inferred based on\n     *  explicit properties.\n     */ get type() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _type);\n    }\n    set type(value) {\n        switch(value){\n            case null:\n                (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _type, null);\n                break;\n            case 0:\n            case \"legacy\":\n                (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _type, 0);\n                break;\n            case 1:\n            case \"berlin\":\n            case \"eip-2930\":\n                (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _type, 1);\n                break;\n            case 2:\n            case \"london\":\n            case \"eip-1559\":\n                (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _type, 2);\n                break;\n            case 3:\n            case \"cancun\":\n            case \"eip-4844\":\n                (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _type, 3);\n                break;\n            case 4:\n            case \"pectra\":\n            case \"eip-7702\":\n                (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _type, 4);\n                break;\n            default:\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"unsupported transaction type\", \"type\", value);\n        }\n    }\n    /**\n     *  The name of the transaction type.\n     */ get typeName() {\n        switch(this.type){\n            case 0:\n                return \"legacy\";\n            case 1:\n                return \"eip-2930\";\n            case 2:\n                return \"eip-1559\";\n            case 3:\n                return \"eip-4844\";\n            case 4:\n                return \"eip-7702\";\n        }\n        return null;\n    }\n    /**\n     *  The ``to`` address for the transaction or ``null`` if the\n     *  transaction is an ``init`` transaction.\n     */ get to() {\n        const value = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _to);\n        if (value == null && this.type === 3) {\n            return _constants_addresses_js__WEBPACK_IMPORTED_MODULE_9__.ZeroAddress;\n        }\n        return value;\n    }\n    set to(value) {\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _to, value == null ? null : (0,_address_index_js__WEBPACK_IMPORTED_MODULE_3__.getAddress)(value));\n    }\n    /**\n     *  The transaction nonce.\n     */ get nonce() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _nonce);\n    }\n    set nonce(value) {\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _nonce, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getNumber)(value, \"value\"));\n    }\n    /**\n     *  The gas limit.\n     */ get gasLimit() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _gasLimit);\n    }\n    set gasLimit(value) {\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _gasLimit, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBigInt)(value));\n    }\n    /**\n     *  The gas price.\n     *\n     *  On legacy networks this defines the fee that will be paid. On\n     *  EIP-1559 networks, this should be ``null``.\n     */ get gasPrice() {\n        const value = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _gasPrice);\n        if (value == null && (this.type === 0 || this.type === 1)) {\n            return BN_0;\n        }\n        return value;\n    }\n    set gasPrice(value) {\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _gasPrice, value == null ? null : (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBigInt)(value, \"gasPrice\"));\n    }\n    /**\n     *  The maximum priority fee per unit of gas to pay. On legacy\n     *  networks this should be ``null``.\n     */ get maxPriorityFeePerGas() {\n        const value = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _maxPriorityFeePerGas);\n        if (value == null) {\n            if (this.type === 2 || this.type === 3) {\n                return BN_0;\n            }\n            return null;\n        }\n        return value;\n    }\n    set maxPriorityFeePerGas(value) {\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _maxPriorityFeePerGas, value == null ? null : (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBigInt)(value, \"maxPriorityFeePerGas\"));\n    }\n    /**\n     *  The maximum total fee per unit of gas to pay. On legacy\n     *  networks this should be ``null``.\n     */ get maxFeePerGas() {\n        const value = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _maxFeePerGas);\n        if (value == null) {\n            if (this.type === 2 || this.type === 3) {\n                return BN_0;\n            }\n            return null;\n        }\n        return value;\n    }\n    set maxFeePerGas(value) {\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _maxFeePerGas, value == null ? null : (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBigInt)(value, \"maxFeePerGas\"));\n    }\n    /**\n     *  The transaction data. For ``init`` transactions this is the\n     *  deployment code.\n     */ get data() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _data);\n    }\n    set data(value) {\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _data, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(value));\n    }\n    /**\n     *  The amount of ether (in wei) to send in this transactions.\n     */ get value() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _value);\n    }\n    set value(value) {\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _value, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBigInt)(value, \"value\"));\n    }\n    /**\n     *  The chain ID this transaction is valid on.\n     */ get chainId() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _chainId);\n    }\n    set chainId(value) {\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _chainId, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBigInt)(value));\n    }\n    /**\n     *  If signed, the signature for this transaction.\n     */ get signature() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _sig) || null;\n    }\n    set signature(value) {\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _sig, value == null ? null : _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.Signature.from(value));\n    }\n    isValid() {\n        const sig = this.signature;\n        if (sig && !sig.isValid()) {\n            return false;\n        }\n        const auths = this.authorizationList;\n        if (auths) {\n            for (const auth of auths){\n                if (!auth.signature.isValid()) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    /**\n     *  The access list.\n     *\n     *  An access list permits discounted (but pre-paid) access to\n     *  bytecode and state variable access within contract execution.\n     */ get accessList() {\n        const value = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _accessList) || null;\n        if (value == null) {\n            if (this.type === 1 || this.type === 2 || this.type === 3) {\n                // @TODO: in v7, this should assign the value or become\n                // a live object itself, otherwise mutation is inconsistent\n                return [];\n            }\n            return null;\n        }\n        return value;\n    }\n    set accessList(value) {\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _accessList, value == null ? null : (0,_accesslist_js__WEBPACK_IMPORTED_MODULE_4__.accessListify)(value));\n    }\n    get authorizationList() {\n        const value = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _auths) || null;\n        if (value == null) {\n            if (this.type === 4) {\n                // @TODO: in v7, this should become a live object itself,\n                // otherwise mutation is inconsistent\n                return [];\n            }\n        }\n        return value;\n    }\n    set authorizationList(auths) {\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _auths, auths == null ? null : auths.map((a)=>(0,_authorization_js__WEBPACK_IMPORTED_MODULE_12__.authorizationify)(a)));\n    }\n    /**\n     *  The max fee per blob gas for Cancun transactions.\n     */ get maxFeePerBlobGas() {\n        const value = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _maxFeePerBlobGas);\n        if (value == null && this.type === 3) {\n            return BN_0;\n        }\n        return value;\n    }\n    set maxFeePerBlobGas(value) {\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _maxFeePerBlobGas, value == null ? null : (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.getBigInt)(value, \"maxFeePerBlobGas\"));\n    }\n    /**\n     *  The BLOb versioned hashes for Cancun transactions.\n     */ get blobVersionedHashes() {\n        // @TODO: Mutation is inconsistent; if unset, the returned value\n        // cannot mutate the object, if set it can\n        let value = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _blobVersionedHashes);\n        if (value == null && this.type === 3) {\n            return [];\n        }\n        return value;\n    }\n    set blobVersionedHashes(value) {\n        if (value != null) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(Array.isArray(value), \"blobVersionedHashes must be an Array\", \"value\", value);\n            value = value.slice();\n            for(let i = 0; i < value.length; i++){\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(value[i], 32), \"invalid blobVersionedHash\", \"value[\".concat(i, \"]\"), value[i]);\n            }\n        }\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _blobVersionedHashes, value);\n    }\n    /**\n     *  The BLObs for the Transaction, if any.\n     *\n     *  If ``blobs`` is non-``null``, then the [[seriailized]]\n     *  will return the network formatted sidecar, otherwise it\n     *  will return the standard [[link-eip-2718]] payload. The\n     *  [[unsignedSerialized]] is unaffected regardless.\n     *\n     *  When setting ``blobs``, either fully valid [[Blob]] objects\n     *  may be specified (i.e. correctly padded, with correct\n     *  committments and proofs) or a raw [[BytesLike]] may\n     *  be provided.\n     *\n     *  If raw [[BytesLike]] are provided, the [[kzg]] property **must**\n     *  be already set. The blob will be correctly padded and the\n     *  [[KzgLibrary]] will be used to compute the committment and\n     *  proof for the blob.\n     *\n     *  A BLOb is a sequence of field elements, each of which must\n     *  be within the BLS field modulo, so some additional processing\n     *  may be required to encode arbitrary data to ensure each 32 byte\n     *  field is within the valid range.\n     *\n     *  Setting this automatically populates [[blobVersionedHashes]],\n     *  overwriting any existing values. Setting this to ``null``\n     *  does **not** remove the [[blobVersionedHashes]], leaving them\n     *  present.\n     */ get blobs() {\n        if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _blobs) == null) {\n            return null;\n        }\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _blobs).map((b)=>Object.assign({}, b));\n    }\n    set blobs(_blobs1) {\n        if (_blobs1 == null) {\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _blobs, null);\n            return;\n        }\n        const blobs = [];\n        const versionedHashes = [];\n        for(let i = 0; i < _blobs1.length; i++){\n            const blob = _blobs1[i];\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isBytesLike)(blob)) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _kzg), \"adding a raw blob requires a KZG library\", \"UNSUPPORTED_OPERATION\", {\n                    operation: \"set blobs()\"\n                });\n                let data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(blob);\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(data.length <= BLOB_SIZE, \"blob is too large\", \"blobs[\".concat(i, \"]\"), blob);\n                // Pad blob if necessary\n                if (data.length !== BLOB_SIZE) {\n                    const padded = new Uint8Array(BLOB_SIZE);\n                    padded.set(data);\n                    data = padded;\n                }\n                const commit = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _kzg).blobToKzgCommitment(data);\n                const proof = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _kzg).computeBlobKzgProof(data, commit));\n                blobs.push({\n                    data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(data),\n                    commitment: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(commit),\n                    proof\n                });\n                versionedHashes.push(getVersionedHash(1, commit));\n            } else {\n                const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(blob.data);\n                const commitment = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(blob.commitment);\n                const proof = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(blob.proof);\n                blobs.push({\n                    data,\n                    commitment,\n                    proof\n                });\n                versionedHashes.push(getVersionedHash(1, commitment));\n            }\n        }\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _blobs, blobs);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _blobVersionedHashes, versionedHashes);\n    }\n    get kzg() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _kzg);\n    }\n    set kzg(kzg) {\n        if (kzg == null) {\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _kzg, null);\n        } else {\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _kzg, getKzgLibrary(kzg));\n        }\n    }\n    get blobWrapperVersion() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _blobWrapperVersion);\n    }\n    set blobWrapperVersion(value) {\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _blobWrapperVersion, value);\n    }\n    /**\n     *  The transaction hash, if signed. Otherwise, ``null``.\n     */ get hash() {\n        if (this.signature == null) {\n            return null;\n        }\n        return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_13__.keccak256)((0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_14__._)(this, _getSerialized, getSerialized).call(this, true, false));\n    }\n    /**\n     *  The pre-image hash of this transaction.\n     *\n     *  This is the digest that a [[Signer]] must sign to authorize\n     *  this transaction.\n     */ get unsignedHash() {\n        return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_13__.keccak256)(this.unsignedSerialized);\n    }\n    /**\n     *  The sending address, if signed. Otherwise, ``null``.\n     */ get from() {\n        if (this.signature == null) {\n            return null;\n        }\n        return (0,_address_js__WEBPACK_IMPORTED_MODULE_15__.recoverAddress)(this.unsignedHash, this.signature.getCanonical());\n    }\n    /**\n     *  The public key of the sender, if signed. Otherwise, ``null``.\n     */ get fromPublicKey() {\n        if (this.signature == null) {\n            return null;\n        }\n        return _crypto_index_js__WEBPACK_IMPORTED_MODULE_16__.SigningKey.recoverPublicKey(this.unsignedHash, this.signature.getCanonical());\n    }\n    /**\n     *  Returns true if signed.\n     *\n     *  This provides a Type Guard that properties requiring a signed\n     *  transaction are non-null.\n     */ isSigned() {\n        return this.signature != null;\n    }\n    /**\n     *  The serialized transaction.\n     *\n     *  This throws if the transaction is unsigned. For the pre-image,\n     *  use [[unsignedSerialized]].\n     */ get serialized() {\n        return (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_14__._)(this, _getSerialized, getSerialized).call(this, true, true);\n    }\n    /**\n     *  The transaction pre-image.\n     *\n     *  The hash of this is the digest which needs to be signed to\n     *  authorize this transaction.\n     */ get unsignedSerialized() {\n        return (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_14__._)(this, _getSerialized, getSerialized).call(this, false, false);\n    }\n    /**\n     *  Return the most \"likely\" type; currently the highest\n     *  supported transaction type.\n     */ inferType() {\n        const types = this.inferTypes();\n        // Prefer London (EIP-1559) over Cancun (BLOb)\n        if (types.indexOf(2) >= 0) {\n            return 2;\n        }\n        // Return the highest inferred type\n        return types.pop();\n    }\n    /**\n     *  Validates the explicit properties and returns a list of compatible\n     *  transaction types.\n     */ inferTypes() {\n        // Checks that there are no conflicting properties set\n        const hasGasPrice = this.gasPrice != null;\n        const hasFee = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null;\n        const hasAccessList = this.accessList != null;\n        const hasBlob = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _maxFeePerBlobGas) != null || (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_10__._)(this, _blobVersionedHashes);\n        //if (hasGasPrice && hasFee) {\n        //    throw new Error(\"transaction cannot have gasPrice and maxFeePerGas\");\n        //}\n        if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(this.maxFeePerGas >= this.maxPriorityFeePerGas, \"priorityFee cannot be more than maxFee\", \"BAD_DATA\", {\n                value: this\n            });\n        }\n        //if (this.type === 2 && hasGasPrice) {\n        //    throw new Error(\"eip-1559 transaction cannot have gasPrice\");\n        //}\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(!hasFee || this.type !== 0 && this.type !== 1, \"transaction type cannot have maxFeePerGas or maxPriorityFeePerGas\", \"BAD_DATA\", {\n            value: this\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(this.type !== 0 || !hasAccessList, \"legacy transaction cannot have accessList\", \"BAD_DATA\", {\n            value: this\n        });\n        const types = [];\n        // Explicit type\n        if (this.type != null) {\n            types.push(this.type);\n        } else {\n            if (this.authorizationList && this.authorizationList.length) {\n                types.push(4);\n            } else if (hasFee) {\n                types.push(2);\n            } else if (hasGasPrice) {\n                types.push(1);\n                if (!hasAccessList) {\n                    types.push(0);\n                }\n            } else if (hasAccessList) {\n                types.push(1);\n                types.push(2);\n            } else if (hasBlob && this.to) {\n                types.push(3);\n            } else {\n                types.push(0);\n                types.push(1);\n                types.push(2);\n                types.push(3);\n            }\n        }\n        types.sort();\n        return types;\n    }\n    /**\n     *  Returns true if this transaction is a legacy transaction (i.e.\n     *  ``type === 0``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */ isLegacy() {\n        return this.type === 0;\n    }\n    /**\n     *  Returns true if this transaction is berlin hardform transaction (i.e.\n     *  ``type === 1``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */ isBerlin() {\n        return this.type === 1;\n    }\n    /**\n     *  Returns true if this transaction is london hardform transaction (i.e.\n     *  ``type === 2``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */ isLondon() {\n        return this.type === 2;\n    }\n    /**\n     *  Returns true if this transaction is an [[link-eip-4844]] BLOB\n     *  transaction.\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */ isCancun() {\n        return this.type === 3;\n    }\n    /**\n     *  Create a copy of this transaciton.\n     */ clone() {\n        return Transaction.from(this);\n    }\n    /**\n     *  Return a JSON-friendly object.\n     */ toJSON() {\n        const s = (v)=>{\n            if (v == null) {\n                return null;\n            }\n            return v.toString();\n        };\n        return {\n            type: this.type,\n            to: this.to,\n            //            from: this.from,\n            data: this.data,\n            nonce: this.nonce,\n            gasLimit: s(this.gasLimit),\n            gasPrice: s(this.gasPrice),\n            maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),\n            maxFeePerGas: s(this.maxFeePerGas),\n            value: s(this.value),\n            chainId: s(this.chainId),\n            sig: this.signature ? this.signature.toJSON() : null,\n            accessList: this.accessList\n        };\n    }\n    [_inspect]() {\n        return this.toString();\n    }\n    toString() {\n        const output = [];\n        const add = (key)=>{\n            let value = this[key];\n            if (typeof value === \"string\") {\n                value = JSON.stringify(value);\n            }\n            output.push(\"\".concat(key, \": \").concat(value));\n        };\n        if (this.type) {\n            add(\"type\");\n        }\n        add(\"to\");\n        add(\"data\");\n        add(\"nonce\");\n        add(\"gasLimit\");\n        add(\"value\");\n        if (this.chainId != null) {\n            add(\"chainId\");\n        }\n        if (this.signature) {\n            add(\"from\");\n            output.push(\"signature: \".concat(this.signature.toString()));\n        }\n        // @TODO: accessList\n        // @TODO: blobs (might make output huge; maybe just include a flag?)\n        const auths = this.authorizationList;\n        if (auths) {\n            const outputAuths = [];\n            for (const auth of auths){\n                const o = [];\n                o.push(\"address: \".concat(JSON.stringify(auth.address)));\n                if (auth.nonce != null) {\n                    o.push(\"nonce: \".concat(auth.nonce));\n                }\n                if (auth.chainId != null) {\n                    o.push(\"chainId: \".concat(auth.chainId));\n                }\n                if (auth.signature) {\n                    o.push(\"signature: \".concat(auth.signature.toString()));\n                }\n                outputAuths.push(\"Authorization { \".concat(o.join(\", \"), \" }\"));\n            }\n            output.push(\"authorizations: [ \".concat(outputAuths.join(\", \"), \" ]\"));\n        }\n        return \"Transaction { \".concat(output.join(\", \"), \" }\");\n    }\n    /**\n     *  Create a **Transaction** from a serialized transaction or a\n     *  Transaction-like object.\n     */ static from(tx) {\n        if (tx == null) {\n            return new Transaction();\n        }\n        if (typeof tx === \"string\") {\n            const payload = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(tx);\n            if (payload[0] >= 0x7f) {\n                return Transaction.from(_parseLegacy(payload));\n            }\n            switch(payload[0]){\n                case 1:\n                    return Transaction.from(_parseEip2930(payload));\n                case 2:\n                    return Transaction.from(_parseEip1559(payload));\n                case 3:\n                    return Transaction.from(_parseEip4844(payload));\n                case 4:\n                    return Transaction.from(_parseEip7702(payload));\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"from\"\n            });\n        }\n        const result = new Transaction();\n        if (tx.type != null) {\n            result.type = tx.type;\n        }\n        if (tx.to != null) {\n            result.to = tx.to;\n        }\n        if (tx.nonce != null) {\n            result.nonce = tx.nonce;\n        }\n        if (tx.gasLimit != null) {\n            result.gasLimit = tx.gasLimit;\n        }\n        if (tx.gasPrice != null) {\n            result.gasPrice = tx.gasPrice;\n        }\n        if (tx.maxPriorityFeePerGas != null) {\n            result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;\n        }\n        if (tx.maxFeePerGas != null) {\n            result.maxFeePerGas = tx.maxFeePerGas;\n        }\n        if (tx.maxFeePerBlobGas != null) {\n            result.maxFeePerBlobGas = tx.maxFeePerBlobGas;\n        }\n        if (tx.data != null) {\n            result.data = tx.data;\n        }\n        if (tx.value != null) {\n            result.value = tx.value;\n        }\n        if (tx.chainId != null) {\n            result.chainId = tx.chainId;\n        }\n        if (tx.signature != null) {\n            result.signature = _crypto_index_js__WEBPACK_IMPORTED_MODULE_5__.Signature.from(tx.signature);\n        }\n        if (tx.accessList != null) {\n            result.accessList = tx.accessList;\n        }\n        if (tx.authorizationList != null) {\n            result.authorizationList = tx.authorizationList;\n        }\n        // This will get overwritten by blobs, if present\n        if (tx.blobVersionedHashes != null) {\n            result.blobVersionedHashes = tx.blobVersionedHashes;\n        }\n        // Make sure we assign the kzg before assigning blobs, which\n        // require the library in the event raw blob data is provided.\n        if (tx.kzg != null) {\n            result.kzg = tx.kzg;\n        }\n        if (tx.blobWrapperVersion != null) {\n            result.blobWrapperVersion = tx.blobWrapperVersion;\n        }\n        if (tx.blobs != null) {\n            result.blobs = tx.blobs;\n        }\n        if (tx.hash != null) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(result.isSigned(), \"unsigned transaction cannot define '.hash'\", \"tx\", tx);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(result.hash === tx.hash, \"hash mismatch\", \"tx\", tx);\n        }\n        if (tx.from != null) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(result.isSigned(), \"unsigned transaction cannot define '.from'\", \"tx\", tx);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(result.from.toLowerCase() === (tx.from || \"\").toLowerCase(), \"from mismatch\", \"tx\", tx);\n        }\n        return result;\n    }\n    /**\n     *  Creates a new Transaction with default values.\n     */ constructor(){\n        (0,_swc_helpers_class_private_method_init__WEBPACK_IMPORTED_MODULE_17__._)(this, _getSerialized);\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_18__._)(this, _type, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_18__._)(this, _to, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_18__._)(this, _data, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_18__._)(this, _nonce, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_18__._)(this, _gasLimit, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_18__._)(this, _gasPrice, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_18__._)(this, _maxPriorityFeePerGas, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_18__._)(this, _maxFeePerGas, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_18__._)(this, _value, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_18__._)(this, _chainId, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_18__._)(this, _sig, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_18__._)(this, _accessList, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_18__._)(this, _maxFeePerBlobGas, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_18__._)(this, _blobVersionedHashes, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_18__._)(this, _kzg, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_18__._)(this, _blobs, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_18__._)(this, _auths, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_18__._)(this, _blobWrapperVersion, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _type, null);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _to, null);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _nonce, 0);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _gasLimit, BN_0);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _gasPrice, null);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _maxPriorityFeePerGas, null);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _maxFeePerGas, null);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _data, \"0x\");\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _value, BN_0);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _chainId, BN_0);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _sig, null);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _accessList, null);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _maxFeePerBlobGas, null);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _blobVersionedHashes, null);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _kzg, null);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _blobs, null);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _auths, null);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_11__._)(this, _blobWrapperVersion, null);\n    }\n} //# sourceMappingURL=transaction.js.map\nfunction getSerialized(signed, sidecar) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(!signed || this.signature != null, \"cannot serialize unsigned transaction; maybe you meant .unsignedSerialized\", \"UNSUPPORTED_OPERATION\", {\n        operation: \".serialized\"\n    });\n    const sig = signed ? this.signature : null;\n    switch(this.inferType()){\n        case 0:\n            return _serializeLegacy(this, sig);\n        case 1:\n            return _serializeEip2930(this, sig);\n        case 2:\n            return _serializeEip1559(this, sig);\n        case 3:\n            return _serializeEip4844(this, sig, sidecar ? this.blobs : null);\n        case 4:\n            return _serializeEip7702(this, sig);\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", {\n        operation: \".serialized\"\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS90cmFuc2FjdGlvbi90cmFuc2FjdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFpRDtBQUNPO0FBQ3NCO0FBQ3VHO0FBQ3JJO0FBQ007QUFDUjtBQUM5QyxNQUFNc0IsT0FBT0MsT0FBTztBQUNwQixNQUFNQyxPQUFPRCxPQUFPO0FBQ3BCLE1BQU1FLFFBQVFGLE9BQU87QUFDckIsTUFBTUcsUUFBUUgsT0FBTztBQUNyQixNQUFNSSxRQUFRSixPQUFPO0FBQ3JCLE1BQU1LLGNBQWNMLE9BQU87QUFDM0IsTUFBTU0sVUFBVUMsT0FBT0MsR0FBRyxDQUFDO0FBQzNCLE1BQU1DLFlBQVksT0FBTztBQUN6QixNQUFNQyxhQUFhO0FBQ25COzs7O0NBSUMsR0FDTSxTQUFTQyxlQUFlQyxNQUFNLEVBQUVDLFNBQVM7SUFDNUMsSUFBSUEsYUFBYSxNQUFNO1FBQ25CQSxZQUFZSDtJQUNoQjtJQUNBLE1BQU1JLGFBQWEsRUFBRTtJQUNyQixNQUFNQyxRQUFRN0IseURBQVFBLENBQUMwQjtJQUN2QixNQUFNSSxXQUFXRCxNQUFNRSxNQUFNLEdBQUdKO0lBQ2hDLElBQUssSUFBSUssSUFBSSxHQUFHQSxJQUFJSCxNQUFNRSxNQUFNLEVBQUVDLEtBQUtGLFNBQVU7UUFDN0NGLFdBQVdLLElBQUksQ0FBQzlCLHdEQUFPQSxDQUFDMEIsTUFBTUssUUFBUSxDQUFDRixHQUFHQSxJQUFJRjtJQUNsRDtJQUNBLE9BQU9GO0FBQ1g7QUFDQSxTQUFTTyxjQUFjQyxHQUFHO0lBQ3RCLE1BQU1DLHNCQUFzQixDQUFDQztRQUN6QixJQUFJLHNCQUFzQkYsS0FBSztZQUMzQiw4REFBOEQ7WUFDOUQsaUVBQWlFO1lBQ2pFLElBQUkseUJBQXlCQSxPQUFPLE9BQVFBLElBQUlDLG1CQUFtQixLQUFNLFlBQVk7Z0JBQ2pGLE9BQU9yQyx5REFBUUEsQ0FBQ29DLElB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akMsUUFBUXRDO3VGQUNSb0QsVUFBVXBEO3VGQUNWZ0YsTUFBTTt1RkFDTlUsYUFBYTt1RkFDYlksbUJBQW1CO3VGQUNuQkMsc0JBQXNCO3VGQUN0QmhGLE1BQU07dUZBQ04wRSxRQUFRO3VGQUNSZ0IsUUFBUTt1RkFDUmpCLHFCQUFxQjtJQUMvQjtBQXlXSixFQUNBLHVDQUF1QztBQTVUbkMsdUJBQWU2RCxNQUFNLEVBQUVDLE9BQU87SUFDMUJ2Syx1REFBTUEsQ0FBQyxDQUFDc0ssVUFBVSxJQUFJLENBQUN4RyxTQUFTLElBQUksTUFBTSw4RUFBOEUseUJBQXlCO1FBQUVpRSxXQUFXO0lBQWM7SUFDNUssTUFBTXRDLE1BQU02RSxTQUFTLElBQUksQ0FBQ3hHLFNBQVMsR0FBRztJQUN0QyxPQUFRLElBQUksQ0FBQzZFLFNBQVM7UUFDbEIsS0FBSztZQUNELE9BQU9uRCxpQkFBaUIsSUFBSSxFQUFFQztRQUNsQyxLQUFLO1lBQ0QsT0FBT2Esa0JBQWtCLElBQUksRUFBRWI7UUFDbkMsS0FBSztZQUNELE9BQU9XLGtCQUFrQixJQUFJLEVBQUVYO1FBQ25DLEtBQUs7WUFDRCxPQUFPd0Isa0JBQWtCLElBQUksRUFBRXhCLEtBQUs4RSxVQUFVLElBQUksQ0FBQzdELEtBQUssR0FBRztRQUMvRCxLQUFLO1lBQ0QsT0FBT2Esa0JBQWtCLElBQUksRUFBRTlCO0lBQ3ZDO0lBQ0F6Rix1REFBTUEsQ0FBQyxPQUFPLGdDQUFnQyx5QkFBeUI7UUFBRStILFdBQVc7SUFBYztBQUN0RyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdHJhbnNhY3Rpb24vdHJhbnNhY3Rpb24uanM/NmViYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IFplcm9BZGRyZXNzIH0gZnJvbSBcIi4uL2NvbnN0YW50cy9hZGRyZXNzZXMuanNcIjtcbmltcG9ydCB7IGtlY2NhazI1Niwgc2hhMjU2LCBTaWduYXR1cmUsIFNpZ25pbmdLZXkgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBjb25jYXQsIGRlY29kZVJscCwgZW5jb2RlUmxwLCBnZXRCeXRlcywgZ2V0QmlnSW50LCBnZXROdW1iZXIsIGhleGxpZnksIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQsIGlzQnl0ZXNMaWtlLCBpc0hleFN0cmluZywgdG9CZUFycmF5LCB6ZXJvUGFkVmFsdWUgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGFjY2Vzc0xpc3RpZnkgfSBmcm9tIFwiLi9hY2Nlc3NsaXN0LmpzXCI7XG5pbXBvcnQgeyBhdXRob3JpemF0aW9uaWZ5IH0gZnJvbSBcIi4vYXV0aG9yaXphdGlvbi5qc1wiO1xuaW1wb3J0IHsgcmVjb3ZlckFkZHJlc3MgfSBmcm9tIFwiLi9hZGRyZXNzLmpzXCI7XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuY29uc3QgQk5fMiA9IEJpZ0ludCgyKTtcbmNvbnN0IEJOXzI3ID0gQmlnSW50KDI3KTtcbmNvbnN0IEJOXzI4ID0gQmlnSW50KDI4KTtcbmNvbnN0IEJOXzM1ID0gQmlnSW50KDM1KTtcbmNvbnN0IEJOX01BWF9VSU5UID0gQmlnSW50KFwiMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpO1xuY29uc3QgaW5zcGVjdCA9IFN5bWJvbC5mb3IoXCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbVwiKTtcbmNvbnN0IEJMT0JfU0laRSA9IDQwOTYgKiAzMjtcbmNvbnN0IENFTExfQ09VTlQgPSAxMjg7XG4vKipcbiAqICBSZXR1cm5zIGEgQkxPYiBwcm9vZiBhcyBpdHMgY2VsbHMgZm9yIFtbbGluay1laXAtNzU5NF1dIEJMT2IuXG4gKlxuICogIFRoZSBkZWZhdWx0ICUlY2VsbENvdW50JSUgaXMgMTI4LlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3BsaXRCbG9iQ2VsbHMoX3Byb29mLCBjZWxsQ291bnQpIHtcbiAgICBpZiAoY2VsbENvdW50ID09IG51bGwpIHtcbiAgICAgICAgY2VsbENvdW50ID0gQ0VMTF9DT1VOVDtcbiAgICB9XG4gICAgY29uc3QgY2VsbFByb29mcyA9IFtdO1xuICAgIGNvbnN0IHByb29mID0gZ2V0Qnl0ZXMoX3Byb29mKTtcbiAgICBjb25zdCBjZWxsU2l6ZSA9IHByb29mLmxlbmd0aCAvIGNlbGxDb3VudDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb29mLmxlbmd0aDsgaSArPSBjZWxsU2l6ZSkge1xuICAgICAgICBjZWxsUHJvb2ZzLnB1c2goaGV4bGlmeShwcm9vZi5zdWJhcnJheShpLCBpICsgY2VsbFNpemUpKSk7XG4gICAgfVxuICAgIHJldHVybiBjZWxsUHJvb2ZzO1xufVxuZnVuY3Rpb24gZ2V0S3pnTGlicmFyeShremcpIHtcbiAgICBjb25zdCBibG9iVG9LemdDb21taXRtZW50ID0gKGJsb2IpID0+IHtcbiAgICAgICAgaWYgKFwiY29tcHV0ZUJsb2JQcm9vZlwiIGluIGt6Zykge1xuICAgICAgICAgICAgLy8gbWljcm8tZWNjLXNpZ25lcjsgY2hlY2sgZm9yIGNvbXB1dGVCbG9iUHJvb2Ygc2luY2UgdGhpcyBBUElcbiAgICAgICAgICAgIC8vIGV4cGVjdHMgYSBzdHJpbmcgd2hpbGUgdGhlIGt6Zy13YXNtIGJlbG93IGV4cGVjdHMgYSBVbml0OEFycmF5XG4gICAgICAgICAgICBpZiAoXCJibG9iVG9LemdDb21taXRtZW50XCIgaW4ga3pnICYmIHR5cGVvZiAoa3pnLmJsb2JUb0t6Z0NvbW1pdG1lbnQpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Qnl0ZXMoa3pnLmJsb2JUb0t6Z0NvbW1pdG1lbnQoaGV4bGlmeShibG9iKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFwiYmxvYlRvS3pnQ29tbWl0bWVudFwiIGluIGt6ZyAmJiB0eXBlb2YgKGt6Zy5ibG9iVG9LemdDb21taXRtZW50KSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAvLyBremctd2FzbSA8MC41LjA7IGJsb2JUb0t6Z0NvbW1pdG1lbnQoVWludDhBcnJheSkgPT4gVWludDhBcnJheVxuICAgICAgICAgICAgcmV0dXJuIGdldEJ5dGVzKGt6Zy5ibG9iVG9LemdDb21taXRtZW50KGJsb2IpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBremctd2FzbSA+PSAwLjUuMDsgYmxvYlRvS1pHQ29tbWl0bWVudChzdHJpbmcpID0+IHN0cmluZ1xuICAgICAgICBpZiAoXCJibG9iVG9LWkdDb21taXRtZW50XCIgaW4ga3pnICYmIHR5cGVvZiAoa3pnLmJsb2JUb0taR0NvbW1pdG1lbnQpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRCeXRlcyhremcuYmxvYlRvS1pHQ29tbWl0bWVudChoZXhsaWZ5KGJsb2IpKSk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgS1pHIGxpYnJhcnlcIiwgXCJremdcIiwga3pnKTtcbiAgICB9O1xuICAgIGNvbnN0IGNvbXB1dGVCbG9iS3pnUHJvb2YgPSAoYmxvYiwgY29tbWl0bWVudCkgPT4ge1xuICAgICAgICAvLyBtaWNyby1lY2Mtc2lnbmVyXG4gICAgICAgIGlmIChcImNvbXB1dGVCbG9iUHJvb2ZcIiBpbiBremcgJiYgdHlwZW9mIChremcuY29tcHV0ZUJsb2JQcm9vZikgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIGdldEJ5dGVzKGt6Zy5jb21wdXRlQmxvYlByb29mKGhleGxpZnkoYmxvYiksIGhleGxpZnkoY29tbWl0bWVudCkpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBremctd2FzbSA8MC41LjA7IGNvbXB1dGVCbG9iS3pnUHJvb2YoVWludDhBcnJheSwgVWludDhBcnJheSkgPT4gVWludDhBcnJheVxuICAgICAgICBpZiAoXCJjb21wdXRlQmxvYkt6Z1Byb29mXCIgaW4ga3pnICYmIHR5cGVvZiAoa3pnLmNvbXB1dGVCbG9iS3pnUHJvb2YpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBremcuY29tcHV0ZUJsb2JLemdQcm9vZihibG9iLCBjb21taXRtZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBremctd2FzbSA+PSAwLjUuMDsgY29tcHV0ZUJsb2JLWkdQcm9vZihzdHJpbmcsIHN0cmluZykgPT4gc3RyaW5nXG4gICAgICAgIGlmIChcImNvbXB1dGVCbG9iS1pHUHJvb2ZcIiBpbiBremcgJiYgdHlwZW9mIChremcuY29tcHV0ZUJsb2JLWkdQcm9vZikgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIGdldEJ5dGVzKGt6Zy5jb21wdXRlQmxvYktaR1Byb29mKGhleGxpZnkoYmxvYiksIGhleGxpZnkoY29tbWl0bWVudCkpKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bnN1cHBvcnRlZCBLWkcgbGlicmFyeVwiLCBcImt6Z1wiLCBremcpO1xuICAgIH07XG4gICAgcmV0dXJuIHsgYmxvYlRvS3pnQ29tbWl0bWVudCwgY29tcHV0ZUJsb2JLemdQcm9vZiB9O1xufVxuZnVuY3Rpb24gZ2V0VmVyc2lvbmVkSGFzaCh2ZXJzaW9uLCBoYXNoKSB7XG4gICAgbGV0IHZlcnNpb25lZCA9IHZlcnNpb24udG9TdHJpbmcoMTYpO1xuICAgIHdoaWxlICh2ZXJzaW9uZWQubGVuZ3RoIDwgMikge1xuICAgICAgICB2ZXJzaW9uZWQgPSBcIjBcIiArIHZlcnNpb25lZDtcbiAgICB9XG4gICAgdmVyc2lvbmVkICs9IHNoYTI1NihoYXNoKS5zdWJzdHJpbmcoNCk7XG4gICAgcmV0dXJuIFwiMHhcIiArIHZlcnNpb25lZDtcbn1cbmZ1bmN0aW9uIGhhbmRsZUFkZHJlc3ModmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IFwiMHhcIikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGdldEFkZHJlc3ModmFsdWUpO1xufVxuZnVuY3Rpb24gaGFuZGxlQWNjZXNzTGlzdCh2YWx1ZSwgcGFyYW0pIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gYWNjZXNzTGlzdGlmeSh2YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgZXJyb3IubWVzc2FnZSwgcGFyYW0sIHZhbHVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYW5kbGVBdXRob3JpemF0aW9uTGlzdCh2YWx1ZSwgcGFyYW0pIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhdXRob3JpemF0aW9uTGlzdDogaW52YWxpZCBhcnJheVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYXV0aCA9IHZhbHVlW2ldO1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGF1dGgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhdXRob3JpemF0aW9uWyR7aX1dOiBpbnZhbGlkIGFycmF5YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXV0aC5sZW5ndGggIT09IDYpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGF1dGhvcml6YXRpb25bJHtpfV06IHdyb25nIGxlbmd0aGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhdXRoWzFdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhdXRob3JpemF0aW9uWyR7aX1dOiBudWxsIGFkZHJlc3NgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBoYW5kbGVBZGRyZXNzKGF1dGhbMV0pLFxuICAgICAgICAgICAgICAgIG5vbmNlOiBoYW5kbGVVaW50KGF1dGhbMl0sIFwibm9uY2VcIiksXG4gICAgICAgICAgICAgICAgY2hhaW5JZDogaGFuZGxlVWludChhdXRoWzBdLCBcImNoYWluSWRcIiksXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBTaWduYXR1cmUuZnJvbSh7XG4gICAgICAgICAgICAgICAgICAgIHlQYXJpdHk6IGhhbmRsZU51bWJlcihhdXRoWzNdLCBcInlQYXJpdHlcIiksXG4gICAgICAgICAgICAgICAgICAgIHI6IHplcm9QYWRWYWx1ZShhdXRoWzRdLCAzMiksXG4gICAgICAgICAgICAgICAgICAgIHM6IHplcm9QYWRWYWx1ZShhdXRoWzVdLCAzMilcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBlcnJvci5tZXNzYWdlLCBwYXJhbSwgdmFsdWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZU51bWJlcihfdmFsdWUsIHBhcmFtKSB7XG4gICAgaWYgKF92YWx1ZSA9PT0gXCIweFwiKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0TnVtYmVyKF92YWx1ZSwgcGFyYW0pO1xufVxuZnVuY3Rpb24gaGFuZGxlVWludChfdmFsdWUsIHBhcmFtKSB7XG4gICAgaWYgKF92YWx1ZSA9PT0gXCIweFwiKSB7XG4gICAgICAgIHJldHVybiBCTl8wO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IGdldEJpZ0ludChfdmFsdWUsIHBhcmFtKTtcbiAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZSA8PSBCTl9NQVhfVUlOVCwgXCJ2YWx1ZSBleGNlZWRzIHVpbnQgc2l6ZVwiLCBwYXJhbSwgdmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGZvcm1hdE51bWJlcihfdmFsdWUsIG5hbWUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldEJpZ0ludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgY29uc3QgcmVzdWx0ID0gdG9CZUFycmF5KHZhbHVlKTtcbiAgICBhc3NlcnRBcmd1bWVudChyZXN1bHQubGVuZ3RoIDw9IDMyLCBgdmFsdWUgdG9vIGxhcmdlYCwgYHR4LiR7bmFtZX1gLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZvcm1hdEFjY2Vzc0xpc3QodmFsdWUpIHtcbiAgICByZXR1cm4gYWNjZXNzTGlzdGlmeSh2YWx1ZSkubWFwKChzZXQpID0+IFtzZXQuYWRkcmVzcywgc2V0LnN0b3JhZ2VLZXlzXSk7XG59XG5mdW5jdGlvbiBmb3JtYXRBdXRob3JpemF0aW9uTGlzdCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5tYXAoKGEpID0+IHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGZvcm1hdE51bWJlcihhLmNoYWluSWQsIFwiY2hhaW5JZFwiKSxcbiAgICAgICAgICAgIGEuYWRkcmVzcyxcbiAgICAgICAgICAgIGZvcm1hdE51bWJlcihhLm5vbmNlLCBcIm5vbmNlXCIpLFxuICAgICAgICAgICAgZm9ybWF0TnVtYmVyKGEuc2lnbmF0dXJlLnlQYXJpdHksIFwieVBhcml0eVwiKSxcbiAgICAgICAgICAgIHRvQmVBcnJheShhLnNpZ25hdHVyZS5yKSxcbiAgICAgICAgICAgIHRvQmVBcnJheShhLnNpZ25hdHVyZS5fcylcbiAgICAgICAgXTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGZvcm1hdEhhc2hlcyh2YWx1ZSwgcGFyYW0pIHtcbiAgICBhc3NlcnRBcmd1bWVudChBcnJheS5pc0FycmF5KHZhbHVlKSwgYGludmFsaWQgJHtwYXJhbX1gLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGlzSGV4U3RyaW5nKHZhbHVlW2ldLCAzMiksIFwiaW52YWxpZCAkeyBwYXJhbSB9IGhhc2hcIiwgYHZhbHVlWyR7aX1dYCwgdmFsdWVbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBfcGFyc2VMZWdhY3koZGF0YSkge1xuICAgIGNvbnN0IGZpZWxkcyA9IGRlY29kZVJscChkYXRhKTtcbiAgICBhc3NlcnRBcmd1bWVudChBcnJheS5pc0FycmF5KGZpZWxkcykgJiYgKGZpZWxkcy5sZW5ndGggPT09IDkgfHwgZmllbGRzLmxlbmd0aCA9PT0gNiksIFwiaW52YWxpZCBmaWVsZCBjb3VudCBmb3IgbGVnYWN5IHRyYW5zYWN0aW9uXCIsIFwiZGF0YVwiLCBkYXRhKTtcbiAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgdHlwZTogMCxcbiAgICAgICAgbm9uY2U6IGhhbmRsZU51bWJlcihmaWVsZHNbMF0sIFwibm9uY2VcIiksXG4gICAgICAgIGdhc1ByaWNlOiBoYW5kbGVVaW50KGZpZWxkc1sxXSwgXCJnYXNQcmljZVwiKSxcbiAgICAgICAgZ2FzTGltaXQ6IGhhbmRsZVVpbnQoZmllbGRzWzJdLCBcImdhc0xpbWl0XCIpLFxuICAgICAgICB0bzogaGFuZGxlQWRkcmVzcyhmaWVsZHNbM10pLFxuICAgICAgICB2YWx1ZTogaGFuZGxlVWludChmaWVsZHNbNF0sIFwidmFsdWVcIiksXG4gICAgICAgIGRhdGE6IGhleGxpZnkoZmllbGRzWzVdKSxcbiAgICAgICAgY2hhaW5JZDogQk5fMFxuICAgIH07XG4gICAgLy8gTGVnYWN5IHVuc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAgaWYgKGZpZWxkcy5sZW5ndGggPT09IDYpIHtcbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbiAgICBjb25zdCB2ID0gaGFuZGxlVWludChmaWVsZHNbNl0sIFwidlwiKTtcbiAgICBjb25zdCByID0gaGFuZGxlVWludChmaWVsZHNbN10sIFwiclwiKTtcbiAgICBjb25zdCBzID0gaGFuZGxlVWludChmaWVsZHNbOF0sIFwic1wiKTtcbiAgICBpZiAociA9PT0gQk5fMCAmJiBzID09PSBCTl8wKSB7XG4gICAgICAgIC8vIEVJUC0xNTUgdW5zaWduZWQgdHJhbnNhY3Rpb25cbiAgICAgICAgdHguY2hhaW5JZCA9IHY7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBFSVAtMTU1IGNoYWluIElEIChvciAwIGZvciBsZWdhY3kpXG4gICAgICAgIGxldCBjaGFpbklkID0gKHYgLSBCTl8zNSkgLyBCTl8yO1xuICAgICAgICBpZiAoY2hhaW5JZCA8IEJOXzApIHtcbiAgICAgICAgICAgIGNoYWluSWQgPSBCTl8wO1xuICAgICAgICB9XG4gICAgICAgIHR4LmNoYWluSWQgPSBjaGFpbklkO1xuICAgICAgICAvLyBTaWduZWQgTGVnYWN5IFRyYW5zYWN0aW9uXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGNoYWluSWQgIT09IEJOXzAgfHwgKHYgPT09IEJOXzI3IHx8IHYgPT09IEJOXzI4KSwgXCJub24tY2Fub25pY2FsIGxlZ2FjeSB2XCIsIFwidlwiLCBmaWVsZHNbNl0pO1xuICAgICAgICB0eC5zaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbSh7XG4gICAgICAgICAgICByOiB6ZXJvUGFkVmFsdWUoZmllbGRzWzddLCAzMiksXG4gICAgICAgICAgICBzOiB6ZXJvUGFkVmFsdWUoZmllbGRzWzhdLCAzMiksXG4gICAgICAgICAgICB2XG4gICAgICAgIH0pO1xuICAgICAgICAvL3R4Lmhhc2ggPSBrZWNjYWsyNTYoZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0eDtcbn1cbmZ1bmN0aW9uIF9zZXJpYWxpemVMZWdhY3kodHgsIHNpZykge1xuICAgIGNvbnN0IGZpZWxkcyA9IFtcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm5vbmNlLCBcIm5vbmNlXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHguZ2FzUHJpY2UgfHwgMCwgXCJnYXNQcmljZVwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lmdhc0xpbWl0LCBcImdhc0xpbWl0XCIpLFxuICAgICAgICAodHgudG8gfHwgXCIweFwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4LnZhbHVlLCBcInZhbHVlXCIpLFxuICAgICAgICB0eC5kYXRhLFxuICAgIF07XG4gICAgbGV0IGNoYWluSWQgPSBCTl8wO1xuICAgIGlmICh0eC5jaGFpbklkICE9IEJOXzApIHtcbiAgICAgICAgLy8gQSBjaGFpbklkIHdhcyBwcm92aWRlZDsgaWYgbm9uLXplcm8gd2UnbGwgdXNlIEVJUC0xNTVcbiAgICAgICAgY2hhaW5JZCA9IGdldEJpZ0ludCh0eC5jaGFpbklkLCBcInR4LmNoYWluSWRcIik7XG4gICAgICAgIC8vIFdlIGhhdmUgYSBjaGFpbklkIGluIHRoZSB0eCBhbmQgYW4gRUlQLTE1NSB2IGluIHRoZSBzaWduYXR1cmUsXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGV5IGFncmVlIHdpdGggZWFjaCBvdGhlclxuICAgICAgICBhc3NlcnRBcmd1bWVudCghc2lnIHx8IHNpZy5uZXR3b3JrViA9PSBudWxsIHx8IHNpZy5sZWdhY3lDaGFpbklkID09PSBjaGFpbklkLCBcInR4LmNoYWluSWQvc2lnLnYgbWlzbWF0Y2hcIiwgXCJzaWdcIiwgc2lnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHguc2lnbmF0dXJlKSB7XG4gICAgICAgIC8vIE5vIGV4cGxpY2l0IGNoYWluSWQsIGJ1dCBFSVAtMTU1IGhhdmUgYSBkZXJpdmVkIGltcGxpY2l0IGNoYWluSWRcbiAgICAgICAgY29uc3QgbGVnYWN5ID0gdHguc2lnbmF0dXJlLmxlZ2FjeUNoYWluSWQ7XG4gICAgICAgIGlmIChsZWdhY3kgIT0gbnVsbCkge1xuICAgICAgICAgICAgY2hhaW5JZCA9IGxlZ2FjeTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSZXF1ZXN0aW5nIGFuIHVuc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAgaWYgKCFzaWcpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSBhbiBFSVAtMTU1IHRyYW5zYWN0aW9uIChjaGFpbklkIHdhcyBzcGVjaWZpZWQgYW5kIG5vbi16ZXJvKVxuICAgICAgICBpZiAoY2hhaW5JZCAhPT0gQk5fMCkge1xuICAgICAgICAgICAgZmllbGRzLnB1c2godG9CZUFycmF5KGNoYWluSWQpKTtcbiAgICAgICAgICAgIGZpZWxkcy5wdXNoKFwiMHhcIik7XG4gICAgICAgICAgICBmaWVsZHMucHVzaChcIjB4XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbmNvZGVSbHAoZmllbGRzKTtcbiAgICB9XG4gICAgLy8gQFRPRE86IFdlIHNob3VsZCBwcm9iYWJseSBjaGVjayB0aGF0IHR4LnNpZ25hdHVyZSwgY2hhaW5JZCwgYW5kIHNpZ1xuICAgIC8vICAgICAgICBtYXRjaCBidXQgdGhhdCBsb2dpYyBjb3VsZCBicmVhayBleGlzdGluZyBjb2RlLCBzbyBzY2hlZHVsZVxuICAgIC8vICAgICAgICB0aGlzIGZvciB0aGUgbmV4dCBtYWpvciBidW1wLlxuICAgIC8vIENvbXB1dGUgdGhlIEVJUC0xNTUgdlxuICAgIGxldCB2ID0gQmlnSW50KDI3ICsgc2lnLnlQYXJpdHkpO1xuICAgIGlmIChjaGFpbklkICE9PSBCTl8wKSB7XG4gICAgICAgIHYgPSBTaWduYXR1cmUuZ2V0Q2hhaW5JZFYoY2hhaW5JZCwgc2lnLnYpO1xuICAgIH1cbiAgICBlbHNlIGlmIChCaWdJbnQoc2lnLnYpICE9PSB2KSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInR4LmNoYWluSWQvc2lnLnYgbWlzbWF0Y2hcIiwgXCJzaWdcIiwgc2lnKTtcbiAgICB9XG4gICAgLy8gQWRkIHRoZSBzaWduYXR1cmVcbiAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkodikpO1xuICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShzaWcucikpO1xuICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShzaWcuX3MpKTtcbiAgICByZXR1cm4gZW5jb2RlUmxwKGZpZWxkcyk7XG59XG5mdW5jdGlvbiBfcGFyc2VFaXBTaWduYXR1cmUodHgsIGZpZWxkcykge1xuICAgIGxldCB5UGFyaXR5O1xuICAgIHRyeSB7XG4gICAgICAgIHlQYXJpdHkgPSBoYW5kbGVOdW1iZXIoZmllbGRzWzBdLCBcInlQYXJpdHlcIik7XG4gICAgICAgIGlmICh5UGFyaXR5ICE9PSAwICYmIHlQYXJpdHkgIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCB5UGFyaXR5XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIHlQYXJpdHlcIiwgXCJ5UGFyaXR5XCIsIGZpZWxkc1swXSk7XG4gICAgfVxuICAgIGNvbnN0IHIgPSB6ZXJvUGFkVmFsdWUoZmllbGRzWzFdLCAzMik7XG4gICAgY29uc3QgcyA9IHplcm9QYWRWYWx1ZShmaWVsZHNbMl0sIDMyKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbSh7IHIsIHMsIHlQYXJpdHkgfSk7XG4gICAgdHguc2lnbmF0dXJlID0gc2lnbmF0dXJlO1xufVxuZnVuY3Rpb24gX3BhcnNlRWlwMTU1OShkYXRhKSB7XG4gICAgY29uc3QgZmllbGRzID0gZGVjb2RlUmxwKGdldEJ5dGVzKGRhdGEpLnNsaWNlKDEpKTtcbiAgICBhc3NlcnRBcmd1bWVudChBcnJheS5pc0FycmF5KGZpZWxkcykgJiYgKGZpZWxkcy5sZW5ndGggPT09IDkgfHwgZmllbGRzLmxlbmd0aCA9PT0gMTIpLCBcImludmFsaWQgZmllbGQgY291bnQgZm9yIHRyYW5zYWN0aW9uIHR5cGU6IDJcIiwgXCJkYXRhXCIsIGhleGxpZnkoZGF0YSkpO1xuICAgIGNvbnN0IHR4ID0ge1xuICAgICAgICB0eXBlOiAyLFxuICAgICAgICBjaGFpbklkOiBoYW5kbGVVaW50KGZpZWxkc1swXSwgXCJjaGFpbklkXCIpLFxuICAgICAgICBub25jZTogaGFuZGxlTnVtYmVyKGZpZWxkc1sxXSwgXCJub25jZVwiKSxcbiAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IGhhbmRsZVVpbnQoZmllbGRzWzJdLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIpLFxuICAgICAgICBtYXhGZWVQZXJHYXM6IGhhbmRsZVVpbnQoZmllbGRzWzNdLCBcIm1heEZlZVBlckdhc1wiKSxcbiAgICAgICAgZ2FzUHJpY2U6IG51bGwsXG4gICAgICAgIGdhc0xpbWl0OiBoYW5kbGVVaW50KGZpZWxkc1s0XSwgXCJnYXNMaW1pdFwiKSxcbiAgICAgICAgdG86IGhhbmRsZUFkZHJlc3MoZmllbGRzWzVdKSxcbiAgICAgICAgdmFsdWU6IGhhbmRsZVVpbnQoZmllbGRzWzZdLCBcInZhbHVlXCIpLFxuICAgICAgICBkYXRhOiBoZXhsaWZ5KGZpZWxkc1s3XSksXG4gICAgICAgIGFjY2Vzc0xpc3Q6IGhhbmRsZUFjY2Vzc0xpc3QoZmllbGRzWzhdLCBcImFjY2Vzc0xpc3RcIiksXG4gICAgfTtcbiAgICAvLyBVbnNpZ25lZCBFSVAtMTU1OSBUcmFuc2FjdGlvblxuICAgIGlmIChmaWVsZHMubGVuZ3RoID09PSA5KSB7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgLy90eC5oYXNoID0ga2VjY2FrMjU2KGRhdGEpO1xuICAgIF9wYXJzZUVpcFNpZ25hdHVyZSh0eCwgZmllbGRzLnNsaWNlKDkpKTtcbiAgICByZXR1cm4gdHg7XG59XG5mdW5jdGlvbiBfc2VyaWFsaXplRWlwMTU1OSh0eCwgc2lnKSB7XG4gICAgY29uc3QgZmllbGRzID0gW1xuICAgICAgICBmb3JtYXROdW1iZXIodHguY2hhaW5JZCwgXCJjaGFpbklkXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubm9uY2UsIFwibm9uY2VcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5tYXhQcmlvcml0eUZlZVBlckdhcyB8fCAwLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubWF4RmVlUGVyR2FzIHx8IDAsIFwibWF4RmVlUGVyR2FzXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHguZ2FzTGltaXQsIFwiZ2FzTGltaXRcIiksXG4gICAgICAgICh0eC50byB8fCBcIjB4XCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgudmFsdWUsIFwidmFsdWVcIiksXG4gICAgICAgIHR4LmRhdGEsXG4gICAgICAgIGZvcm1hdEFjY2Vzc0xpc3QodHguYWNjZXNzTGlzdCB8fCBbXSlcbiAgICBdO1xuICAgIGlmIChzaWcpIHtcbiAgICAgICAgZmllbGRzLnB1c2goZm9ybWF0TnVtYmVyKHNpZy55UGFyaXR5LCBcInlQYXJpdHlcIikpO1xuICAgICAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoc2lnLnIpKTtcbiAgICAgICAgZmllbGRzLnB1c2godG9CZUFycmF5KHNpZy5zKSk7XG4gICAgfVxuICAgIHJldHVybiBjb25jYXQoW1wiMHgwMlwiLCBlbmNvZGVSbHAoZmllbGRzKV0pO1xufVxuZnVuY3Rpb24gX3BhcnNlRWlwMjkzMChkYXRhKSB7XG4gICAgY29uc3QgZmllbGRzID0gZGVjb2RlUmxwKGdldEJ5dGVzKGRhdGEpLnNsaWNlKDEpKTtcbiAgICBhc3NlcnRBcmd1bWVudChBcnJheS5pc0FycmF5KGZpZWxkcykgJiYgKGZpZWxkcy5sZW5ndGggPT09IDggfHwgZmllbGRzLmxlbmd0aCA9PT0gMTEpLCBcImludmFsaWQgZmllbGQgY291bnQgZm9yIHRyYW5zYWN0aW9uIHR5cGU6IDFcIiwgXCJkYXRhXCIsIGhleGxpZnkoZGF0YSkpO1xuICAgIGNvbnN0IHR4ID0ge1xuICAgICAgICB0eXBlOiAxLFxuICAgICAgICBjaGFpbklkOiBoYW5kbGVVaW50KGZpZWxkc1swXSwgXCJjaGFpbklkXCIpLFxuICAgICAgICBub25jZTogaGFuZGxlTnVtYmVyKGZpZWxkc1sxXSwgXCJub25jZVwiKSxcbiAgICAgICAgZ2FzUHJpY2U6IGhhbmRsZVVpbnQoZmllbGRzWzJdLCBcImdhc1ByaWNlXCIpLFxuICAgICAgICBnYXNMaW1pdDogaGFuZGxlVWludChmaWVsZHNbM10sIFwiZ2FzTGltaXRcIiksXG4gICAgICAgIHRvOiBoYW5kbGVBZGRyZXNzKGZpZWxkc1s0XSksXG4gICAgICAgIHZhbHVlOiBoYW5kbGVVaW50KGZpZWxkc1s1XSwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgZGF0YTogaGV4bGlmeShmaWVsZHNbNl0pLFxuICAgICAgICBhY2Nlc3NMaXN0OiBoYW5kbGVBY2Nlc3NMaXN0KGZpZWxkc1s3XSwgXCJhY2Nlc3NMaXN0XCIpXG4gICAgfTtcbiAgICAvLyBVbnNpZ25lZCBFSVAtMjkzMCBUcmFuc2FjdGlvblxuICAgIGlmIChmaWVsZHMubGVuZ3RoID09PSA4KSB7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgLy90eC5oYXNoID0ga2VjY2FrMjU2KGRhdGEpO1xuICAgIF9wYXJzZUVpcFNpZ25hdHVyZSh0eCwgZmllbGRzLnNsaWNlKDgpKTtcbiAgICByZXR1cm4gdHg7XG59XG5mdW5jdGlvbiBfc2VyaWFsaXplRWlwMjkzMCh0eCwgc2lnKSB7XG4gICAgY29uc3QgZmllbGRzID0gW1xuICAgICAgICBmb3JtYXROdW1iZXIodHguY2hhaW5JZCwgXCJjaGFpbklkXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubm9uY2UsIFwibm9uY2VcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5nYXNQcmljZSB8fCAwLCBcImdhc1ByaWNlXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHguZ2FzTGltaXQsIFwiZ2FzTGltaXRcIiksXG4gICAgICAgICh0eC50byB8fCBcIjB4XCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgudmFsdWUsIFwidmFsdWVcIiksXG4gICAgICAgIHR4LmRhdGEsXG4gICAgICAgIGZvcm1hdEFjY2Vzc0xpc3QodHguYWNjZXNzTGlzdCB8fCBbXSlcbiAgICBdO1xuICAgIGlmIChzaWcpIHtcbiAgICAgICAgZmllbGRzLnB1c2goZm9ybWF0TnVtYmVyKHNpZy55UGFyaXR5LCBcInJlY292ZXJ5UGFyYW1cIikpO1xuICAgICAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoc2lnLnIpKTtcbiAgICAgICAgZmllbGRzLnB1c2godG9CZUFycmF5KHNpZy5zKSk7XG4gICAgfVxuICAgIHJldHVybiBjb25jYXQoW1wiMHgwMVwiLCBlbmNvZGVSbHAoZmllbGRzKV0pO1xufVxuZnVuY3Rpb24gX3BhcnNlRWlwNDg0NChkYXRhKSB7XG4gICAgbGV0IGZpZWxkcyA9IGRlY29kZVJscChnZXRCeXRlcyhkYXRhKS5zbGljZSgxKSk7XG4gICAgbGV0IHR5cGVOYW1lID0gXCIzXCI7XG4gICAgbGV0IGJsb2JXcmFwcGVyVmVyc2lvbiA9IG51bGw7XG4gICAgbGV0IGJsb2JzID0gbnVsbDtcbiAgICAvLyBQYXJzZSB0aGUgbmV0d29yayBmb3JtYXRcbiAgICBpZiAoZmllbGRzLmxlbmd0aCA9PT0gNCAmJiBBcnJheS5pc0FycmF5KGZpZWxkc1swXSkpIHtcbiAgICAgICAgLy8gRUlQLTQ4NDQgZm9ybWF0IHdpdGggc2lkZWNhclxuICAgICAgICB0eXBlTmFtZSA9IFwiMyAobmV0d29yayBmb3JtYXQpXCI7XG4gICAgICAgIGNvbnN0IGZCbG9icyA9IGZpZWxkc1sxXSwgZkNvbW1pdHMgPSBmaWVsZHNbMl0sIGZQcm9vZnMgPSBmaWVsZHNbM107XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KEFycmF5LmlzQXJyYXkoZkJsb2JzKSwgXCJpbnZhbGlkIG5ldHdvcmsgZm9ybWF0OiBibG9icyBub3QgYW4gYXJyYXlcIiwgXCJmaWVsZHNbMV1cIiwgZkJsb2JzKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoQXJyYXkuaXNBcnJheShmQ29tbWl0cyksIFwiaW52YWxpZCBuZXR3b3JrIGZvcm1hdDogY29tbWl0bWVudHMgbm90IGFuIGFycmF5XCIsIFwiZmllbGRzWzJdXCIsIGZDb21taXRzKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoQXJyYXkuaXNBcnJheShmUHJvb2ZzKSwgXCJpbnZhbGlkIG5ldHdvcmsgZm9ybWF0OiBwcm9vZnMgbm90IGFuIGFycmF5XCIsIFwiZmllbGRzWzNdXCIsIGZQcm9vZnMpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChmQmxvYnMubGVuZ3RoID09PSBmQ29tbWl0cy5sZW5ndGgsIFwiaW52YWxpZCBuZXR3b3JrIGZvcm1hdDogYmxvYnMvY29tbWl0bWVudHMgbGVuZ3RoIG1pc21hdGNoXCIsIFwiZmllbGRzXCIsIGZpZWxkcyk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZCbG9icy5sZW5ndGggPT09IGZQcm9vZnMubGVuZ3RoLCBcImludmFsaWQgbmV0d29yayBmb3JtYXQ6IGJsb2JzL3Byb29mcyBsZW5ndGggbWlzbWF0Y2hcIiwgXCJmaWVsZHNcIiwgZmllbGRzKTtcbiAgICAgICAgYmxvYnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWVsZHNbMV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGJsb2JzLnB1c2goe1xuICAgICAgICAgICAgICAgIGRhdGE6IGZCbG9ic1tpXSxcbiAgICAgICAgICAgICAgICBjb21taXRtZW50OiBmQ29tbWl0c1tpXSxcbiAgICAgICAgICAgICAgICBwcm9vZjogZlByb29mc1tpXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZpZWxkcyA9IGZpZWxkc1swXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZmllbGRzLmxlbmd0aCA9PT0gNSAmJiBBcnJheS5pc0FycmF5KGZpZWxkc1swXSkpIHtcbiAgICAgICAgLy8gRUlQLTc1OTQgZm9ybWF0IHdpdGggc2lkZWNhclxuICAgICAgICB0eXBlTmFtZSA9IFwiMyAoRUlQLTc1OTQgbmV0d29yayBmb3JtYXQpXCI7XG4gICAgICAgIGJsb2JXcmFwcGVyVmVyc2lvbiA9IGdldE51bWJlcihmaWVsZHNbMV0pO1xuICAgICAgICBjb25zdCBmQmxvYnMgPSBmaWVsZHNbMl0sIGZDb21taXRzID0gZmllbGRzWzNdLCBmUHJvb2ZzID0gZmllbGRzWzRdO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChibG9iV3JhcHBlclZlcnNpb24gPT09IDEsIGB1bnN1cHBvcnRlZCBFSVAtNzU5NCBuZXR3b3JrIGZvcm1hdCB2ZXJzaW9uOiAke2Jsb2JXcmFwcGVyVmVyc2lvbn1gLCBcImZpZWxkc1sxXVwiLCBibG9iV3JhcHBlclZlcnNpb24pO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChBcnJheS5pc0FycmF5KGZCbG9icyksIFwiaW52YWxpZCBFSVAtNzU5NCBuZXR3b3JrIGZvcm1hdDogYmxvYnMgbm90IGFuIGFycmF5XCIsIFwiZmllbGRzWzJdXCIsIGZCbG9icyk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KEFycmF5LmlzQXJyYXkoZkNvbW1pdHMpLCBcImludmFsaWQgRUlQLTc1OTQgbmV0d29yayBmb3JtYXQ6IGNvbW1pdG1lbnRzIG5vdCBhbiBhcnJheVwiLCBcImZpZWxkc1szXVwiLCBmQ29tbWl0cyk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KEFycmF5LmlzQXJyYXkoZlByb29mcyksIFwiaW52YWxpZCBFSVAtNzU5NCBuZXR3b3JrIGZvcm1hdDogcHJvb2ZzIG5vdCBhbiBhcnJheVwiLCBcImZpZWxkc1s0XVwiLCBmUHJvb2ZzKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZkJsb2JzLmxlbmd0aCA9PT0gZkNvbW1pdHMubGVuZ3RoLCBcImludmFsaWQgbmV0d29yayBmb3JtYXQ6IGJsb2JzL2NvbW1pdG1lbnRzIGxlbmd0aCBtaXNtYXRjaFwiLCBcImZpZWxkc1wiLCBmaWVsZHMpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChmQmxvYnMubGVuZ3RoICogQ0VMTF9DT1VOVCA9PT0gZlByb29mcy5sZW5ndGgsIFwiaW52YWxpZCBuZXR3b3JrIGZvcm1hdDogYmxvYnMvcHJvb2ZzIGxlbmd0aCBtaXNtYXRjaFwiLCBcImZpZWxkc1wiLCBmaWVsZHMpO1xuICAgICAgICBibG9icyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZCbG9icy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcHJvb2YgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgQ0VMTF9DT1VOVDsgaisrKSB7XG4gICAgICAgICAgICAgICAgcHJvb2YucHVzaChmUHJvb2ZzWyhpICogQ0VMTF9DT1VOVCkgKyBqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBibG9icy5wdXNoKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBmQmxvYnNbaV0sXG4gICAgICAgICAgICAgICAgY29tbWl0bWVudDogZkNvbW1pdHNbaV0sXG4gICAgICAgICAgICAgICAgcHJvb2Y6IGNvbmNhdChwcm9vZilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZpZWxkcyA9IGZpZWxkc1swXTtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoQXJyYXkuaXNBcnJheShmaWVsZHMpICYmIChmaWVsZHMubGVuZ3RoID09PSAxMSB8fCBmaWVsZHMubGVuZ3RoID09PSAxNCksIGBpbnZhbGlkIGZpZWxkIGNvdW50IGZvciB0cmFuc2FjdGlvbiB0eXBlOiAke3R5cGVOYW1lfWAsIFwiZGF0YVwiLCBoZXhsaWZ5KGRhdGEpKTtcbiAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgdHlwZTogMyxcbiAgICAgICAgY2hhaW5JZDogaGFuZGxlVWludChmaWVsZHNbMF0sIFwiY2hhaW5JZFwiKSxcbiAgICAgICAgbm9uY2U6IGhhbmRsZU51bWJlcihmaWVsZHNbMV0sIFwibm9uY2VcIiksXG4gICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBoYW5kbGVVaW50KGZpZWxkc1syXSwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiKSxcbiAgICAgICAgbWF4RmVlUGVyR2FzOiBoYW5kbGVVaW50KGZpZWxkc1szXSwgXCJtYXhGZWVQZXJHYXNcIiksXG4gICAgICAgIGdhc1ByaWNlOiBudWxsLFxuICAgICAgICBnYXNMaW1pdDogaGFuZGxlVWludChmaWVsZHNbNF0sIFwiZ2FzTGltaXRcIiksXG4gICAgICAgIHRvOiBoYW5kbGVBZGRyZXNzKGZpZWxkc1s1XSksXG4gICAgICAgIHZhbHVlOiBoYW5kbGVVaW50KGZpZWxkc1s2XSwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgZGF0YTogaGV4bGlmeShmaWVsZHNbN10pLFxuICAgICAgICBhY2Nlc3NMaXN0OiBoYW5kbGVBY2Nlc3NMaXN0KGZpZWxkc1s4XSwgXCJhY2Nlc3NMaXN0XCIpLFxuICAgICAgICBtYXhGZWVQZXJCbG9iR2FzOiBoYW5kbGVVaW50KGZpZWxkc1s5XSwgXCJtYXhGZWVQZXJCbG9iR2FzXCIpLFxuICAgICAgICBibG9iVmVyc2lvbmVkSGFzaGVzOiBmaWVsZHNbMTBdLFxuICAgICAgICBibG9iV3JhcHBlclZlcnNpb25cbiAgICB9O1xuICAgIGlmIChibG9icykge1xuICAgICAgICB0eC5ibG9icyA9IGJsb2JzO1xuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudCh0eC50byAhPSBudWxsLCBgaW52YWxpZCBhZGRyZXNzIGZvciB0cmFuc2FjdGlvbiB0eXBlOiAke3R5cGVOYW1lfWAsIFwiZGF0YVwiLCBkYXRhKTtcbiAgICBhc3NlcnRBcmd1bWVudChBcnJheS5pc0FycmF5KHR4LmJsb2JWZXJzaW9uZWRIYXNoZXMpLCBcImludmFsaWQgYmxvYlZlcnNpb25lZEhhc2hlczogbXVzdCBiZSBhbiBhcnJheVwiLCBcImRhdGFcIiwgZGF0YSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eC5ibG9iVmVyc2lvbmVkSGFzaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGlzSGV4U3RyaW5nKHR4LmJsb2JWZXJzaW9uZWRIYXNoZXNbaV0sIDMyKSwgYGludmFsaWQgYmxvYlZlcnNpb25lZEhhc2ggYXQgaW5kZXggJHtpfTogbXVzdCBiZSBsZW5ndGggMzJgLCBcImRhdGFcIiwgZGF0YSk7XG4gICAgfVxuICAgIC8vIFVuc2lnbmVkIEVJUC00ODQ0IFRyYW5zYWN0aW9uXG4gICAgaWYgKGZpZWxkcy5sZW5ndGggPT09IDExKSB7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgLy8gQFRPRE86IERvIHdlIG5lZWQgdG8gZG8gdGhpcz8gVGhpcyBpcyBvbmx5IGNhbGxlZCBpbnRlcm5hbGx5XG4gICAgLy8gYW5kIHVzZWQgdG8gdmVyaWZ5IGhhc2hlczsgaXQgbWlnaHQgc2F2ZSB0aW1lIHRvIG5vdCBkbyB0aGlzXG4gICAgLy90eC5oYXNoID0ga2VjY2FrMjU2KGNvbmNhdChbIFwiMHgwM1wiLCBlbmNvZGVSbHAoZmllbGRzKSBdKSk7XG4gICAgX3BhcnNlRWlwU2lnbmF0dXJlKHR4LCBmaWVsZHMuc2xpY2UoMTEpKTtcbiAgICByZXR1cm4gdHg7XG59XG5mdW5jdGlvbiBfc2VyaWFsaXplRWlwNDg0NCh0eCwgc2lnLCBibG9icykge1xuICAgIGNvbnN0IGZpZWxkcyA9IFtcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4LmNoYWluSWQsIFwiY2hhaW5JZFwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm5vbmNlLCBcIm5vbmNlXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgfHwgMCwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm1heEZlZVBlckdhcyB8fCAwLCBcIm1heEZlZVBlckdhc1wiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lmdhc0xpbWl0LCBcImdhc0xpbWl0XCIpLFxuICAgICAgICAodHgudG8gfHwgWmVyb0FkZHJlc3MpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgudmFsdWUsIFwidmFsdWVcIiksXG4gICAgICAgIHR4LmRhdGEsXG4gICAgICAgIGZvcm1hdEFjY2Vzc0xpc3QodHguYWNjZXNzTGlzdCB8fCBbXSksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5tYXhGZWVQZXJCbG9iR2FzIHx8IDAsIFwibWF4RmVlUGVyQmxvYkdhc1wiKSxcbiAgICAgICAgZm9ybWF0SGFzaGVzKHR4LmJsb2JWZXJzaW9uZWRIYXNoZXMgfHwgW10sIFwiYmxvYlZlcnNpb25lZEhhc2hlc1wiKVxuICAgIF07XG4gICAgaWYgKHNpZykge1xuICAgICAgICBmaWVsZHMucHVzaChmb3JtYXROdW1iZXIoc2lnLnlQYXJpdHksIFwieVBhcml0eVwiKSk7XG4gICAgICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShzaWcucikpO1xuICAgICAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoc2lnLnMpKTtcbiAgICAgICAgLy8gV2UgaGF2ZSBibG9iczsgcmV0dXJuIHRoZSBuZXR3b3JrIHdyYXBwZWQgZm9ybWF0XG4gICAgICAgIGlmIChibG9icykge1xuICAgICAgICAgICAgLy8gVXNlIEVJUC03NTk0XG4gICAgICAgICAgICBpZiAodHguYmxvYldyYXBwZXJWZXJzaW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3cmFwcGVyVmVyc2lvbiA9IHRvQmVBcnJheSh0eC5ibG9iV3JhcHBlclZlcnNpb24pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxQcm9vZnMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgcHJvb2YgfSBvZiBibG9icykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gZ2V0Qnl0ZXMocHJvb2YpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjZWxsU2l6ZSA9IHAubGVuZ3RoIC8gQ0VMTF9DT1VOVDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSArPSBjZWxsU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFByb29mcy5wdXNoKHAuc3ViYXJyYXkoaSwgaSArIGNlbGxTaXplKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmNhdChbXG4gICAgICAgICAgICAgICAgICAgIFwiMHgwM1wiLFxuICAgICAgICAgICAgICAgICAgICBlbmNvZGVSbHAoW1xuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgd3JhcHBlclZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBibG9icy5tYXAoKGIpID0+IGIuZGF0YSksXG4gICAgICAgICAgICAgICAgICAgICAgICBibG9icy5tYXAoKGIpID0+IGIuY29tbWl0bWVudCksXG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsUHJvb2ZzXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGYWxsIGJhY2sgb250byBjbGFzc2ljIEVJUC00ODQ0IGJlaGF2aW9yXG4gICAgICAgICAgICByZXR1cm4gY29uY2F0KFtcbiAgICAgICAgICAgICAgICBcIjB4MDNcIixcbiAgICAgICAgICAgICAgICBlbmNvZGVSbHAoW1xuICAgICAgICAgICAgICAgICAgICBmaWVsZHMsXG4gICAgICAgICAgICAgICAgICAgIGJsb2JzLm1hcCgoYikgPT4gYi5kYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgYmxvYnMubWFwKChiKSA9PiBiLmNvbW1pdG1lbnQpLFxuICAgICAgICAgICAgICAgICAgICBibG9icy5tYXAoKGIpID0+IGIucHJvb2YpLFxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29uY2F0KFtcIjB4MDNcIiwgZW5jb2RlUmxwKGZpZWxkcyldKTtcbn1cbmZ1bmN0aW9uIF9wYXJzZUVpcDc3MDIoZGF0YSkge1xuICAgIGNvbnN0IGZpZWxkcyA9IGRlY29kZVJscChnZXRCeXRlcyhkYXRhKS5zbGljZSgxKSk7XG4gICAgYXNzZXJ0QXJndW1lbnQoQXJyYXkuaXNBcnJheShmaWVsZHMpICYmIChmaWVsZHMubGVuZ3RoID09PSAxMCB8fCBmaWVsZHMubGVuZ3RoID09PSAxMyksIFwiaW52YWxpZCBmaWVsZCBjb3VudCBmb3IgdHJhbnNhY3Rpb24gdHlwZTogNFwiLCBcImRhdGFcIiwgaGV4bGlmeShkYXRhKSk7XG4gICAgY29uc3QgdHggPSB7XG4gICAgICAgIHR5cGU6IDQsXG4gICAgICAgIGNoYWluSWQ6IGhhbmRsZVVpbnQoZmllbGRzWzBdLCBcImNoYWluSWRcIiksXG4gICAgICAgIG5vbmNlOiBoYW5kbGVOdW1iZXIoZmllbGRzWzFdLCBcIm5vbmNlXCIpLFxuICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogaGFuZGxlVWludChmaWVsZHNbMl0sIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIiksXG4gICAgICAgIG1heEZlZVBlckdhczogaGFuZGxlVWludChmaWVsZHNbM10sIFwibWF4RmVlUGVyR2FzXCIpLFxuICAgICAgICBnYXNQcmljZTogbnVsbCxcbiAgICAgICAgZ2FzTGltaXQ6IGhhbmRsZVVpbnQoZmllbGRzWzRdLCBcImdhc0xpbWl0XCIpLFxuICAgICAgICB0bzogaGFuZGxlQWRkcmVzcyhmaWVsZHNbNV0pLFxuICAgICAgICB2YWx1ZTogaGFuZGxlVWludChmaWVsZHNbNl0sIFwidmFsdWVcIiksXG4gICAgICAgIGRhdGE6IGhleGxpZnkoZmllbGRzWzddKSxcbiAgICAgICAgYWNjZXNzTGlzdDogaGFuZGxlQWNjZXNzTGlzdChmaWVsZHNbOF0sIFwiYWNjZXNzTGlzdFwiKSxcbiAgICAgICAgYXV0aG9yaXphdGlvbkxpc3Q6IGhhbmRsZUF1dGhvcml6YXRpb25MaXN0KGZpZWxkc1s5XSwgXCJhdXRob3JpemF0aW9uTGlzdFwiKSxcbiAgICB9O1xuICAgIC8vIFVuc2lnbmVkIEVJUC03NzAyIFRyYW5zYWN0aW9uXG4gICAgaWYgKGZpZWxkcy5sZW5ndGggPT09IDEwKSB7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgX3BhcnNlRWlwU2lnbmF0dXJlKHR4LCBmaWVsZHMuc2xpY2UoMTApKTtcbiAgICByZXR1cm4gdHg7XG59XG5mdW5jdGlvbiBfc2VyaWFsaXplRWlwNzcwMih0eCwgc2lnKSB7XG4gICAgY29uc3QgZmllbGRzID0gW1xuICAgICAgICBmb3JtYXROdW1iZXIodHguY2hhaW5JZCwgXCJjaGFpbklkXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubm9uY2UsIFwibm9uY2VcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5tYXhQcmlvcml0eUZlZVBlckdhcyB8fCAwLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubWF4RmVlUGVyR2FzIHx8IDAsIFwibWF4RmVlUGVyR2FzXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHguZ2FzTGltaXQsIFwiZ2FzTGltaXRcIiksXG4gICAgICAgICh0eC50byB8fCBcIjB4XCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgudmFsdWUsIFwidmFsdWVcIiksXG4gICAgICAgIHR4LmRhdGEsXG4gICAgICAgIGZvcm1hdEFjY2Vzc0xpc3QodHguYWNjZXNzTGlzdCB8fCBbXSksXG4gICAgICAgIGZvcm1hdEF1dGhvcml6YXRpb25MaXN0KHR4LmF1dGhvcml6YXRpb25MaXN0IHx8IFtdKVxuICAgIF07XG4gICAgaWYgKHNpZykge1xuICAgICAgICBmaWVsZHMucHVzaChmb3JtYXROdW1iZXIoc2lnLnlQYXJpdHksIFwieVBhcml0eVwiKSk7XG4gICAgICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShzaWcucikpO1xuICAgICAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoc2lnLnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmNhdChbXCIweDA0XCIsIGVuY29kZVJscChmaWVsZHMpXSk7XG59XG4vKipcbiAqICBBICoqVHJhbnNhY3Rpb24qKiBkZXNjcmliZXMgYW4gb3BlcmF0aW9uIHRvIGJlIGV4ZWN1dGVkIG9uXG4gKiAgRXRoZXJldW0gYnkgYW4gRXh0ZXJuYWxseSBPd25lZCBBY2NvdW50IChFT0EpLiBJdCBpbmNsdWRlc1xuICogIHdobyAodGhlIFtbdG9dXSBhZGRyZXNzKSwgd2hhdCAodGhlIFtbZGF0YV1dKSBhbmQgaG93IG11Y2ggKHRoZVxuICogIFtbdmFsdWVdXSBpbiBldGhlcikgdGhlIG9wZXJhdGlvbiBzaG91bGQgZW50YWlsLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIHR4ID0gbmV3IFRyYW5zYWN0aW9uKClcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICB0eC5kYXRhID0gXCIweDEyMzRcIjtcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuZXhwb3J0IGNsYXNzIFRyYW5zYWN0aW9uIHtcbiAgICAjdHlwZTtcbiAgICAjdG87XG4gICAgI2RhdGE7XG4gICAgI25vbmNlO1xuICAgICNnYXNMaW1pdDtcbiAgICAjZ2FzUHJpY2U7XG4gICAgI21heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICNtYXhGZWVQZXJHYXM7XG4gICAgI3ZhbHVlO1xuICAgICNjaGFpbklkO1xuICAgICNzaWc7XG4gICAgI2FjY2Vzc0xpc3Q7XG4gICAgI21heEZlZVBlckJsb2JHYXM7XG4gICAgI2Jsb2JWZXJzaW9uZWRIYXNoZXM7XG4gICAgI2t6ZztcbiAgICAjYmxvYnM7XG4gICAgI2F1dGhzO1xuICAgICNibG9iV3JhcHBlclZlcnNpb247XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiB0eXBlLlxuICAgICAqXG4gICAgICogIElmIG51bGwsIHRoZSB0eXBlIHdpbGwgYmUgYXV0b21hdGljYWxseSBpbmZlcnJlZCBiYXNlZCBvblxuICAgICAqICBleHBsaWNpdCBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIGdldCB0eXBlKCkgeyByZXR1cm4gdGhpcy4jdHlwZTsgfVxuICAgIHNldCB0eXBlKHZhbHVlKSB7XG4gICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgbnVsbDpcbiAgICAgICAgICAgICAgICB0aGlzLiN0eXBlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhc2UgXCJsZWdhY3lcIjpcbiAgICAgICAgICAgICAgICB0aGlzLiN0eXBlID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhc2UgXCJiZXJsaW5cIjpcbiAgICAgICAgICAgIGNhc2UgXCJlaXAtMjkzMFwiOlxuICAgICAgICAgICAgICAgIHRoaXMuI3R5cGUgPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FzZSBcImxvbmRvblwiOlxuICAgICAgICAgICAgY2FzZSBcImVpcC0xNTU5XCI6XG4gICAgICAgICAgICAgICAgdGhpcy4jdHlwZSA9IDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYXNlIFwiY2FuY3VuXCI6XG4gICAgICAgICAgICBjYXNlIFwiZWlwLTQ4NDRcIjpcbiAgICAgICAgICAgICAgICB0aGlzLiN0eXBlID0gMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGNhc2UgXCJwZWN0cmFcIjpcbiAgICAgICAgICAgIGNhc2UgXCJlaXAtNzcwMlwiOlxuICAgICAgICAgICAgICAgIHRoaXMuI3R5cGUgPSA0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bnN1cHBvcnRlZCB0cmFuc2FjdGlvbiB0eXBlXCIsIFwidHlwZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lIG9mIHRoZSB0cmFuc2FjdGlvbiB0eXBlLlxuICAgICAqL1xuICAgIGdldCB0eXBlTmFtZSgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFwibGVnYWN5XCI7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBcImVpcC0yOTMwXCI7XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBcImVpcC0xNTU5XCI7XG4gICAgICAgICAgICBjYXNlIDM6IHJldHVybiBcImVpcC00ODQ0XCI7XG4gICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBcImVpcC03NzAyXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgYGB0b2BgIGFkZHJlc3MgZm9yIHRoZSB0cmFuc2FjdGlvbiBvciBgYG51bGxgYCBpZiB0aGVcbiAgICAgKiAgdHJhbnNhY3Rpb24gaXMgYW4gYGBpbml0YGAgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgZ2V0IHRvKCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI3RvO1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCAmJiB0aGlzLnR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgIHJldHVybiBaZXJvQWRkcmVzcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHNldCB0byh2YWx1ZSkge1xuICAgICAgICB0aGlzLiN0byA9ICh2YWx1ZSA9PSBudWxsKSA/IG51bGwgOiBnZXRBZGRyZXNzKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBub25jZS5cbiAgICAgKi9cbiAgICBnZXQgbm9uY2UoKSB7IHJldHVybiB0aGlzLiNub25jZTsgfVxuICAgIHNldCBub25jZSh2YWx1ZSkgeyB0aGlzLiNub25jZSA9IGdldE51bWJlcih2YWx1ZSwgXCJ2YWx1ZVwiKTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgZ2FzIGxpbWl0LlxuICAgICAqL1xuICAgIGdldCBnYXNMaW1pdCgpIHsgcmV0dXJuIHRoaXMuI2dhc0xpbWl0OyB9XG4gICAgc2V0IGdhc0xpbWl0KHZhbHVlKSB7IHRoaXMuI2dhc0xpbWl0ID0gZ2V0QmlnSW50KHZhbHVlKTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgZ2FzIHByaWNlLlxuICAgICAqXG4gICAgICogIE9uIGxlZ2FjeSBuZXR3b3JrcyB0aGlzIGRlZmluZXMgdGhlIGZlZSB0aGF0IHdpbGwgYmUgcGFpZC4gT25cbiAgICAgKiAgRUlQLTE1NTkgbmV0d29ya3MsIHRoaXMgc2hvdWxkIGJlIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdldCBnYXNQcmljZSgpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiNnYXNQcmljZTtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgJiYgKHRoaXMudHlwZSA9PT0gMCB8fCB0aGlzLnR5cGUgPT09IDEpKSB7XG4gICAgICAgICAgICByZXR1cm4gQk5fMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHNldCBnYXNQcmljZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLiNnYXNQcmljZSA9ICh2YWx1ZSA9PSBudWxsKSA/IG51bGwgOiBnZXRCaWdJbnQodmFsdWUsIFwiZ2FzUHJpY2VcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSBwcmlvcml0eSBmZWUgcGVyIHVuaXQgb2YgZ2FzIHRvIHBheS4gT24gbGVnYWN5XG4gICAgICogIG5ldHdvcmtzIHRoaXMgc2hvdWxkIGJlIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdldCBtYXhQcmlvcml0eUZlZVBlckdhcygpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiNtYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IDIgfHwgdGhpcy50eXBlID09PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJOXzA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHNldCBtYXhQcmlvcml0eUZlZVBlckdhcyh2YWx1ZSkge1xuICAgICAgICB0aGlzLiNtYXhQcmlvcml0eUZlZVBlckdhcyA9ICh2YWx1ZSA9PSBudWxsKSA/IG51bGwgOiBnZXRCaWdJbnQodmFsdWUsIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSB0b3RhbCBmZWUgcGVyIHVuaXQgb2YgZ2FzIHRvIHBheS4gT24gbGVnYWN5XG4gICAgICogIG5ldHdvcmtzIHRoaXMgc2hvdWxkIGJlIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdldCBtYXhGZWVQZXJHYXMoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jbWF4RmVlUGVyR2FzO1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gMiB8fCB0aGlzLnR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQk5fMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgc2V0IG1heEZlZVBlckdhcyh2YWx1ZSkge1xuICAgICAgICB0aGlzLiNtYXhGZWVQZXJHYXMgPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogZ2V0QmlnSW50KHZhbHVlLCBcIm1heEZlZVBlckdhc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBkYXRhLiBGb3IgYGBpbml0YGAgdHJhbnNhY3Rpb25zIHRoaXMgaXMgdGhlXG4gICAgICogIGRlcGxveW1lbnQgY29kZS5cbiAgICAgKi9cbiAgICBnZXQgZGF0YSgpIHsgcmV0dXJuIHRoaXMuI2RhdGE7IH1cbiAgICBzZXQgZGF0YSh2YWx1ZSkgeyB0aGlzLiNkYXRhID0gaGV4bGlmeSh2YWx1ZSk7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGFtb3VudCBvZiBldGhlciAoaW4gd2VpKSB0byBzZW5kIGluIHRoaXMgdHJhbnNhY3Rpb25zLlxuICAgICAqL1xuICAgIGdldCB2YWx1ZSgpIHsgcmV0dXJuIHRoaXMuI3ZhbHVlOyB9XG4gICAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI3ZhbHVlID0gZ2V0QmlnSW50KHZhbHVlLCBcInZhbHVlXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGNoYWluIElEIHRoaXMgdHJhbnNhY3Rpb24gaXMgdmFsaWQgb24uXG4gICAgICovXG4gICAgZ2V0IGNoYWluSWQoKSB7IHJldHVybiB0aGlzLiNjaGFpbklkOyB9XG4gICAgc2V0IGNoYWluSWQodmFsdWUpIHsgdGhpcy4jY2hhaW5JZCA9IGdldEJpZ0ludCh2YWx1ZSk7IH1cbiAgICAvKipcbiAgICAgKiAgSWYgc2lnbmVkLCB0aGUgc2lnbmF0dXJlIGZvciB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGdldCBzaWduYXR1cmUoKSB7IHJldHVybiB0aGlzLiNzaWcgfHwgbnVsbDsgfVxuICAgIHNldCBzaWduYXR1cmUodmFsdWUpIHtcbiAgICAgICAgdGhpcy4jc2lnID0gKHZhbHVlID09IG51bGwpID8gbnVsbCA6IFNpZ25hdHVyZS5mcm9tKHZhbHVlKTtcbiAgICB9XG4gICAgaXNWYWxpZCgpIHtcbiAgICAgICAgY29uc3Qgc2lnID0gdGhpcy5zaWduYXR1cmU7XG4gICAgICAgIGlmIChzaWcgJiYgIXNpZy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhdXRocyA9IHRoaXMuYXV0aG9yaXphdGlvbkxpc3Q7XG4gICAgICAgIGlmIChhdXRocykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBhdXRoIG9mIGF1dGhzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhdXRoLnNpZ25hdHVyZS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBhY2Nlc3MgbGlzdC5cbiAgICAgKlxuICAgICAqICBBbiBhY2Nlc3MgbGlzdCBwZXJtaXRzIGRpc2NvdW50ZWQgKGJ1dCBwcmUtcGFpZCkgYWNjZXNzIHRvXG4gICAgICogIGJ5dGVjb2RlIGFuZCBzdGF0ZSB2YXJpYWJsZSBhY2Nlc3Mgd2l0aGluIGNvbnRyYWN0IGV4ZWN1dGlvbi5cbiAgICAgKi9cbiAgICBnZXQgYWNjZXNzTGlzdCgpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiNhY2Nlc3NMaXN0IHx8IG51bGw7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAxIHx8IHRoaXMudHlwZSA9PT0gMiB8fCB0aGlzLnR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICAvLyBAVE9ETzogaW4gdjcsIHRoaXMgc2hvdWxkIGFzc2lnbiB0aGUgdmFsdWUgb3IgYmVjb21lXG4gICAgICAgICAgICAgICAgLy8gYSBsaXZlIG9iamVjdCBpdHNlbGYsIG90aGVyd2lzZSBtdXRhdGlvbiBpcyBpbmNvbnNpc3RlbnRcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHNldCBhY2Nlc3NMaXN0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI2FjY2Vzc0xpc3QgPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogYWNjZXNzTGlzdGlmeSh2YWx1ZSk7XG4gICAgfVxuICAgIGdldCBhdXRob3JpemF0aW9uTGlzdCgpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiNhdXRocyB8fCBudWxsO1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gNCkge1xuICAgICAgICAgICAgICAgIC8vIEBUT0RPOiBpbiB2NywgdGhpcyBzaG91bGQgYmVjb21lIGEgbGl2ZSBvYmplY3QgaXRzZWxmLFxuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBtdXRhdGlvbiBpcyBpbmNvbnNpc3RlbnRcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZXQgYXV0aG9yaXphdGlvbkxpc3QoYXV0aHMpIHtcbiAgICAgICAgdGhpcy4jYXV0aHMgPSAoYXV0aHMgPT0gbnVsbCkgPyBudWxsIDogYXV0aHMubWFwKChhKSA9PiBhdXRob3JpemF0aW9uaWZ5KGEpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXggZmVlIHBlciBibG9iIGdhcyBmb3IgQ2FuY3VuIHRyYW5zYWN0aW9ucy5cbiAgICAgKi9cbiAgICBnZXQgbWF4RmVlUGVyQmxvYkdhcygpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiNtYXhGZWVQZXJCbG9iR2FzO1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCAmJiB0aGlzLnR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgIHJldHVybiBCTl8wO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgc2V0IG1heEZlZVBlckJsb2JHYXModmFsdWUpIHtcbiAgICAgICAgdGhpcy4jbWF4RmVlUGVyQmxvYkdhcyA9ICh2YWx1ZSA9PSBudWxsKSA/IG51bGwgOiBnZXRCaWdJbnQodmFsdWUsIFwibWF4RmVlUGVyQmxvYkdhc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBCTE9iIHZlcnNpb25lZCBoYXNoZXMgZm9yIENhbmN1biB0cmFuc2FjdGlvbnMuXG4gICAgICovXG4gICAgZ2V0IGJsb2JWZXJzaW9uZWRIYXNoZXMoKSB7XG4gICAgICAgIC8vIEBUT0RPOiBNdXRhdGlvbiBpcyBpbmNvbnNpc3RlbnQ7IGlmIHVuc2V0LCB0aGUgcmV0dXJuZWQgdmFsdWVcbiAgICAgICAgLy8gY2Fubm90IG11dGF0ZSB0aGUgb2JqZWN0LCBpZiBzZXQgaXQgY2FuXG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuI2Jsb2JWZXJzaW9uZWRIYXNoZXM7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsICYmIHRoaXMudHlwZSA9PT0gMykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgc2V0IGJsb2JWZXJzaW9uZWRIYXNoZXModmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KEFycmF5LmlzQXJyYXkodmFsdWUpLCBcImJsb2JWZXJzaW9uZWRIYXNoZXMgbXVzdCBiZSBhbiBBcnJheVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChpc0hleFN0cmluZyh2YWx1ZVtpXSwgMzIpLCBcImludmFsaWQgYmxvYlZlcnNpb25lZEhhc2hcIiwgYHZhbHVlWyR7aX1dYCwgdmFsdWVbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2Jsb2JWZXJzaW9uZWRIYXNoZXMgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBCTE9icyBmb3IgdGhlIFRyYW5zYWN0aW9uLCBpZiBhbnkuXG4gICAgICpcbiAgICAgKiAgSWYgYGBibG9ic2BgIGlzIG5vbi1gYG51bGxgYCwgdGhlbiB0aGUgW1tzZXJpYWlsaXplZF1dXG4gICAgICogIHdpbGwgcmV0dXJuIHRoZSBuZXR3b3JrIGZvcm1hdHRlZCBzaWRlY2FyLCBvdGhlcndpc2UgaXRcbiAgICAgKiAgd2lsbCByZXR1cm4gdGhlIHN0YW5kYXJkIFtbbGluay1laXAtMjcxOF1dIHBheWxvYWQuIFRoZVxuICAgICAqICBbW3Vuc2lnbmVkU2VyaWFsaXplZF1dIGlzIHVuYWZmZWN0ZWQgcmVnYXJkbGVzcy5cbiAgICAgKlxuICAgICAqICBXaGVuIHNldHRpbmcgYGBibG9ic2BgLCBlaXRoZXIgZnVsbHkgdmFsaWQgW1tCbG9iXV0gb2JqZWN0c1xuICAgICAqICBtYXkgYmUgc3BlY2lmaWVkIChpLmUuIGNvcnJlY3RseSBwYWRkZWQsIHdpdGggY29ycmVjdFxuICAgICAqICBjb21taXR0bWVudHMgYW5kIHByb29mcykgb3IgYSByYXcgW1tCeXRlc0xpa2VdXSBtYXlcbiAgICAgKiAgYmUgcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiAgSWYgcmF3IFtbQnl0ZXNMaWtlXV0gYXJlIHByb3ZpZGVkLCB0aGUgW1tremddXSBwcm9wZXJ0eSAqKm11c3QqKlxuICAgICAqICBiZSBhbHJlYWR5IHNldC4gVGhlIGJsb2Igd2lsbCBiZSBjb3JyZWN0bHkgcGFkZGVkIGFuZCB0aGVcbiAgICAgKiAgW1tLemdMaWJyYXJ5XV0gd2lsbCBiZSB1c2VkIHRvIGNvbXB1dGUgdGhlIGNvbW1pdHRtZW50IGFuZFxuICAgICAqICBwcm9vZiBmb3IgdGhlIGJsb2IuXG4gICAgICpcbiAgICAgKiAgQSBCTE9iIGlzIGEgc2VxdWVuY2Ugb2YgZmllbGQgZWxlbWVudHMsIGVhY2ggb2Ygd2hpY2ggbXVzdFxuICAgICAqICBiZSB3aXRoaW4gdGhlIEJMUyBmaWVsZCBtb2R1bG8sIHNvIHNvbWUgYWRkaXRpb25hbCBwcm9jZXNzaW5nXG4gICAgICogIG1heSBiZSByZXF1aXJlZCB0byBlbmNvZGUgYXJiaXRyYXJ5IGRhdGEgdG8gZW5zdXJlIGVhY2ggMzIgYnl0ZVxuICAgICAqICBmaWVsZCBpcyB3aXRoaW4gdGhlIHZhbGlkIHJhbmdlLlxuICAgICAqXG4gICAgICogIFNldHRpbmcgdGhpcyBhdXRvbWF0aWNhbGx5IHBvcHVsYXRlcyBbW2Jsb2JWZXJzaW9uZWRIYXNoZXNdXSxcbiAgICAgKiAgb3ZlcndyaXRpbmcgYW55IGV4aXN0aW5nIHZhbHVlcy4gU2V0dGluZyB0aGlzIHRvIGBgbnVsbGBgXG4gICAgICogIGRvZXMgKipub3QqKiByZW1vdmUgdGhlIFtbYmxvYlZlcnNpb25lZEhhc2hlc11dLCBsZWF2aW5nIHRoZW1cbiAgICAgKiAgcHJlc2VudC5cbiAgICAgKi9cbiAgICBnZXQgYmxvYnMoKSB7XG4gICAgICAgIGlmICh0aGlzLiNibG9icyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jYmxvYnMubWFwKChiKSA9PiBPYmplY3QuYXNzaWduKHt9LCBiKSk7XG4gICAgfVxuICAgIHNldCBibG9icyhfYmxvYnMpIHtcbiAgICAgICAgaWYgKF9ibG9icyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLiNibG9icyA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmxvYnMgPSBbXTtcbiAgICAgICAgY29uc3QgdmVyc2lvbmVkSGFzaGVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgX2Jsb2JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBibG9iID0gX2Jsb2JzW2ldO1xuICAgICAgICAgICAgaWYgKGlzQnl0ZXNMaWtlKGJsb2IpKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KHRoaXMuI2t6ZywgXCJhZGRpbmcgYSByYXcgYmxvYiByZXF1aXJlcyBhIEtaRyBsaWJyYXJ5XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNldCBibG9icygpXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IGdldEJ5dGVzKGJsb2IpO1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGRhdGEubGVuZ3RoIDw9IEJMT0JfU0laRSwgXCJibG9iIGlzIHRvbyBsYXJnZVwiLCBgYmxvYnNbJHtpfV1gLCBibG9iKTtcbiAgICAgICAgICAgICAgICAvLyBQYWQgYmxvYiBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggIT09IEJMT0JfU0laRSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYWRkZWQgPSBuZXcgVWludDhBcnJheShCTE9CX1NJWkUpO1xuICAgICAgICAgICAgICAgICAgICBwYWRkZWQuc2V0KGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gcGFkZGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjb21taXQgPSB0aGlzLiNremcuYmxvYlRvS3pnQ29tbWl0bWVudChkYXRhKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9vZiA9IGhleGxpZnkodGhpcy4ja3pnLmNvbXB1dGVCbG9iS3pnUHJvb2YoZGF0YSwgY29tbWl0KSk7XG4gICAgICAgICAgICAgICAgYmxvYnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGhleGxpZnkoZGF0YSksXG4gICAgICAgICAgICAgICAgICAgIGNvbW1pdG1lbnQ6IGhleGxpZnkoY29tbWl0KSxcbiAgICAgICAgICAgICAgICAgICAgcHJvb2ZcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uZWRIYXNoZXMucHVzaChnZXRWZXJzaW9uZWRIYXNoKDEsIGNvbW1pdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGhleGxpZnkoYmxvYi5kYXRhKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21taXRtZW50ID0gaGV4bGlmeShibG9iLmNvbW1pdG1lbnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb29mID0gaGV4bGlmeShibG9iLnByb29mKTtcbiAgICAgICAgICAgICAgICBibG9icy5wdXNoKHsgZGF0YSwgY29tbWl0bWVudCwgcHJvb2YgfSk7XG4gICAgICAgICAgICAgICAgdmVyc2lvbmVkSGFzaGVzLnB1c2goZ2V0VmVyc2lvbmVkSGFzaCgxLCBjb21taXRtZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jYmxvYnMgPSBibG9icztcbiAgICAgICAgdGhpcy4jYmxvYlZlcnNpb25lZEhhc2hlcyA9IHZlcnNpb25lZEhhc2hlcztcbiAgICB9XG4gICAgZ2V0IGt6ZygpIHsgcmV0dXJuIHRoaXMuI2t6ZzsgfVxuICAgIHNldCBremcoa3pnKSB7XG4gICAgICAgIGlmIChremcgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy4ja3pnID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI2t6ZyA9IGdldEt6Z0xpYnJhcnkoa3pnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgYmxvYldyYXBwZXJWZXJzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jYmxvYldyYXBwZXJWZXJzaW9uO1xuICAgIH1cbiAgICBzZXQgYmxvYldyYXBwZXJWZXJzaW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI2Jsb2JXcmFwcGVyVmVyc2lvbiA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBUcmFuc2FjdGlvbiB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLiN0eXBlID0gbnVsbDtcbiAgICAgICAgdGhpcy4jdG8gPSBudWxsO1xuICAgICAgICB0aGlzLiNub25jZSA9IDA7XG4gICAgICAgIHRoaXMuI2dhc0xpbWl0ID0gQk5fMDtcbiAgICAgICAgdGhpcy4jZ2FzUHJpY2UgPSBudWxsO1xuICAgICAgICB0aGlzLiNtYXhQcmlvcml0eUZlZVBlckdhcyA9IG51bGw7XG4gICAgICAgIHRoaXMuI21heEZlZVBlckdhcyA9IG51bGw7XG4gICAgICAgIHRoaXMuI2RhdGEgPSBcIjB4XCI7XG4gICAgICAgIHRoaXMuI3ZhbHVlID0gQk5fMDtcbiAgICAgICAgdGhpcy4jY2hhaW5JZCA9IEJOXzA7XG4gICAgICAgIHRoaXMuI3NpZyA9IG51bGw7XG4gICAgICAgIHRoaXMuI2FjY2Vzc0xpc3QgPSBudWxsO1xuICAgICAgICB0aGlzLiNtYXhGZWVQZXJCbG9iR2FzID0gbnVsbDtcbiAgICAgICAgdGhpcy4jYmxvYlZlcnNpb25lZEhhc2hlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuI2t6ZyA9IG51bGw7XG4gICAgICAgIHRoaXMuI2Jsb2JzID0gbnVsbDtcbiAgICAgICAgdGhpcy4jYXV0aHMgPSBudWxsO1xuICAgICAgICB0aGlzLiNibG9iV3JhcHBlclZlcnNpb24gPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIGhhc2gsIGlmIHNpZ25lZC4gT3RoZXJ3aXNlLCBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnZXQgaGFzaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmF0dXJlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZWNjYWsyNTYodGhpcy4jZ2V0U2VyaWFsaXplZCh0cnVlLCBmYWxzZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHByZS1pbWFnZSBoYXNoIG9mIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyB0aGUgZGlnZXN0IHRoYXQgYSBbW1NpZ25lcl1dIG11c3Qgc2lnbiB0byBhdXRob3JpemVcbiAgICAgKiAgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBnZXQgdW5zaWduZWRIYXNoKCkge1xuICAgICAgICByZXR1cm4ga2VjY2FrMjU2KHRoaXMudW5zaWduZWRTZXJpYWxpemVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBzZW5kaW5nIGFkZHJlc3MsIGlmIHNpZ25lZC4gT3RoZXJ3aXNlLCBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnZXQgZnJvbSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmF0dXJlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWNvdmVyQWRkcmVzcyh0aGlzLnVuc2lnbmVkSGFzaCwgdGhpcy5zaWduYXR1cmUuZ2V0Q2Fub25pY2FsKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHB1YmxpYyBrZXkgb2YgdGhlIHNlbmRlciwgaWYgc2lnbmVkLiBPdGhlcndpc2UsIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdldCBmcm9tUHVibGljS2V5KCkge1xuICAgICAgICBpZiAodGhpcy5zaWduYXR1cmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNpZ25pbmdLZXkucmVjb3ZlclB1YmxpY0tleSh0aGlzLnVuc2lnbmVkSGFzaCwgdGhpcy5zaWduYXR1cmUuZ2V0Q2Fub25pY2FsKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHNpZ25lZC5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHByb3BlcnRpZXMgcmVxdWlyaW5nIGEgc2lnbmVkXG4gICAgICogIHRyYW5zYWN0aW9uIGFyZSBub24tbnVsbC5cbiAgICAgKi9cbiAgICBpc1NpZ25lZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbmF0dXJlICE9IG51bGw7XG4gICAgfVxuICAgICNnZXRTZXJpYWxpemVkKHNpZ25lZCwgc2lkZWNhcikge1xuICAgICAgICBhc3NlcnQoIXNpZ25lZCB8fCB0aGlzLnNpZ25hdHVyZSAhPSBudWxsLCBcImNhbm5vdCBzZXJpYWxpemUgdW5zaWduZWQgdHJhbnNhY3Rpb247IG1heWJlIHlvdSBtZWFudCAudW5zaWduZWRTZXJpYWxpemVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcIi5zZXJpYWxpemVkXCIgfSk7XG4gICAgICAgIGNvbnN0IHNpZyA9IHNpZ25lZCA/IHRoaXMuc2lnbmF0dXJlIDogbnVsbDtcbiAgICAgICAgc3dpdGNoICh0aGlzLmluZmVyVHlwZSgpKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zZXJpYWxpemVMZWdhY3kodGhpcywgc2lnKTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZUVpcDI5MzAodGhpcywgc2lnKTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZUVpcDE1NTkodGhpcywgc2lnKTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZUVpcDQ4NDQodGhpcywgc2lnLCBzaWRlY2FyID8gdGhpcy5ibG9icyA6IG51bGwpO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHJldHVybiBfc2VyaWFsaXplRWlwNzcwMih0aGlzLCBzaWcpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJ1bnN1cHBvcnRlZCB0cmFuc2FjdGlvbiB0eXBlXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcIi5zZXJpYWxpemVkXCIgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgc2VyaWFsaXplZCB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIHRocm93cyBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgdW5zaWduZWQuIEZvciB0aGUgcHJlLWltYWdlLFxuICAgICAqICB1c2UgW1t1bnNpZ25lZFNlcmlhbGl6ZWRdXS5cbiAgICAgKi9cbiAgICBnZXQgc2VyaWFsaXplZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2dldFNlcmlhbGl6ZWQodHJ1ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdHJhbnNhY3Rpb24gcHJlLWltYWdlLlxuICAgICAqXG4gICAgICogIFRoZSBoYXNoIG9mIHRoaXMgaXMgdGhlIGRpZ2VzdCB3aGljaCBuZWVkcyB0byBiZSBzaWduZWQgdG9cbiAgICAgKiAgYXV0aG9yaXplIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgZ2V0IHVuc2lnbmVkU2VyaWFsaXplZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2dldFNlcmlhbGl6ZWQoZmFsc2UsIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgbW9zdCBcImxpa2VseVwiIHR5cGU7IGN1cnJlbnRseSB0aGUgaGlnaGVzdFxuICAgICAqICBzdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZS5cbiAgICAgKi9cbiAgICBpbmZlclR5cGUoKSB7XG4gICAgICAgIGNvbnN0IHR5cGVzID0gdGhpcy5pbmZlclR5cGVzKCk7XG4gICAgICAgIC8vIFByZWZlciBMb25kb24gKEVJUC0xNTU5KSBvdmVyIENhbmN1biAoQkxPYilcbiAgICAgICAgaWYgKHR5cGVzLmluZGV4T2YoMikgPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIHRoZSBoaWdoZXN0IGluZmVycmVkIHR5cGVcbiAgICAgICAgcmV0dXJuICh0eXBlcy5wb3AoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBWYWxpZGF0ZXMgdGhlIGV4cGxpY2l0IHByb3BlcnRpZXMgYW5kIHJldHVybnMgYSBsaXN0IG9mIGNvbXBhdGlibGVcbiAgICAgKiAgdHJhbnNhY3Rpb24gdHlwZXMuXG4gICAgICovXG4gICAgaW5mZXJUeXBlcygpIHtcbiAgICAgICAgLy8gQ2hlY2tzIHRoYXQgdGhlcmUgYXJlIG5vIGNvbmZsaWN0aW5nIHByb3BlcnRpZXMgc2V0XG4gICAgICAgIGNvbnN0IGhhc0dhc1ByaWNlID0gdGhpcy5nYXNQcmljZSAhPSBudWxsO1xuICAgICAgICBjb25zdCBoYXNGZWUgPSAodGhpcy5tYXhGZWVQZXJHYXMgIT0gbnVsbCB8fCB0aGlzLm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpO1xuICAgICAgICBjb25zdCBoYXNBY2Nlc3NMaXN0ID0gKHRoaXMuYWNjZXNzTGlzdCAhPSBudWxsKTtcbiAgICAgICAgY29uc3QgaGFzQmxvYiA9ICh0aGlzLiNtYXhGZWVQZXJCbG9iR2FzICE9IG51bGwgfHwgdGhpcy4jYmxvYlZlcnNpb25lZEhhc2hlcyk7XG4gICAgICAgIC8vaWYgKGhhc0dhc1ByaWNlICYmIGhhc0ZlZSkge1xuICAgICAgICAvLyAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cmFuc2FjdGlvbiBjYW5ub3QgaGF2ZSBnYXNQcmljZSBhbmQgbWF4RmVlUGVyR2FzXCIpO1xuICAgICAgICAvL31cbiAgICAgICAgaWYgKHRoaXMubWF4RmVlUGVyR2FzICE9IG51bGwgJiYgdGhpcy5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBhc3NlcnQodGhpcy5tYXhGZWVQZXJHYXMgPj0gdGhpcy5tYXhQcmlvcml0eUZlZVBlckdhcywgXCJwcmlvcml0eUZlZSBjYW5ub3QgYmUgbW9yZSB0aGFuIG1heEZlZVwiLCBcIkJBRF9EQVRBXCIsIHsgdmFsdWU6IHRoaXMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy9pZiAodGhpcy50eXBlID09PSAyICYmIGhhc0dhc1ByaWNlKSB7XG4gICAgICAgIC8vICAgIHRocm93IG5ldyBFcnJvcihcImVpcC0xNTU5IHRyYW5zYWN0aW9uIGNhbm5vdCBoYXZlIGdhc1ByaWNlXCIpO1xuICAgICAgICAvL31cbiAgICAgICAgYXNzZXJ0KCFoYXNGZWUgfHwgKHRoaXMudHlwZSAhPT0gMCAmJiB0aGlzLnR5cGUgIT09IDEpLCBcInRyYW5zYWN0aW9uIHR5cGUgY2Fubm90IGhhdmUgbWF4RmVlUGVyR2FzIG9yIG1heFByaW9yaXR5RmVlUGVyR2FzXCIsIFwiQkFEX0RBVEFcIiwgeyB2YWx1ZTogdGhpcyB9KTtcbiAgICAgICAgYXNzZXJ0KHRoaXMudHlwZSAhPT0gMCB8fCAhaGFzQWNjZXNzTGlzdCwgXCJsZWdhY3kgdHJhbnNhY3Rpb24gY2Fubm90IGhhdmUgYWNjZXNzTGlzdFwiLCBcIkJBRF9EQVRBXCIsIHsgdmFsdWU6IHRoaXMgfSk7XG4gICAgICAgIGNvbnN0IHR5cGVzID0gW107XG4gICAgICAgIC8vIEV4cGxpY2l0IHR5cGVcbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0eXBlcy5wdXNoKHRoaXMudHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hdXRob3JpemF0aW9uTGlzdCAmJiB0aGlzLmF1dGhvcml6YXRpb25MaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYXNGZWUpIHtcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzR2FzUHJpY2UpIHtcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDEpO1xuICAgICAgICAgICAgICAgIGlmICghaGFzQWNjZXNzTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc0FjY2Vzc0xpc3QpIHtcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDEpO1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYXNCbG9iICYmIHRoaXMudG8pIHtcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgwKTtcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDEpO1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMik7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0eXBlcy5zb3J0KCk7XG4gICAgICAgIHJldHVybiB0eXBlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHRyYW5zYWN0aW9uIGlzIGEgbGVnYWN5IHRyYW5zYWN0aW9uIChpLmUuXG4gICAgICogIGBgdHlwZSA9PT0gMGBgKS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoZSByZWxhdGVkIHByb3BlcnRpZXMgYXJlXG4gICAgICogIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGlzTGVnYWN5KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudHlwZSA9PT0gMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyB0cmFuc2FjdGlvbiBpcyBiZXJsaW4gaGFyZGZvcm0gdHJhbnNhY3Rpb24gKGkuZS5cbiAgICAgKiAgYGB0eXBlID09PSAxYGApLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgdGhlIHJlbGF0ZWQgcHJvcGVydGllcyBhcmVcbiAgICAgKiAgbm9uLW51bGwuXG4gICAgICovXG4gICAgaXNCZXJsaW4oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHRyYW5zYWN0aW9uIGlzIGxvbmRvbiBoYXJkZm9ybSB0cmFuc2FjdGlvbiAoaS5lLlxuICAgICAqICBgYHR5cGUgPT09IDJgYCkuXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgdGhhdCB0aGUgcmVsYXRlZCBwcm9wZXJ0aWVzIGFyZVxuICAgICAqICBub24tbnVsbC5cbiAgICAgKi9cbiAgICBpc0xvbmRvbigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IDIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgdHJhbnNhY3Rpb24gaXMgYW4gW1tsaW5rLWVpcC00ODQ0XV0gQkxPQlxuICAgICAqICB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoZSByZWxhdGVkIHByb3BlcnRpZXMgYXJlXG4gICAgICogIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGlzQ2FuY3VuKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudHlwZSA9PT0gMyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgdHJhbnNhY2l0b24uXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBUcmFuc2FjdGlvbi5mcm9tKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgSlNPTi1mcmllbmRseSBvYmplY3QuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCBzID0gKHYpID0+IHtcbiAgICAgICAgICAgIGlmICh2ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2LnRvU3RyaW5nKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICB0bzogdGhpcy50byxcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgZnJvbTogdGhpcy5mcm9tLFxuICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLFxuICAgICAgICAgICAgbm9uY2U6IHRoaXMubm9uY2UsXG4gICAgICAgICAgICBnYXNMaW1pdDogcyh0aGlzLmdhc0xpbWl0KSxcbiAgICAgICAgICAgIGdhc1ByaWNlOiBzKHRoaXMuZ2FzUHJpY2UpLFxuICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHModGhpcy5tYXhQcmlvcml0eUZlZVBlckdhcyksXG4gICAgICAgICAgICBtYXhGZWVQZXJHYXM6IHModGhpcy5tYXhGZWVQZXJHYXMpLFxuICAgICAgICAgICAgdmFsdWU6IHModGhpcy52YWx1ZSksXG4gICAgICAgICAgICBjaGFpbklkOiBzKHRoaXMuY2hhaW5JZCksXG4gICAgICAgICAgICBzaWc6IHRoaXMuc2lnbmF0dXJlID8gdGhpcy5zaWduYXR1cmUudG9KU09OKCkgOiBudWxsLFxuICAgICAgICAgICAgYWNjZXNzTGlzdDogdGhpcy5hY2Nlc3NMaXN0XG4gICAgICAgIH07XG4gICAgfVxuICAgIFtpbnNwZWN0XSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IFtdO1xuICAgICAgICBjb25zdCBhZGQgPSAoa2V5KSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSB0aGlzW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHB1dC5wdXNoKGAke2tleX06ICR7dmFsdWV9YCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGFkZChcInR5cGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgYWRkKFwidG9cIik7XG4gICAgICAgIGFkZChcImRhdGFcIik7XG4gICAgICAgIGFkZChcIm5vbmNlXCIpO1xuICAgICAgICBhZGQoXCJnYXNMaW1pdFwiKTtcbiAgICAgICAgYWRkKFwidmFsdWVcIik7XG4gICAgICAgIGlmICh0aGlzLmNoYWluSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgYWRkKFwiY2hhaW5JZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zaWduYXR1cmUpIHtcbiAgICAgICAgICAgIGFkZChcImZyb21cIik7XG4gICAgICAgICAgICBvdXRwdXQucHVzaChgc2lnbmF0dXJlOiAke3RoaXMuc2lnbmF0dXJlLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQFRPRE86IGFjY2Vzc0xpc3RcbiAgICAgICAgLy8gQFRPRE86IGJsb2JzIChtaWdodCBtYWtlIG91dHB1dCBodWdlOyBtYXliZSBqdXN0IGluY2x1ZGUgYSBmbGFnPylcbiAgICAgICAgY29uc3QgYXV0aHMgPSB0aGlzLmF1dGhvcml6YXRpb25MaXN0O1xuICAgICAgICBpZiAoYXV0aHMpIHtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dEF1dGhzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGF1dGggb2YgYXV0aHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvID0gW107XG4gICAgICAgICAgICAgICAgby5wdXNoKGBhZGRyZXNzOiAke0pTT04uc3RyaW5naWZ5KGF1dGguYWRkcmVzcyl9YCk7XG4gICAgICAgICAgICAgICAgaWYgKGF1dGgubm9uY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBvLnB1c2goYG5vbmNlOiAke2F1dGgubm9uY2V9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhdXRoLmNoYWluSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBvLnB1c2goYGNoYWluSWQ6ICR7YXV0aC5jaGFpbklkfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXV0aC5zaWduYXR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgby5wdXNoKGBzaWduYXR1cmU6ICR7YXV0aC5zaWduYXR1cmUudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0cHV0QXV0aHMucHVzaChgQXV0aG9yaXphdGlvbiB7ICR7by5qb2luKFwiLCBcIil9IH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHB1dC5wdXNoKGBhdXRob3JpemF0aW9uczogWyAke291dHB1dEF1dGhzLmpvaW4oXCIsIFwiKX0gXWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgVHJhbnNhY3Rpb24geyAke291dHB1dC5qb2luKFwiLCBcIil9IH1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgKipUcmFuc2FjdGlvbioqIGZyb20gYSBzZXJpYWxpemVkIHRyYW5zYWN0aW9uIG9yIGFcbiAgICAgKiAgVHJhbnNhY3Rpb24tbGlrZSBvYmplY3QuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20odHgpIHtcbiAgICAgICAgaWYgKHR4ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mICh0eCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBnZXRCeXRlcyh0eCk7XG4gICAgICAgICAgICBpZiAocGF5bG9hZFswXSA+PSAweDdmKSB7IC8vIEBUT0RPOiA+IHZzID49ID8/XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uLmZyb20oX3BhcnNlTGVnYWN5KHBheWxvYWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAocGF5bG9hZFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFRyYW5zYWN0aW9uLmZyb20oX3BhcnNlRWlwMjkzMChwYXlsb2FkKSk7XG4gICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gVHJhbnNhY3Rpb24uZnJvbShfcGFyc2VFaXAxNTU5KHBheWxvYWQpKTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBUcmFuc2FjdGlvbi5mcm9tKF9wYXJzZUVpcDQ4NDQocGF5bG9hZCkpO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFRyYW5zYWN0aW9uLmZyb20oX3BhcnNlRWlwNzcwMihwYXlsb2FkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJmcm9tXCIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgICAgIGlmICh0eC50eXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC50eXBlID0gdHgudHlwZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHgudG8gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LnRvID0gdHgudG87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4Lm5vbmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5ub25jZSA9IHR4Lm5vbmNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5nYXNMaW1pdCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuZ2FzTGltaXQgPSB0eC5nYXNMaW1pdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguZ2FzUHJpY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0Lmdhc1ByaWNlID0gdHguZ2FzUHJpY2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5tYXhQcmlvcml0eUZlZVBlckdhcyA9IHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5tYXhGZWVQZXJHYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0Lm1heEZlZVBlckdhcyA9IHR4Lm1heEZlZVBlckdhcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHgubWF4RmVlUGVyQmxvYkdhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQubWF4RmVlUGVyQmxvYkdhcyA9IHR4Lm1heEZlZVBlckJsb2JHYXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LmRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LmRhdGEgPSB0eC5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQudmFsdWUgPSB0eC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguY2hhaW5JZCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuY2hhaW5JZCA9IHR4LmNoYWluSWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LnNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb20odHguc2lnbmF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguYWNjZXNzTGlzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuYWNjZXNzTGlzdCA9IHR4LmFjY2Vzc0xpc3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LmF1dGhvcml6YXRpb25MaXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hdXRob3JpemF0aW9uTGlzdCA9IHR4LmF1dGhvcml6YXRpb25MaXN0O1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgd2lsbCBnZXQgb3ZlcndyaXR0ZW4gYnkgYmxvYnMsIGlmIHByZXNlbnRcbiAgICAgICAgaWYgKHR4LmJsb2JWZXJzaW9uZWRIYXNoZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LmJsb2JWZXJzaW9uZWRIYXNoZXMgPSB0eC5ibG9iVmVyc2lvbmVkSGFzaGVzO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBhc3NpZ24gdGhlIGt6ZyBiZWZvcmUgYXNzaWduaW5nIGJsb2JzLCB3aGljaFxuICAgICAgICAvLyByZXF1aXJlIHRoZSBsaWJyYXJ5IGluIHRoZSBldmVudCByYXcgYmxvYiBkYXRhIGlzIHByb3ZpZGVkLlxuICAgICAgICBpZiAodHgua3pnICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5remcgPSB0eC5remc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LmJsb2JXcmFwcGVyVmVyc2lvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuYmxvYldyYXBwZXJWZXJzaW9uID0gdHguYmxvYldyYXBwZXJWZXJzaW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5ibG9icyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuYmxvYnMgPSB0eC5ibG9icztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguaGFzaCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChyZXN1bHQuaXNTaWduZWQoKSwgXCJ1bnNpZ25lZCB0cmFuc2FjdGlvbiBjYW5ub3QgZGVmaW5lICcuaGFzaCdcIiwgXCJ0eFwiLCB0eCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChyZXN1bHQuaGFzaCA9PT0gdHguaGFzaCwgXCJoYXNoIG1pc21hdGNoXCIsIFwidHhcIiwgdHgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5mcm9tICE9IG51bGwpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHJlc3VsdC5pc1NpZ25lZCgpLCBcInVuc2lnbmVkIHRyYW5zYWN0aW9uIGNhbm5vdCBkZWZpbmUgJy5mcm9tJ1wiLCBcInR4XCIsIHR4KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHJlc3VsdC5mcm9tLnRvTG93ZXJDYXNlKCkgPT09ICh0eC5mcm9tIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCksIFwiZnJvbSBtaXNtYXRjaFwiLCBcInR4XCIsIHR4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zYWN0aW9uLmpzLm1hcCJdLCJuYW1lcyI6WyJnZXRBZGRyZXNzIiwiWmVyb0FkZHJlc3MiLCJrZWNjYWsyNTYiLCJzaGEyNTYiLCJTaWduYXR1cmUiLCJTaWduaW5nS2V5IiwiY29uY2F0IiwiZGVjb2RlUmxwIiwiZW5jb2RlUmxwIiwiZ2V0Qnl0ZXMiLCJnZXRCaWdJbnQiLCJnZXROdW1iZXIiLCJoZXhsaWZ5IiwiYXNzZXJ0IiwiYXNzZXJ0QXJndW1lbnQiLCJpc0J5dGVzTGlrZSIsImlzSGV4U3RyaW5nIiwidG9CZUFycmF5IiwiemVyb1BhZFZhbHVlIiwiYWNjZXNzTGlzdGlmeSIsImF1dGhvcml6YXRpb25pZnkiLCJyZWNvdmVyQWRkcmVzcyIsIkJOXzAiLCJCaWdJbnQiLCJCTl8yIiwiQk5fMjciLCJCTl8yOCIsIkJOXzM1IiwiQk5fTUFYX1VJTlQiLCJpbnNwZWN0IiwiU3ltYm9sIiwiZm9yIiwiQkxPQl9TSVpFIiwiQ0VMTF9DT1VOVCIsInNwbGl0QmxvYkNlbGxzIiwiX3Byb29mIiwiY2VsbENvdW50IiwiY2VsbFByb29mcyIsInByb29mIiwiY2VsbFNpemUiLCJsZW5ndGgiLCJpIiwicHVzaCIsInN1YmFycmF5IiwiZ2V0S3pnTGlicmFyeSIsImt6ZyIsImJsb2JUb0t6Z0NvbW1pdG1lbnQiLCJibG9iIiwiYmxvYlRvS1pHQ29tbWl0bWVudCIsImNvbXB1dGVCbG9iS3pnUHJvb2YiLCJjb21taXRtZW50IiwiY29tcHV0ZUJsb2JQcm9vZiIsImNvbXB1dGVCbG9iS1pHUHJvb2YiLCJnZXRWZXJzaW9uZWRIYXNoIiwidmVyc2lvbiIsImhhc2giLCJ2ZXJzaW9uZWQiLCJ0b1N0cmluZyIsInN1YnN0cmluZyIsImhhbmRsZUFkZHJlc3MiLCJ2YWx1ZSIsImhhbmRsZUFjY2Vzc0xpc3QiLCJwYXJhbSIsImVycm9yIiwibWVzc2FnZSIsImhhbmRsZUF1dGhvcml6YXRpb25MaXN0IiwiQXJyYXkiLCJpc0FycmF5IiwiRXJyb3IiLCJyZXN1bHQiLCJhdXRoIiwiYWRkcmVzcyIsIm5vbmNlIiwiaGFuZGxlVWludCIsImNoYWluSWQiLCJzaWduYXR1cmUiLCJmcm9tIiwieVBhcml0eSIsImhhbmRsZU51bWJlciIsInIiLCJzIiwiX3ZhbHVlIiwiZm9ybWF0TnVtYmVyIiwibmFtZSIsImZvcm1hdEFjY2Vzc0xpc3QiLCJtYXAiLCJzZXQiLCJzdG9yYWdlS2V5cyIsImZvcm1hdEF1dGhvcml6YXRpb25MaXN0IiwiYSIsIl9zIiwiZm9ybWF0SGFzaGVzIiwiX3BhcnNlTGVnYWN5IiwiZGF0YSIsImZpZWxkcyIsInR4IiwidHlwZSIsImdhc1ByaWNlIiwiZ2FzTGltaXQiLCJ0byIsInYiLCJfc2VyaWFsaXplTGVnYWN5Iiwic2lnIiwibmV0d29ya1YiLCJsZWdhY3lDaGFpbklkIiwibGVnYWN5IiwiZ2V0Q2hhaW5JZFYiLCJfcGFyc2VFaXBTaWduYXR1cmUiLCJfcGFyc2VFaXAxNTU5Iiwic2xpY2UiLCJtYXhQcmlvcml0eUZlZVBlckdhcyIsIm1heEZlZVBlckdhcyIsImFjY2Vzc0xpc3QiLCJfc2VyaWFsaXplRWlwMTU1OSIsIl9wYXJzZUVpcDI5MzAiLCJfc2VyaWFsaXplRWlwMjkzMCIsIl9wYXJzZUVpcDQ4NDQiLCJ0eXBlTmFtZSIsImJsb2JXcmFwcGVyVmVyc2lvbiIsImJsb2JzIiwiZkJsb2JzIiwiZkNvbW1pdHMiLCJmUHJvb2ZzIiwiaiIsIm1heEZlZVBlckJsb2JHYXMiLCJibG9iVmVyc2lvbmVkSGFzaGVzIiwiX3NlcmlhbGl6ZUVpcDQ4NDQiLCJ3cmFwcGVyVmVyc2lvbiIsInAiLCJiIiwiX3BhcnNlRWlwNzcwMiIsImF1dGhvcml6YXRpb25MaXN0IiwiX3NlcmlhbGl6ZUVpcDc3MDIiLCJUcmFuc2FjdGlvbiIsImlzVmFsaWQiLCJhdXRocyIsIk9iamVjdCIsImFzc2lnbiIsIl9ibG9icyIsInZlcnNpb25lZEhhc2hlcyIsIm9wZXJhdGlvbiIsInBhZGRlZCIsIlVpbnQ4QXJyYXkiLCJjb21taXQiLCJnZXRTZXJpYWxpemVkIiwidW5zaWduZWRIYXNoIiwidW5zaWduZWRTZXJpYWxpemVkIiwiZ2V0Q2Fub25pY2FsIiwiZnJvbVB1YmxpY0tleSIsInJlY292ZXJQdWJsaWNLZXkiLCJpc1NpZ25lZCIsInNlcmlhbGl6ZWQiLCJpbmZlclR5cGUiLCJ0eXBlcyIsImluZmVyVHlwZXMiLCJpbmRleE9mIiwicG9wIiwiaGFzR2FzUHJpY2UiLCJoYXNGZWUiLCJoYXNBY2Nlc3NMaXN0IiwiaGFzQmxvYiIsInNvcnQiLCJpc0xlZ2FjeSIsImlzQmVybGluIiwiaXNMb25kb24iLCJpc0NhbmN1biIsImNsb25lIiwidG9KU09OIiwib3V0cHV0IiwiYWRkIiwia2V5IiwiSlNPTiIsInN0cmluZ2lmeSIsIm91dHB1dEF1dGhzIiwibyIsImpvaW4iLCJwYXlsb2FkIiwidG9Mb3dlckNhc2UiLCJjb25zdHJ1Y3RvciIsInNpZ25lZCIsInNpZGVjYXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/transaction/transaction.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/utils/base58.js":
/*!*****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/base58.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeBase58: function() { return /* binding */ decodeBase58; },\n/* harmony export */   encodeBase58: function() { return /* binding */ encodeBase58; }\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _maths_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./maths.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/**\n *  The [Base58 Encoding](link-base58) scheme allows a **numeric** value\n *  to be encoded as a compact string using a radix of 58 using only\n *  alpha-numeric characters. Confusingly similar characters are omitted\n *  (i.e. ``\"l0O\"``).\n *\n *  Note that Base58 encodes a **numeric** value, not arbitrary bytes,\n *  since any zero-bytes on the left would get removed. To mitigate this\n *  issue most schemes that use Base58 choose specific high-order values\n *  to ensure non-zero prefixes.\n *\n *  @_subsection: api/utils:Base58 Encoding [about-base58]\n */ \n\n\nconst Alphabet = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nlet Lookup = null;\nfunction getAlpha(letter) {\n    if (Lookup == null) {\n        Lookup = {};\n        for(let i = 0; i < Alphabet.length; i++){\n            Lookup[Alphabet[i]] = BigInt(i);\n        }\n    }\n    const result = Lookup[letter];\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(result != null, \"invalid base58 value\", \"letter\", letter);\n    return result;\n}\nconst BN_0 = BigInt(0);\nconst BN_58 = BigInt(58);\n/**\n *  Encode %%value%% as a Base58-encoded string.\n */ function encodeBase58(_value) {\n    const bytes = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_value);\n    let value = (0,_maths_js__WEBPACK_IMPORTED_MODULE_2__.toBigInt)(bytes);\n    let result = \"\";\n    while(value){\n        result = Alphabet[Number(value % BN_58)] + result;\n        value /= BN_58;\n    }\n    // Account for leading padding zeros\n    for(let i = 0; i < bytes.length; i++){\n        if (bytes[i]) {\n            break;\n        }\n        result = Alphabet[0] + result;\n    }\n    return result;\n}\n/**\n *  Decode the Base58-encoded %%value%%.\n */ function decodeBase58(value) {\n    let result = BN_0;\n    for(let i = 0; i < value.length; i++){\n        result *= BN_58;\n        result += getAlpha(value[i]);\n    }\n    return result;\n} //# sourceMappingURL=base58.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9iYXNlNTguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7O0NBWUMsR0FDb0M7QUFDUTtBQUNQO0FBQ3RDLE1BQU1HLFdBQVc7QUFDakIsSUFBSUMsU0FBUztBQUNiLFNBQVNDLFNBQVNDLE1BQU07SUFDcEIsSUFBSUYsVUFBVSxNQUFNO1FBQ2hCQSxTQUFTLENBQUM7UUFDVixJQUFLLElBQUlHLElBQUksR0FBR0EsSUFBSUosU0FBU0ssTUFBTSxFQUFFRCxJQUFLO1lBQ3RDSCxNQUFNLENBQUNELFFBQVEsQ0FBQ0ksRUFBRSxDQUFDLEdBQUdFLE9BQU9GO1FBQ2pDO0lBQ0o7SUFDQSxNQUFNRyxTQUFTTixNQUFNLENBQUNFLE9BQU87SUFDN0JMLDBEQUFjQSxDQUFDUyxVQUFVLE1BQU8sd0JBQXVCLFVBQVVKO0lBQ2pFLE9BQU9JO0FBQ1g7QUFDQSxNQUFNQyxPQUFPRixPQUFPO0FBQ3BCLE1BQU1HLFFBQVFILE9BQU87QUFDckI7O0NBRUMsR0FDTSxTQUFTSSxhQUFhQyxNQUFNO0lBQy9CLE1BQU1DLFFBQVFmLGtEQUFRQSxDQUFDYztJQUN2QixJQUFJRSxRQUFRZCxtREFBUUEsQ0FBQ2E7SUFDckIsSUFBSUwsU0FBUztJQUNiLE1BQU9NLE1BQU87UUFDVk4sU0FBU1AsUUFBUSxDQUFDYyxPQUFPRCxRQUFRSixPQUFPLEdBQUdGO1FBQzNDTSxTQUFTSjtJQUNiO0lBQ0Esb0NBQW9DO0lBQ3BDLElBQUssSUFBSUwsSUFBSSxHQUFHQSxJQUFJUSxNQUFNUCxNQUFNLEVBQUVELElBQUs7UUFDbkMsSUFBSVEsS0FBSyxDQUFDUixFQUFFLEVBQUU7WUFDVjtRQUNKO1FBQ0FHLFNBQVNQLFFBQVEsQ0FBQyxFQUFFLEdBQUdPO0lBQzNCO0lBQ0EsT0FBT0E7QUFDWDtBQUNBOztDQUVDLEdBQ00sU0FBU1EsYUFBYUYsS0FBSztJQUM5QixJQUFJTixTQUFTQztJQUNiLElBQUssSUFBSUosSUFBSSxHQUFHQSxJQUFJUyxNQUFNUixNQUFNLEVBQUVELElBQUs7UUFDbkNHLFVBQVVFO1FBQ1ZGLFVBQVVMLFNBQVNXLEtBQUssQ0FBQ1QsRUFBRTtJQUMvQjtJQUNBLE9BQU9HO0FBQ1gsRUFDQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL2Jhc2U1OC5qcz9jNGQyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIFRoZSBbQmFzZTU4IEVuY29kaW5nXShsaW5rLWJhc2U1OCkgc2NoZW1lIGFsbG93cyBhICoqbnVtZXJpYyoqIHZhbHVlXG4gKiAgdG8gYmUgZW5jb2RlZCBhcyBhIGNvbXBhY3Qgc3RyaW5nIHVzaW5nIGEgcmFkaXggb2YgNTggdXNpbmcgb25seVxuICogIGFscGhhLW51bWVyaWMgY2hhcmFjdGVycy4gQ29uZnVzaW5nbHkgc2ltaWxhciBjaGFyYWN0ZXJzIGFyZSBvbWl0dGVkXG4gKiAgKGkuZS4gYGBcImwwT1wiYGApLlxuICpcbiAqICBOb3RlIHRoYXQgQmFzZTU4IGVuY29kZXMgYSAqKm51bWVyaWMqKiB2YWx1ZSwgbm90IGFyYml0cmFyeSBieXRlcyxcbiAqICBzaW5jZSBhbnkgemVyby1ieXRlcyBvbiB0aGUgbGVmdCB3b3VsZCBnZXQgcmVtb3ZlZC4gVG8gbWl0aWdhdGUgdGhpc1xuICogIGlzc3VlIG1vc3Qgc2NoZW1lcyB0aGF0IHVzZSBCYXNlNTggY2hvb3NlIHNwZWNpZmljIGhpZ2gtb3JkZXIgdmFsdWVzXG4gKiAgdG8gZW5zdXJlIG5vbi16ZXJvIHByZWZpeGVzLlxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS91dGlsczpCYXNlNTggRW5jb2RpbmcgW2Fib3V0LWJhc2U1OF1cbiAqL1xuaW1wb3J0IHsgZ2V0Qnl0ZXMgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5pbXBvcnQgeyBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IHsgdG9CaWdJbnQgfSBmcm9tIFwiLi9tYXRocy5qc1wiO1xuY29uc3QgQWxwaGFiZXQgPSBcIjEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpcIjtcbmxldCBMb29rdXAgPSBudWxsO1xuZnVuY3Rpb24gZ2V0QWxwaGEobGV0dGVyKSB7XG4gICAgaWYgKExvb2t1cCA9PSBudWxsKSB7XG4gICAgICAgIExvb2t1cCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEFscGhhYmV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBMb29rdXBbQWxwaGFiZXRbaV1dID0gQmlnSW50KGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IExvb2t1cFtsZXR0ZXJdO1xuICAgIGFzc2VydEFyZ3VtZW50KHJlc3VsdCAhPSBudWxsLCBgaW52YWxpZCBiYXNlNTggdmFsdWVgLCBcImxldHRlclwiLCBsZXR0ZXIpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuY29uc3QgQk5fNTggPSBCaWdJbnQoNTgpO1xuLyoqXG4gKiAgRW5jb2RlICUldmFsdWUlJSBhcyBhIEJhc2U1OC1lbmNvZGVkIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUJhc2U1OChfdmFsdWUpIHtcbiAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKF92YWx1ZSk7XG4gICAgbGV0IHZhbHVlID0gdG9CaWdJbnQoYnl0ZXMpO1xuICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgIHdoaWxlICh2YWx1ZSkge1xuICAgICAgICByZXN1bHQgPSBBbHBoYWJldFtOdW1iZXIodmFsdWUgJSBCTl81OCldICsgcmVzdWx0O1xuICAgICAgICB2YWx1ZSAvPSBCTl81ODtcbiAgICB9XG4gICAgLy8gQWNjb3VudCBmb3IgbGVhZGluZyBwYWRkaW5nIHplcm9zXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYnl0ZXNbaV0pIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IEFscGhhYmV0WzBdICsgcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiAgRGVjb2RlIHRoZSBCYXNlNTgtZW5jb2RlZCAlJXZhbHVlJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVCYXNlNTgodmFsdWUpIHtcbiAgICBsZXQgcmVzdWx0ID0gQk5fMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCAqPSBCTl81ODtcbiAgICAgICAgcmVzdWx0ICs9IGdldEFscGhhKHZhbHVlW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2U1OC5qcy5tYXAiXSwibmFtZXMiOlsiZ2V0Qnl0ZXMiLCJhc3NlcnRBcmd1bWVudCIsInRvQmlnSW50IiwiQWxwaGFiZXQiLCJMb29rdXAiLCJnZXRBbHBoYSIsImxldHRlciIsImkiLCJsZW5ndGgiLCJCaWdJbnQiLCJyZXN1bHQiLCJCTl8wIiwiQk5fNTgiLCJlbmNvZGVCYXNlNTgiLCJfdmFsdWUiLCJieXRlcyIsInZhbHVlIiwiTnVtYmVyIiwiZGVjb2RlQmFzZTU4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/utils/base58.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/utils/base64-browser.js":
/*!*************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/base64-browser.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeBase64: function() { return /* binding */ decodeBase64; },\n/* harmony export */   encodeBase64: function() { return /* binding */ encodeBase64; }\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n// utils/base64-browser\n\nfunction decodeBase64(textData) {\n    textData = atob(textData);\n    const data = new Uint8Array(textData.length);\n    for(let i = 0; i < textData.length; i++){\n        data[i] = textData.charCodeAt(i);\n    }\n    return (0,_data_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(data);\n}\nfunction encodeBase64(_data) {\n    const data = (0,_data_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(_data);\n    let textData = \"\";\n    for(let i = 0; i < data.length; i++){\n        textData += String.fromCharCode(data[i]);\n    }\n    return btoa(textData);\n} //# sourceMappingURL=base64-browser.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9iYXNlNjQtYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSx1QkFBdUI7QUFDYztBQUM5QixTQUFTQyxhQUFhQyxRQUFRO0lBQ2pDQSxXQUFXQyxLQUFLRDtJQUNoQixNQUFNRSxPQUFPLElBQUlDLFdBQVdILFNBQVNJLE1BQU07SUFDM0MsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlMLFNBQVNJLE1BQU0sRUFBRUMsSUFBSztRQUN0Q0gsSUFBSSxDQUFDRyxFQUFFLEdBQUdMLFNBQVNNLFVBQVUsQ0FBQ0Q7SUFDbEM7SUFDQSxPQUFPUCxrREFBUUEsQ0FBQ0k7QUFDcEI7QUFDTyxTQUFTSyxhQUFhQyxLQUFLO0lBQzlCLE1BQU1OLE9BQU9KLGtEQUFRQSxDQUFDVTtJQUN0QixJQUFJUixXQUFXO0lBQ2YsSUFBSyxJQUFJSyxJQUFJLEdBQUdBLElBQUlILEtBQUtFLE1BQU0sRUFBRUMsSUFBSztRQUNsQ0wsWUFBWVMsT0FBT0MsWUFBWSxDQUFDUixJQUFJLENBQUNHLEVBQUU7SUFDM0M7SUFDQSxPQUFPTSxLQUFLWDtBQUNoQixFQUNBLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvYmFzZTY0LWJyb3dzZXIuanM/ZTk1YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB1dGlscy9iYXNlNjQtYnJvd3NlclxuaW1wb3J0IHsgZ2V0Qnl0ZXMgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQmFzZTY0KHRleHREYXRhKSB7XG4gICAgdGV4dERhdGEgPSBhdG9iKHRleHREYXRhKTtcbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodGV4dERhdGEubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHREYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRhdGFbaV0gPSB0ZXh0RGF0YS5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0Qnl0ZXMoZGF0YSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlQmFzZTY0KF9kYXRhKSB7XG4gICAgY29uc3QgZGF0YSA9IGdldEJ5dGVzKF9kYXRhKTtcbiAgICBsZXQgdGV4dERhdGEgPSBcIlwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0ZXh0RGF0YSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gYnRvYSh0ZXh0RGF0YSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlNjQtYnJvd3Nlci5qcy5tYXAiXSwibmFtZXMiOlsiZ2V0Qnl0ZXMiLCJkZWNvZGVCYXNlNjQiLCJ0ZXh0RGF0YSIsImF0b2IiLCJkYXRhIiwiVWludDhBcnJheSIsImxlbmd0aCIsImkiLCJjaGFyQ29kZUF0IiwiZW5jb2RlQmFzZTY0IiwiX2RhdGEiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJidG9hIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/utils/base64-browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js":
/*!***************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/data.js ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   concat: function() { return /* binding */ concat; },\n/* harmony export */   dataLength: function() { return /* binding */ dataLength; },\n/* harmony export */   dataSlice: function() { return /* binding */ dataSlice; },\n/* harmony export */   getBytes: function() { return /* binding */ getBytes; },\n/* harmony export */   getBytesCopy: function() { return /* binding */ getBytesCopy; },\n/* harmony export */   hexlify: function() { return /* binding */ hexlify; },\n/* harmony export */   isBytesLike: function() { return /* binding */ isBytesLike; },\n/* harmony export */   isHexString: function() { return /* binding */ isHexString; },\n/* harmony export */   stripZerosLeft: function() { return /* binding */ stripZerosLeft; },\n/* harmony export */   zeroPadBytes: function() { return /* binding */ zeroPadBytes; },\n/* harmony export */   zeroPadValue: function() { return /* binding */ zeroPadValue; }\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/**\n *  Some data helpers.\n *\n *\n *  @_subsection api/utils:Data Helpers  [about-data]\n */ \nfunction _getBytes(value, name, copy) {\n    if (value instanceof Uint8Array) {\n        if (copy) {\n            return new Uint8Array(value);\n        }\n        return value;\n    }\n    if (typeof value === \"string\" && value.length % 2 === 0 && value.match(/^0x[0-9a-f]*$/i)) {\n        const result = new Uint8Array((value.length - 2) / 2);\n        let offset = 2;\n        for(let i = 0; i < result.length; i++){\n            result[i] = parseInt(value.substring(offset, offset + 2), 16);\n            offset += 2;\n        }\n        return result;\n    }\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid BytesLike value\", name || \"value\", value);\n}\n/**\n *  Get a typed Uint8Array for %%value%%. If already a Uint8Array\n *  the original %%value%% is returned; if a copy is required use\n *  [[getBytesCopy]].\n *\n *  @see: getBytesCopy\n */ function getBytes(value, name) {\n    return _getBytes(value, name, false);\n}\n/**\n *  Get a typed Uint8Array for %%value%%, creating a copy if necessary\n *  to prevent any modifications of the returned value from being\n *  reflected elsewhere.\n *\n *  @see: getBytes\n */ function getBytesCopy(value, name) {\n    return _getBytes(value, name, true);\n}\n/**\n *  Returns true if %%value%% is a valid [[HexString]].\n *\n *  If %%length%% is ``true`` or a //number//, it also checks that\n *  %%value%% is a valid [[DataHexString]] of %%length%% (if a //number//)\n *  bytes of data (e.g. ``0x1234`` is 2 bytes).\n */ function isHexString(value, length) {\n    if (typeof value !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false;\n    }\n    if (typeof length === \"number\" && value.length !== 2 + 2 * length) {\n        return false;\n    }\n    if (length === true && value.length % 2 !== 0) {\n        return false;\n    }\n    return true;\n}\n/**\n *  Returns true if %%value%% is a valid representation of arbitrary\n *  data (i.e. a valid [[DataHexString]] or a Uint8Array).\n */ function isBytesLike(value) {\n    return isHexString(value, true) || value instanceof Uint8Array;\n}\nconst HexCharacters = \"0123456789abcdef\";\n/**\n *  Returns a [[DataHexString]] representation of %%data%%.\n */ function hexlify(data) {\n    const bytes = getBytes(data);\n    let result = \"0x\";\n    for(let i = 0; i < bytes.length; i++){\n        const v = bytes[i];\n        result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n    }\n    return result;\n}\n/**\n *  Returns a [[DataHexString]] by concatenating all values\n *  within %%data%%.\n */ function concat(datas) {\n    return \"0x\" + datas.map((d)=>hexlify(d).substring(2)).join(\"\");\n}\n/**\n *  Returns the length of %%data%%, in bytes.\n */ function dataLength(data) {\n    if (isHexString(data, true)) {\n        return (data.length - 2) / 2;\n    }\n    return getBytes(data).length;\n}\n/**\n *  Returns a [[DataHexString]] by slicing %%data%% from the %%start%%\n *  offset to the %%end%% offset.\n *\n *  By default %%start%% is 0 and %%end%% is the length of %%data%%.\n */ function dataSlice(data, start, end) {\n    const bytes = getBytes(data);\n    if (end != null && end > bytes.length) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"cannot slice beyond data bounds\", \"BUFFER_OVERRUN\", {\n            buffer: bytes,\n            length: bytes.length,\n            offset: end\n        });\n    }\n    return hexlify(bytes.slice(start == null ? 0 : start, end == null ? bytes.length : end));\n}\n/**\n *  Return the [[DataHexString]] result by stripping all **leading**\n ** zero bytes from %%data%%.\n */ function stripZerosLeft(data) {\n    let bytes = hexlify(data).substring(2);\n    while(bytes.startsWith(\"00\")){\n        bytes = bytes.substring(2);\n    }\n    return \"0x\" + bytes;\n}\nfunction zeroPad(data, length, left) {\n    const bytes = getBytes(data);\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(length >= bytes.length, \"padding exceeds data length\", \"BUFFER_OVERRUN\", {\n        buffer: new Uint8Array(bytes),\n        length: length,\n        offset: length + 1\n    });\n    const result = new Uint8Array(length);\n    result.fill(0);\n    if (left) {\n        result.set(bytes, length - bytes.length);\n    } else {\n        result.set(bytes, 0);\n    }\n    return hexlify(result);\n}\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **left**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **values** are in Solidity\n *  (e.g. ``uint128``).\n */ function zeroPadValue(data, length) {\n    return zeroPad(data, length, true);\n}\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **right**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **bytes** are in Solidity\n *  (e.g. ``bytes16``).\n */ function zeroPadBytes(data, length) {\n    return zeroPad(data, length, false);\n} //# sourceMappingURL=data.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9kYXRhLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7OztDQUtDLEdBQ29EO0FBQ3JELFNBQVNFLFVBQVVDLEtBQUssRUFBRUMsSUFBSSxFQUFFQyxJQUFJO0lBQ2hDLElBQUlGLGlCQUFpQkcsWUFBWTtRQUM3QixJQUFJRCxNQUFNO1lBQ04sT0FBTyxJQUFJQyxXQUFXSDtRQUMxQjtRQUNBLE9BQU9BO0lBQ1g7SUFDQSxJQUFJLE9BQVFBLFVBQVcsWUFBWSxNQUFPSSxNQUFNLEdBQUcsTUFBTyxLQUN0REosTUFBTUssS0FBSyxDQUFDLG1CQUFtQjtRQUMvQixNQUFNQyxTQUFTLElBQUlILFdBQVcsQ0FBQ0gsTUFBTUksTUFBTSxHQUFHLEtBQUs7UUFDbkQsSUFBSUcsU0FBUztRQUNiLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRixPQUFPRixNQUFNLEVBQUVJLElBQUs7WUFDcENGLE1BQU0sQ0FBQ0UsRUFBRSxHQUFHQyxTQUFTVCxNQUFNVSxTQUFTLENBQUNILFFBQVFBLFNBQVMsSUFBSTtZQUMxREEsVUFBVTtRQUNkO1FBQ0EsT0FBT0Q7SUFDWDtJQUNBUiwwREFBY0EsQ0FBQyxPQUFPLDJCQUEyQkcsUUFBUSxTQUFTRDtBQUN0RTtBQUNBOzs7Ozs7Q0FNQyxHQUNNLFNBQVNXLFNBQVNYLEtBQUssRUFBRUMsSUFBSTtJQUNoQyxPQUFPRixVQUFVQyxPQUFPQyxNQUFNO0FBQ2xDO0FBQ0E7Ozs7OztDQU1DLEdBQ00sU0FBU1csYUFBYVosS0FBSyxFQUFFQyxJQUFJO0lBQ3BDLE9BQU9GLFVBQVVDLE9BQU9DLE1BQU07QUFDbEM7QUFDQTs7Ozs7O0NBTUMsR0FDTSxTQUFTWSxZQUFZYixLQUFLLEVBQUVJLE1BQU07SUFDckMsSUFBSSxPQUFRSixVQUFXLFlBQVksQ0FBQ0EsTUFBTUssS0FBSyxDQUFDLHFCQUFxQjtRQUNqRSxPQUFPO0lB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LFFBQVE7QUFDakMsRUFDQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL2RhdGEuanM/YzY4YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBTb21lIGRhdGEgaGVscGVycy5cbiAqXG4gKlxuICogIEBfc3Vic2VjdGlvbiBhcGkvdXRpbHM6RGF0YSBIZWxwZXJzICBbYWJvdXQtZGF0YV1cbiAqL1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuZnVuY3Rpb24gX2dldEJ5dGVzKHZhbHVlLCBuYW1lLCBjb3B5KSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICBpZiAoY29weSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiAmJiAodmFsdWUubGVuZ3RoICUgMikgPT09IDAgJiZcbiAgICAgICAgdmFsdWUubWF0Y2goL14weFswLTlhLWZdKiQvaSkpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoKHZhbHVlLmxlbmd0aCAtIDIpIC8gMik7XG4gICAgICAgIGxldCBvZmZzZXQgPSAyO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0W2ldID0gcGFyc2VJbnQodmFsdWUuc3Vic3RyaW5nKG9mZnNldCwgb2Zmc2V0ICsgMiksIDE2KTtcbiAgICAgICAgICAgIG9mZnNldCArPSAyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgQnl0ZXNMaWtlIHZhbHVlXCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG59XG4vKipcbiAqICBHZXQgYSB0eXBlZCBVaW50OEFycmF5IGZvciAlJXZhbHVlJSUuIElmIGFscmVhZHkgYSBVaW50OEFycmF5XG4gKiAgdGhlIG9yaWdpbmFsICUldmFsdWUlJSBpcyByZXR1cm5lZDsgaWYgYSBjb3B5IGlzIHJlcXVpcmVkIHVzZVxuICogIFtbZ2V0Qnl0ZXNDb3B5XV0uXG4gKlxuICogIEBzZWU6IGdldEJ5dGVzQ29weVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Qnl0ZXModmFsdWUsIG5hbWUpIHtcbiAgICByZXR1cm4gX2dldEJ5dGVzKHZhbHVlLCBuYW1lLCBmYWxzZSk7XG59XG4vKipcbiAqICBHZXQgYSB0eXBlZCBVaW50OEFycmF5IGZvciAlJXZhbHVlJSUsIGNyZWF0aW5nIGEgY29weSBpZiBuZWNlc3NhcnlcbiAqICB0byBwcmV2ZW50IGFueSBtb2RpZmljYXRpb25zIG9mIHRoZSByZXR1cm5lZCB2YWx1ZSBmcm9tIGJlaW5nXG4gKiAgcmVmbGVjdGVkIGVsc2V3aGVyZS5cbiAqXG4gKiAgQHNlZTogZ2V0Qnl0ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJ5dGVzQ29weSh2YWx1ZSwgbmFtZSkge1xuICAgIHJldHVybiBfZ2V0Qnl0ZXModmFsdWUsIG5hbWUsIHRydWUpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhIHZhbGlkIFtbSGV4U3RyaW5nXV0uXG4gKlxuICogIElmICUlbGVuZ3RoJSUgaXMgYGB0cnVlYGAgb3IgYSAvL251bWJlci8vLCBpdCBhbHNvIGNoZWNrcyB0aGF0XG4gKiAgJSV2YWx1ZSUlIGlzIGEgdmFsaWQgW1tEYXRhSGV4U3RyaW5nXV0gb2YgJSVsZW5ndGglJSAoaWYgYSAvL251bWJlci8vKVxuICogIGJ5dGVzIG9mIGRhdGEgKGUuZy4gYGAweDEyMzRgYCBpcyAyIGJ5dGVzKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSGV4U3RyaW5nKHZhbHVlLCBsZW5ndGgpIHtcbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwic3RyaW5nXCIgfHwgIXZhbHVlLm1hdGNoKC9eMHhbMC05QS1GYS1mXSokLykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChsZW5ndGgpID09PSBcIm51bWJlclwiICYmIHZhbHVlLmxlbmd0aCAhPT0gMiArIDIgKiBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoID09PSB0cnVlICYmICh2YWx1ZS5sZW5ndGggJSAyKSAhPT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhIHZhbGlkIHJlcHJlc2VudGF0aW9uIG9mIGFyYml0cmFyeVxuICogIGRhdGEgKGkuZS4gYSB2YWxpZCBbW0RhdGFIZXhTdHJpbmddXSBvciBhIFVpbnQ4QXJyYXkpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNCeXRlc0xpa2UodmFsdWUpIHtcbiAgICByZXR1cm4gKGlzSGV4U3RyaW5nKHZhbHVlLCB0cnVlKSB8fCAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSk7XG59XG5jb25zdCBIZXhDaGFyYWN0ZXJzID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG4vKipcbiAqICBSZXR1cm5zIGEgW1tEYXRhSGV4U3RyaW5nXV0gcmVwcmVzZW50YXRpb24gb2YgJSVkYXRhJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhsaWZ5KGRhdGEpIHtcbiAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKGRhdGEpO1xuICAgIGxldCByZXN1bHQgPSBcIjB4XCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB2ID0gYnl0ZXNbaV07XG4gICAgICAgIHJlc3VsdCArPSBIZXhDaGFyYWN0ZXJzWyh2ICYgMHhmMCkgPj4gNF0gKyBIZXhDaGFyYWN0ZXJzW3YgJiAweDBmXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogIFJldHVybnMgYSBbW0RhdGFIZXhTdHJpbmddXSBieSBjb25jYXRlbmF0aW5nIGFsbCB2YWx1ZXNcbiAqICB3aXRoaW4gJSVkYXRhJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXQoZGF0YXMpIHtcbiAgICByZXR1cm4gXCIweFwiICsgZGF0YXMubWFwKChkKSA9PiBoZXhsaWZ5KGQpLnN1YnN0cmluZygyKSkuam9pbihcIlwiKTtcbn1cbi8qKlxuICogIFJldHVybnMgdGhlIGxlbmd0aCBvZiAlJWRhdGElJSwgaW4gYnl0ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkYXRhTGVuZ3RoKGRhdGEpIHtcbiAgICBpZiAoaXNIZXhTdHJpbmcoZGF0YSwgdHJ1ZSkpIHtcbiAgICAgICAgcmV0dXJuIChkYXRhLmxlbmd0aCAtIDIpIC8gMjtcbiAgICB9XG4gICAgcmV0dXJuIGdldEJ5dGVzKGRhdGEpLmxlbmd0aDtcbn1cbi8qKlxuICogIFJldHVybnMgYSBbW0RhdGFIZXhTdHJpbmddXSBieSBzbGljaW5nICUlZGF0YSUlIGZyb20gdGhlICUlc3RhcnQlJVxuICogIG9mZnNldCB0byB0aGUgJSVlbmQlJSBvZmZzZXQuXG4gKlxuICogIEJ5IGRlZmF1bHQgJSVzdGFydCUlIGlzIDAgYW5kICUlZW5kJSUgaXMgdGhlIGxlbmd0aCBvZiAlJWRhdGElJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRhdGFTbGljZShkYXRhLCBzdGFydCwgZW5kKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyhkYXRhKTtcbiAgICBpZiAoZW5kICE9IG51bGwgJiYgZW5kID4gYnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJjYW5ub3Qgc2xpY2UgYmV5b25kIGRhdGEgYm91bmRzXCIsIFwiQlVGRkVSX09WRVJSVU5cIiwge1xuICAgICAgICAgICAgYnVmZmVyOiBieXRlcywgbGVuZ3RoOiBieXRlcy5sZW5ndGgsIG9mZnNldDogZW5kXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gaGV4bGlmeShieXRlcy5zbGljZSgoc3RhcnQgPT0gbnVsbCkgPyAwIDogc3RhcnQsIChlbmQgPT0gbnVsbCkgPyBieXRlcy5sZW5ndGggOiBlbmQpKTtcbn1cbi8qKlxuICogIFJldHVybiB0aGUgW1tEYXRhSGV4U3RyaW5nXV0gcmVzdWx0IGJ5IHN0cmlwcGluZyBhbGwgKipsZWFkaW5nKipcbiAqKiB6ZXJvIGJ5dGVzIGZyb20gJSVkYXRhJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpcFplcm9zTGVmdChkYXRhKSB7XG4gICAgbGV0IGJ5dGVzID0gaGV4bGlmeShkYXRhKS5zdWJzdHJpbmcoMik7XG4gICAgd2hpbGUgKGJ5dGVzLnN0YXJ0c1dpdGgoXCIwMFwiKSkge1xuICAgICAgICBieXRlcyA9IGJ5dGVzLnN1YnN0cmluZygyKTtcbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIGJ5dGVzO1xufVxuZnVuY3Rpb24gemVyb1BhZChkYXRhLCBsZW5ndGgsIGxlZnQpIHtcbiAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKGRhdGEpO1xuICAgIGFzc2VydChsZW5ndGggPj0gYnl0ZXMubGVuZ3RoLCBcInBhZGRpbmcgZXhjZWVkcyBkYXRhIGxlbmd0aFwiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHtcbiAgICAgICAgYnVmZmVyOiBuZXcgVWludDhBcnJheShieXRlcyksXG4gICAgICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgICAgICBvZmZzZXQ6IGxlbmd0aCArIDFcbiAgICB9KTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIHJlc3VsdC5maWxsKDApO1xuICAgIGlmIChsZWZ0KSB7XG4gICAgICAgIHJlc3VsdC5zZXQoYnl0ZXMsIGxlbmd0aCAtIGJ5dGVzLmxlbmd0aCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQuc2V0KGJ5dGVzLCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleGxpZnkocmVzdWx0KTtcbn1cbi8qKlxuICogIFJldHVybiB0aGUgW1tEYXRhSGV4U3RyaW5nXV0gb2YgJSVkYXRhJSUgcGFkZGVkIG9uIHRoZSAqKmxlZnQqKlxuICogIHRvICUlbGVuZ3RoJSUgYnl0ZXMuXG4gKlxuICogIElmICUlZGF0YSUlIGFscmVhZHkgZXhjZWVkcyAlJWxlbmd0aCUlLCBhIFtbQnVmZmVyT3ZlcnJ1bkVycm9yXV0gaXNcbiAqICB0aHJvd24uXG4gKlxuICogIFRoaXMgcGFkcyBkYXRhIHRoZSBzYW1lIGFzICoqdmFsdWVzKiogYXJlIGluIFNvbGlkaXR5XG4gKiAgKGUuZy4gYGB1aW50MTI4YGApLlxuICovXG5leHBvcnQgZnVuY3Rpb24gemVyb1BhZFZhbHVlKGRhdGEsIGxlbmd0aCkge1xuICAgIHJldHVybiB6ZXJvUGFkKGRhdGEsIGxlbmd0aCwgdHJ1ZSk7XG59XG4vKipcbiAqICBSZXR1cm4gdGhlIFtbRGF0YUhleFN0cmluZ11dIG9mICUlZGF0YSUlIHBhZGRlZCBvbiB0aGUgKipyaWdodCoqXG4gKiAgdG8gJSVsZW5ndGglJSBieXRlcy5cbiAqXG4gKiAgSWYgJSVkYXRhJSUgYWxyZWFkeSBleGNlZWRzICUlbGVuZ3RoJSUsIGEgW1tCdWZmZXJPdmVycnVuRXJyb3JdXSBpc1xuICogIHRocm93bi5cbiAqXG4gKiAgVGhpcyBwYWRzIGRhdGEgdGhlIHNhbWUgYXMgKipieXRlcyoqIGFyZSBpbiBTb2xpZGl0eVxuICogIChlLmcuIGBgYnl0ZXMxNmBgKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHplcm9QYWRCeXRlcyhkYXRhLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gemVyb1BhZChkYXRhLCBsZW5ndGgsIGZhbHNlKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGEuanMubWFwIl0sIm5hbWVzIjpbImFzc2VydCIsImFzc2VydEFyZ3VtZW50IiwiX2dldEJ5dGVzIiwidmFsdWUiLCJuYW1lIiwiY29weSIsIlVpbnQ4QXJyYXkiLCJsZW5ndGgiLCJtYXRjaCIsInJlc3VsdCIsIm9mZnNldCIsImkiLCJwYXJzZUludCIsInN1YnN0cmluZyIsImdldEJ5dGVzIiwiZ2V0Qnl0ZXNDb3B5IiwiaXNIZXhTdHJpbmciLCJpc0J5dGVzTGlrZSIsIkhleENoYXJhY3RlcnMiLCJoZXhsaWZ5IiwiZGF0YSIsImJ5dGVzIiwidiIsImNvbmNhdCIsImRhdGFzIiwibWFwIiwiZCIsImpvaW4iLCJkYXRhTGVuZ3RoIiwiZGF0YVNsaWNlIiwic3RhcnQiLCJlbmQiLCJidWZmZXIiLCJzbGljZSIsInN0cmlwWmVyb3NMZWZ0Iiwic3RhcnRzV2l0aCIsInplcm9QYWQiLCJsZWZ0IiwiZmlsbCIsInNldCIsInplcm9QYWRWYWx1ZSIsInplcm9QYWRCeXRlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/utils/errors.js":
/*!*****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/errors.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assert: function() { return /* binding */ assert; },\n/* harmony export */   assertArgument: function() { return /* binding */ assertArgument; },\n/* harmony export */   assertArgumentCount: function() { return /* binding */ assertArgumentCount; },\n/* harmony export */   assertNormalize: function() { return /* binding */ assertNormalize; },\n/* harmony export */   assertPrivate: function() { return /* binding */ assertPrivate; },\n/* harmony export */   isCallException: function() { return /* binding */ isCallException; },\n/* harmony export */   isError: function() { return /* binding */ isError; },\n/* harmony export */   makeError: function() { return /* binding */ makeError; }\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_version.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/_version.js\");\n/* harmony import */ var _properties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./properties.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/**\n *  All errors in ethers include properties to ensure they are both\n *  human-readable (i.e. ``.message``) and machine-readable (i.e. ``.code``).\n *\n *  The [[isError]] function can be used to check the error ``code`` and\n *  provide a type guard for the properties present on that error interface.\n *\n *  @_section: api/utils/errors:Errors  [about-errors]\n */ \n\nfunction stringify(value, seen) {\n    if (value == null) {\n        return \"null\";\n    }\n    if (seen == null) {\n        seen = new Set();\n    }\n    if (typeof value === \"object\") {\n        if (seen.has(value)) {\n            return \"[Circular]\";\n        }\n        seen.add(value);\n    }\n    if (Array.isArray(value)) {\n        return \"[ \" + value.map((v)=>stringify(v, seen)).join(\", \") + \" ]\";\n    }\n    if (value instanceof Uint8Array) {\n        const HEX = \"0123456789abcdef\";\n        let result = \"0x\";\n        for(let i = 0; i < value.length; i++){\n            result += HEX[value[i] >> 4];\n            result += HEX[value[i] & 0xf];\n        }\n        return result;\n    }\n    if (typeof value === \"object\" && typeof value.toJSON === \"function\") {\n        return stringify(value.toJSON(), seen);\n    }\n    switch(typeof value){\n        case \"boolean\":\n        case \"number\":\n        case \"symbol\":\n            return value.toString();\n        case \"bigint\":\n            return BigInt(value).toString();\n        case \"string\":\n            return JSON.stringify(value);\n        case \"object\":\n            {\n                const keys = Object.keys(value);\n                keys.sort();\n                return \"{ \" + keys.map((k)=>\"\".concat(stringify(k, seen), \": \").concat(stringify(value[k], seen))).join(\", \") + \" }\";\n            }\n    }\n    return \"[ COULD NOT SERIALIZE ]\";\n}\n/**\n *  Returns true if the %%error%% matches an error thrown by ethers\n *  that matches the error %%code%%.\n *\n *  In TypeScript environments, this can be used to check that %%error%%\n *  matches an EthersError type, which means the expected properties will\n *  be set.\n *\n *  @See [ErrorCodes](api:ErrorCode)\n *  @example\n *    try {\n *      // code....\n *    } catch (e) {\n *      if (isError(e, \"CALL_EXCEPTION\")) {\n *          // The Type Guard has validated this object\n *          console.log(e.data);\n *      }\n *    }\n */ function isError(error, code) {\n    return error && error.code === code;\n}\n/**\n *  Returns true if %%error%% is a [[CallExceptionError].\n */ function isCallException(error) {\n    return isError(error, \"CALL_EXCEPTION\");\n}\n/**\n *  Returns a new Error configured to the format ethers emits errors, with\n *  the %%message%%, [[api:ErrorCode]] %%code%% and additional properties\n *  for the corresponding EthersError.\n *\n *  Each error in ethers includes the version of ethers, a\n *  machine-readable [[ErrorCode]], and depending on %%code%%, additional\n *  required properties. The error message will also include the %%message%%,\n *  ethers version, %%code%% and all additional properties, serialized.\n */ function makeError(message, code, info) {\n    let shortMessage = message;\n    {\n        const details = [];\n        if (info) {\n            if (\"message\" in info || \"code\" in info || \"name\" in info) {\n                throw new Error(\"value will overwrite populated values: \".concat(stringify(info)));\n            }\n            for(const key in info){\n                if (key === \"shortMessage\") {\n                    continue;\n                }\n                const value = info[key];\n                //                try {\n                details.push(key + \"=\" + stringify(value));\n            //                } catch (error: any) {\n            //                console.log(\"MMM\", error.message);\n            //                    details.push(key + \"=[could not serialize object]\");\n            //                }\n            }\n        }\n        details.push(\"code=\".concat(code));\n        details.push(\"version=\".concat(_version_js__WEBPACK_IMPORTED_MODULE_0__.version));\n        if (details.length) {\n            message += \" (\" + details.join(\", \") + \")\";\n        }\n    }\n    let error;\n    switch(code){\n        case \"INVALID_ARGUMENT\":\n            error = new TypeError(message);\n            break;\n        case \"NUMERIC_FAULT\":\n        case \"BUFFER_OVERRUN\":\n            error = new RangeError(message);\n            break;\n        default:\n            error = new Error(message);\n    }\n    (0,_properties_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(error, {\n        code\n    });\n    if (info) {\n        Object.assign(error, info);\n    }\n    if (error.shortMessage == null) {\n        (0,_properties_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(error, {\n            shortMessage\n        });\n    }\n    return error;\n}\n/**\n *  Throws an EthersError with %%message%%, %%code%% and additional error\n *  %%info%% when %%check%% is falsish..\n *\n *  @see [[api:makeError]]\n */ function assert(check, message, code, info) {\n    if (!check) {\n        throw makeError(message, code, info);\n    }\n}\n/**\n *  A simple helper to simply ensuring provided arguments match expected\n *  constraints, throwing if not.\n *\n *  In TypeScript environments, the %%check%% has been asserted true, so\n *  any further code does not need additional compile-time checks.\n */ function assertArgument(check, message, name, value) {\n    assert(check, message, \"INVALID_ARGUMENT\", {\n        argument: name,\n        value: value\n    });\n}\nfunction assertArgumentCount(count, expectedCount, message) {\n    if (message == null) {\n        message = \"\";\n    }\n    if (message) {\n        message = \": \" + message;\n    }\n    assert(count >= expectedCount, \"missing argument\" + message, \"MISSING_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n    assert(count <= expectedCount, \"too many arguments\" + message, \"UNEXPECTED_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n}\nconst _normalizeForms = [\n    \"NFD\",\n    \"NFC\",\n    \"NFKD\",\n    \"NFKC\"\n].reduce((accum, form)=>{\n    try {\n        // General test for normalize\n        /* c8 ignore start */ if (\"test\".normalize(form) !== \"test\") {\n            throw new Error(\"bad\");\n        }\n        ;\n        /* c8 ignore stop */ if (form === \"NFD\") {\n            const check = String.fromCharCode(0xe9).normalize(\"NFD\");\n            const expected = String.fromCharCode(0x65, 0x0301);\n            /* c8 ignore start */ if (check !== expected) {\n                throw new Error(\"broken\");\n            }\n        /* c8 ignore stop */ }\n        accum.push(form);\n    } catch (error) {}\n    return accum;\n}, []);\n/**\n *  Throws if the normalization %%form%% is not supported.\n */ function assertNormalize(form) {\n    assert(_normalizeForms.indexOf(form) >= 0, \"platform missing String.prototype.normalize\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"String.prototype.normalize\",\n        info: {\n            form\n        }\n    });\n}\n/**\n *  Many classes use file-scoped values to guard the constructor,\n *  making it effectively private. This facilitates that pattern\n *  by ensuring the %%givenGaurd%% matches the file-scoped %%guard%%,\n *  throwing if not, indicating the %%className%% if provided.\n */ function assertPrivate(givenGuard, guard, className) {\n    if (className == null) {\n        className = \"\";\n    }\n    if (givenGuard !== guard) {\n        let method = className, operation = \"new\";\n        if (className) {\n            method += \".\";\n            operation += \" \" + className;\n        }\n        assert(false, \"private constructor; use \".concat(method, \"from* methods\"), \"UNSUPPORTED_OPERATION\", {\n            operation\n        });\n    }\n} //# sourceMappingURL=errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9lcnJvcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7OztDQVFDLEdBQ3dDO0FBQ1U7QUFDbkQsU0FBU0UsVUFBVUMsS0FBSyxFQUFFQyxJQUFJO0lBQzFCLElBQUlELFNBQVMsTUFBTTtRQUNmLE9BQU87SUFDWDtJQUNBLElBQUlDLFFBQVEsTUFBTTtRQUNkQSxPQUFPLElBQUlDO0lBQ2Y7SUFDQSxJQUFJLE9BQVFGLFVBQVcsVUFBVTtRQUM3QixJQUFJQyxLQUFLRSxHQUFHLENBQUNILFFBQVE7WUFDakIsT0FBTztRQUNYO1FBQ0FDLEtBQUtHLEdBQUcsQ0FBQ0o7SUFDYjtJQUNBLElBQUlLLE1BQU1DLE9BQU8sQ0FBQ04sUUFBUTtRQUN0QixPQUFPLE9BQU8sTUFBT08sR0FBRyxDQUFDLENBQUNDLElBQU1ULFVBQVVTLEdBQUdQLE9BQVFRLElBQUksQ0FBQyxRQUFRO0lBQ3RFO0lBQ0EsSUFBSVQsaUJBQWlCVSxZQUFZO1FBQzdCLE1BQU1DLE1BQU07UUFDWixJQUFJQyxTQUFTO1FBQ2IsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUliLE1BQU1jLE1BQU0sRUFBRUQsSUFBSztZQUNuQ0QsVUFBVUQsR0FBRyxDQUFDWCxLQUFLLENBQUNhLEVBQUUsSUFBSSxFQUFFO1lBQzVCRCxVQUFVRCxHQUFHLENBQUNYLEtBQUssQ0FBQ2EsRUFBRSxHQUFHLElBQUk7UUFDakM7UUFDQSxPQUFPRDtJQUNYO0lBQ0EsSUFBSSxPQUFRWixVQUFXLFlBQVksT0FBUUEsTUFBTWUsTUFBTSxLQUFNLFlBQVk7UUFDckUsT0FBT2hCLFVBQVVDLE1BQU1lLE1BQU0sSUFBSWQ7SUFDckM7SUFDQSxPQUFRLE9BQVFEO1FBQ1osS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0QsT0FBT0EsTUFBTWdCLFFBQVE7UUFDekIsS0FBSztZQUNELE9BQU9DLE9BQU9q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LFdBQVc7WUFDWEMsVUFBVTtZQUNWTCxhQUFhLE1BQU1JO1FBQ3ZCO1FBQ0F0QixPQUFPLE9BQU8sNEJBQW1DLE9BQVB1QixRQUFPLGtCQUFnQix5QkFBeUI7WUFDdEZMO1FBQ0o7SUFDSjtBQUNKLEVBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9lcnJvcnMuanM/ODY2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBBbGwgZXJyb3JzIGluIGV0aGVycyBpbmNsdWRlIHByb3BlcnRpZXMgdG8gZW5zdXJlIHRoZXkgYXJlIGJvdGhcbiAqICBodW1hbi1yZWFkYWJsZSAoaS5lLiBgYC5tZXNzYWdlYGApIGFuZCBtYWNoaW5lLXJlYWRhYmxlIChpLmUuIGBgLmNvZGVgYCkuXG4gKlxuICogIFRoZSBbW2lzRXJyb3JdXSBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byBjaGVjayB0aGUgZXJyb3IgYGBjb2RlYGAgYW5kXG4gKiAgcHJvdmlkZSBhIHR5cGUgZ3VhcmQgZm9yIHRoZSBwcm9wZXJ0aWVzIHByZXNlbnQgb24gdGhhdCBlcnJvciBpbnRlcmZhY2UuXG4gKlxuICogIEBfc2VjdGlvbjogYXBpL3V0aWxzL2Vycm9yczpFcnJvcnMgIFthYm91dC1lcnJvcnNdXG4gKi9cbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi4vX3ZlcnNpb24uanNcIjtcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMgfSBmcm9tIFwiLi9wcm9wZXJ0aWVzLmpzXCI7XG5mdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUsIHNlZW4pIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgfVxuICAgIGlmIChzZWVuID09IG51bGwpIHtcbiAgICAgICAgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmIChzZWVuLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBcIltDaXJjdWxhcl1cIjtcbiAgICAgICAgfVxuICAgICAgICBzZWVuLmFkZCh2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gXCJbIFwiICsgKHZhbHVlLm1hcCgodikgPT4gc3RyaW5naWZ5KHYsIHNlZW4pKSkuam9pbihcIiwgXCIpICsgXCIgXVwiO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIGNvbnN0IEhFWCA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCIweFwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gSEVYW3ZhbHVlW2ldID4+IDRdO1xuICAgICAgICAgICAgcmVzdWx0ICs9IEhFWFt2YWx1ZVtpXSAmIDB4Zl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiAodmFsdWUudG9KU09OKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnkodmFsdWUudG9KU09OKCksIHNlZW4pO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGVvZiAodmFsdWUpKSB7XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpLnRvU3RyaW5nKCk7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjoge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICAgICAgICAgIGtleXMuc29ydCgpO1xuICAgICAgICAgICAgcmV0dXJuIFwieyBcIiArIGtleXMubWFwKChrKSA9PiBgJHtzdHJpbmdpZnkoaywgc2Vlbil9OiAke3N0cmluZ2lmeSh2YWx1ZVtrXSwgc2Vlbil9YCkuam9pbihcIiwgXCIpICsgXCIgfVwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBgWyBDT1VMRCBOT1QgU0VSSUFMSVpFIF1gO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0cnVlIGlmIHRoZSAlJWVycm9yJSUgbWF0Y2hlcyBhbiBlcnJvciB0aHJvd24gYnkgZXRoZXJzXG4gKiAgdGhhdCBtYXRjaGVzIHRoZSBlcnJvciAlJWNvZGUlJS5cbiAqXG4gKiAgSW4gVHlwZVNjcmlwdCBlbnZpcm9ubWVudHMsIHRoaXMgY2FuIGJlIHVzZWQgdG8gY2hlY2sgdGhhdCAlJWVycm9yJSVcbiAqICBtYXRjaGVzIGFuIEV0aGVyc0Vycm9yIHR5cGUsIHdoaWNoIG1lYW5zIHRoZSBleHBlY3RlZCBwcm9wZXJ0aWVzIHdpbGxcbiAqICBiZSBzZXQuXG4gKlxuICogIEBTZWUgW0Vycm9yQ29kZXNdKGFwaTpFcnJvckNvZGUpXG4gKiAgQGV4YW1wbGVcbiAqICAgIHRyeSB7XG4gKiAgICAgIC8vIGNvZGUuLi4uXG4gKiAgICB9IGNhdGNoIChlKSB7XG4gKiAgICAgIGlmIChpc0Vycm9yKGUsIFwiQ0FMTF9FWENFUFRJT05cIikpIHtcbiAqICAgICAgICAgIC8vIFRoZSBUeXBlIEd1YXJkIGhhcyB2YWxpZGF0ZWQgdGhpcyBvYmplY3RcbiAqICAgICAgICAgIGNvbnNvbGUubG9nKGUuZGF0YSk7XG4gKiAgICAgIH1cbiAqICAgIH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRXJyb3IoZXJyb3IsIGNvZGUpIHtcbiAgICByZXR1cm4gKGVycm9yICYmIGVycm9yLmNvZGUgPT09IGNvZGUpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0cnVlIGlmICUlZXJyb3IlJSBpcyBhIFtbQ2FsbEV4Y2VwdGlvbkVycm9yXS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ2FsbEV4Y2VwdGlvbihlcnJvcikge1xuICAgIHJldHVybiBpc0Vycm9yKGVycm9yLCBcIkNBTExfRVhDRVBUSU9OXCIpO1xufVxuLyoqXG4gKiAgUmV0dXJucyBhIG5ldyBFcnJvciBjb25maWd1cmVkIHRvIHRoZSBmb3JtYXQgZXRoZXJzIGVtaXRzIGVycm9ycywgd2l0aFxuICogIHRoZSAlJW1lc3NhZ2UlJSwgW1thcGk6RXJyb3JDb2RlXV0gJSVjb2RlJSUgYW5kIGFkZGl0aW9uYWwgcHJvcGVydGllc1xuICogIGZvciB0aGUgY29ycmVzcG9uZGluZyBFdGhlcnNFcnJvci5cbiAqXG4gKiAgRWFjaCBlcnJvciBpbiBldGhlcnMgaW5jbHVkZXMgdGhlIHZlcnNpb24gb2YgZXRoZXJzLCBhXG4gKiAgbWFjaGluZS1yZWFkYWJsZSBbW0Vycm9yQ29kZV1dLCBhbmQgZGVwZW5kaW5nIG9uICUlY29kZSUlLCBhZGRpdGlvbmFsXG4gKiAgcmVxdWlyZWQgcHJvcGVydGllcy4gVGhlIGVycm9yIG1lc3NhZ2Ugd2lsbCBhbHNvIGluY2x1ZGUgdGhlICUlbWVzc2FnZSUlLFxuICogIGV0aGVycyB2ZXJzaW9uLCAlJWNvZGUlJSBhbmQgYWxsIGFkZGl0aW9uYWwgcHJvcGVydGllcywgc2VyaWFsaXplZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VFcnJvcihtZXNzYWdlLCBjb2RlLCBpbmZvKSB7XG4gICAgbGV0IHNob3J0TWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAge1xuICAgICAgICBjb25zdCBkZXRhaWxzID0gW107XG4gICAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgICAgICBpZiAoXCJtZXNzYWdlXCIgaW4gaW5mbyB8fCBcImNvZGVcIiBpbiBpbmZvIHx8IFwibmFtZVwiIGluIGluZm8pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHZhbHVlIHdpbGwgb3ZlcndyaXRlIHBvcHVsYXRlZCB2YWx1ZXM6ICR7c3RyaW5naWZ5KGluZm8pfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gaW5mbykge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwic2hvcnRNZXNzYWdlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gKGluZm9ba2V5XSk7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkZXRhaWxzLnB1c2goa2V5ICsgXCI9XCIgKyBzdHJpbmdpZnkodmFsdWUpKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJNTU1cIiwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgIGRldGFpbHMucHVzaChrZXkgKyBcIj1bY291bGQgbm90IHNlcmlhbGl6ZSBvYmplY3RdXCIpO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZXRhaWxzLnB1c2goYGNvZGU9JHtjb2RlfWApO1xuICAgICAgICBkZXRhaWxzLnB1c2goYHZlcnNpb249JHt2ZXJzaW9ufWApO1xuICAgICAgICBpZiAoZGV0YWlscy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgKFwiICsgZGV0YWlscy5qb2luKFwiLCBcIikgKyBcIilcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgZXJyb3I7XG4gICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgIGNhc2UgXCJJTlZBTElEX0FSR1VNRU5UXCI6XG4gICAgICAgICAgICBlcnJvciA9IG5ldyBUeXBlRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIk5VTUVSSUNfRkFVTFRcIjpcbiAgICAgICAgY2FzZSBcIkJVRkZFUl9PVkVSUlVOXCI6XG4gICAgICAgICAgICBlcnJvciA9IG5ldyBSYW5nZUVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgZGVmaW5lUHJvcGVydGllcyhlcnJvciwgeyBjb2RlIH0pO1xuICAgIGlmIChpbmZvKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oZXJyb3IsIGluZm8pO1xuICAgIH1cbiAgICBpZiAoZXJyb3Iuc2hvcnRNZXNzYWdlID09IG51bGwpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyhlcnJvciwgeyBzaG9ydE1lc3NhZ2UgfSk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcjtcbn1cbi8qKlxuICogIFRocm93cyBhbiBFdGhlcnNFcnJvciB3aXRoICUlbWVzc2FnZSUlLCAlJWNvZGUlJSBhbmQgYWRkaXRpb25hbCBlcnJvclxuICogICUlaW5mbyUlIHdoZW4gJSVjaGVjayUlIGlzIGZhbHNpc2guLlxuICpcbiAqICBAc2VlIFtbYXBpOm1ha2VFcnJvcl1dXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQoY2hlY2ssIG1lc3NhZ2UsIGNvZGUsIGluZm8pIHtcbiAgICBpZiAoIWNoZWNrKSB7XG4gICAgICAgIHRocm93IG1ha2VFcnJvcihtZXNzYWdlLCBjb2RlLCBpbmZvKTtcbiAgICB9XG59XG4vKipcbiAqICBBIHNpbXBsZSBoZWxwZXIgdG8gc2ltcGx5IGVuc3VyaW5nIHByb3ZpZGVkIGFyZ3VtZW50cyBtYXRjaCBleHBlY3RlZFxuICogIGNvbnN0cmFpbnRzLCB0aHJvd2luZyBpZiBub3QuXG4gKlxuICogIEluIFR5cGVTY3JpcHQgZW52aXJvbm1lbnRzLCB0aGUgJSVjaGVjayUlIGhhcyBiZWVuIGFzc2VydGVkIHRydWUsIHNvXG4gKiAgYW55IGZ1cnRoZXIgY29kZSBkb2VzIG5vdCBuZWVkIGFkZGl0aW9uYWwgY29tcGlsZS10aW1lIGNoZWNrcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEFyZ3VtZW50KGNoZWNrLCBtZXNzYWdlLCBuYW1lLCB2YWx1ZSkge1xuICAgIGFzc2VydChjaGVjaywgbWVzc2FnZSwgXCJJTlZBTElEX0FSR1VNRU5UXCIsIHsgYXJndW1lbnQ6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRBcmd1bWVudENvdW50KGNvdW50LCBleHBlY3RlZENvdW50LCBtZXNzYWdlKSB7XG4gICAgaWYgKG1lc3NhZ2UgPT0gbnVsbCkge1xuICAgICAgICBtZXNzYWdlID0gXCJcIjtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgbWVzc2FnZSA9IFwiOiBcIiArIG1lc3NhZ2U7XG4gICAgfVxuICAgIGFzc2VydChjb3VudCA+PSBleHBlY3RlZENvdW50LCBcIm1pc3NpbmcgYXJndW1lbnRcIiArIG1lc3NhZ2UsIFwiTUlTU0lOR19BUkdVTUVOVFwiLCB7XG4gICAgICAgIGNvdW50OiBjb3VudCxcbiAgICAgICAgZXhwZWN0ZWRDb3VudDogZXhwZWN0ZWRDb3VudFxuICAgIH0pO1xuICAgIGFzc2VydChjb3VudCA8PSBleHBlY3RlZENvdW50LCBcInRvbyBtYW55IGFyZ3VtZW50c1wiICsgbWVzc2FnZSwgXCJVTkVYUEVDVEVEX0FSR1VNRU5UXCIsIHtcbiAgICAgICAgY291bnQ6IGNvdW50LFxuICAgICAgICBleHBlY3RlZENvdW50OiBleHBlY3RlZENvdW50XG4gICAgfSk7XG59XG5jb25zdCBfbm9ybWFsaXplRm9ybXMgPSBbXCJORkRcIiwgXCJORkNcIiwgXCJORktEXCIsIFwiTkZLQ1wiXS5yZWR1Y2UoKGFjY3VtLCBmb3JtKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gR2VuZXJhbCB0ZXN0IGZvciBub3JtYWxpemVcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmIChcInRlc3RcIi5ub3JtYWxpemUoZm9ybSkgIT09IFwidGVzdFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICBpZiAoZm9ybSA9PT0gXCJORkRcIikge1xuICAgICAgICAgICAgY29uc3QgY2hlY2sgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZTkpLm5vcm1hbGl6ZShcIk5GRFwiKTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweDY1LCAweDAzMDEpO1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICBpZiAoY2hlY2sgIT09IGV4cGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYnJva2VuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgfVxuICAgICAgICBhY2N1bS5wdXNoKGZvcm0pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIHJldHVybiBhY2N1bTtcbn0sIFtdKTtcbi8qKlxuICogIFRocm93cyBpZiB0aGUgbm9ybWFsaXphdGlvbiAlJWZvcm0lJSBpcyBub3Qgc3VwcG9ydGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0Tm9ybWFsaXplKGZvcm0pIHtcbiAgICBhc3NlcnQoX25vcm1hbGl6ZUZvcm1zLmluZGV4T2YoZm9ybSkgPj0gMCwgXCJwbGF0Zm9ybSBtaXNzaW5nIFN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgb3BlcmF0aW9uOiBcIlN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplXCIsIGluZm86IHsgZm9ybSB9XG4gICAgfSk7XG59XG4vKipcbiAqICBNYW55IGNsYXNzZXMgdXNlIGZpbGUtc2NvcGVkIHZhbHVlcyB0byBndWFyZCB0aGUgY29uc3RydWN0b3IsXG4gKiAgbWFraW5nIGl0IGVmZmVjdGl2ZWx5IHByaXZhdGUuIFRoaXMgZmFjaWxpdGF0ZXMgdGhhdCBwYXR0ZXJuXG4gKiAgYnkgZW5zdXJpbmcgdGhlICUlZ2l2ZW5HYXVyZCUlIG1hdGNoZXMgdGhlIGZpbGUtc2NvcGVkICUlZ3VhcmQlJSxcbiAqICB0aHJvd2luZyBpZiBub3QsIGluZGljYXRpbmcgdGhlICUlY2xhc3NOYW1lJSUgaWYgcHJvdmlkZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRQcml2YXRlKGdpdmVuR3VhcmQsIGd1YXJkLCBjbGFzc05hbWUpIHtcbiAgICBpZiAoY2xhc3NOYW1lID09IG51bGwpIHtcbiAgICAgICAgY2xhc3NOYW1lID0gXCJcIjtcbiAgICB9XG4gICAgaWYgKGdpdmVuR3VhcmQgIT09IGd1YXJkKSB7XG4gICAgICAgIGxldCBtZXRob2QgPSBjbGFzc05hbWUsIG9wZXJhdGlvbiA9IFwibmV3XCI7XG4gICAgICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIG1ldGhvZCArPSBcIi5cIjtcbiAgICAgICAgICAgIG9wZXJhdGlvbiArPSBcIiBcIiArIGNsYXNzTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoZmFsc2UsIGBwcml2YXRlIGNvbnN0cnVjdG9yOyB1c2UgJHttZXRob2R9ZnJvbSogbWV0aG9kc2AsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvblxuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iLCJkZWZpbmVQcm9wZXJ0aWVzIiwic3RyaW5naWZ5IiwidmFsdWUiLCJzZWVuIiwiU2V0IiwiaGFzIiwiYWRkIiwiQXJyYXkiLCJpc0FycmF5IiwibWFwIiwidiIsImpvaW4iLCJVaW50OEFycmF5IiwiSEVYIiwicmVzdWx0IiwiaSIsImxlbmd0aCIsInRvSlNPTiIsInRvU3RyaW5nIiwiQmlnSW50IiwiSlNPTiIsImtleXMiLCJPYmplY3QiLCJzb3J0IiwiayIsImlzRXJyb3IiLCJlcnJvciIsImNvZGUiLCJpc0NhbGxFeGNlcHRpb24iLCJtYWtlRXJyb3IiLCJtZXNzYWdlIiwiaW5mbyIsInNob3J0TWVzc2FnZSIsImRldGFpbHMiLCJFcnJvciIsImtleSIsInB1c2giLCJUeXBlRXJyb3IiLCJSYW5nZUVycm9yIiwiYXNzaWduIiwiYXNzZXJ0IiwiY2hlY2siLCJhc3NlcnRBcmd1bWVudCIsIm5hbWUiLCJhcmd1bWVudCIsImFzc2VydEFyZ3VtZW50Q291bnQiLCJjb3VudCIsImV4cGVjdGVkQ291bnQiLCJfbm9ybWFsaXplRm9ybXMiLCJyZWR1Y2UiLCJhY2N1bSIsImZvcm0iLCJub3JtYWxpemUiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJleHBlY3RlZCIsImFzc2VydE5vcm1hbGl6ZSIsImluZGV4T2YiLCJvcGVyYXRpb24iLCJhc3NlcnRQcml2YXRlIiwiZ2l2ZW5HdWFyZCIsImd1YXJkIiwiY2xhc3NOYW1lIiwibWV0aG9kIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/utils/errors.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/utils/events.js":
/*!*****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/events.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventPayload: function() { return /* binding */ EventPayload; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_get */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_get.js\");\n/* harmony import */ var _swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_init */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_init.js\");\n/* harmony import */ var _swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_set */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_set.js\");\n/* harmony import */ var _properties_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./properties.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/**\n *  Events allow for applications to use the observer pattern, which\n *  allows subscribing and publishing events, outside the normal\n *  execution paths.\n *\n *  @_section api/utils/events:Events  [about-events]\n */ \n\n\n\nvar _listener = /*#__PURE__*/ new WeakMap();\n/**\n *  When an [[EventEmitterable]] triggers a [[Listener]], the\n *  callback always ahas one additional argument passed, which is\n *  an **EventPayload**.\n */ class EventPayload {\n    /**\n     *  Unregister the triggered listener for future events.\n     */ async removeListener() {\n        if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _listener) == null) {\n            return;\n        }\n        await this.emitter.off(this.filter, (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_0__._)(this, _listener));\n    }\n    /**\n     *  Create a new **EventPayload** for %%emitter%% with\n     *  the %%listener%% and for %%filter%%.\n     */ constructor(emitter, listener, filter){\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_1__._)(this, _listener, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_2__._)(this, _listener, listener);\n        (0,_properties_js__WEBPACK_IMPORTED_MODULE_3__.defineProperties)(this, {\n            emitter,\n            filter\n        });\n    }\n} //# sourceMappingURL=events.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9ldmVudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7Ozs7O0NBTUM7OztBQUNrRDtJQWUvQztBQWRKOzs7O0NBSUMsR0FDTSxNQUFNQztJQWtCVDs7S0FFQyxHQUNELE1BQU1DLGlCQUFpQjtRQUNuQixJQUFJLDRFQUFJLEVBQUVDLGNBQVksTUFBTTtZQUN4QjtRQUNKO1FBQ0EsTUFBTSxJQUFJLENBQUNDLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLElBQUksQ0FBQ0MsTUFBTSxFQUFFLDRFQUFJLEVBQUVIO0lBQzlDO0lBaEJBOzs7S0FHQyxHQUNESSxZQUFZSCxPQUFPLEVBQUVELFFBQVEsRUFBRUcsTUFBTSxDQUFFO1FBTHZDOzttQkFBQTs7c0ZBTVVILFdBQVdBO1FBQ2pCSCxnRUFBZ0JBLENBQUMsSUFBSSxFQUFFO1lBQUVJO1lBQVNFO1FBQU87SUFDN0M7QUFVSixFQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZXZlbnRzLmpzPzczM2YiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgRXZlbnRzIGFsbG93IGZvciBhcHBsaWNhdGlvbnMgdG8gdXNlIHRoZSBvYnNlcnZlciBwYXR0ZXJuLCB3aGljaFxuICogIGFsbG93cyBzdWJzY3JpYmluZyBhbmQgcHVibGlzaGluZyBldmVudHMsIG91dHNpZGUgdGhlIG5vcm1hbFxuICogIGV4ZWN1dGlvbiBwYXRocy5cbiAqXG4gKiAgQF9zZWN0aW9uIGFwaS91dGlscy9ldmVudHM6RXZlbnRzICBbYWJvdXQtZXZlbnRzXVxuICovXG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4vcHJvcGVydGllcy5qc1wiO1xuLyoqXG4gKiAgV2hlbiBhbiBbW0V2ZW50RW1pdHRlcmFibGVdXSB0cmlnZ2VycyBhIFtbTGlzdGVuZXJdXSwgdGhlXG4gKiAgY2FsbGJhY2sgYWx3YXlzIGFoYXMgb25lIGFkZGl0aW9uYWwgYXJndW1lbnQgcGFzc2VkLCB3aGljaCBpc1xuICogIGFuICoqRXZlbnRQYXlsb2FkKiouXG4gKi9cbmV4cG9ydCBjbGFzcyBFdmVudFBheWxvYWQge1xuICAgIC8qKlxuICAgICAqICBUaGUgZXZlbnQgZmlsdGVyLlxuICAgICAqL1xuICAgIGZpbHRlcjtcbiAgICAvKipcbiAgICAgKiAgVGhlICoqRXZlbnRFbWl0dGVyYWJsZSoqLlxuICAgICAqL1xuICAgIGVtaXR0ZXI7XG4gICAgI2xpc3RlbmVyO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipFdmVudFBheWxvYWQqKiBmb3IgJSVlbWl0dGVyJSUgd2l0aFxuICAgICAqICB0aGUgJSVsaXN0ZW5lciUlIGFuZCBmb3IgJSVmaWx0ZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbWl0dGVyLCBsaXN0ZW5lciwgZmlsdGVyKSB7XG4gICAgICAgIHRoaXMuI2xpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBlbWl0dGVyLCBmaWx0ZXIgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBVbnJlZ2lzdGVyIHRoZSB0cmlnZ2VyZWQgbGlzdGVuZXIgZm9yIGZ1dHVyZSBldmVudHMuXG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlTGlzdGVuZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLiNsaXN0ZW5lciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5lbWl0dGVyLm9mZih0aGlzLmZpbHRlciwgdGhpcy4jbGlzdGVuZXIpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZW50cy5qcy5tYXAiXSwibmFtZXMiOlsiZGVmaW5lUHJvcGVydGllcyIsIkV2ZW50UGF5bG9hZCIsInJlbW92ZUxpc3RlbmVyIiwibGlzdGVuZXIiLCJlbWl0dGVyIiwib2ZmIiwiZmlsdGVyIiwiY29uc3RydWN0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/utils/events.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/utils/fetch.js":
/*!****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/fetch.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FetchCancelSignal: function() { return /* binding */ FetchCancelSignal; },\n/* harmony export */   FetchRequest: function() { return /* binding */ FetchRequest; },\n/* harmony export */   FetchResponse: function() { return /* binding */ FetchResponse; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_get */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_get.js\");\n/* harmony import */ var _swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_init */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_init.js\");\n/* harmony import */ var _swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_set */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_set.js\");\n/* harmony import */ var _swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @swc/helpers/_/_class_private_method_get */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_method_get.js\");\n/* harmony import */ var _swc_helpers_class_private_method_init__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @swc/helpers/_/_class_private_method_init */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_method_init.js\");\n/* harmony import */ var _base64_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base64.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/base64-browser.js\");\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./data.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _properties_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./properties.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utf8_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utf8.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var _geturl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geturl.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/geturl-browser.js\");\n/**\n *  Fetching content from the web is environment-specific, so Ethers\n *  provides an abstraction that each environment can implement to provide\n *  this service.\n *\n *  On [Node.js](link-node), the ``http`` and ``https`` libs are used to\n *  create a request object, register event listeners and process data\n *  and populate the [[FetchResponse]].\n *\n *  In a browser, the [DOM fetch](link-js-fetch) is used, and the resulting\n *  ``Promise`` is waited on to retrieve the payload.\n *\n *  The [[FetchRequest]] is responsible for handling many common situations,\n *  such as redirects, server throttling, authentication, etc.\n *\n *  It also handles common gateways, such as IPFS and data URIs.\n *\n *  @_section api/utils/fetching:Fetching Web Content  [about-fetch]\n */ \n\n\n\n\n\n\n\n\n\n\nconst MAX_ATTEMPTS = 12;\nconst SLOT_INTERVAL = 250;\n// The global FetchGetUrlFunc implementation.\nlet defaultGetUrlFunc = (0,_geturl_js__WEBPACK_IMPORTED_MODULE_0__.createGetUrl)();\nconst reData = new RegExp(\"^data:([^;:]*)?(;base64)?,(.*)$\", \"i\");\nconst reIpfs = new RegExp(\"^ipfs://(ipfs/)?(.*)$\", \"i\");\n// If locked, new Gateways cannot be added\nlet locked = false;\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs\nasync function dataGatewayFunc(url, signal) {\n    try {\n        const match = url.match(reData);\n        if (!match) {\n            throw new Error(\"invalid data\");\n        }\n        return new FetchResponse(200, \"OK\", {\n            \"content-type\": match[1] || \"text/plain\"\n        }, match[2] ? (0,_base64_js__WEBPACK_IMPORTED_MODULE_1__.decodeBase64)(match[3]) : unpercent(match[3]));\n    } catch (error) {\n        return new FetchResponse(599, \"BAD REQUEST (invalid data: URI)\", {}, null, new FetchRequest(url));\n    }\n}\n/**\n *  Returns a [[FetchGatewayFunc]] for fetching content from a standard\n *  IPFS gateway hosted at %%baseUrl%%.\n */ function getIpfsGatewayFunc(baseUrl) {\n    async function gatewayIpfs(url, signal) {\n        try {\n            const match = url.match(reIpfs);\n            if (!match) {\n                throw new Error(\"invalid link\");\n            }\n            return new FetchRequest(\"\".concat(baseUrl).concat(match[2]));\n        } catch (error) {\n            return new FetchResponse(599, \"BAD REQUEST (invalid IPFS URI)\", {}, null, new FetchRequest(url));\n        }\n    }\n    return gatewayIpfs;\n}\nconst Gateways = {\n    \"data\": dataGatewayFunc,\n    \"ipfs\": getIpfsGatewayFunc(\"https://gateway.ipfs.io/ipfs/\")\n};\nconst fetchSignals = new WeakMap();\nvar _listeners = /*#__PURE__*/ new WeakMap(), _cancelled = /*#__PURE__*/ new WeakMap();\n/**\n *  @_ignore\n */ class FetchCancelSignal {\n    addListener(listener) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(!(0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _cancelled), \"singal already cancelled\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fetchCancelSignal.addCancelListener\"\n        });\n        (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _listeners).push(listener);\n    }\n    get cancelled() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _cancelled);\n    }\n    checkSignal() {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.cancelled, \"cancelled\", \"CANCELLED\", {});\n    }\n    constructor(request){\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_4__._)(this, _listeners, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_4__._)(this, _cancelled, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _listeners, []);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _cancelled, false);\n        fetchSignals.set(request, ()=>{\n            if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _cancelled)) {\n                return;\n            }\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _cancelled, true);\n            for (const listener of (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _listeners)){\n                setTimeout(()=>{\n                    listener();\n                }, 0);\n            }\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _listeners, []);\n        });\n    }\n}\n// Check the signal, throwing if it is cancelled\nfunction checkSignal(signal) {\n    if (signal == null) {\n        throw new Error(\"missing signal; should not happen\");\n    }\n    signal.checkSignal();\n    return signal;\n}\nvar _allowInsecure = /*#__PURE__*/ new WeakMap(), _gzip = /*#__PURE__*/ new WeakMap(), _headers = /*#__PURE__*/ new WeakMap(), _method = /*#__PURE__*/ new WeakMap(), _timeout = /*#__PURE__*/ new WeakMap(), _url = /*#__PURE__*/ new WeakMap(), _body = /*#__PURE__*/ new WeakMap(), _bodyType = /*#__PURE__*/ new WeakMap(), _creds = /*#__PURE__*/ new WeakMap(), // Hooks\n_preflight = /*#__PURE__*/ new WeakMap(), _process = /*#__PURE__*/ new WeakMap(), _retry = /*#__PURE__*/ new WeakMap(), _signal = /*#__PURE__*/ new WeakMap(), _throttle = /*#__PURE__*/ new WeakMap(), _getUrlFunc = /*#__PURE__*/ new WeakMap(), _send = /*#__PURE__*/ new WeakSet();\nlet _Symbol_iterator = Symbol.iterator;\n/**\n *  Represents a request for a resource using a URI.\n *\n *  By default, the supported schemes are ``HTTP``, ``HTTPS``, ``data:``,\n *  and ``IPFS:``.\n *\n *  Additional schemes can be added globally using [[registerGateway]].\n *\n *  @example:\n *    req = new FetchRequest(\"https://www.ricmoo.com\")\n *    resp = await req.send()\n *    resp.body.length\n *    //_result:\n */ class FetchRequest {\n    /**\n     *  The fetch URL to request.\n     */ get url() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _url);\n    }\n    set url(url) {\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _url, String(url));\n    }\n    /**\n     *  The fetch body, if any, to send as the request body. //(default: null)//\n     *\n     *  When setting a body, the intrinsic ``Content-Type`` is automatically\n     *  set and will be used if **not overridden** by setting a custom\n     *  header.\n     *\n     *  If %%body%% is null, the body is cleared (along with the\n     *  intrinsic ``Content-Type``).\n     *\n     *  If %%body%% is a string, the intrinsic ``Content-Type`` is set to\n     *  ``text/plain``.\n     *\n     *  If %%body%% is a Uint8Array, the intrinsic ``Content-Type`` is set to\n     *  ``application/octet-stream``.\n     *\n     *  If %%body%% is any other object, the intrinsic ``Content-Type`` is\n     *  set to ``application/json``.\n     */ get body() {\n        if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _body) == null) {\n            return null;\n        }\n        return new Uint8Array((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _body));\n    }\n    set body(body) {\n        if (body == null) {\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _body, undefined);\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _bodyType, undefined);\n        } else if (typeof body === \"string\") {\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _body, (0,_utf8_js__WEBPACK_IMPORTED_MODULE_6__.toUtf8Bytes)(body));\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _bodyType, \"text/plain\");\n        } else if (body instanceof Uint8Array) {\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _body, body);\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _bodyType, \"application/octet-stream\");\n        } else if (typeof body === \"object\") {\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _body, (0,_utf8_js__WEBPACK_IMPORTED_MODULE_6__.toUtf8Bytes)(JSON.stringify(body)));\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _bodyType, \"application/json\");\n        } else {\n            throw new Error(\"invalid body\");\n        }\n    }\n    /**\n     *  Returns true if the request has a body.\n     */ hasBody() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _body) != null;\n    }\n    /**\n     *  The HTTP method to use when requesting the URI. If no method\n     *  has been explicitly set, then ``GET`` is used if the body is\n     *  null and ``POST`` otherwise.\n     */ get method() {\n        if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _method)) {\n            return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _method);\n        }\n        if (this.hasBody()) {\n            return \"POST\";\n        }\n        return \"GET\";\n    }\n    set method(method) {\n        if (method == null) {\n            method = \"\";\n        }\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _method, String(method).toUpperCase());\n    }\n    /**\n     *  The headers that will be used when requesting the URI. All\n     *  keys are lower-case.\n     *\n     *  This object is a copy, so any changes will **NOT** be reflected\n     *  in the ``FetchRequest``.\n     *\n     *  To set a header entry, use the ``setHeader`` method.\n     */ get headers() {\n        const headers = Object.assign({}, (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _headers));\n        if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _creds)) {\n            headers[\"authorization\"] = \"Basic \".concat((0,_base64_js__WEBPACK_IMPORTED_MODULE_1__.encodeBase64)((0,_utf8_js__WEBPACK_IMPORTED_MODULE_6__.toUtf8Bytes)((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _creds))));\n        }\n        ;\n        if (this.allowGzip) {\n            headers[\"accept-encoding\"] = \"gzip\";\n        }\n        if (headers[\"content-type\"] == null && (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _bodyType)) {\n            headers[\"content-type\"] = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _bodyType);\n        }\n        if (this.body) {\n            headers[\"content-length\"] = String(this.body.length);\n        }\n        return headers;\n    }\n    /**\n     *  Get the header for %%key%%, ignoring case.\n     */ getHeader(key) {\n        return this.headers[key.toLowerCase()];\n    }\n    /**\n     *  Set the header for %%key%% to %%value%%. All values are coerced\n     *  to a string.\n     */ setHeader(key, value) {\n        (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _headers)[String(key).toLowerCase()] = String(value);\n    }\n    /**\n     *  Clear all headers, resetting all intrinsic headers.\n     */ clearHeaders() {\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _headers, {});\n    }\n    [_Symbol_iterator]() {\n        const headers = this.headers;\n        const keys = Object.keys(headers);\n        let index = 0;\n        return {\n            next: ()=>{\n                if (index < keys.length) {\n                    const key = keys[index++];\n                    return {\n                        value: [\n                            key,\n                            headers[key]\n                        ],\n                        done: false\n                    };\n                }\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n        };\n    }\n    /**\n     *  The value that will be sent for the ``Authorization`` header.\n     *\n     *  To set the credentials, use the ``setCredentials`` method.\n     */ get credentials() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _creds) || null;\n    }\n    /**\n     *  Sets an ``Authorization`` for %%username%% with %%password%%.\n     */ setCredentials(username, password) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(!username.match(/:/), \"invalid basic authentication username\", \"username\", \"[REDACTED]\");\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _creds, \"\".concat(username, \":\").concat(password));\n    }\n    /**\n     *  Enable and request gzip-encoded responses. The response will\n     *  automatically be decompressed. //(default: true)//\n     */ get allowGzip() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _gzip);\n    }\n    set allowGzip(value) {\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _gzip, !!value);\n    }\n    /**\n     *  Allow ``Authentication`` credentials to be sent over insecure\n     *  channels. //(default: false)//\n     */ get allowInsecureAuthentication() {\n        return !!(0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _allowInsecure);\n    }\n    set allowInsecureAuthentication(value) {\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _allowInsecure, !!value);\n    }\n    /**\n     *  The timeout (in milliseconds) to wait for a complete response.\n     *  //(default: 5 minutes)//\n     */ get timeout() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _timeout);\n    }\n    set timeout(timeout) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(timeout >= 0, \"timeout must be non-zero\", \"timeout\", timeout);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _timeout, timeout);\n    }\n    /**\n     *  This function is called prior to each request, for example\n     *  during a redirection or retry in case of server throttling.\n     *\n     *  This offers an opportunity to populate headers or update\n     *  content before sending a request.\n     */ get preflightFunc() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _preflight) || null;\n    }\n    set preflightFunc(preflight) {\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _preflight, preflight);\n    }\n    /**\n     *  This function is called after each response, offering an\n     *  opportunity to provide client-level throttling or updating\n     *  response data.\n     *\n     *  Any error thrown in this causes the ``send()`` to throw.\n     *\n     *  To schedule a retry attempt (assuming the maximum retry limit\n     *  has not been reached), use [[response.throwThrottleError]].\n     */ get processFunc() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _process) || null;\n    }\n    set processFunc(process) {\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _process, process);\n    }\n    /**\n     *  This function is called on each retry attempt.\n     */ get retryFunc() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _retry) || null;\n    }\n    set retryFunc(retry) {\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _retry, retry);\n    }\n    /**\n     *  This function is called to fetch content from HTTP and\n     *  HTTPS URLs and is platform specific (e.g. nodejs vs\n     *  browsers).\n     *\n     *  This is by default the currently registered global getUrl\n     *  function, which can be changed using [[registerGetUrl]].\n     *  If this has been set, setting is to ``null`` will cause\n     *  this FetchRequest (and any future clones) to revert back to\n     *  using the currently registered global getUrl function.\n     *\n     *  Setting this is generally not necessary, but may be useful\n     *  for developers that wish to intercept requests or to\n     *  configurege a proxy or other agent.\n     */ get getUrlFunc() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _getUrlFunc) || defaultGetUrlFunc;\n    }\n    set getUrlFunc(value) {\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _getUrlFunc, value);\n    }\n    toString() {\n        return \"<FetchRequest method=\".concat(JSON.stringify(this.method), \" url=\").concat(JSON.stringify(this.url), \" headers=\").concat(JSON.stringify(this.headers), \" body=\").concat((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _body) ? (0,_data_js__WEBPACK_IMPORTED_MODULE_7__.hexlify)((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _body)) : \"null\", \">\");\n    }\n    /**\n     *  Update the throttle parameters used to determine maximum\n     *  attempts and exponential-backoff properties.\n     */ setThrottleParams(params) {\n        if (params.slotInterval != null) {\n            (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _throttle).slotInterval = params.slotInterval;\n        }\n        if (params.maxAttempts != null) {\n            (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _throttle).maxAttempts = params.maxAttempts;\n        }\n    }\n    /**\n     *  Resolves to the response by sending the request.\n     */ send() {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _signal) == null, \"request already sent\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fetchRequest.send\"\n        });\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _signal, new FetchCancelSignal(this));\n        return (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_8__._)(this, _send, send).call(this, 0, getTime() + this.timeout, 0, this, new FetchResponse(0, \"\", {}, null, this));\n    }\n    /**\n     *  Cancels the inflight response, causing a ``CANCELLED``\n     *  error to be rejected from the [[send]].\n     */ cancel() {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _signal) != null, \"request has not been sent\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fetchRequest.cancel\"\n        });\n        const signal = fetchSignals.get(this);\n        if (!signal) {\n            throw new Error(\"missing signal; should not happen\");\n        }\n        signal();\n    }\n    /**\n     *  Returns a new [[FetchRequest]] that represents the redirection\n     *  to %%location%%.\n     */ redirect(location) {\n        // Redirection; for now we only support absolute locations\n        const current = this.url.split(\":\")[0].toLowerCase();\n        const target = location.split(\":\")[0].toLowerCase();\n        // Don't allow redirecting:\n        // - non-GET requests\n        // - downgrading the security (e.g. https => http)\n        // - to non-HTTP (or non-HTTPS) protocols [this could be relaxed?]\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.method === \"GET\" && (current !== \"https\" || target !== \"http\") && location.match(/^https?:/), \"unsupported redirect\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"redirect(\".concat(this.method, \" \").concat(JSON.stringify(this.url), \" => \").concat(JSON.stringify(location), \")\")\n        });\n        // Create a copy of this request, with a new URL\n        const req = new FetchRequest(location);\n        req.method = \"GET\";\n        req.allowGzip = this.allowGzip;\n        req.timeout = this.timeout;\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(req, _headers, Object.assign({}, (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _headers)));\n        if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _body)) {\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(req, _body, new Uint8Array((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _body)));\n        }\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(req, _bodyType, (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _bodyType));\n        // Do not forward credentials unless on the same domain; only absolute\n        //req.allowInsecure = false;\n        // paths are currently supported; may want a way to specify to forward?\n        //setStore(req.#props, \"creds\", getStore(this.#pros, \"creds\"));\n        return req;\n    }\n    /**\n     *  Create a new copy of this request.\n     */ clone() {\n        const clone = new FetchRequest(this.url);\n        // Preserve \"default method\" (i.e. null)\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(clone, _method, (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _method));\n        // Preserve \"default body\" with type, copying the Uint8Array is present\n        if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _body)) {\n            (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(clone, _body, (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _body));\n        }\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(clone, _bodyType, (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _bodyType));\n        // Preserve \"default headers\"\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(clone, _headers, Object.assign({}, (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _headers)));\n        // Credentials is readonly, so we copy internally\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(clone, _creds, (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _creds));\n        if (this.allowGzip) {\n            clone.allowGzip = true;\n        }\n        clone.timeout = this.timeout;\n        if (this.allowInsecureAuthentication) {\n            clone.allowInsecureAuthentication = true;\n        }\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(clone, _preflight, (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _preflight));\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(clone, _process, (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _process));\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(clone, _retry, (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _retry));\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(clone, _throttle, Object.assign({}, (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _throttle)));\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(clone, _getUrlFunc, (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _getUrlFunc));\n        return clone;\n    }\n    /**\n     *  Locks all static configuration for gateways and FetchGetUrlFunc\n     *  registration.\n     */ static lockConfig() {\n        locked = true;\n    }\n    /**\n     *  Get the current Gateway function for %%scheme%%.\n     */ static getGateway(scheme) {\n        return Gateways[scheme.toLowerCase()] || null;\n    }\n    /**\n     *  Use the %%func%% when fetching URIs using %%scheme%%.\n     *\n     *  This method affects all requests globally.\n     *\n     *  If [[lockConfig]] has been called, no change is made and this\n     *  throws.\n     */ static registerGateway(scheme, func) {\n        scheme = scheme.toLowerCase();\n        if (scheme === \"http\" || scheme === \"https\") {\n            throw new Error(\"cannot intercept \".concat(scheme, \"; use registerGetUrl\"));\n        }\n        if (locked) {\n            throw new Error(\"gateways locked\");\n        }\n        Gateways[scheme] = func;\n    }\n    /**\n     *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.\n     *\n     *  This method affects all requests globally.\n     *\n     *  If [[lockConfig]] has been called, no change is made and this\n     *  throws.\n     */ static registerGetUrl(getUrl) {\n        if (locked) {\n            throw new Error(\"gateways locked\");\n        }\n        defaultGetUrlFunc = getUrl;\n    }\n    /**\n     *  Creates a getUrl function that fetches content from HTTP and\n     *  HTTPS URLs.\n     *\n     *  The available %%options%% are dependent on the platform\n     *  implementation of the default getUrl function.\n     *\n     *  This is not generally something that is needed, but is useful\n     *  when trying to customize simple behaviour when fetching HTTP\n     *  content.\n     */ static createGetUrlFunc(options) {\n        return (0,_geturl_js__WEBPACK_IMPORTED_MODULE_0__.createGetUrl)(options);\n    }\n    /**\n     *  Creates a function that can \"fetch\" data URIs.\n     *\n     *  Note that this is automatically done internally to support\n     *  data URIs, so it is not necessary to register it.\n     *\n     *  This is not generally something that is needed, but may\n     *  be useful in a wrapper to perfom custom data URI functionality.\n     */ static createDataGateway() {\n        return dataGatewayFunc;\n    }\n    /**\n     *  Creates a function that will fetch IPFS (unvalidated) from\n     *  a custom gateway baseUrl.\n     *\n     *  The default IPFS gateway used internally is\n     *  ``\"https:/\\/gateway.ipfs.io/ipfs/\"``.\n     */ static createIpfsGatewayFunc(baseUrl) {\n        return getIpfsGatewayFunc(baseUrl);\n    }\n    /**\n     *  Create a new FetchRequest instance with default values.\n     *\n     *  Once created, each property may be set before issuing a\n     *  ``.send()`` to make the request.\n     */ constructor(url){\n        (0,_swc_helpers_class_private_method_init__WEBPACK_IMPORTED_MODULE_9__._)(this, _send);\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_4__._)(this, _allowInsecure, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_4__._)(this, _gzip, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_4__._)(this, _headers, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_4__._)(this, _method, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_4__._)(this, _timeout, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_4__._)(this, _url, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_4__._)(this, _body, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_4__._)(this, _bodyType, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_4__._)(this, _creds, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_4__._)(this, _preflight, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_4__._)(this, _process, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_4__._)(this, _retry, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_4__._)(this, _signal, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_4__._)(this, _throttle, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_4__._)(this, _getUrlFunc, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _url, String(url));\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _allowInsecure, false);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _gzip, true);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _headers, {});\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _method, \"\");\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _timeout, 300000);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _throttle, {\n            slotInterval: SLOT_INTERVAL,\n            maxAttempts: MAX_ATTEMPTS\n        });\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _getUrlFunc, null);\n    }\n}\nasync function send(attempt, expires, delay, _request, _response) {\n    var _req_redirect, _req_clone, _req_clone1;\n    if (attempt >= (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _throttle).maxAttempts) {\n        return _response.makeServerError(\"exceeded maximum retry limit\");\n    }\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(getTime() <= expires, \"timeout\", \"TIMEOUT\", {\n        operation: \"request.send\",\n        reason: \"timeout\",\n        request: _request\n    });\n    if (delay > 0) {\n        await wait(delay);\n    }\n    let req = this.clone();\n    const scheme = (req.url.split(\":\")[0] || \"\").toLowerCase();\n    // Process any Gateways\n    if (scheme in Gateways) {\n        const result = await Gateways[scheme](req.url, checkSignal((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(_request, _signal)));\n        if (result instanceof FetchResponse) {\n            let response = result;\n            if (this.processFunc) {\n                checkSignal((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(_request, _signal));\n                try {\n                    response = await this.processFunc(req, response);\n                } catch (error) {\n                    // Something went wrong during processing; throw a 5xx server error\n                    if (error.throttle == null || typeof error.stall !== \"number\") {\n                        response.makeServerError(\"error in post-processing function\", error).assertOk();\n                    }\n                // Ignore throttling\n                }\n            }\n            return response;\n        }\n        req = result;\n    }\n    // We have a preflight function; update the request\n    if (this.preflightFunc) {\n        req = await this.preflightFunc(req);\n    }\n    const resp = await this.getUrlFunc(req, checkSignal((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(_request, _signal)));\n    let response = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request);\n    if (response.statusCode === 301 || response.statusCode === 302) {\n        // Redirect\n        try {\n            const location = response.headers.location || \"\";\n            return (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_8__._)(_req_redirect = req.redirect(location), _send, send).call(_req_redirect, attempt + 1, expires, 0, _request, response);\n        } catch (error) {}\n        // Things won't get any better on another attempt; abort\n        return response;\n    } else if (response.statusCode === 429) {\n        // Throttle\n        if (this.retryFunc == null || await this.retryFunc(req, response, attempt)) {\n            const retryAfter = response.headers[\"retry-after\"];\n            let delay = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _throttle).slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));\n            if (typeof retryAfter === \"string\" && retryAfter.match(/^[1-9][0-9]*$/)) {\n                delay = parseInt(retryAfter);\n            }\n            return (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_8__._)(_req_clone = req.clone(), _send, send).call(_req_clone, attempt + 1, expires, delay, _request, response);\n        }\n    }\n    if (this.processFunc) {\n        checkSignal((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(_request, _signal));\n        try {\n            response = await this.processFunc(req, response);\n        } catch (error) {\n            // Something went wrong during processing; throw a 5xx server error\n            if (error.throttle == null || typeof error.stall !== \"number\") {\n                response.makeServerError(\"error in post-processing function\", error).assertOk();\n            }\n            // Throttle\n            let delay = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _throttle).slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));\n            ;\n            if (error.stall >= 0) {\n                delay = error.stall;\n            }\n            return (0,_swc_helpers_class_private_method_get__WEBPACK_IMPORTED_MODULE_8__._)(_req_clone1 = req.clone(), _send, send).call(_req_clone1, attempt + 1, expires, delay, _request, response);\n        }\n    }\n    return response;\n}\n;\nvar _statusCode = /*#__PURE__*/ new WeakMap(), _statusMessage = /*#__PURE__*/ new WeakMap(), _headers1 = /*#__PURE__*/ new WeakMap(), _body1 = /*#__PURE__*/ new WeakMap(), _request = /*#__PURE__*/ new WeakMap(), _error = /*#__PURE__*/ new WeakMap();\nlet _Symbol_iterator1 = Symbol.iterator;\n/**\n *  The response for a FetchRequest.\n */ class FetchResponse {\n    toString() {\n        return \"<FetchResponse status=\".concat(this.statusCode, \" body=\").concat((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _body1) ? (0,_data_js__WEBPACK_IMPORTED_MODULE_7__.hexlify)((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _body1)) : \"null\", \">\");\n    }\n    /**\n     *  The response status code.\n     */ get statusCode() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _statusCode);\n    }\n    /**\n     *  The response status message.\n     */ get statusMessage() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _statusMessage);\n    }\n    /**\n     *  The response headers. All keys are lower-case.\n     */ get headers() {\n        return Object.assign({}, (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _headers1));\n    }\n    /**\n     *  The response body, or ``null`` if there was no body.\n     */ get body() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _body1) == null ? null : new Uint8Array((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _body1));\n    }\n    /**\n     *  The response body as a UTF-8 encoded string, or the empty\n     *  string (i.e. ``\"\"``) if there was no body.\n     *\n     *  An error is thrown if the body is invalid UTF-8 data.\n     */ get bodyText() {\n        try {\n            return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _body1) == null ? \"\" : (0,_utf8_js__WEBPACK_IMPORTED_MODULE_6__.toUtf8String)((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _body1));\n        } catch (error) {\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false, \"response body is not valid UTF-8 data\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"bodyText\",\n                info: {\n                    response: this\n                }\n            });\n        }\n    }\n    /**\n     *  The response body, decoded as JSON.\n     *\n     *  An error is thrown if the body is invalid JSON-encoded data\n     *  or if there was no body.\n     */ get bodyJson() {\n        try {\n            return JSON.parse(this.bodyText);\n        } catch (error) {\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false, \"response body is not valid JSON\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"bodyJson\",\n                info: {\n                    response: this\n                }\n            });\n        }\n    }\n    [_Symbol_iterator1]() {\n        const headers = this.headers;\n        const keys = Object.keys(headers);\n        let index = 0;\n        return {\n            next: ()=>{\n                if (index < keys.length) {\n                    const key = keys[index++];\n                    return {\n                        value: [\n                            key,\n                            headers[key]\n                        ],\n                        done: false\n                    };\n                }\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n        };\n    }\n    /**\n     *  Return a Response with matching headers and body, but with\n     *  an error status code (i.e. 599) and %%message%% with an\n     *  optional %%error%%.\n     */ makeServerError(message, error) {\n        let statusMessage;\n        if (!message) {\n            message = \"\".concat(this.statusCode, \" \").concat(this.statusMessage);\n            statusMessage = \"CLIENT ESCALATED SERVER ERROR (\".concat(message, \")\");\n        } else {\n            statusMessage = \"CLIENT ESCALATED SERVER ERROR (\".concat(this.statusCode, \" \").concat(this.statusMessage, \"; \").concat(message, \")\");\n        }\n        const response = new FetchResponse(599, statusMessage, this.headers, this.body, (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _request) || undefined);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(response, _error, {\n            message,\n            error\n        });\n        return response;\n    }\n    /**\n     *  If called within a [request.processFunc](FetchRequest-processFunc)\n     *  call, causes the request to retry as if throttled for %%stall%%\n     *  milliseconds.\n     */ throwThrottleError(message, stall) {\n        if (stall == null) {\n            stall = -1;\n        } else {\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(Number.isInteger(stall) && stall >= 0, \"invalid stall timeout\", \"stall\", stall);\n        }\n        const error = new Error(message || \"throttling requests\");\n        (0,_properties_js__WEBPACK_IMPORTED_MODULE_10__.defineProperties)(error, {\n            stall,\n            throttle: true\n        });\n        throw error;\n    }\n    /**\n     *  Get the header value for %%key%%, ignoring case.\n     */ getHeader(key) {\n        return this.headers[key.toLowerCase()];\n    }\n    /**\n     *  Returns true if the response has a body.\n     */ hasBody() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _body1) != null;\n    }\n    /**\n     *  The request made for this response.\n     */ get request() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _request);\n    }\n    /**\n     *  Returns true if this response was a success statusCode.\n     */ ok() {\n        return (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _error).message === \"\" && this.statusCode >= 200 && this.statusCode < 300;\n    }\n    /**\n     *  Throws a ``SERVER_ERROR`` if this response is not ok.\n     */ assertOk() {\n        if (this.ok()) {\n            return;\n        }\n        let { message, error } = (0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _error);\n        if (message === \"\") {\n            message = \"server response \".concat(this.statusCode, \" \").concat(this.statusMessage);\n        }\n        let requestUrl = null;\n        if (this.request) {\n            requestUrl = this.request.url;\n        }\n        let responseBody = null;\n        try {\n            if ((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _body1)) {\n                responseBody = (0,_utf8_js__WEBPACK_IMPORTED_MODULE_6__.toUtf8String)((0,_swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, _body1));\n            }\n        } catch (e) {}\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false, message, \"SERVER_ERROR\", {\n            request: this.request || \"unknown request\",\n            response: this,\n            error,\n            info: {\n                requestUrl,\n                responseBody,\n                responseStatus: \"\".concat(this.statusCode, \" \").concat(this.statusMessage)\n            }\n        });\n    }\n    constructor(statusCode, statusMessage, headers, body, request){\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_4__._)(this, _statusCode, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_4__._)(this, _statusMessage, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_4__._)(this, _headers1, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_4__._)(this, _body1, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_4__._)(this, _request, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_4__._)(this, _error, {\n            writable: true,\n            value: void 0\n        });\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _statusCode, statusCode);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _statusMessage, statusMessage);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _headers1, Object.keys(headers).reduce((accum, k)=>{\n            accum[k.toLowerCase()] = String(headers[k]);\n            return accum;\n        }, {}));\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _body1, body == null ? null : new Uint8Array(body));\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _request, request || null);\n        (0,_swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_5__._)(this, _error, {\n            message: \"\"\n        });\n    }\n}\nfunction getTime() {\n    return new Date().getTime();\n}\nfunction unpercent(value) {\n    return (0,_utf8_js__WEBPACK_IMPORTED_MODULE_6__.toUtf8Bytes)(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code)=>{\n        return String.fromCharCode(parseInt(code, 16));\n    }));\n}\nfunction wait(delay) {\n    return new Promise((resolve)=>setTimeout(resolve, delay));\n} //# sourceMappingURL=fetch.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9mZXRjaC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrQkM7Ozs7O0FBQ3dEO0FBQ3JCO0FBQ2lCO0FBQ0Y7QUFDRztBQUNYO0FBQzNDLE1BQU1TLGVBQWU7QUFDckIsTUFBTUMsZ0JBQWdCO0FBQ3RCLDZDQUE2QztBQUM3QyxJQUFJQyxvQkFBb0JILHdEQUFZQTtBQUNwQyxNQUFNSSxTQUFTLElBQUlDLE9BQU8sbUNBQW1DO0FBQzdELE1BQU1DLFNBQVMsSUFBSUQsT0FBTyx5QkFBMEI7QUFDcEQsMENBQTBDO0FBQzFDLElBQUlFLFNBQVM7QUFDYiw2RUFBNkU7QUFDN0UsZUFBZUMsZ0JBQWdCQyxHQUFHLEVBQUVDLE1BQU07SUFDdEMsSUFBSTtRQUNBLE1BQU1DLFFBQVFGLElBQUlFLEtBQUssQ0FBQ1A7UUFDeEIsSUFBSSxDQUFDTyxPQUFPO1lBQ1IsTUFBTSxJQUFJQyxNQUFNO1FBQ3BCO1FBQ0EsT0FBTyxJQUFJQyxjQUFjLEtBQUssTUFBTTtZQUNoQyxnQkFBaUJGLEtBQUssQ0FBQyxFQUFFLElBQUk7UUFDakMsR0FBSUEsS0FBSyxDQUFDLEVBQUUsR0FBR25CLHdEQUFZQSxDQUFDbUIsS0FBSyxDQUFDLEVBQUUsSUFBSUcsVUFBVUgsS0FBSyxDQUFDLEVBQUU7SUFDOUQsRUFDQSxPQUFPSSxPQUFPO1FBQ1YsT0FBTyxJQUFJRixjQUFjLEtBQUssbUNBQW1DLENBQUMsR0FBRyxNQUFNLElBQUlHLGFBQWFQO0lBQ2hHO0FBQ0o7QUFDQTs7O0NBR0MsR0FDRCxTQUFTUSxtQkFBbUJDLE9BQU87SUFDL0IsZUFBZUMsWUFBWVYsR0FBRyxFQUFFQyxNQUFNO1FBQ2xDLElBQUk7WUFDQSxNQUFNQyxRQUFRRixJQUFJRSxLQUFLLENBQUNMO1lBQ3hCLElBQUksQ0FBQ0ssT0FBTztnQkFDUixNQUFNLElBQUlD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Q3BCLFVBQVUsRUFBQyxLQUFzQixPQUFuQixJQUFJLENBQUNDLGFBQWE7WUFDNUQ7UUFDSjtJQUNKO0lBaEdBekYsWUFBWXdGLFVBQVUsRUFBRUMsYUFBYSxFQUFFekUsT0FBTyxFQUFFVCxJQUFJLEVBQUVOLE9BQU8sQ0FBRTtRQTNFL0Q7O21CQUFBOztRQUNBOzttQkFBQTs7UUFDQTs7bUJBQUE7O1FBQ0E7O21CQUFBOztRQUNBOzttQkFBQTs7UUFDQTs7bUJBQUE7O3NGQXVFVXVGLGFBQWFBO3NGQUNiQyxnQkFBZ0JBO3NGQUNoQnpFLFdBQVVDLE9BQU9XLElBQUksQ0FBQ1osU0FBUzZGLE1BQU0sQ0FBQyxDQUFDQyxPQUFPQztZQUNoREQsS0FBSyxDQUFDQyxFQUFFdkYsV0FBVyxHQUFHLEdBQUdsQixPQUFPVSxPQUFPLENBQUMrRixFQUFFO1lBQzFDLE9BQU9EO1FBQ1gsR0FBRyxDQUFDO3NGQUNFdkcsUUFBUSxRQUFTLE9BQVEsT0FBTyxJQUFJQyxXQUFXRDtzRkFDL0NOLFVBQVdBLFdBQVc7c0ZBQ3RCakIsUUFBUTtZQUFFb0gsU0FBUztRQUFHO0lBQ2hDO0FBdUZKO0FBQ0EsU0FBUzlDO0lBQVksT0FBTyxJQUFLMEQsT0FBUTFELE9BQU87QUFBSTtBQUNwRCxTQUFTdkUsVUFBVTJDLEtBQUs7SUFDcEIsT0FBTzNELHFEQUFXQSxDQUFDMkQsTUFBTXVGLE9BQU8sQ0FBQyx5QkFBeUIsQ0FBQ0MsS0FBS0M7UUFDNUQsT0FBTzdHLE9BQU84RyxZQUFZLENBQUNyQixTQUFTb0IsTUFBTTtJQUM5QztBQUNKO0FBQ0EsU0FBU2pDLEtBQUtMLEtBQUs7SUFDZixPQUFPLElBQUl3QyxRQUFRLENBQUNDLFVBQVluSCxXQUFXbUgsU0FBU3pDO0FBQ3hELEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9mZXRjaC5qcz9lMWU1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIEZldGNoaW5nIGNvbnRlbnQgZnJvbSB0aGUgd2ViIGlzIGVudmlyb25tZW50LXNwZWNpZmljLCBzbyBFdGhlcnNcbiAqICBwcm92aWRlcyBhbiBhYnN0cmFjdGlvbiB0aGF0IGVhY2ggZW52aXJvbm1lbnQgY2FuIGltcGxlbWVudCB0byBwcm92aWRlXG4gKiAgdGhpcyBzZXJ2aWNlLlxuICpcbiAqICBPbiBbTm9kZS5qc10obGluay1ub2RlKSwgdGhlIGBgaHR0cGBgIGFuZCBgYGh0dHBzYGAgbGlicyBhcmUgdXNlZCB0b1xuICogIGNyZWF0ZSBhIHJlcXVlc3Qgb2JqZWN0LCByZWdpc3RlciBldmVudCBsaXN0ZW5lcnMgYW5kIHByb2Nlc3MgZGF0YVxuICogIGFuZCBwb3B1bGF0ZSB0aGUgW1tGZXRjaFJlc3BvbnNlXV0uXG4gKlxuICogIEluIGEgYnJvd3NlciwgdGhlIFtET00gZmV0Y2hdKGxpbmstanMtZmV0Y2gpIGlzIHVzZWQsIGFuZCB0aGUgcmVzdWx0aW5nXG4gKiAgYGBQcm9taXNlYGAgaXMgd2FpdGVkIG9uIHRvIHJldHJpZXZlIHRoZSBwYXlsb2FkLlxuICpcbiAqICBUaGUgW1tGZXRjaFJlcXVlc3RdXSBpcyByZXNwb25zaWJsZSBmb3IgaGFuZGxpbmcgbWFueSBjb21tb24gc2l0dWF0aW9ucyxcbiAqICBzdWNoIGFzIHJlZGlyZWN0cywgc2VydmVyIHRocm90dGxpbmcsIGF1dGhlbnRpY2F0aW9uLCBldGMuXG4gKlxuICogIEl0IGFsc28gaGFuZGxlcyBjb21tb24gZ2F0ZXdheXMsIHN1Y2ggYXMgSVBGUyBhbmQgZGF0YSBVUklzLlxuICpcbiAqICBAX3NlY3Rpb24gYXBpL3V0aWxzL2ZldGNoaW5nOkZldGNoaW5nIFdlYiBDb250ZW50ICBbYWJvdXQtZmV0Y2hdXG4gKi9cbmltcG9ydCB7IGRlY29kZUJhc2U2NCwgZW5jb2RlQmFzZTY0IH0gZnJvbSBcIi4vYmFzZTY0LmpzXCI7XG5pbXBvcnQgeyBoZXhsaWZ5IH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcyB9IGZyb20gXCIuL3Byb3BlcnRpZXMuanNcIjtcbmltcG9ydCB7IHRvVXRmOEJ5dGVzLCB0b1V0ZjhTdHJpbmcgfSBmcm9tIFwiLi91dGY4LmpzXCI7XG5pbXBvcnQgeyBjcmVhdGVHZXRVcmwgfSBmcm9tIFwiLi9nZXR1cmwuanNcIjtcbmNvbnN0IE1BWF9BVFRFTVBUUyA9IDEyO1xuY29uc3QgU0xPVF9JTlRFUlZBTCA9IDI1MDtcbi8vIFRoZSBnbG9iYWwgRmV0Y2hHZXRVcmxGdW5jIGltcGxlbWVudGF0aW9uLlxubGV0IGRlZmF1bHRHZXRVcmxGdW5jID0gY3JlYXRlR2V0VXJsKCk7XG5jb25zdCByZURhdGEgPSBuZXcgUmVnRXhwKFwiXmRhdGE6KFteOzpdKik/KDtiYXNlNjQpPywoLiopJFwiLCBcImlcIik7XG5jb25zdCByZUlwZnMgPSBuZXcgUmVnRXhwKFwiXmlwZnM6L1xcLyhpcGZzLyk/KC4qKSRcIiwgXCJpXCIpO1xuLy8gSWYgbG9ja2VkLCBuZXcgR2F0ZXdheXMgY2Fubm90IGJlIGFkZGVkXG5sZXQgbG9ja2VkID0gZmFsc2U7XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0Jhc2ljc19vZl9IVFRQL0RhdGFfVVJMc1xuYXN5bmMgZnVuY3Rpb24gZGF0YUdhdGV3YXlGdW5jKHVybCwgc2lnbmFsKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB1cmwubWF0Y2gocmVEYXRhKTtcbiAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBkYXRhXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRmV0Y2hSZXNwb25zZSgyMDAsIFwiT0tcIiwge1xuICAgICAgICAgICAgXCJjb250ZW50LXR5cGVcIjogKG1hdGNoWzFdIHx8IFwidGV4dC9wbGFpblwiKSxcbiAgICAgICAgfSwgKG1hdGNoWzJdID8gZGVjb2RlQmFzZTY0KG1hdGNoWzNdKSA6IHVucGVyY2VudChtYXRjaFszXSkpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmV0Y2hSZXNwb25zZSg1OTksIFwiQkFEIFJFUVVFU1QgKGludmFsaWQgZGF0YTogVVJJKVwiLCB7fSwgbnVsbCwgbmV3IEZldGNoUmVxdWVzdCh1cmwpKTtcbiAgICB9XG59XG4vKipcbiAqICBSZXR1cm5zIGEgW1tGZXRjaEdhdGV3YXlGdW5jXV0gZm9yIGZldGNoaW5nIGNvbnRlbnQgZnJvbSBhIHN0YW5kYXJkXG4gKiAgSVBGUyBnYXRld2F5IGhvc3RlZCBhdCAlJWJhc2VVcmwlJS5cbiAqL1xuZnVuY3Rpb24gZ2V0SXBmc0dhdGV3YXlGdW5jKGJhc2VVcmwpIHtcbiAgICBhc3luYyBmdW5jdGlvbiBnYXRld2F5SXBmcyh1cmwsIHNpZ25hbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB1cmwubWF0Y2gocmVJcGZzKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGxpbmtcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZldGNoUmVxdWVzdChgJHtiYXNlVXJsfSR7bWF0Y2hbMl19YCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZldGNoUmVzcG9uc2UoNTk5LCBcIkJBRCBSRVFVRVNUIChpbnZhbGlkIElQRlMgVVJJKVwiLCB7fSwgbnVsbCwgbmV3IEZldGNoUmVxdWVzdCh1cmwpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ2F0ZXdheUlwZnM7XG59XG5jb25zdCBHYXRld2F5cyA9IHtcbiAgICBcImRhdGFcIjogZGF0YUdhdGV3YXlGdW5jLFxuICAgIFwiaXBmc1wiOiBnZXRJcGZzR2F0ZXdheUZ1bmMoXCJodHRwczovXFwvZ2F0ZXdheS5pcGZzLmlvL2lwZnMvXCIpXG59O1xuY29uc3QgZmV0Y2hTaWduYWxzID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBGZXRjaENhbmNlbFNpZ25hbCB7XG4gICAgI2xpc3RlbmVycztcbiAgICAjY2FuY2VsbGVkO1xuICAgIGNvbnN0cnVjdG9yKHJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy4jbGlzdGVuZXJzID0gW107XG4gICAgICAgIHRoaXMuI2NhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICBmZXRjaFNpZ25hbHMuc2V0KHJlcXVlc3QsICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNjYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLiNsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgbGlzdGVuZXIoKTsgfSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNsaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFkZExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIGFzc2VydCghdGhpcy4jY2FuY2VsbGVkLCBcInNpbmdhbCBhbHJlYWR5IGNhbmNlbGxlZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZmV0Y2hDYW5jZWxTaWduYWwuYWRkQ2FuY2VsTGlzdGVuZXJcIlxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cbiAgICBnZXQgY2FuY2VsbGVkKCkgeyByZXR1cm4gdGhpcy4jY2FuY2VsbGVkOyB9XG4gICAgY2hlY2tTaWduYWwoKSB7XG4gICAgICAgIGFzc2VydCghdGhpcy5jYW5jZWxsZWQsIFwiY2FuY2VsbGVkXCIsIFwiQ0FOQ0VMTEVEXCIsIHt9KTtcbiAgICB9XG59XG4vLyBDaGVjayB0aGUgc2lnbmFsLCB0aHJvd2luZyBpZiBpdCBpcyBjYW5jZWxsZWRcbmZ1bmN0aW9uIGNoZWNrU2lnbmFsKHNpZ25hbCkge1xuICAgIGlmIChzaWduYWwgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIHNpZ25hbDsgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgfVxuICAgIHNpZ25hbC5jaGVja1NpZ25hbCgpO1xuICAgIHJldHVybiBzaWduYWw7XG59XG4vKipcbiAqICBSZXByZXNlbnRzIGEgcmVxdWVzdCBmb3IgYSByZXNvdXJjZSB1c2luZyBhIFVSSS5cbiAqXG4gKiAgQnkgZGVmYXVsdCwgdGhlIHN1cHBvcnRlZCBzY2hlbWVzIGFyZSBgYEhUVFBgYCwgYGBIVFRQU2BgLCBgYGRhdGE6YGAsXG4gKiAgYW5kIGBgSVBGUzpgYC5cbiAqXG4gKiAgQWRkaXRpb25hbCBzY2hlbWVzIGNhbiBiZSBhZGRlZCBnbG9iYWxseSB1c2luZyBbW3JlZ2lzdGVyR2F0ZXdheV1dLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIHJlcSA9IG5ldyBGZXRjaFJlcXVlc3QoXCJodHRwczovL3d3dy5yaWNtb28uY29tXCIpXG4gKiAgICByZXNwID0gYXdhaXQgcmVxLnNlbmQoKVxuICogICAgcmVzcC5ib2R5Lmxlbmd0aFxuICogICAgLy9fcmVzdWx0OlxuICovXG5leHBvcnQgY2xhc3MgRmV0Y2hSZXF1ZXN0IHtcbiAgICAjYWxsb3dJbnNlY3VyZTtcbiAgICAjZ3ppcDtcbiAgICAjaGVhZGVycztcbiAgICAjbWV0aG9kO1xuICAgICN0aW1lb3V0O1xuICAgICN1cmw7XG4gICAgI2JvZHk7XG4gICAgI2JvZHlUeXBlO1xuICAgICNjcmVkcztcbiAgICAvLyBIb29rc1xuICAgICNwcmVmbGlnaHQ7XG4gICAgI3Byb2Nlc3M7XG4gICAgI3JldHJ5O1xuICAgICNzaWduYWw7XG4gICAgI3Rocm90dGxlO1xuICAgICNnZXRVcmxGdW5jO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmV0Y2ggVVJMIHRvIHJlcXVlc3QuXG4gICAgICovXG4gICAgZ2V0IHVybCgpIHsgcmV0dXJuIHRoaXMuI3VybDsgfVxuICAgIHNldCB1cmwodXJsKSB7XG4gICAgICAgIHRoaXMuI3VybCA9IFN0cmluZyh1cmwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGZldGNoIGJvZHksIGlmIGFueSwgdG8gc2VuZCBhcyB0aGUgcmVxdWVzdCBib2R5LiAvLyhkZWZhdWx0OiBudWxsKS8vXG4gICAgICpcbiAgICAgKiAgV2hlbiBzZXR0aW5nIGEgYm9keSwgdGhlIGludHJpbnNpYyBgYENvbnRlbnQtVHlwZWBgIGlzIGF1dG9tYXRpY2FsbHlcbiAgICAgKiAgc2V0IGFuZCB3aWxsIGJlIHVzZWQgaWYgKipub3Qgb3ZlcnJpZGRlbioqIGJ5IHNldHRpbmcgYSBjdXN0b21cbiAgICAgKiAgaGVhZGVyLlxuICAgICAqXG4gICAgICogIElmICUlYm9keSUlIGlzIG51bGwsIHRoZSBib2R5IGlzIGNsZWFyZWQgKGFsb25nIHdpdGggdGhlXG4gICAgICogIGludHJpbnNpYyBgYENvbnRlbnQtVHlwZWBgKS5cbiAgICAgKlxuICAgICAqICBJZiAlJWJvZHklJSBpcyBhIHN0cmluZywgdGhlIGludHJpbnNpYyBgYENvbnRlbnQtVHlwZWBgIGlzIHNldCB0b1xuICAgICAqICBgYHRleHQvcGxhaW5gYC5cbiAgICAgKlxuICAgICAqICBJZiAlJWJvZHklJSBpcyBhIFVpbnQ4QXJyYXksIHRoZSBpbnRyaW5zaWMgYGBDb250ZW50LVR5cGVgYCBpcyBzZXQgdG9cbiAgICAgKiAgYGBhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1gYC5cbiAgICAgKlxuICAgICAqICBJZiAlJWJvZHklJSBpcyBhbnkgb3RoZXIgb2JqZWN0LCB0aGUgaW50cmluc2ljIGBgQ29udGVudC1UeXBlYGAgaXNcbiAgICAgKiAgc2V0IHRvIGBgYXBwbGljYXRpb24vanNvbmBgLlxuICAgICAqL1xuICAgIGdldCBib2R5KCkge1xuICAgICAgICBpZiAodGhpcy4jYm9keSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodGhpcy4jYm9keSk7XG4gICAgfVxuICAgIHNldCBib2R5KGJvZHkpIHtcbiAgICAgICAgaWYgKGJvZHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy4jYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuI2JvZHlUeXBlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiAoYm9keSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRoaXMuI2JvZHkgPSB0b1V0ZjhCeXRlcyhib2R5KTtcbiAgICAgICAgICAgIHRoaXMuI2JvZHlUeXBlID0gXCJ0ZXh0L3BsYWluXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYm9keSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgIHRoaXMuI2JvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy4jYm9keVR5cGUgPSBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiAoYm9keSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHRoaXMuI2JvZHkgPSB0b1V0ZjhCeXRlcyhKU09OLnN0cmluZ2lmeShib2R5KSk7XG4gICAgICAgICAgICB0aGlzLiNib2R5VHlwZSA9IFwiYXBwbGljYXRpb24vanNvblwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBib2R5XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhlIHJlcXVlc3QgaGFzIGEgYm9keS5cbiAgICAgKi9cbiAgICBoYXNCb2R5KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI2JvZHkgIT0gbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgSFRUUCBtZXRob2QgdG8gdXNlIHdoZW4gcmVxdWVzdGluZyB0aGUgVVJJLiBJZiBubyBtZXRob2RcbiAgICAgKiAgaGFzIGJlZW4gZXhwbGljaXRseSBzZXQsIHRoZW4gYGBHRVRgYCBpcyB1c2VkIGlmIHRoZSBib2R5IGlzXG4gICAgICogIG51bGwgYW5kIGBgUE9TVGBgIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBnZXQgbWV0aG9kKCkge1xuICAgICAgICBpZiAodGhpcy4jbWV0aG9kKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jbWV0aG9kO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhhc0JvZHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiUE9TVFwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIkdFVFwiO1xuICAgIH1cbiAgICBzZXQgbWV0aG9kKG1ldGhvZCkge1xuICAgICAgICBpZiAobWV0aG9kID09IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbWV0aG9kID0gU3RyaW5nKG1ldGhvZCkudG9VcHBlckNhc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBoZWFkZXJzIHRoYXQgd2lsbCBiZSB1c2VkIHdoZW4gcmVxdWVzdGluZyB0aGUgVVJJLiBBbGxcbiAgICAgKiAga2V5cyBhcmUgbG93ZXItY2FzZS5cbiAgICAgKlxuICAgICAqICBUaGlzIG9iamVjdCBpcyBhIGNvcHksIHNvIGFueSBjaGFuZ2VzIHdpbGwgKipOT1QqKiBiZSByZWZsZWN0ZWRcbiAgICAgKiAgaW4gdGhlIGBgRmV0Y2hSZXF1ZXN0YGAuXG4gICAgICpcbiAgICAgKiAgVG8gc2V0IGEgaGVhZGVyIGVudHJ5LCB1c2UgdGhlIGBgc2V0SGVhZGVyYGAgbWV0aG9kLlxuICAgICAqL1xuICAgIGdldCBoZWFkZXJzKCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy4jaGVhZGVycyk7XG4gICAgICAgIGlmICh0aGlzLiNjcmVkcykge1xuICAgICAgICAgICAgaGVhZGVyc1tcImF1dGhvcml6YXRpb25cIl0gPSBgQmFzaWMgJHtlbmNvZGVCYXNlNjQodG9VdGY4Qnl0ZXModGhpcy4jY3JlZHMpKX1gO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgaWYgKHRoaXMuYWxsb3dHemlwKSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wiYWNjZXB0LWVuY29kaW5nXCJdID0gXCJnemlwXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gPT0gbnVsbCAmJiB0aGlzLiNib2R5VHlwZSkge1xuICAgICAgICAgICAgaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA9IHRoaXMuI2JvZHlUeXBlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJvZHkpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJjb250ZW50LWxlbmd0aFwiXSA9IFN0cmluZyh0aGlzLmJvZHkubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgaGVhZGVyIGZvciAlJWtleSUlLCBpZ25vcmluZyBjYXNlLlxuICAgICAqL1xuICAgIGdldEhlYWRlcihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTZXQgdGhlIGhlYWRlciBmb3IgJSVrZXklJSB0byAlJXZhbHVlJSUuIEFsbCB2YWx1ZXMgYXJlIGNvZXJjZWRcbiAgICAgKiAgdG8gYSBzdHJpbmcuXG4gICAgICovXG4gICAgc2V0SGVhZGVyKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy4jaGVhZGVyc1tTdHJpbmcoa2V5KS50b0xvd2VyQ2FzZSgpXSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDbGVhciBhbGwgaGVhZGVycywgcmVzZXR0aW5nIGFsbCBpbnRyaW5zaWMgaGVhZGVycy5cbiAgICAgKi9cbiAgICBjbGVhckhlYWRlcnMoKSB7XG4gICAgICAgIHRoaXMuI2hlYWRlcnMgPSB7fTtcbiAgICB9XG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLmhlYWRlcnM7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhoZWFkZXJzKTtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBrZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2luZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFtrZXksIGhlYWRlcnNba2V5XV0sIGRvbmU6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSB2YWx1ZSB0aGF0IHdpbGwgYmUgc2VudCBmb3IgdGhlIGBgQXV0aG9yaXphdGlvbmBgIGhlYWRlci5cbiAgICAgKlxuICAgICAqICBUbyBzZXQgdGhlIGNyZWRlbnRpYWxzLCB1c2UgdGhlIGBgc2V0Q3JlZGVudGlhbHNgYCBtZXRob2QuXG4gICAgICovXG4gICAgZ2V0IGNyZWRlbnRpYWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jY3JlZHMgfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFNldHMgYW4gYGBBdXRob3JpemF0aW9uYGAgZm9yICUldXNlcm5hbWUlJSB3aXRoICUlcGFzc3dvcmQlJS5cbiAgICAgKi9cbiAgICBzZXRDcmVkZW50aWFscyh1c2VybmFtZSwgcGFzc3dvcmQpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoIXVzZXJuYW1lLm1hdGNoKC86LyksIFwiaW52YWxpZCBiYXNpYyBhdXRoZW50aWNhdGlvbiB1c2VybmFtZVwiLCBcInVzZXJuYW1lXCIsIFwiW1JFREFDVEVEXVwiKTtcbiAgICAgICAgdGhpcy4jY3JlZHMgPSBgJHt1c2VybmFtZX06JHtwYXNzd29yZH1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRW5hYmxlIGFuZCByZXF1ZXN0IGd6aXAtZW5jb2RlZCByZXNwb25zZXMuIFRoZSByZXNwb25zZSB3aWxsXG4gICAgICogIGF1dG9tYXRpY2FsbHkgYmUgZGVjb21wcmVzc2VkLiAvLyhkZWZhdWx0OiB0cnVlKS8vXG4gICAgICovXG4gICAgZ2V0IGFsbG93R3ppcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2d6aXA7XG4gICAgfVxuICAgIHNldCBhbGxvd0d6aXAodmFsdWUpIHtcbiAgICAgICAgdGhpcy4jZ3ppcCA9ICEhdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBBbGxvdyBgYEF1dGhlbnRpY2F0aW9uYGAgY3JlZGVudGlhbHMgdG8gYmUgc2VudCBvdmVyIGluc2VjdXJlXG4gICAgICogIGNoYW5uZWxzLiAvLyhkZWZhdWx0OiBmYWxzZSkvL1xuICAgICAqL1xuICAgIGdldCBhbGxvd0luc2VjdXJlQXV0aGVudGljYXRpb24oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuI2FsbG93SW5zZWN1cmU7XG4gICAgfVxuICAgIHNldCBhbGxvd0luc2VjdXJlQXV0aGVudGljYXRpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy4jYWxsb3dJbnNlY3VyZSA9ICEhdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdGltZW91dCAoaW4gbWlsbGlzZWNvbmRzKSB0byB3YWl0IGZvciBhIGNvbXBsZXRlIHJlc3BvbnNlLlxuICAgICAqICAvLyhkZWZhdWx0OiA1IG1pbnV0ZXMpLy9cbiAgICAgKi9cbiAgICBnZXQgdGltZW91dCgpIHsgcmV0dXJuIHRoaXMuI3RpbWVvdXQ7IH1cbiAgICBzZXQgdGltZW91dCh0aW1lb3V0KSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHRpbWVvdXQgPj0gMCwgXCJ0aW1lb3V0IG11c3QgYmUgbm9uLXplcm9cIiwgXCJ0aW1lb3V0XCIsIHRpbWVvdXQpO1xuICAgICAgICB0aGlzLiN0aW1lb3V0ID0gdGltZW91dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHByaW9yIHRvIGVhY2ggcmVxdWVzdCwgZm9yIGV4YW1wbGVcbiAgICAgKiAgZHVyaW5nIGEgcmVkaXJlY3Rpb24gb3IgcmV0cnkgaW4gY2FzZSBvZiBzZXJ2ZXIgdGhyb3R0bGluZy5cbiAgICAgKlxuICAgICAqICBUaGlzIG9mZmVycyBhbiBvcHBvcnR1bml0eSB0byBwb3B1bGF0ZSBoZWFkZXJzIG9yIHVwZGF0ZVxuICAgICAqICBjb250ZW50IGJlZm9yZSBzZW5kaW5nIGEgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBnZXQgcHJlZmxpZ2h0RnVuYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3ByZWZsaWdodCB8fCBudWxsO1xuICAgIH1cbiAgICBzZXQgcHJlZmxpZ2h0RnVuYyhwcmVmbGlnaHQpIHtcbiAgICAgICAgdGhpcy4jcHJlZmxpZ2h0ID0gcHJlZmxpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYWZ0ZXIgZWFjaCByZXNwb25zZSwgb2ZmZXJpbmcgYW5cbiAgICAgKiAgb3Bwb3J0dW5pdHkgdG8gcHJvdmlkZSBjbGllbnQtbGV2ZWwgdGhyb3R0bGluZyBvciB1cGRhdGluZ1xuICAgICAqICByZXNwb25zZSBkYXRhLlxuICAgICAqXG4gICAgICogIEFueSBlcnJvciB0aHJvd24gaW4gdGhpcyBjYXVzZXMgdGhlIGBgc2VuZCgpYGAgdG8gdGhyb3cuXG4gICAgICpcbiAgICAgKiAgVG8gc2NoZWR1bGUgYSByZXRyeSBhdHRlbXB0IChhc3N1bWluZyB0aGUgbWF4aW11bSByZXRyeSBsaW1pdFxuICAgICAqICBoYXMgbm90IGJlZW4gcmVhY2hlZCksIHVzZSBbW3Jlc3BvbnNlLnRocm93VGhyb3R0bGVFcnJvcl1dLlxuICAgICAqL1xuICAgIGdldCBwcm9jZXNzRnVuYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3Byb2Nlc3MgfHwgbnVsbDtcbiAgICB9XG4gICAgc2V0IHByb2Nlc3NGdW5jKHByb2Nlc3MpIHtcbiAgICAgICAgdGhpcy4jcHJvY2VzcyA9IHByb2Nlc3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBlYWNoIHJldHJ5IGF0dGVtcHQuXG4gICAgICovXG4gICAgZ2V0IHJldHJ5RnVuYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3JldHJ5IHx8IG51bGw7XG4gICAgfVxuICAgIHNldCByZXRyeUZ1bmMocmV0cnkpIHtcbiAgICAgICAgdGhpcy4jcmV0cnkgPSByZXRyeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHRvIGZldGNoIGNvbnRlbnQgZnJvbSBIVFRQIGFuZFxuICAgICAqICBIVFRQUyBVUkxzIGFuZCBpcyBwbGF0Zm9ybSBzcGVjaWZpYyAoZS5nLiBub2RlanMgdnNcbiAgICAgKiAgYnJvd3NlcnMpLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgYnkgZGVmYXVsdCB0aGUgY3VycmVudGx5IHJlZ2lzdGVyZWQgZ2xvYmFsIGdldFVybFxuICAgICAqICBmdW5jdGlvbiwgd2hpY2ggY2FuIGJlIGNoYW5nZWQgdXNpbmcgW1tyZWdpc3RlckdldFVybF1dLlxuICAgICAqICBJZiB0aGlzIGhhcyBiZWVuIHNldCwgc2V0dGluZyBpcyB0byBgYG51bGxgYCB3aWxsIGNhdXNlXG4gICAgICogIHRoaXMgRmV0Y2hSZXF1ZXN0IChhbmQgYW55IGZ1dHVyZSBjbG9uZXMpIHRvIHJldmVydCBiYWNrIHRvXG4gICAgICogIHVzaW5nIHRoZSBjdXJyZW50bHkgcmVnaXN0ZXJlZCBnbG9iYWwgZ2V0VXJsIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogIFNldHRpbmcgdGhpcyBpcyBnZW5lcmFsbHkgbm90IG5lY2Vzc2FyeSwgYnV0IG1heSBiZSB1c2VmdWxcbiAgICAgKiAgZm9yIGRldmVsb3BlcnMgdGhhdCB3aXNoIHRvIGludGVyY2VwdCByZXF1ZXN0cyBvciB0b1xuICAgICAqICBjb25maWd1cmVnZSBhIHByb3h5IG9yIG90aGVyIGFnZW50LlxuICAgICAqL1xuICAgIGdldCBnZXRVcmxGdW5jKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZ2V0VXJsRnVuYyB8fCBkZWZhdWx0R2V0VXJsRnVuYztcbiAgICB9XG4gICAgc2V0IGdldFVybEZ1bmModmFsdWUpIHtcbiAgICAgICAgdGhpcy4jZ2V0VXJsRnVuYyA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3IEZldGNoUmVxdWVzdCBpbnN0YW5jZSB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICAgICAqXG4gICAgICogIE9uY2UgY3JlYXRlZCwgZWFjaCBwcm9wZXJ0eSBtYXkgYmUgc2V0IGJlZm9yZSBpc3N1aW5nIGFcbiAgICAgKiAgYGAuc2VuZCgpYGAgdG8gbWFrZSB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih1cmwpIHtcbiAgICAgICAgdGhpcy4jdXJsID0gU3RyaW5nKHVybCk7XG4gICAgICAgIHRoaXMuI2FsbG93SW5zZWN1cmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jZ3ppcCA9IHRydWU7XG4gICAgICAgIHRoaXMuI2hlYWRlcnMgPSB7fTtcbiAgICAgICAgdGhpcy4jbWV0aG9kID0gXCJcIjtcbiAgICAgICAgdGhpcy4jdGltZW91dCA9IDMwMDAwMDtcbiAgICAgICAgdGhpcy4jdGhyb3R0bGUgPSB7XG4gICAgICAgICAgICBzbG90SW50ZXJ2YWw6IFNMT1RfSU5URVJWQUwsXG4gICAgICAgICAgICBtYXhBdHRlbXB0czogTUFYX0FUVEVNUFRTXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuI2dldFVybEZ1bmMgPSBudWxsO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGA8RmV0Y2hSZXF1ZXN0IG1ldGhvZD0ke0pTT04uc3RyaW5naWZ5KHRoaXMubWV0aG9kKX0gdXJsPSR7SlNPTi5zdHJpbmdpZnkodGhpcy51cmwpfSBoZWFkZXJzPSR7SlNPTi5zdHJpbmdpZnkodGhpcy5oZWFkZXJzKX0gYm9keT0ke3RoaXMuI2JvZHkgPyBoZXhsaWZ5KHRoaXMuI2JvZHkpIDogXCJudWxsXCJ9PmA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBVcGRhdGUgdGhlIHRocm90dGxlIHBhcmFtZXRlcnMgdXNlZCB0byBkZXRlcm1pbmUgbWF4aW11bVxuICAgICAqICBhdHRlbXB0cyBhbmQgZXhwb25lbnRpYWwtYmFja29mZiBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIHNldFRocm90dGxlUGFyYW1zKHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zLnNsb3RJbnRlcnZhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLiN0aHJvdHRsZS5zbG90SW50ZXJ2YWwgPSBwYXJhbXMuc2xvdEludGVydmFsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMubWF4QXR0ZW1wdHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy4jdGhyb3R0bGUubWF4QXR0ZW1wdHMgPSBwYXJhbXMubWF4QXR0ZW1wdHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgI3NlbmQoYXR0ZW1wdCwgZXhwaXJlcywgZGVsYXksIF9yZXF1ZXN0LCBfcmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKGF0dGVtcHQgPj0gdGhpcy4jdGhyb3R0bGUubWF4QXR0ZW1wdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVzcG9uc2UubWFrZVNlcnZlckVycm9yKFwiZXhjZWVkZWQgbWF4aW11bSByZXRyeSBsaW1pdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoZ2V0VGltZSgpIDw9IGV4cGlyZXMsIFwidGltZW91dFwiLCBcIlRJTUVPVVRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInJlcXVlc3Quc2VuZFwiLCByZWFzb246IFwidGltZW91dFwiLCByZXF1ZXN0OiBfcmVxdWVzdFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGRlbGF5ID4gMCkge1xuICAgICAgICAgICAgYXdhaXQgd2FpdChkZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlcSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgY29uc3Qgc2NoZW1lID0gKHJlcS51cmwuc3BsaXQoXCI6XCIpWzBdIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIC8vIFByb2Nlc3MgYW55IEdhdGV3YXlzXG4gICAgICAgIGlmIChzY2hlbWUgaW4gR2F0ZXdheXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IEdhdGV3YXlzW3NjaGVtZV0ocmVxLnVybCwgY2hlY2tTaWduYWwoX3JlcXVlc3QuI3NpZ25hbCkpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEZldGNoUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzcG9uc2UgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvY2Vzc0Z1bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tTaWduYWwoX3JlcXVlc3QuI3NpZ25hbCk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJvY2Vzc0Z1bmMocmVxLCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTb21ldGhpbmcgd2VudCB3cm9uZyBkdXJpbmcgcHJvY2Vzc2luZzsgdGhyb3cgYSA1eHggc2VydmVyIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IudGhyb3R0bGUgPT0gbnVsbCB8fCB0eXBlb2YgKGVycm9yLnN0YWxsKSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLm1ha2VTZXJ2ZXJFcnJvcihcImVycm9yIGluIHBvc3QtcHJvY2Vzc2luZyBmdW5jdGlvblwiLCBlcnJvcikuYXNzZXJ0T2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSB0aHJvdHRsaW5nXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGhhdmUgYSBwcmVmbGlnaHQgZnVuY3Rpb247IHVwZGF0ZSB0aGUgcmVxdWVzdFxuICAgICAgICBpZiAodGhpcy5wcmVmbGlnaHRGdW5jKSB7XG4gICAgICAgICAgICByZXEgPSBhd2FpdCB0aGlzLnByZWZsaWdodEZ1bmMocmVxKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwID0gYXdhaXQgdGhpcy5nZXRVcmxGdW5jKHJlcSwgY2hlY2tTaWduYWwoX3JlcXVlc3QuI3NpZ25hbCkpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBuZXcgRmV0Y2hSZXNwb25zZShyZXNwLnN0YXR1c0NvZGUsIHJlc3Auc3RhdHVzTWVzc2FnZSwgcmVzcC5oZWFkZXJzLCByZXNwLmJvZHksIF9yZXF1ZXN0KTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwMSB8fCByZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDIpIHtcbiAgICAgICAgICAgIC8vIFJlZGlyZWN0XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gcmVzcG9uc2UuaGVhZGVycy5sb2NhdGlvbiB8fCBcIlwiO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXEucmVkaXJlY3QobG9jYXRpb24pLiNzZW5kKGF0dGVtcHQgKyAxLCBleHBpcmVzLCAwLCBfcmVxdWVzdCwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIC8vIFRoaW5ncyB3b24ndCBnZXQgYW55IGJldHRlciBvbiBhbm90aGVyIGF0dGVtcHQ7IGFib3J0XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gNDI5KSB7XG4gICAgICAgICAgICAvLyBUaHJvdHRsZVxuICAgICAgICAgICAgaWYgKHRoaXMucmV0cnlGdW5jID09IG51bGwgfHwgKGF3YWl0IHRoaXMucmV0cnlGdW5jKHJlcSwgcmVzcG9uc2UsIGF0dGVtcHQpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldHJ5QWZ0ZXIgPSByZXNwb25zZS5oZWFkZXJzW1wicmV0cnktYWZ0ZXJcIl07XG4gICAgICAgICAgICAgICAgbGV0IGRlbGF5ID0gdGhpcy4jdGhyb3R0bGUuc2xvdEludGVydmFsICogTWF0aC50cnVuYyhNYXRoLnJhbmRvbSgpICogTWF0aC5wb3coMiwgYXR0ZW1wdCkpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHJldHJ5QWZ0ZXIpID09PSBcInN0cmluZ1wiICYmIHJldHJ5QWZ0ZXIubWF0Y2goL15bMS05XVswLTldKiQvKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxheSA9IHBhcnNlSW50KHJldHJ5QWZ0ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxLmNsb25lKCkuI3NlbmQoYXR0ZW1wdCArIDEsIGV4cGlyZXMsIGRlbGF5LCBfcmVxdWVzdCwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb2Nlc3NGdW5jKSB7XG4gICAgICAgICAgICBjaGVja1NpZ25hbChfcmVxdWVzdC4jc2lnbmFsKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByb2Nlc3NGdW5jKHJlcSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gU29tZXRoaW5nIHdlbnQgd3JvbmcgZHVyaW5nIHByb2Nlc3Npbmc7IHRocm93IGEgNXh4IHNlcnZlciBlcnJvclxuICAgICAgICAgICAgICAgIGlmIChlcnJvci50aHJvdHRsZSA9PSBudWxsIHx8IHR5cGVvZiAoZXJyb3Iuc3RhbGwpICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLm1ha2VTZXJ2ZXJFcnJvcihcImVycm9yIGluIHBvc3QtcHJvY2Vzc2luZyBmdW5jdGlvblwiLCBlcnJvcikuYXNzZXJ0T2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhyb3R0bGVcbiAgICAgICAgICAgICAgICBsZXQgZGVsYXkgPSB0aGlzLiN0aHJvdHRsZS5zbG90SW50ZXJ2YWwgKiBNYXRoLnRydW5jKE1hdGgucmFuZG9tKCkgKiBNYXRoLnBvdygyLCBhdHRlbXB0KSk7XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5zdGFsbCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGF5ID0gZXJyb3Iuc3RhbGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXEuY2xvbmUoKS4jc2VuZChhdHRlbXB0ICsgMSwgZXhwaXJlcywgZGVsYXksIF9yZXF1ZXN0LCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIHJlc3BvbnNlIGJ5IHNlbmRpbmcgdGhlIHJlcXVlc3QuXG4gICAgICovXG4gICAgc2VuZCgpIHtcbiAgICAgICAgYXNzZXJ0KHRoaXMuI3NpZ25hbCA9PSBudWxsLCBcInJlcXVlc3QgYWxyZWFkeSBzZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImZldGNoUmVxdWVzdC5zZW5kXCIgfSk7XG4gICAgICAgIHRoaXMuI3NpZ25hbCA9IG5ldyBGZXRjaENhbmNlbFNpZ25hbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3NlbmQoMCwgZ2V0VGltZSgpICsgdGhpcy50aW1lb3V0LCAwLCB0aGlzLCBuZXcgRmV0Y2hSZXNwb25zZSgwLCBcIlwiLCB7fSwgbnVsbCwgdGhpcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ2FuY2VscyB0aGUgaW5mbGlnaHQgcmVzcG9uc2UsIGNhdXNpbmcgYSBgYENBTkNFTExFRGBgXG4gICAgICogIGVycm9yIHRvIGJlIHJlamVjdGVkIGZyb20gdGhlIFtbc2VuZF1dLlxuICAgICAqL1xuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgYXNzZXJ0KHRoaXMuI3NpZ25hbCAhPSBudWxsLCBcInJlcXVlc3QgaGFzIG5vdCBiZWVuIHNlbnRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZmV0Y2hSZXF1ZXN0LmNhbmNlbFwiIH0pO1xuICAgICAgICBjb25zdCBzaWduYWwgPSBmZXRjaFNpZ25hbHMuZ2V0KHRoaXMpO1xuICAgICAgICBpZiAoIXNpZ25hbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBzaWduYWw7IHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHNpZ25hbCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZldGNoUmVxdWVzdF1dIHRoYXQgcmVwcmVzZW50cyB0aGUgcmVkaXJlY3Rpb25cbiAgICAgKiAgdG8gJSVsb2NhdGlvbiUlLlxuICAgICAqL1xuICAgIHJlZGlyZWN0KGxvY2F0aW9uKSB7XG4gICAgICAgIC8vIFJlZGlyZWN0aW9uOyBmb3Igbm93IHdlIG9ubHkgc3VwcG9ydCBhYnNvbHV0ZSBsb2NhdGlvbnNcbiAgICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMudXJsLnNwbGl0KFwiOlwiKVswXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBsb2NhdGlvbi5zcGxpdChcIjpcIilbMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgLy8gRG9uJ3QgYWxsb3cgcmVkaXJlY3Rpbmc6XG4gICAgICAgIC8vIC0gbm9uLUdFVCByZXF1ZXN0c1xuICAgICAgICAvLyAtIGRvd25ncmFkaW5nIHRoZSBzZWN1cml0eSAoZS5nLiBodHRwcyA9PiBodHRwKVxuICAgICAgICAvLyAtIHRvIG5vbi1IVFRQIChvciBub24tSFRUUFMpIHByb3RvY29scyBbdGhpcyBjb3VsZCBiZSByZWxheGVkP11cbiAgICAgICAgYXNzZXJ0KHRoaXMubWV0aG9kID09PSBcIkdFVFwiICYmIChjdXJyZW50ICE9PSBcImh0dHBzXCIgfHwgdGFyZ2V0ICE9PSBcImh0dHBcIikgJiYgbG9jYXRpb24ubWF0Y2goL15odHRwcz86LyksIGB1bnN1cHBvcnRlZCByZWRpcmVjdGAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogYHJlZGlyZWN0KCR7dGhpcy5tZXRob2R9ICR7SlNPTi5zdHJpbmdpZnkodGhpcy51cmwpfSA9PiAke0pTT04uc3RyaW5naWZ5KGxvY2F0aW9uKX0pYFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ3JlYXRlIGEgY29weSBvZiB0aGlzIHJlcXVlc3QsIHdpdGggYSBuZXcgVVJMXG4gICAgICAgIGNvbnN0IHJlcSA9IG5ldyBGZXRjaFJlcXVlc3QobG9jYXRpb24pO1xuICAgICAgICByZXEubWV0aG9kID0gXCJHRVRcIjtcbiAgICAgICAgcmVxLmFsbG93R3ppcCA9IHRoaXMuYWxsb3dHemlwO1xuICAgICAgICByZXEudGltZW91dCA9IHRoaXMudGltZW91dDtcbiAgICAgICAgcmVxLiNoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy4jaGVhZGVycyk7XG4gICAgICAgIGlmICh0aGlzLiNib2R5KSB7XG4gICAgICAgICAgICByZXEuI2JvZHkgPSBuZXcgVWludDhBcnJheSh0aGlzLiNib2R5KTtcbiAgICAgICAgfVxuICAgICAgICByZXEuI2JvZHlUeXBlID0gdGhpcy4jYm9keVR5cGU7XG4gICAgICAgIC8vIERvIG5vdCBmb3J3YXJkIGNyZWRlbnRpYWxzIHVubGVzcyBvbiB0aGUgc2FtZSBkb21haW47IG9ubHkgYWJzb2x1dGVcbiAgICAgICAgLy9yZXEuYWxsb3dJbnNlY3VyZSA9IGZhbHNlO1xuICAgICAgICAvLyBwYXRocyBhcmUgY3VycmVudGx5IHN1cHBvcnRlZDsgbWF5IHdhbnQgYSB3YXkgdG8gc3BlY2lmeSB0byBmb3J3YXJkP1xuICAgICAgICAvL3NldFN0b3JlKHJlcS4jcHJvcHMsIFwiY3JlZHNcIiwgZ2V0U3RvcmUodGhpcy4jcHJvcywgXCJjcmVkc1wiKSk7XG4gICAgICAgIHJldHVybiByZXE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgY29weSBvZiB0aGlzIHJlcXVlc3QuXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IGNsb25lID0gbmV3IEZldGNoUmVxdWVzdCh0aGlzLnVybCk7XG4gICAgICAgIC8vIFByZXNlcnZlIFwiZGVmYXVsdCBtZXRob2RcIiAoaS5lLiBudWxsKVxuICAgICAgICBjbG9uZS4jbWV0aG9kID0gdGhpcy4jbWV0aG9kO1xuICAgICAgICAvLyBQcmVzZXJ2ZSBcImRlZmF1bHQgYm9keVwiIHdpdGggdHlwZSwgY29weWluZyB0aGUgVWludDhBcnJheSBpcyBwcmVzZW50XG4gICAgICAgIGlmICh0aGlzLiNib2R5KSB7XG4gICAgICAgICAgICBjbG9uZS4jYm9keSA9IHRoaXMuI2JvZHk7XG4gICAgICAgIH1cbiAgICAgICAgY2xvbmUuI2JvZHlUeXBlID0gdGhpcy4jYm9keVR5cGU7XG4gICAgICAgIC8vIFByZXNlcnZlIFwiZGVmYXVsdCBoZWFkZXJzXCJcbiAgICAgICAgY2xvbmUuI2hlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLiNoZWFkZXJzKTtcbiAgICAgICAgLy8gQ3JlZGVudGlhbHMgaXMgcmVhZG9ubHksIHNvIHdlIGNvcHkgaW50ZXJuYWxseVxuICAgICAgICBjbG9uZS4jY3JlZHMgPSB0aGlzLiNjcmVkcztcbiAgICAgICAgaWYgKHRoaXMuYWxsb3dHemlwKSB7XG4gICAgICAgICAgICBjbG9uZS5hbGxvd0d6aXAgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNsb25lLnRpbWVvdXQgPSB0aGlzLnRpbWVvdXQ7XG4gICAgICAgIGlmICh0aGlzLmFsbG93SW5zZWN1cmVBdXRoZW50aWNhdGlvbikge1xuICAgICAgICAgICAgY2xvbmUuYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjbG9uZS4jcHJlZmxpZ2h0ID0gdGhpcy4jcHJlZmxpZ2h0O1xuICAgICAgICBjbG9uZS4jcHJvY2VzcyA9IHRoaXMuI3Byb2Nlc3M7XG4gICAgICAgIGNsb25lLiNyZXRyeSA9IHRoaXMuI3JldHJ5O1xuICAgICAgICBjbG9uZS4jdGhyb3R0bGUgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLiN0aHJvdHRsZSk7XG4gICAgICAgIGNsb25lLiNnZXRVcmxGdW5jID0gdGhpcy4jZ2V0VXJsRnVuYztcbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgTG9ja3MgYWxsIHN0YXRpYyBjb25maWd1cmF0aW9uIGZvciBnYXRld2F5cyBhbmQgRmV0Y2hHZXRVcmxGdW5jXG4gICAgICogIHJlZ2lzdHJhdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgbG9ja0NvbmZpZygpIHtcbiAgICAgICAgbG9ja2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgY3VycmVudCBHYXRld2F5IGZ1bmN0aW9uIGZvciAlJXNjaGVtZSUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRHYXRld2F5KHNjaGVtZSkge1xuICAgICAgICByZXR1cm4gR2F0ZXdheXNbc2NoZW1lLnRvTG93ZXJDYXNlKCldIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBVc2UgdGhlICUlZnVuYyUlIHdoZW4gZmV0Y2hpbmcgVVJJcyB1c2luZyAlJXNjaGVtZSUlLlxuICAgICAqXG4gICAgICogIFRoaXMgbWV0aG9kIGFmZmVjdHMgYWxsIHJlcXVlc3RzIGdsb2JhbGx5LlxuICAgICAqXG4gICAgICogIElmIFtbbG9ja0NvbmZpZ11dIGhhcyBiZWVuIGNhbGxlZCwgbm8gY2hhbmdlIGlzIG1hZGUgYW5kIHRoaXNcbiAgICAgKiAgdGhyb3dzLlxuICAgICAqL1xuICAgIHN0YXRpYyByZWdpc3RlckdhdGV3YXkoc2NoZW1lLCBmdW5jKSB7XG4gICAgICAgIHNjaGVtZSA9IHNjaGVtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoc2NoZW1lID09PSBcImh0dHBcIiB8fCBzY2hlbWUgPT09IFwiaHR0cHNcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgaW50ZXJjZXB0ICR7c2NoZW1lfTsgdXNlIHJlZ2lzdGVyR2V0VXJsYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2tlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2F0ZXdheXMgbG9ja2VkXCIpO1xuICAgICAgICB9XG4gICAgICAgIEdhdGV3YXlzW3NjaGVtZV0gPSBmdW5jO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVXNlICUlZ2V0VXJsJSUgd2hlbiBmZXRjaGluZyBVUklzIG92ZXIgSFRUUCBhbmQgSFRUUFMgcmVxdWVzdHMuXG4gICAgICpcbiAgICAgKiAgVGhpcyBtZXRob2QgYWZmZWN0cyBhbGwgcmVxdWVzdHMgZ2xvYmFsbHkuXG4gICAgICpcbiAgICAgKiAgSWYgW1tsb2NrQ29uZmlnXV0gaGFzIGJlZW4gY2FsbGVkLCBubyBjaGFuZ2UgaXMgbWFkZSBhbmQgdGhpc1xuICAgICAqICB0aHJvd3MuXG4gICAgICovXG4gICAgc3RhdGljIHJlZ2lzdGVyR2V0VXJsKGdldFVybCkge1xuICAgICAgICBpZiAobG9ja2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnYXRld2F5cyBsb2NrZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdEdldFVybEZ1bmMgPSBnZXRVcmw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgZ2V0VXJsIGZ1bmN0aW9uIHRoYXQgZmV0Y2hlcyBjb250ZW50IGZyb20gSFRUUCBhbmRcbiAgICAgKiAgSFRUUFMgVVJMcy5cbiAgICAgKlxuICAgICAqICBUaGUgYXZhaWxhYmxlICUlb3B0aW9ucyUlIGFyZSBkZXBlbmRlbnQgb24gdGhlIHBsYXRmb3JtXG4gICAgICogIGltcGxlbWVudGF0aW9uIG9mIHRoZSBkZWZhdWx0IGdldFVybCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIG5vdCBnZW5lcmFsbHkgc29tZXRoaW5nIHRoYXQgaXMgbmVlZGVkLCBidXQgaXMgdXNlZnVsXG4gICAgICogIHdoZW4gdHJ5aW5nIHRvIGN1c3RvbWl6ZSBzaW1wbGUgYmVoYXZpb3VyIHdoZW4gZmV0Y2hpbmcgSFRUUFxuICAgICAqICBjb250ZW50LlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVHZXRVcmxGdW5jKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUdldFVybChvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGNhbiBcImZldGNoXCIgZGF0YSBVUklzLlxuICAgICAqXG4gICAgICogIE5vdGUgdGhhdCB0aGlzIGlzIGF1dG9tYXRpY2FsbHkgZG9uZSBpbnRlcm5hbGx5IHRvIHN1cHBvcnRcbiAgICAgKiAgZGF0YSBVUklzLCBzbyBpdCBpcyBub3QgbmVjZXNzYXJ5IHRvIHJlZ2lzdGVyIGl0LlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgbm90IGdlbmVyYWxseSBzb21ldGhpbmcgdGhhdCBpcyBuZWVkZWQsIGJ1dCBtYXlcbiAgICAgKiAgYmUgdXNlZnVsIGluIGEgd3JhcHBlciB0byBwZXJmb20gY3VzdG9tIGRhdGEgVVJJIGZ1bmN0aW9uYWxpdHkuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZURhdGFHYXRld2F5KCkge1xuICAgICAgICByZXR1cm4gZGF0YUdhdGV3YXlGdW5jO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBmZXRjaCBJUEZTICh1bnZhbGlkYXRlZCkgZnJvbVxuICAgICAqICBhIGN1c3RvbSBnYXRld2F5IGJhc2VVcmwuXG4gICAgICpcbiAgICAgKiAgVGhlIGRlZmF1bHQgSVBGUyBnYXRld2F5IHVzZWQgaW50ZXJuYWxseSBpc1xuICAgICAqICBgYFwiaHR0cHM6L1xcL2dhdGV3YXkuaXBmcy5pby9pcGZzL1wiYGAuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUlwZnNHYXRld2F5RnVuYyhiYXNlVXJsKSB7XG4gICAgICAgIHJldHVybiBnZXRJcGZzR2F0ZXdheUZ1bmMoYmFzZVVybCk7XG4gICAgfVxufVxuO1xuLyoqXG4gKiAgVGhlIHJlc3BvbnNlIGZvciBhIEZldGNoUmVxdWVzdC5cbiAqL1xuZXhwb3J0IGNsYXNzIEZldGNoUmVzcG9uc2Uge1xuICAgICNzdGF0dXNDb2RlO1xuICAgICNzdGF0dXNNZXNzYWdlO1xuICAgICNoZWFkZXJzO1xuICAgICNib2R5O1xuICAgICNyZXF1ZXN0O1xuICAgICNlcnJvcjtcbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGA8RmV0Y2hSZXNwb25zZSBzdGF0dXM9JHt0aGlzLnN0YXR1c0NvZGV9IGJvZHk9JHt0aGlzLiNib2R5ID8gaGV4bGlmeSh0aGlzLiNib2R5KSA6IFwibnVsbFwifT5gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHJlc3BvbnNlIHN0YXR1cyBjb2RlLlxuICAgICAqL1xuICAgIGdldCBzdGF0dXNDb2RlKCkgeyByZXR1cm4gdGhpcy4jc3RhdHVzQ29kZTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcmVzcG9uc2Ugc3RhdHVzIG1lc3NhZ2UuXG4gICAgICovXG4gICAgZ2V0IHN0YXR1c01lc3NhZ2UoKSB7IHJldHVybiB0aGlzLiNzdGF0dXNNZXNzYWdlOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSByZXNwb25zZSBoZWFkZXJzLiBBbGwga2V5cyBhcmUgbG93ZXItY2FzZS5cbiAgICAgKi9cbiAgICBnZXQgaGVhZGVycygpIHsgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRoaXMuI2hlYWRlcnMpOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSByZXNwb25zZSBib2R5LCBvciBgYG51bGxgYCBpZiB0aGVyZSB3YXMgbm8gYm9keS5cbiAgICAgKi9cbiAgICBnZXQgYm9keSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNib2R5ID09IG51bGwpID8gbnVsbCA6IG5ldyBVaW50OEFycmF5KHRoaXMuI2JvZHkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHJlc3BvbnNlIGJvZHkgYXMgYSBVVEYtOCBlbmNvZGVkIHN0cmluZywgb3IgdGhlIGVtcHR5XG4gICAgICogIHN0cmluZyAoaS5lLiBgYFwiXCJgYCkgaWYgdGhlcmUgd2FzIG5vIGJvZHkuXG4gICAgICpcbiAgICAgKiAgQW4gZXJyb3IgaXMgdGhyb3duIGlmIHRoZSBib2R5IGlzIGludmFsaWQgVVRGLTggZGF0YS5cbiAgICAgKi9cbiAgICBnZXQgYm9keVRleHQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuI2JvZHkgPT0gbnVsbCkgPyBcIlwiIDogdG9VdGY4U3RyaW5nKHRoaXMuI2JvZHkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInJlc3BvbnNlIGJvZHkgaXMgbm90IHZhbGlkIFVURi04IGRhdGFcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJib2R5VGV4dFwiLCBpbmZvOiB7IHJlc3BvbnNlOiB0aGlzIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcmVzcG9uc2UgYm9keSwgZGVjb2RlZCBhcyBKU09OLlxuICAgICAqXG4gICAgICogIEFuIGVycm9yIGlzIHRocm93biBpZiB0aGUgYm9keSBpcyBpbnZhbGlkIEpTT04tZW5jb2RlZCBkYXRhXG4gICAgICogIG9yIGlmIHRoZXJlIHdhcyBubyBib2R5LlxuICAgICAqL1xuICAgIGdldCBib2R5SnNvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRoaXMuYm9keVRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInJlc3BvbnNlIGJvZHkgaXMgbm90IHZhbGlkIEpTT05cIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJib2R5SnNvblwiLCBpbmZvOiB7IHJlc3BvbnNlOiB0aGlzIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5oZWFkZXJzO1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaGVhZGVycyk7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwga2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBba2V5LCBoZWFkZXJzW2tleV1dLCBkb25lOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHN0YXR1c0NvZGUsIHN0YXR1c01lc3NhZ2UsIGhlYWRlcnMsIGJvZHksIHJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy4jc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgICAgIHRoaXMuI3N0YXR1c01lc3NhZ2UgPSBzdGF0dXNNZXNzYWdlO1xuICAgICAgICB0aGlzLiNoZWFkZXJzID0gT2JqZWN0LmtleXMoaGVhZGVycykucmVkdWNlKChhY2N1bSwgaykgPT4ge1xuICAgICAgICAgICAgYWNjdW1bay50b0xvd2VyQ2FzZSgpXSA9IFN0cmluZyhoZWFkZXJzW2tdKTtcbiAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICB0aGlzLiNib2R5ID0gKChib2R5ID09IG51bGwpID8gbnVsbCA6IG5ldyBVaW50OEFycmF5KGJvZHkpKTtcbiAgICAgICAgdGhpcy4jcmVxdWVzdCA9IChyZXF1ZXN0IHx8IG51bGwpO1xuICAgICAgICB0aGlzLiNlcnJvciA9IHsgbWVzc2FnZTogXCJcIiB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgUmVzcG9uc2Ugd2l0aCBtYXRjaGluZyBoZWFkZXJzIGFuZCBib2R5LCBidXQgd2l0aFxuICAgICAqICBhbiBlcnJvciBzdGF0dXMgY29kZSAoaS5lLiA1OTkpIGFuZCAlJW1lc3NhZ2UlJSB3aXRoIGFuXG4gICAgICogIG9wdGlvbmFsICUlZXJyb3IlJS5cbiAgICAgKi9cbiAgICBtYWtlU2VydmVyRXJyb3IobWVzc2FnZSwgZXJyb3IpIHtcbiAgICAgICAgbGV0IHN0YXR1c01lc3NhZ2U7XG4gICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IGAke3RoaXMuc3RhdHVzQ29kZX0gJHt0aGlzLnN0YXR1c01lc3NhZ2V9YDtcbiAgICAgICAgICAgIHN0YXR1c01lc3NhZ2UgPSBgQ0xJRU5UIEVTQ0FMQVRFRCBTRVJWRVIgRVJST1IgKCR7bWVzc2FnZX0pYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXR1c01lc3NhZ2UgPSBgQ0xJRU5UIEVTQ0FMQVRFRCBTRVJWRVIgRVJST1IgKCR7dGhpcy5zdGF0dXNDb2RlfSAke3RoaXMuc3RhdHVzTWVzc2FnZX07ICR7bWVzc2FnZX0pYDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IG5ldyBGZXRjaFJlc3BvbnNlKDU5OSwgc3RhdHVzTWVzc2FnZSwgdGhpcy5oZWFkZXJzLCB0aGlzLmJvZHksIHRoaXMuI3JlcXVlc3QgfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgcmVzcG9uc2UuI2Vycm9yID0geyBtZXNzYWdlLCBlcnJvciB9O1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJZiBjYWxsZWQgd2l0aGluIGEgW3JlcXVlc3QucHJvY2Vzc0Z1bmNdKEZldGNoUmVxdWVzdC1wcm9jZXNzRnVuYylcbiAgICAgKiAgY2FsbCwgY2F1c2VzIHRoZSByZXF1ZXN0IHRvIHJldHJ5IGFzIGlmIHRocm90dGxlZCBmb3IgJSVzdGFsbCUlXG4gICAgICogIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICB0aHJvd1Rocm90dGxlRXJyb3IobWVzc2FnZSwgc3RhbGwpIHtcbiAgICAgICAgaWYgKHN0YWxsID09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YWxsID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChOdW1iZXIuaXNJbnRlZ2VyKHN0YWxsKSAmJiBzdGFsbCA+PSAwLCBcImludmFsaWQgc3RhbGwgdGltZW91dFwiLCBcInN0YWxsXCIsIHN0YWxsKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlIHx8IFwidGhyb3R0bGluZyByZXF1ZXN0c1wiKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyhlcnJvciwgeyBzdGFsbCwgdGhyb3R0bGU6IHRydWUgfSk7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSBoZWFkZXIgdmFsdWUgZm9yICUla2V5JSUsIGlnbm9yaW5nIGNhc2UuXG4gICAgICovXG4gICAgZ2V0SGVhZGVyKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGUgcmVzcG9uc2UgaGFzIGEgYm9keS5cbiAgICAgKi9cbiAgICBoYXNCb2R5KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI2JvZHkgIT0gbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcmVxdWVzdCBtYWRlIGZvciB0aGlzIHJlc3BvbnNlLlxuICAgICAqL1xuICAgIGdldCByZXF1ZXN0KCkgeyByZXR1cm4gdGhpcy4jcmVxdWVzdDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyByZXNwb25zZSB3YXMgYSBzdWNjZXNzIHN0YXR1c0NvZGUuXG4gICAgICovXG4gICAgb2soKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jZXJyb3IubWVzc2FnZSA9PT0gXCJcIiAmJiB0aGlzLnN0YXR1c0NvZGUgPj0gMjAwICYmIHRoaXMuc3RhdHVzQ29kZSA8IDMwMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaHJvd3MgYSBgYFNFUlZFUl9FUlJPUmBgIGlmIHRoaXMgcmVzcG9uc2UgaXMgbm90IG9rLlxuICAgICAqL1xuICAgIGFzc2VydE9rKCkge1xuICAgICAgICBpZiAodGhpcy5vaygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgbWVzc2FnZSwgZXJyb3IgfSA9IHRoaXMuI2Vycm9yO1xuICAgICAgICBpZiAobWVzc2FnZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgbWVzc2FnZSA9IGBzZXJ2ZXIgcmVzcG9uc2UgJHt0aGlzLnN0YXR1c0NvZGV9ICR7dGhpcy5zdGF0dXNNZXNzYWdlfWA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlcXVlc3RVcmwgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5yZXF1ZXN0KSB7XG4gICAgICAgICAgICByZXF1ZXN0VXJsID0gdGhpcy5yZXF1ZXN0LnVybDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2VCb2R5ID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNib2R5KSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VCb2R5ID0gdG9VdGY4U3RyaW5nKHRoaXMuI2JvZHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBtZXNzYWdlLCBcIlNFUlZFUl9FUlJPUlwiLCB7XG4gICAgICAgICAgICByZXF1ZXN0OiAodGhpcy5yZXF1ZXN0IHx8IFwidW5rbm93biByZXF1ZXN0XCIpLCByZXNwb25zZTogdGhpcywgZXJyb3IsXG4gICAgICAgICAgICBpbmZvOiB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdFVybCwgcmVzcG9uc2VCb2R5LFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlU3RhdHVzOiBgJHt0aGlzLnN0YXR1c0NvZGV9ICR7dGhpcy5zdGF0dXNNZXNzYWdlfWBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0VGltZSgpIHsgcmV0dXJuIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7IH1cbmZ1bmN0aW9uIHVucGVyY2VudCh2YWx1ZSkge1xuICAgIHJldHVybiB0b1V0ZjhCeXRlcyh2YWx1ZS5yZXBsYWNlKC8lKFswLTlhLWZdWzAtOWEtZl0pL2dpLCAoYWxsLCBjb2RlKSA9PiB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGNvZGUsIDE2KSk7XG4gICAgfSkpO1xufVxuZnVuY3Rpb24gd2FpdChkZWxheSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmV0Y2guanMubWFwIl0sIm5hbWVzIjpbImRlY29kZUJhc2U2NCIsImVuY29kZUJhc2U2NCIsImhleGxpZnkiLCJhc3NlcnQiLCJhc3NlcnRBcmd1bWVudCIsImRlZmluZVByb3BlcnRpZXMiLCJ0b1V0ZjhCeXRlcyIsInRvVXRmOFN0cmluZyIsImNyZWF0ZUdldFVybCIsIk1BWF9BVFRFTVBUUyIsIlNMT1RfSU5URVJWQUwiLCJkZWZhdWx0R2V0VXJsRnVuYyIsInJlRGF0YSIsIlJlZ0V4cCIsInJlSXBmcyIsImxvY2tlZCIsImRhdGFHYXRld2F5RnVuYyIsInVybCIsInNpZ25hbCIsIm1hdGNoIiwiRXJyb3IiLCJGZXRjaFJlc3BvbnNlIiwidW5wZXJjZW50IiwiZXJyb3IiLCJGZXRjaFJlcXVlc3QiLCJnZXRJcGZzR2F0ZXdheUZ1bmMiLCJiYXNlVXJsIiwiZ2F0ZXdheUlwZnMiLCJHYXRld2F5cyIsImZldGNoU2lnbmFscyIsIldlYWtNYXAiLCJGZXRjaENhbmNlbFNpZ25hbCIsImFkZExpc3RlbmVyIiwibGlzdGVuZXIiLCJjYW5jZWxsZWQiLCJvcGVyYXRpb24iLCJsaXN0ZW5lcnMiLCJwdXNoIiwiY2hlY2tTaWduYWwiLCJjb25zdHJ1Y3RvciIsInJlcXVlc3QiLCJzZXQiLCJzZXRUaW1lb3V0IiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJTdHJpbmciLCJib2R5IiwiVWludDhBcnJheSIsInVuZGVmaW5lZCIsImJvZHlUeXBlIiwiSlNPTiIsInN0cmluZ2lmeSIsImhhc0JvZHkiLCJtZXRob2QiLCJ0b1VwcGVyQ2FzZSIsImhlYWRlcnMiLCJPYmplY3QiLCJhc3NpZ24iLCJjcmVkcyIsImFsbG93R3ppcCIsImxlbmd0aCIsImdldEhlYWRlciIsImtleSIsInRvTG93ZXJDYXNlIiwic2V0SGVhZGVyIiwidmFsdWUiLCJjbGVhckhlYWRlcnMiLCJrZXlzIiwiaW5kZXgiLCJuZXh0IiwiZG9uZSIsImNyZWRlbnRpYWxzIiwic2V0Q3JlZGVudGlhbHMiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwiZ3ppcCIsImFsbG93SW5zZWN1cmVBdXRoZW50aWNhdGlvbiIsImFsbG93SW5zZWN1cmUiLCJ0aW1lb3V0IiwicHJlZmxpZ2h0RnVuYyIsInByZWZsaWdodCIsInByb2Nlc3NGdW5jIiwicHJvY2VzcyIsInJldHJ5RnVuYyIsInJldHJ5IiwiZ2V0VXJsRnVuYyIsInRvU3RyaW5nIiwic2V0VGhyb3R0bGVQYXJhbXMiLCJwYXJhbXMiLCJzbG90SW50ZXJ2YWwiLCJ0aHJvdHRsZSIsIm1heEF0dGVtcHRzIiwic2VuZCIsImdldFRpbWUiLCJjYW5jZWwiLCJnZXQiLCJyZWRpcmVjdCIsImxvY2F0aW9uIiwiY3VycmVudCIsInNwbGl0IiwidGFyZ2V0IiwicmVxIiwiY2xvbmUiLCJsb2NrQ29uZmlnIiwiZ2V0R2F0ZXdheSIsInNjaGVtZSIsInJlZ2lzdGVyR2F0ZXdheSIsImZ1bmMiLCJyZWdpc3RlckdldFVybCIsImdldFVybCIsImNyZWF0ZUdldFVybEZ1bmMiLCJvcHRpb25zIiwiY3JlYXRlRGF0YUdhdGV3YXkiLCJjcmVhdGVJcGZzR2F0ZXdheUZ1bmMiLCJhdHRlbXB0IiwiZXhwaXJlcyIsImRlbGF5IiwiX3JlcXVlc3QiLCJfcmVzcG9uc2UiLCJtYWtlU2VydmVyRXJyb3IiLCJyZWFzb24iLCJ3YWl0IiwicmVzdWx0IiwicmVzcG9uc2UiLCJzdGFsbCIsImFzc2VydE9rIiwicmVzcCIsInN0YXR1c0NvZGUiLCJzdGF0dXNNZXNzYWdlIiwicmV0cnlBZnRlciIsIk1hdGgiLCJ0cnVuYyIsInJhbmRvbSIsInBvdyIsInBhcnNlSW50IiwiYm9keVRleHQiLCJpbmZvIiwiYm9keUpzb24iLCJwYXJzZSIsIm1lc3NhZ2UiLCJ0aHJvd1Rocm90dGxlRXJyb3IiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJvayIsInJlcXVlc3RVcmwiLCJyZXNwb25zZUJvZHkiLCJlIiwicmVzcG9uc2VTdGF0dXMiLCJyZWR1Y2UiLCJhY2N1bSIsImsiLCJEYXRlIiwicmVwbGFjZSIsImFsbCIsImNvZGUiLCJmcm9tQ2hhckNvZGUiLCJQcm9taXNlIiwicmVzb2x2ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/utils/fetch.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/utils/geturl-browser.js":
/*!*************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/geturl-browser.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createGetUrl: function() { return /* binding */ createGetUrl; },\n/* harmony export */   getUrl: function() { return /* binding */ getUrl; }\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n\nfunction createGetUrl(options) {\n    async function getUrl(req, _signal) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(_signal == null || !_signal.cancelled, \"request cancelled before sending\", \"CANCELLED\");\n        const protocol = req.url.split(\":\")[0].toLowerCase();\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(protocol === \"http\" || protocol === \"https\", \"unsupported protocol \".concat(protocol), \"UNSUPPORTED_OPERATION\", {\n            info: {\n                protocol\n            },\n            operation: \"request\"\n        });\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(protocol === \"https\" || !req.credentials || req.allowInsecureAuthentication, \"insecure authorized connections unsupported\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"request\"\n        });\n        let error = null;\n        const controller = new AbortController();\n        const timer = setTimeout(()=>{\n            error = (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.makeError)(\"request timeout\", \"TIMEOUT\");\n            controller.abort();\n        }, req.timeout);\n        if (_signal) {\n            _signal.addListener(()=>{\n                error = (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.makeError)(\"request cancelled\", \"CANCELLED\");\n                controller.abort();\n            });\n        }\n        const init = Object.assign({}, options, {\n            method: req.method,\n            headers: new Headers(Array.from(req)),\n            body: req.body || undefined,\n            signal: controller.signal\n        });\n        let resp;\n        try {\n            resp = await fetch(req.url, init);\n        } catch (_error) {\n            clearTimeout(timer);\n            if (error) {\n                throw error;\n            }\n            throw _error;\n        }\n        clearTimeout(timer);\n        const headers = {};\n        resp.headers.forEach((value, key)=>{\n            headers[key.toLowerCase()] = value;\n        });\n        const respBody = await resp.arrayBuffer();\n        const body = respBody == null ? null : new Uint8Array(respBody);\n        return {\n            statusCode: resp.status,\n            statusMessage: resp.statusText,\n            headers,\n            body\n        };\n    }\n    return getUrl;\n}\n// @TODO: remove in v7; provided for backwards compat\nconst defaultGetUrl = createGetUrl({});\nasync function getUrl(req, _signal) {\n    return defaultGetUrl(req, _signal);\n} //# sourceMappingURL=geturl-browser.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9nZXR1cmwtYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBZ0Q7QUFDekMsU0FBU0UsYUFBYUMsT0FBTztJQUNoQyxlQUFlQyxPQUFPQyxHQUFHLEVBQUVDLE9BQU87UUFDOUJOLGtEQUFNQSxDQUFDTSxXQUFXLFFBQVEsQ0FBQ0EsUUFBUUMsU0FBUyxFQUFFLG9DQUFvQztRQUNsRixNQUFNQyxXQUFXSCxJQUFJSSxHQUFHLENBQUNDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDQyxXQUFXO1FBQ2xEWCxrREFBTUEsQ0FBQ1EsYUFBYSxVQUFVQSxhQUFhLFNBQVMsd0JBQWlDLE9BQVRBLFdBQVkseUJBQXlCO1lBQzdHSSxNQUFNO2dCQUFFSjtZQUFTO1lBQ2pCSyxXQUFXO1FBQ2Y7UUFDQWIsa0RBQU1BLENBQUNRLGFBQWEsV0FBVyxDQUFDSCxJQUFJUyxXQUFXLElBQUlULElBQUlVLDJCQUEyQixFQUFFLCtDQUErQyx5QkFBeUI7WUFDeEpGLFdBQVc7UUFDZjtRQUNBLElBQUlHLFFBQVE7UUFDWixNQUFNQyxhQUFhLElBQUlDO1FBQ3ZCLE1BQU1DLFFBQVFDLFdBQVc7WUFDckJKLFFBQVFmLHFEQUFTQSxDQUFDLG1CQUFtQjtZQUNyQ2dCLFdBQVdJLEtBQUs7UUFDcEIsR0FBR2hCLElBQUlpQixPQUFPO1FBQ2QsSUFBSWhCLFNBQVM7WUFDVEEsUUFBUWlCLFdBQVcsQ0FBQztnQkFDaEJQLFFBQVFmLHFEQUFTQSxDQUFDLHFCQUFxQjtnQkFDdkNnQixXQUFXSSxLQUFLO1lBQ3BCO1FBQ0o7UUFDQSxNQUFNRyxPQUFPQyxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHdkIsU0FBUztZQUNwQ3dCLFFBQVF0QixJQUFJc0IsTUFBTTtZQUNsQkMsU0FBUyxJQUFJQyxRQUFRQyxNQUFNQyxJQUFJLENBQUMxQjtZQUNoQzJCLE1BQU0zQixJQUFJMkIsSUFBSSxJQUFJQztZQUNsQkMsUUFBUWpCLFdBQVdpQixNQUFNO1FBQzdCO1FBQ0EsSUFBSUM7UUFDSixJQUFJO1lBQ0FBLE9BQU8sTUFBTUMsTUFBTS9CLElBQUlJLEdBQUcsRUFBRWU7UUFDaEMsRUFDQSxPQUFPYSxRQUFRO1lBQ1hDLGFBQWFuQjtZQUNiLElBQUlILE9BQU87Z0JBQ1AsTUFBTUE7WUFDVjtZQUNBLE1BQU1xQjtRQUNWO1FBQ0FDLGFBQWFuQjtRQUNiLE1BQU1TLFVBQVUsQ0FBQztRQUNqQk8sS0FBS1AsT0FBTyxDQUFDVyxPQUFPLENBQUMsQ0FBQ0MsT0FBT0M7WUFDekJiLE9BQU8sQ0FBQ2EsSUFBSTlCLFdBQVcsR0FBRyxHQUFHNkI7UUFDakM7UUFDQSxNQUFNRSxXQUFXLE1BQU1QLEtBQUtRLFdBQVc7UUFDdkMsTUFBTVgsT0FBTyxZQUFhLE9BQVEsT0FBTyxJQUFJWSxXQUFXRjtRQUN4RCxPQUFPO1lBQ0hHLFlBQVlWLEtBQUtXLE1BQU07WUFDdkJDLGVBQWVaLEtBQUthLFVBQVU7WUFDOUJwQjtZQUFTSTtRQUNiO0lBQ0o7SUFDQSxPQUFPNUI7QUFDWDtBQUNBLHFEQUFxRDtBQUNyRCxNQUFNNkMsZ0JBQWdCL0MsYUFBYSxDQUFDO0FBQzdCLGVBQWVFLE9BQU9DLEdBQUcsRUFBRUMsT0FBTztJQUNyQyxPQUFPMkMsY0FBYzVDLEtBQUtDO0FBQzlCLEVBQ0EsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9nZXR1cmwtYnJvd3Nlci5qcz83NmExIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFzc2VydCwgbWFrZUVycm9yIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlR2V0VXJsKG9wdGlvbnMpIHtcbiAgICBhc3luYyBmdW5jdGlvbiBnZXRVcmwocmVxLCBfc2lnbmFsKSB7XG4gICAgICAgIGFzc2VydChfc2lnbmFsID09IG51bGwgfHwgIV9zaWduYWwuY2FuY2VsbGVkLCBcInJlcXVlc3QgY2FuY2VsbGVkIGJlZm9yZSBzZW5kaW5nXCIsIFwiQ0FOQ0VMTEVEXCIpO1xuICAgICAgICBjb25zdCBwcm90b2NvbCA9IHJlcS51cmwuc3BsaXQoXCI6XCIpWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGFzc2VydChwcm90b2NvbCA9PT0gXCJodHRwXCIgfHwgcHJvdG9jb2wgPT09IFwiaHR0cHNcIiwgYHVuc3VwcG9ydGVkIHByb3RvY29sICR7cHJvdG9jb2x9YCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgaW5mbzogeyBwcm90b2NvbCB9LFxuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInJlcXVlc3RcIlxuICAgICAgICB9KTtcbiAgICAgICAgYXNzZXJ0KHByb3RvY29sID09PSBcImh0dHBzXCIgfHwgIXJlcS5jcmVkZW50aWFscyB8fCByZXEuYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uLCBcImluc2VjdXJlIGF1dGhvcml6ZWQgY29ubmVjdGlvbnMgdW5zdXBwb3J0ZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInJlcXVlc3RcIlxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGVycm9yID0gbWFrZUVycm9yKFwicmVxdWVzdCB0aW1lb3V0XCIsIFwiVElNRU9VVFwiKTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgfSwgcmVxLnRpbWVvdXQpO1xuICAgICAgICBpZiAoX3NpZ25hbCkge1xuICAgICAgICAgICAgX3NpZ25hbC5hZGRMaXN0ZW5lcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBtYWtlRXJyb3IoXCJyZXF1ZXN0IGNhbmNlbGxlZFwiLCBcIkNBTkNFTExFRFwiKTtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbml0ID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgbWV0aG9kOiByZXEubWV0aG9kLFxuICAgICAgICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnMoQXJyYXkuZnJvbShyZXEpKSxcbiAgICAgICAgICAgIGJvZHk6IHJlcS5ib2R5IHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWxcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCByZXNwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzcCA9IGF3YWl0IGZldGNoKHJlcS51cmwsIGluaXQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IF9lcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgICAgIHJlc3AuaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICBoZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzcEJvZHkgPSBhd2FpdCByZXNwLmFycmF5QnVmZmVyKCk7XG4gICAgICAgIGNvbnN0IGJvZHkgPSAocmVzcEJvZHkgPT0gbnVsbCkgPyBudWxsIDogbmV3IFVpbnQ4QXJyYXkocmVzcEJvZHkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdHVzQ29kZTogcmVzcC5zdGF0dXMsXG4gICAgICAgICAgICBzdGF0dXNNZXNzYWdlOiByZXNwLnN0YXR1c1RleHQsXG4gICAgICAgICAgICBoZWFkZXJzLCBib2R5XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBnZXRVcmw7XG59XG4vLyBAVE9ETzogcmVtb3ZlIGluIHY3OyBwcm92aWRlZCBmb3IgYmFja3dhcmRzIGNvbXBhdFxuY29uc3QgZGVmYXVsdEdldFVybCA9IGNyZWF0ZUdldFVybCh7fSk7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VXJsKHJlcSwgX3NpZ25hbCkge1xuICAgIHJldHVybiBkZWZhdWx0R2V0VXJsKHJlcSwgX3NpZ25hbCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXR1cmwtYnJvd3Nlci5qcy5tYXAiXSwibmFtZXMiOlsiYXNzZXJ0IiwibWFrZUVycm9yIiwiY3JlYXRlR2V0VXJsIiwib3B0aW9ucyIsImdldFVybCIsInJlcSIsIl9zaWduYWwiLCJjYW5jZWxsZWQiLCJwcm90b2NvbCIsInVybCIsInNwbGl0IiwidG9Mb3dlckNhc2UiLCJpbmZvIiwib3BlcmF0aW9uIiwiY3JlZGVudGlhbHMiLCJhbGxvd0luc2VjdXJlQXV0aGVudGljYXRpb24iLCJlcnJvciIsImNvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJ0aW1lciIsInNldFRpbWVvdXQiLCJhYm9ydCIsInRpbWVvdXQiLCJhZGRMaXN0ZW5lciIsImluaXQiLCJPYmplY3QiLCJhc3NpZ24iLCJtZXRob2QiLCJoZWFkZXJzIiwiSGVhZGVycyIsIkFycmF5IiwiZnJvbSIsImJvZHkiLCJ1bmRlZmluZWQiLCJzaWduYWwiLCJyZXNwIiwiZmV0Y2giLCJfZXJyb3IiLCJjbGVhclRpbWVvdXQiLCJmb3JFYWNoIiwidmFsdWUiLCJrZXkiLCJyZXNwQm9keSIsImFycmF5QnVmZmVyIiwiVWludDhBcnJheSIsInN0YXR1c0NvZGUiLCJzdGF0dXMiLCJzdGF0dXNNZXNzYWdlIiwic3RhdHVzVGV4dCIsImRlZmF1bHRHZXRVcmwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/utils/geturl-browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/utils/maths.js":
/*!****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/maths.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromTwos: function() { return /* binding */ fromTwos; },\n/* harmony export */   getBigInt: function() { return /* binding */ getBigInt; },\n/* harmony export */   getNumber: function() { return /* binding */ getNumber; },\n/* harmony export */   getUint: function() { return /* binding */ getUint; },\n/* harmony export */   mask: function() { return /* binding */ mask; },\n/* harmony export */   toBeArray: function() { return /* binding */ toBeArray; },\n/* harmony export */   toBeHex: function() { return /* binding */ toBeHex; },\n/* harmony export */   toBigInt: function() { return /* binding */ toBigInt; },\n/* harmony export */   toNumber: function() { return /* binding */ toNumber; },\n/* harmony export */   toQuantity: function() { return /* binding */ toQuantity; },\n/* harmony export */   toTwos: function() { return /* binding */ toTwos; }\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/**\n *  Some mathematic operations.\n *\n *  @_subsection: api/utils:Math Helpers  [about-maths]\n */ \n\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\n//const BN_Max256 = (BN_1 << BigInt(256)) - BN_1;\n// IEEE 754 support 53-bits of mantissa\nconst maxValue = 0x1fffffffffffff;\n/**\n *  Convert %%value%% from a twos-compliment representation of %%width%%\n *  bits to its value.\n *\n *  If the highest bit is ``1``, the result will be negative.\n */ function fromTwos(_value, _width) {\n    const value = getUint(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value >> width === BN_0, \"overflow\", \"NUMERIC_FAULT\", {\n        operation: \"fromTwos\",\n        fault: \"overflow\",\n        value: _value\n    });\n    // Top bit set; treat as a negative value\n    if (value >> width - BN_1) {\n        const mask = (BN_1 << width) - BN_1;\n        return -((~value & mask) + BN_1);\n    }\n    return value;\n}\n/**\n *  Convert %%value%% to a twos-compliment representation of\n *  %%width%% bits.\n *\n *  The result will always be positive.\n */ function toTwos(_value, _width) {\n    let value = getBigInt(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n    const limit = BN_1 << width - BN_1;\n    if (value < BN_0) {\n        value = -value;\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value <= limit, \"too low\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\",\n            fault: \"overflow\",\n            value: _value\n        });\n        const mask = (BN_1 << width) - BN_1;\n        return (~value & mask) + BN_1;\n    } else {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value < limit, \"too high\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\",\n            fault: \"overflow\",\n            value: _value\n        });\n    }\n    return value;\n}\n/**\n *  Mask %%value%% with a bitmask of %%bits%% ones.\n */ function mask(_value, _bits) {\n    const value = getUint(_value, \"value\");\n    const bits = BigInt(getNumber(_bits, \"bits\"));\n    return value & (BN_1 << bits) - BN_1;\n}\n/**\n *  Gets a BigInt from %%value%%. If it is an invalid value for\n *  a BigInt, then an ArgumentError will be thrown for %%name%%.\n */ function getBigInt(value, name) {\n    switch(typeof value){\n        case \"bigint\":\n            return value;\n        case \"number\":\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return BigInt(value);\n        case \"string\":\n            try {\n                if (value === \"\") {\n                    throw new Error(\"empty string\");\n                }\n                if (value[0] === \"-\" && value[1] !== \"-\") {\n                    return -BigInt(value.substring(1));\n                }\n                return BigInt(value);\n            } catch (e) {\n                (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid BigNumberish string: \".concat(e.message), name || \"value\", value);\n            }\n    }\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid BigNumberish value\", name || \"value\", value);\n}\n/**\n *  Returns %%value%% as a bigint, validating it is valid as a bigint\n *  value and that it is positive.\n */ function getUint(value, name) {\n    const result = getBigInt(value, name);\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(result >= BN_0, \"unsigned value cannot be negative\", \"NUMERIC_FAULT\", {\n        fault: \"overflow\",\n        operation: \"getUint\",\n        value\n    });\n    return result;\n}\nconst Nibbles = \"0123456789abcdef\";\n/*\n * Converts %%value%% to a BigInt. If %%value%% is a Uint8Array, it\n * is treated as Big Endian data.\n */ function toBigInt(value) {\n    if (value instanceof Uint8Array) {\n        let result = \"0x0\";\n        for (const v of value){\n            result += Nibbles[v >> 4];\n            result += Nibbles[v & 0x0f];\n        }\n        return BigInt(result);\n    }\n    return getBigInt(value);\n}\n/**\n *  Gets a //number// from %%value%%. If it is an invalid value for\n *  a //number//, then an ArgumentError will be thrown for %%name%%.\n */ function getNumber(value, name) {\n    switch(typeof value){\n        case \"bigint\":\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return Number(value);\n        case \"number\":\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return value;\n        case \"string\":\n            try {\n                if (value === \"\") {\n                    throw new Error(\"empty string\");\n                }\n                return getNumber(BigInt(value), name);\n            } catch (e) {\n                (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid numeric string: \".concat(e.message), name || \"value\", value);\n            }\n    }\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid numeric value\", name || \"value\", value);\n}\n/**\n *  Converts %%value%% to a number. If %%value%% is a Uint8Array, it\n *  is treated as Big Endian data. Throws if the value is not safe.\n */ function toNumber(value) {\n    return getNumber(toBigInt(value));\n}\n/**\n *  Converts %%value%% to a Big Endian hexstring, optionally padded to\n *  %%width%% bytes.\n */ function toBeHex(_value, _width) {\n    const value = getUint(_value, \"value\");\n    let result = value.toString(16);\n    if (_width == null) {\n        // Ensure the value is of even length\n        if (result.length % 2) {\n            result = \"0\" + result;\n        }\n    } else {\n        const width = getNumber(_width, \"width\");\n        // Special case when both value and width are 0 (see: #5025)\n        if (width === 0 && value === BN_0) {\n            return \"0x\";\n        }\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(width * 2 >= result.length, \"value exceeds width (\".concat(width, \" bytes)\"), \"NUMERIC_FAULT\", {\n            operation: \"toBeHex\",\n            fault: \"overflow\",\n            value: _value\n        });\n        // Pad the value to the required width\n        while(result.length < width * 2){\n            result = \"0\" + result;\n        }\n    }\n    return \"0x\" + result;\n}\n/**\n *  Converts %%value%% to a Big Endian Uint8Array.\n */ function toBeArray(_value, _width) {\n    const value = getUint(_value, \"value\");\n    if (value === BN_0) {\n        const width = _width != null ? getNumber(_width, \"width\") : 0;\n        return new Uint8Array(width);\n    }\n    let hex = value.toString(16);\n    if (hex.length % 2) {\n        hex = \"0\" + hex;\n    }\n    if (_width != null) {\n        const width = getNumber(_width, \"width\");\n        while(hex.length < width * 2){\n            hex = \"00\" + hex;\n        }\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(width * 2 === hex.length, \"value exceeds width (\".concat(width, \" bytes)\"), \"NUMERIC_FAULT\", {\n            operation: \"toBeArray\",\n            fault: \"overflow\",\n            value: _value\n        });\n    }\n    const result = new Uint8Array(hex.length / 2);\n    for(let i = 0; i < result.length; i++){\n        const offset = i * 2;\n        result[i] = parseInt(hex.substring(offset, offset + 2), 16);\n    }\n    return result;\n}\n/**\n *  Returns a [[HexString]] for %%value%% safe to use as a //Quantity//.\n *\n *  A //Quantity// does not have and leading 0 values unless the value is\n *  the literal value `0x0`. This is most commonly used for JSSON-RPC\n *  numeric values.\n */ function toQuantity(value) {\n    let result = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)((0,_data_js__WEBPACK_IMPORTED_MODULE_1__.isBytesLike)(value) ? value : toBeArray(value)).substring(2);\n    while(result.startsWith(\"0\")){\n        result = result.substring(1);\n    }\n    if (result === \"\") {\n        result = \"0\";\n    }\n    return \"0x\" + result;\n} //# sourceMappingURL=maths.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9tYXRocy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Q0FJQyxHQUNnRDtBQUNJO0FBQ3JELE1BQU1JLE9BQU9DLE9BQU87QUFDcEIsTUFBTUMsT0FBT0QsT0FBTztBQUNwQixpREFBaUQ7QUFDakQsdUNBQXVDO0FBQ3ZDLE1BQU1FLFdBQVc7QUFDakI7Ozs7O0NBS0MsR0FDTSxTQUFTQyxTQUFTQyxNQUFNLEVBQUVDLE1BQU07SUFDbkMsTUFBTUMsUUFBUUMsUUFBUUgsUUFBUTtJQUM5QixNQUFNSSxRQUFRUixPQUFPUyxVQUFVSixRQUFRO0lBQ3ZDUixrREFBTUEsQ0FBQyxTQUFVVyxVQUFXVCxNQUFNLFlBQVksaUJBQWlCO1FBQzNEVyxXQUFXO1FBQVlDLE9BQU87UUFBWUwsT0FBT0Y7SUFDckQ7SUFDQSx5Q0FBeUM7SUFDekMsSUFBSUUsU0FBVUUsUUFBUVAsTUFBTztRQUN6QixNQUFNVyxPQUFPLENBQUNYLFFBQVFPLEtBQUksSUFBS1A7UUFDL0IsT0FBTyxDQUFFLEVBQUMsQ0FBRUssUUFBU00sSUFBRyxJQUFLWCxJQUFHO0lBQ3BDO0lBQ0EsT0FBT0s7QUFDWDtBQUNBOzs7OztDQUtDLEdBQ00sU0FBU08sT0FBT1QsTUFBTSxFQUFFQyxNQUFNO0lBQ2pDLElBQUlDLFFBQVFRLFVBQVVWLFFBQVE7SUFDOUIsTUFBTUksUUFBUVIsT0FBT1MsVUFBVUosUUFBUTtJQUN2QyxNQUFNVSxRQUFTZCxRQUFTTyxRQUFRUDtJQUNoQyxJQUFJSyxRQUFRUCxNQUFNO1FBQ2RPLFFBQVEsQ0FBQ0E7UUFDVFQsa0RBQU1BLENBQUNTLFNBQVNTLE9BQU8sV0FBVyxpQkFBaUI7WUFDL0NMLFdBQVc7WUFBVUMsT0FBTztZQUFZTCxPQUFPRjtRQUNuRDtRQUNBLE1BQU1RLE9BQU8sQ0FBQ1gsUUFBUU8sS0FBSSxJQUFLUDtRQUMvQixPQUFPLENBQUMs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QUNoQkUsTUFBTSxNQUFNQTtJQUNoQjtJQUNBLElBQUk5QixVQUFVLE1BQU07UUFDaEIsTUFBTUcsUUFBUUMsVUFBVUosUUFBUTtRQUNoQyxNQUFPOEIsSUFBSUYsTUFBTSxHQUFJekIsUUFBUSxFQUFJO1lBQzdCMkIsTUFBTSxPQUFPQTtRQUNqQjtRQUNBdEMsa0RBQU1BLENBQUMsUUFBUyxNQUFPc0MsSUFBSUYsTUFBTSxFQUFFLHdCQUE4QixPQUFOekIsT0FBTSxZQUFVLGlCQUFpQjtZQUN4RkUsV0FBVztZQUNYQyxPQUFPO1lBQ1BMLE9BQU9GO1FBQ1g7SUFDSjtJQUNBLE1BQU1xQixTQUFTLElBQUlHLFdBQVdPLElBQUlGLE1BQU0sR0FBRztJQUMzQyxJQUFLLElBQUlHLElBQUksR0FBR0EsSUFBSVgsT0FBT1EsTUFBTSxFQUFFRyxJQUFLO1FBQ3BDLE1BQU1DLFNBQVNELElBQUk7UUFDbkJYLE1BQU0sQ0FBQ1csRUFBRSxHQUFHRSxTQUFTSCxJQUFJYixTQUFTLENBQUNlLFFBQVFBLFNBQVMsSUFBSTtJQUM1RDtJQUNBLE9BQU9aO0FBQ1g7QUFDQTs7Ozs7O0NBTUMsR0FDTSxTQUFTYyxXQUFXakMsS0FBSztJQUM1QixJQUFJbUIsU0FBUzlCLGlEQUFPQSxDQUFDQyxxREFBV0EsQ0FBQ1UsU0FBU0EsUUFBUTRCLFVBQVU1QixRQUFRZ0IsU0FBUyxDQUFDO0lBQzlFLE1BQU9HLE9BQU9lLFVBQVUsQ0FBQyxLQUFNO1FBQzNCZixTQUFTQSxPQUFPSCxTQUFTLENBQUM7SUFDOUI7SUFDQSxJQUFJRyxXQUFXLElBQUk7UUFDZkEsU0FBUztJQUNiO0lBQ0EsT0FBTyxPQUFPQTtBQUNsQixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvbWF0aHMuanM/YmNlMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBTb21lIG1hdGhlbWF0aWMgb3BlcmF0aW9ucy5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvdXRpbHM6TWF0aCBIZWxwZXJzICBbYWJvdXQtbWF0aHNdXG4gKi9cbmltcG9ydCB7IGhleGxpZnksIGlzQnl0ZXNMaWtlIH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmNvbnN0IEJOXzEgPSBCaWdJbnQoMSk7XG4vL2NvbnN0IEJOX01heDI1NiA9IChCTl8xIDw8IEJpZ0ludCgyNTYpKSAtIEJOXzE7XG4vLyBJRUVFIDc1NCBzdXBwb3J0IDUzLWJpdHMgb2YgbWFudGlzc2FcbmNvbnN0IG1heFZhbHVlID0gMHgxZmZmZmZmZmZmZmZmZjtcbi8qKlxuICogIENvbnZlcnQgJSV2YWx1ZSUlIGZyb20gYSB0d29zLWNvbXBsaW1lbnQgcmVwcmVzZW50YXRpb24gb2YgJSV3aWR0aCUlXG4gKiAgYml0cyB0byBpdHMgdmFsdWUuXG4gKlxuICogIElmIHRoZSBoaWdoZXN0IGJpdCBpcyBgYDFgYCwgdGhlIHJlc3VsdCB3aWxsIGJlIG5lZ2F0aXZlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVR3b3MoX3ZhbHVlLCBfd2lkdGgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldFVpbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgIGNvbnN0IHdpZHRoID0gQmlnSW50KGdldE51bWJlcihfd2lkdGgsIFwid2lkdGhcIikpO1xuICAgIGFzc2VydCgodmFsdWUgPj4gd2lkdGgpID09PSBCTl8wLCBcIm92ZXJmbG93XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgIG9wZXJhdGlvbjogXCJmcm9tVHdvc1wiLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogX3ZhbHVlXG4gICAgfSk7XG4gICAgLy8gVG9wIGJpdCBzZXQ7IHRyZWF0IGFzIGEgbmVnYXRpdmUgdmFsdWVcbiAgICBpZiAodmFsdWUgPj4gKHdpZHRoIC0gQk5fMSkpIHtcbiAgICAgICAgY29uc3QgbWFzayA9IChCTl8xIDw8IHdpZHRoKSAtIEJOXzE7XG4gICAgICAgIHJldHVybiAtKCgofnZhbHVlKSAmIG1hc2spICsgQk5fMSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogIENvbnZlcnQgJSV2YWx1ZSUlIHRvIGEgdHdvcy1jb21wbGltZW50IHJlcHJlc2VudGF0aW9uIG9mXG4gKiAgJSV3aWR0aCUlIGJpdHMuXG4gKlxuICogIFRoZSByZXN1bHQgd2lsbCBhbHdheXMgYmUgcG9zaXRpdmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1R3b3MoX3ZhbHVlLCBfd2lkdGgpIHtcbiAgICBsZXQgdmFsdWUgPSBnZXRCaWdJbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgIGNvbnN0IHdpZHRoID0gQmlnSW50KGdldE51bWJlcihfd2lkdGgsIFwid2lkdGhcIikpO1xuICAgIGNvbnN0IGxpbWl0ID0gKEJOXzEgPDwgKHdpZHRoIC0gQk5fMSkpO1xuICAgIGlmICh2YWx1ZSA8IEJOXzApIHtcbiAgICAgICAgdmFsdWUgPSAtdmFsdWU7XG4gICAgICAgIGFzc2VydCh2YWx1ZSA8PSBsaW1pdCwgXCJ0b28gbG93XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwidG9Ud29zXCIsIGZhdWx0OiBcIm92ZXJmbG93XCIsIHZhbHVlOiBfdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG1hc2sgPSAoQk5fMSA8PCB3aWR0aCkgLSBCTl8xO1xuICAgICAgICByZXR1cm4gKCh+dmFsdWUpICYgbWFzaykgKyBCTl8xO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXNzZXJ0KHZhbHVlIDwgbGltaXQsIFwidG9vIGhpZ2hcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJ0b1R3b3NcIiwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IF92YWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiAgTWFzayAlJXZhbHVlJSUgd2l0aCBhIGJpdG1hc2sgb2YgJSViaXRzJSUgb25lcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hc2soX3ZhbHVlLCBfYml0cykge1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0VWludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgY29uc3QgYml0cyA9IEJpZ0ludChnZXROdW1iZXIoX2JpdHMsIFwiYml0c1wiKSk7XG4gICAgcmV0dXJuIHZhbHVlICYgKChCTl8xIDw8IGJpdHMpIC0gQk5fMSk7XG59XG4vKipcbiAqICBHZXRzIGEgQmlnSW50IGZyb20gJSV2YWx1ZSUlLiBJZiBpdCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvclxuICogIGEgQmlnSW50LCB0aGVuIGFuIEFyZ3VtZW50RXJyb3Igd2lsbCBiZSB0aHJvd24gZm9yICUlbmFtZSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QmlnSW50KHZhbHVlLCBuYW1lKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgKHZhbHVlKSkge1xuICAgICAgICBjYXNlIFwiYmlnaW50XCI6IHJldHVybiB2YWx1ZTtcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSksIFwidW5kZXJmbG93XCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZSA+PSAtbWF4VmFsdWUgJiYgdmFsdWUgPD0gbWF4VmFsdWUsIFwib3ZlcmZsb3dcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbXB0eSBzdHJpbmdcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZVswXSA9PT0gXCItXCIgJiYgdmFsdWVbMV0gIT09IFwiLVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtQmlnSW50KHZhbHVlLnN1YnN0cmluZygxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGludmFsaWQgQmlnTnVtYmVyaXNoIHN0cmluZzogJHtlLm1lc3NhZ2V9YCwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBCaWdOdW1iZXJpc2ggdmFsdWVcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbn1cbi8qKlxuICogIFJldHVybnMgJSV2YWx1ZSUlIGFzIGEgYmlnaW50LCB2YWxpZGF0aW5nIGl0IGlzIHZhbGlkIGFzIGEgYmlnaW50XG4gKiAgdmFsdWUgYW5kIHRoYXQgaXQgaXMgcG9zaXRpdmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVaW50KHZhbHVlLCBuYW1lKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gZ2V0QmlnSW50KHZhbHVlLCBuYW1lKTtcbiAgICBhc3NlcnQocmVzdWx0ID49IEJOXzAsIFwidW5zaWduZWQgdmFsdWUgY2Fubm90IGJlIG5lZ2F0aXZlXCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgIGZhdWx0OiBcIm92ZXJmbG93XCIsIG9wZXJhdGlvbjogXCJnZXRVaW50XCIsIHZhbHVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IE5pYmJsZXMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbi8qXG4gKiBDb252ZXJ0cyAlJXZhbHVlJSUgdG8gYSBCaWdJbnQuIElmICUldmFsdWUlJSBpcyBhIFVpbnQ4QXJyYXksIGl0XG4gKiBpcyB0cmVhdGVkIGFzIEJpZyBFbmRpYW4gZGF0YS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQmlnSW50KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCIweDBcIjtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIHZhbHVlKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gTmliYmxlc1t2ID4+IDRdO1xuICAgICAgICAgICAgcmVzdWx0ICs9IE5pYmJsZXNbdiAmIDB4MGZdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCaWdJbnQocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEJpZ0ludCh2YWx1ZSk7XG59XG4vKipcbiAqICBHZXRzIGEgLy9udW1iZXIvLyBmcm9tICUldmFsdWUlJS4gSWYgaXQgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3JcbiAqICBhIC8vbnVtYmVyLy8sIHRoZW4gYW4gQXJndW1lbnRFcnJvciB3aWxsIGJlIHRocm93biBmb3IgJSVuYW1lJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXROdW1iZXIodmFsdWUsIG5hbWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiAodmFsdWUpKSB7XG4gICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlID49IC1tYXhWYWx1ZSAmJiB2YWx1ZSA8PSBtYXhWYWx1ZSwgXCJvdmVyZmxvd1wiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KE51bWJlci5pc0ludGVnZXIodmFsdWUpLCBcInVuZGVyZmxvd1wiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodmFsdWUgPj0gLW1heFZhbHVlICYmIHZhbHVlIDw9IG1heFZhbHVlLCBcIm92ZXJmbG93XCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImVtcHR5IHN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldE51bWJlcihCaWdJbnQodmFsdWUpLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBpbnZhbGlkIG51bWVyaWMgc3RyaW5nOiAke2UubWVzc2FnZX1gLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIG51bWVyaWMgdmFsdWVcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbn1cbi8qKlxuICogIENvbnZlcnRzICUldmFsdWUlJSB0byBhIG51bWJlci4gSWYgJSV2YWx1ZSUlIGlzIGEgVWludDhBcnJheSwgaXRcbiAqICBpcyB0cmVhdGVkIGFzIEJpZyBFbmRpYW4gZGF0YS4gVGhyb3dzIGlmIHRoZSB2YWx1ZSBpcyBub3Qgc2FmZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIGdldE51bWJlcih0b0JpZ0ludCh2YWx1ZSkpO1xufVxuLyoqXG4gKiAgQ29udmVydHMgJSV2YWx1ZSUlIHRvIGEgQmlnIEVuZGlhbiBoZXhzdHJpbmcsIG9wdGlvbmFsbHkgcGFkZGVkIHRvXG4gKiAgJSV3aWR0aCUlIGJ5dGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CZUhleChfdmFsdWUsIF93aWR0aCkge1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0VWludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgbGV0IHJlc3VsdCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICBpZiAoX3dpZHRoID09IG51bGwpIHtcbiAgICAgICAgLy8gRW5zdXJlIHRoZSB2YWx1ZSBpcyBvZiBldmVuIGxlbmd0aFxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCAlIDIpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB3aWR0aCA9IGdldE51bWJlcihfd2lkdGgsIFwid2lkdGhcIik7XG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZSB3aGVuIGJvdGggdmFsdWUgYW5kIHdpZHRoIGFyZSAwIChzZWU6ICM1MDI1KVxuICAgICAgICBpZiAod2lkdGggPT09IDAgJiYgdmFsdWUgPT09IEJOXzApIHtcbiAgICAgICAgICAgIHJldHVybiBcIjB4XCI7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KHdpZHRoICogMiA+PSByZXN1bHQubGVuZ3RoLCBgdmFsdWUgZXhjZWVkcyB3aWR0aCAoJHt3aWR0aH0gYnl0ZXMpYCwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJ0b0JlSGV4XCIsXG4gICAgICAgICAgICBmYXVsdDogXCJvdmVyZmxvd1wiLFxuICAgICAgICAgICAgdmFsdWU6IF92YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gUGFkIHRoZSB2YWx1ZSB0byB0aGUgcmVxdWlyZWQgd2lkdGhcbiAgICAgICAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCAod2lkdGggKiAyKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gXCIwXCIgKyByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIHJlc3VsdDtcbn1cbi8qKlxuICogIENvbnZlcnRzICUldmFsdWUlJSB0byBhIEJpZyBFbmRpYW4gVWludDhBcnJheS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQmVBcnJheShfdmFsdWUsIF93aWR0aCkge1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0VWludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgaWYgKHZhbHVlID09PSBCTl8wKSB7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gKF93aWR0aCAhPSBudWxsKSA/IGdldE51bWJlcihfd2lkdGgsIFwid2lkdGhcIikgOiAwO1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkod2lkdGgpO1xuICAgIH1cbiAgICBsZXQgaGV4ID0gdmFsdWUudG9TdHJpbmcoMTYpO1xuICAgIGlmIChoZXgubGVuZ3RoICUgMikge1xuICAgICAgICBoZXggPSBcIjBcIiArIGhleDtcbiAgICB9XG4gICAgaWYgKF93aWR0aCAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gZ2V0TnVtYmVyKF93aWR0aCwgXCJ3aWR0aFwiKTtcbiAgICAgICAgd2hpbGUgKGhleC5sZW5ndGggPCAod2lkdGggKiAyKSkge1xuICAgICAgICAgICAgaGV4ID0gXCIwMFwiICsgaGV4O1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydCgod2lkdGggKiAyKSA9PT0gaGV4Lmxlbmd0aCwgYHZhbHVlIGV4Y2VlZHMgd2lkdGggKCR7d2lkdGh9IGJ5dGVzKWAsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwidG9CZUFycmF5XCIsXG4gICAgICAgICAgICBmYXVsdDogXCJvdmVyZmxvd1wiLFxuICAgICAgICAgICAgdmFsdWU6IF92YWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoaGV4Lmxlbmd0aCAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGkgKiAyO1xuICAgICAgICByZXN1bHRbaV0gPSBwYXJzZUludChoZXguc3Vic3RyaW5nKG9mZnNldCwgb2Zmc2V0ICsgMiksIDE2KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogIFJldHVybnMgYSBbW0hleFN0cmluZ11dIGZvciAlJXZhbHVlJSUgc2FmZSB0byB1c2UgYXMgYSAvL1F1YW50aXR5Ly8uXG4gKlxuICogIEEgLy9RdWFudGl0eS8vIGRvZXMgbm90IGhhdmUgYW5kIGxlYWRpbmcgMCB2YWx1ZXMgdW5sZXNzIHRoZSB2YWx1ZSBpc1xuICogIHRoZSBsaXRlcmFsIHZhbHVlIGAweDBgLiBUaGlzIGlzIG1vc3QgY29tbW9ubHkgdXNlZCBmb3IgSlNTT04tUlBDXG4gKiAgbnVtZXJpYyB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1F1YW50aXR5KHZhbHVlKSB7XG4gICAgbGV0IHJlc3VsdCA9IGhleGxpZnkoaXNCeXRlc0xpa2UodmFsdWUpID8gdmFsdWUgOiB0b0JlQXJyYXkodmFsdWUpKS5zdWJzdHJpbmcoMik7XG4gICAgd2hpbGUgKHJlc3VsdC5zdGFydHNXaXRoKFwiMFwiKSkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0ID09PSBcIlwiKSB7XG4gICAgICAgIHJlc3VsdCA9IFwiMFwiO1xuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF0aHMuanMubWFwIl0sIm5hbWVzIjpbImhleGxpZnkiLCJpc0J5dGVzTGlrZSIsImFzc2VydCIsImFzc2VydEFyZ3VtZW50IiwiQk5fMCIsIkJpZ0ludCIsIkJOXzEiLCJtYXhWYWx1ZSIsImZyb21Ud29zIiwiX3ZhbHVlIiwiX3dpZHRoIiwidmFsdWUiLCJnZXRVaW50Iiwid2lkdGgiLCJnZXROdW1iZXIiLCJvcGVyYXRpb24iLCJmYXVsdCIsIm1hc2siLCJ0b1R3b3MiLCJnZXRCaWdJbnQiLCJsaW1pdCIsIl9iaXRzIiwiYml0cyIsIm5hbWUiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJFcnJvciIsInN1YnN0cmluZyIsImUiLCJtZXNzYWdlIiwicmVzdWx0IiwiTmliYmxlcyIsInRvQmlnSW50IiwiVWludDhBcnJheSIsInYiLCJ0b051bWJlciIsInRvQmVIZXgiLCJ0b1N0cmluZyIsImxlbmd0aCIsInRvQmVBcnJheSIsImhleCIsImkiLCJvZmZzZXQiLCJwYXJzZUludCIsInRvUXVhbnRpdHkiLCJzdGFydHNXaXRoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/utils/maths.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/utils/properties.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/properties.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defineProperties: function() { return /* binding */ defineProperties; },\n/* harmony export */   resolveProperties: function() { return /* binding */ resolveProperties; }\n/* harmony export */ });\n/**\n *  Property helper functions.\n *\n *  @_subsection api/utils:Properties  [about-properties]\n */ function checkType(value, type, name) {\n    const types = type.split(\"|\").map((t)=>t.trim());\n    for(let i = 0; i < types.length; i++){\n        switch(type){\n            case \"any\":\n                return;\n            case \"bigint\":\n            case \"boolean\":\n            case \"number\":\n            case \"string\":\n                if (typeof value === type) {\n                    return;\n                }\n        }\n    }\n    const error = new Error(\"invalid value for type \".concat(type));\n    error.code = \"INVALID_ARGUMENT\";\n    error.argument = \"value.\".concat(name);\n    error.value = value;\n    throw error;\n}\n/**\n *  Resolves to a new object that is a copy of %%value%%, but with all\n *  values resolved.\n */ async function resolveProperties(value) {\n    const keys = Object.keys(value);\n    const results = await Promise.all(keys.map((k)=>Promise.resolve(value[k])));\n    return results.reduce((accum, v, index)=>{\n        accum[keys[index]] = v;\n        return accum;\n    }, {});\n}\n/**\n *  Assigns the %%values%% to %%target%% as read-only values.\n *\n *  It %%types%% is specified, the values are checked.\n */ function defineProperties(target, values, types) {\n    for(let key in values){\n        let value = values[key];\n        const type = types ? types[key] : null;\n        if (type) {\n            checkType(value, type, key);\n        }\n        Object.defineProperty(target, key, {\n            enumerable: true,\n            value,\n            writable: false\n        });\n    }\n} //# sourceMappingURL=properties.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9wcm9wZXJ0aWVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Ozs7Q0FJQyxHQUNELFNBQVNBLFVBQVVDLEtBQUssRUFBRUMsSUFBSSxFQUFFQyxJQUFJO0lBQ2hDLE1BQU1DLFFBQVFGLEtBQUtHLEtBQUssQ0FBQyxLQUFLQyxHQUFHLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLElBQUk7SUFDN0MsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlMLE1BQU1NLE1BQU0sRUFBRUQsSUFBSztRQUNuQyxPQUFRUDtZQUNKLEtBQUs7Z0JBQ0Q7WUFDSixLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO2dCQUNELElBQUksT0FBUUQsVUFBV0MsTUFBTTtvQkFDekI7Z0JBQ0o7UUFDUjtJQUNKO0lBQ0EsTUFBTVMsUUFBUSxJQUFJQyxNQUFNLDBCQUErQixPQUFMVjtJQUNsRFMsTUFBTUUsSUFBSSxHQUFHO0lBQ2JGLE1BQU1HLFFBQVEsR0FBRyxTQUFjLE9BQUxYO0lBQzFCUSxNQUFNVixLQUFLLEdBQUdBO0lBQ2QsTUFBTVU7QUFDVjtBQUNBOzs7Q0FHQyxHQUNNLGVBQWVJLGtCQUFrQmQsS0FBSztJQUN6QyxNQUFNZSxPQUFPQyxPQUFPRCxJQUFJLENBQUNmO0lBQ3pCLE1BQU1pQixVQUFVLE1BQU1DLFFBQVFDLEdBQUcsQ0FBQ0osS0FBS1YsR0FBRyxDQUFDLENBQUNlLElBQU1GLFFBQVFHLE9BQU8sQ0FBQ3JCLEtBQUssQ0FBQ29CLEVBQUU7SUFDMUUsT0FBT0gsUUFBUUssTUFBTSxDQUFDLENBQUNDLE9BQU9DLEdBQUdDO1FBQzdCRixLQUFLLENBQUNSLElBQUksQ0FBQ1UsTUFBTSxDQUFDLEdBQUdEO1FBQ3JCLE9BQU9EO0lBQ1gsR0FBRyxDQUFDO0FBQ1I7QUFDQTs7OztDQUlDLEdBQ00sU0FBU0csaUJBQWlCQyxNQUFNLEVBQUVDLE1BQU0sRUFBRXpCLEtBQUs7SUFDbEQsSUFBSyxJQUFJMEIsT0FBT0QsT0FBUTtRQUNwQixJQUFJNUIsUUFBUTRCLE1BQU0sQ0FBQ0MsSUFBSTtRQUN2QixNQUFNNUIsT0FBUUUsUUFBUUEsS0FBSyxDQUFDMEIsSUFBSSxHQUFHO1FBQ25DLElBQUk1QixNQUFNO1lBQ05GLFVBQVVDLE9BQU9DLE1BQU00QjtRQUMzQjtRQUNBYixPQUFPYyxjQUFjLENBQUNILFFBQVFFLEtBQUs7WUFBRUUsWUFBWTtZQUFNL0I7WUFBT2dDLFVBQVU7UUFBTTtJQUNsRjtBQUNKLEVBQ0Esc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9wcm9wZXJ0aWVzLmpzPzUyMDciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgUHJvcGVydHkgaGVscGVyIGZ1bmN0aW9ucy5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uIGFwaS91dGlsczpQcm9wZXJ0aWVzICBbYWJvdXQtcHJvcGVydGllc11cbiAqL1xuZnVuY3Rpb24gY2hlY2tUeXBlKHZhbHVlLCB0eXBlLCBuYW1lKSB7XG4gICAgY29uc3QgdHlwZXMgPSB0eXBlLnNwbGl0KFwifFwiKS5tYXAodCA9PiB0LnRyaW0oKSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJhbnlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBpbnZhbGlkIHZhbHVlIGZvciB0eXBlICR7dHlwZX1gKTtcbiAgICBlcnJvci5jb2RlID0gXCJJTlZBTElEX0FSR1VNRU5UXCI7XG4gICAgZXJyb3IuYXJndW1lbnQgPSBgdmFsdWUuJHtuYW1lfWA7XG4gICAgZXJyb3IudmFsdWUgPSB2YWx1ZTtcbiAgICB0aHJvdyBlcnJvcjtcbn1cbi8qKlxuICogIFJlc29sdmVzIHRvIGEgbmV3IG9iamVjdCB0aGF0IGlzIGEgY29weSBvZiAlJXZhbHVlJSUsIGJ1dCB3aXRoIGFsbFxuICogIHZhbHVlcyByZXNvbHZlZC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlc29sdmVQcm9wZXJ0aWVzKHZhbHVlKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoa2V5cy5tYXAoKGspID0+IFByb21pc2UucmVzb2x2ZSh2YWx1ZVtrXSkpKTtcbiAgICByZXR1cm4gcmVzdWx0cy5yZWR1Y2UoKGFjY3VtLCB2LCBpbmRleCkgPT4ge1xuICAgICAgICBhY2N1bVtrZXlzW2luZGV4XV0gPSB2O1xuICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgfSwge30pO1xufVxuLyoqXG4gKiAgQXNzaWducyB0aGUgJSV2YWx1ZXMlJSB0byAlJXRhcmdldCUlIGFzIHJlYWQtb25seSB2YWx1ZXMuXG4gKlxuICogIEl0ICUldHlwZXMlJSBpcyBzcGVjaWZpZWQsIHRoZSB2YWx1ZXMgYXJlIGNoZWNrZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgdmFsdWVzLCB0eXBlcykge1xuICAgIGZvciAobGV0IGtleSBpbiB2YWx1ZXMpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gdmFsdWVzW2tleV07XG4gICAgICAgIGNvbnN0IHR5cGUgPSAodHlwZXMgPyB0eXBlc1trZXldIDogbnVsbCk7XG4gICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICBjaGVja1R5cGUodmFsdWUsIHR5cGUsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlLCB3cml0YWJsZTogZmFsc2UgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvcGVydGllcy5qcy5tYXAiXSwibmFtZXMiOlsiY2hlY2tUeXBlIiwidmFsdWUiLCJ0eXBlIiwibmFtZSIsInR5cGVzIiwic3BsaXQiLCJtYXAiLCJ0IiwidHJpbSIsImkiLCJsZW5ndGgiLCJlcnJvciIsIkVycm9yIiwiY29kZSIsImFyZ3VtZW50IiwicmVzb2x2ZVByb3BlcnRpZXMiLCJrZXlzIiwiT2JqZWN0IiwicmVzdWx0cyIsIlByb21pc2UiLCJhbGwiLCJrIiwicmVzb2x2ZSIsInJlZHVjZSIsImFjY3VtIiwidiIsImluZGV4IiwiZGVmaW5lUHJvcGVydGllcyIsInRhcmdldCIsInZhbHVlcyIsImtleSIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/utils/properties.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/utils/rlp-decode.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/rlp-decode.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeRlp: function() { return /* binding */ decodeRlp; }\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n//See: https://github.com/ethereum/wiki/wiki/RLP\n\n\n\nfunction hexlifyByte(value) {\n    let result = value.toString(16);\n    while(result.length < 2){\n        result = \"0\" + result;\n    }\n    return \"0x\" + result;\n}\nfunction unarrayifyInteger(data, offset, length) {\n    let result = 0;\n    for(let i = 0; i < length; i++){\n        result = result * 256 + data[offset + i];\n    }\n    return result;\n}\nfunction _decodeChildren(data, offset, childOffset, length) {\n    const result = [];\n    while(childOffset < offset + 1 + length){\n        const decoded = _decode(data, childOffset);\n        result.push(decoded.result);\n        childOffset += decoded.consumed;\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(childOffset <= offset + 1 + length, \"child data too short\", \"BUFFER_OVERRUN\", {\n            buffer: data,\n            length,\n            offset\n        });\n    }\n    return {\n        consumed: 1 + length,\n        result: result\n    };\n}\n// returns { consumed: number, result: Object }\nfunction _decode(data, offset) {\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(data.length !== 0, \"data too short\", \"BUFFER_OVERRUN\", {\n        buffer: data,\n        length: 0,\n        offset: 1\n    });\n    const checkOffset = (offset)=>{\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(offset <= data.length, \"data short segment too short\", \"BUFFER_OVERRUN\", {\n            buffer: data,\n            length: data.length,\n            offset\n        });\n    };\n    // Array with extra length prefix\n    if (data[offset] >= 0xf8) {\n        const lengthLength = data[offset] - 0xf7;\n        checkOffset(offset + 1 + lengthLength);\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        checkOffset(offset + 1 + lengthLength + length);\n        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n    } else if (data[offset] >= 0xc0) {\n        const length = data[offset] - 0xc0;\n        checkOffset(offset + 1 + length);\n        return _decodeChildren(data, offset, offset + 1, length);\n    } else if (data[offset] >= 0xb8) {\n        const lengthLength = data[offset] - 0xb7;\n        checkOffset(offset + 1 + lengthLength);\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        checkOffset(offset + 1 + lengthLength + length);\n        const result = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n        return {\n            consumed: 1 + lengthLength + length,\n            result: result\n        };\n    } else if (data[offset] >= 0x80) {\n        const length = data[offset] - 0x80;\n        checkOffset(offset + 1 + length);\n        const result = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(data.slice(offset + 1, offset + 1 + length));\n        return {\n            consumed: 1 + length,\n            result: result\n        };\n    }\n    return {\n        consumed: 1,\n        result: hexlifyByte(data[offset])\n    };\n}\n/**\n *  Decodes %%data%% into the structured data it represents.\n */ function decodeRlp(_data) {\n    const data = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_data, \"data\");\n    const decoded = _decode(data, 0);\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(decoded.consumed === data.length, \"unexpected junk after rlp payload\", \"data\", _data);\n    return decoded.result;\n} //# sourceMappingURL=rlp-decode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9ybHAtZGVjb2RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLGdEQUFnRDtBQUNaO0FBQ2lCO0FBQ2hCO0FBQ3JDLFNBQVNJLFlBQVlDLEtBQUs7SUFDdEIsSUFBSUMsU0FBU0QsTUFBTUUsUUFBUSxDQUFDO0lBQzVCLE1BQU9ELE9BQU9FLE1BQU0sR0FBRyxFQUFHO1FBQ3RCRixTQUFTLE1BQU1BO0lBQ25CO0lBQ0EsT0FBTyxPQUFPQTtBQUNsQjtBQUNBLFNBQVNHLGtCQUFrQkMsSUFBSSxFQUFFQyxNQUFNLEVBQUVILE1BQU07SUFDM0MsSUFBSUYsU0FBUztJQUNiLElBQUssSUFBSU0sSUFBSSxHQUFHQSxJQUFJSixRQUFRSSxJQUFLO1FBQzdCTixTQUFTLFNBQVUsTUFBT0ksSUFBSSxDQUFDQyxTQUFTQyxFQUFFO0lBQzlDO0lBQ0EsT0FBT047QUFDWDtBQUNBLFNBQVNPLGdCQUFnQkgsSUFBSSxFQUFFQyxNQUFNLEVBQUVHLFdBQVcsRUFBRU4sTUFBTTtJQUN0RCxNQUFNRixTQUFTLEVBQUU7SUFDakIsTUFBT1EsY0FBY0gsU0FBUyxJQUFJSCxPQUFRO1FBQ3RDLE1BQU1PLFVBQVVDLFFBQVFOLE1BQU1JO1FBQzlCUixPQUFPVyxJQUFJLENBQUNGLFFBQVFULE1BQU07UUFDMUJRLGVBQWVDLFFBQVFHLFFBQVE7UUFDL0JqQixrREFBTUEsQ0FBQ2EsZUFBZUgsU0FBUyxJQUFJSCxRQUFRLHdCQUF3QixrQkFBa0I7WUFDakZXLFFBQVFUO1lBQU1GO1lBQVFHO1FBQzFCO0lBQ0o7SUFDQSxPQUFPO1FBQUVPLFVBQVcsSUFBSVY7UUFBU0YsUUFBUUE7SUFBTztBQUNwRDtBQUNBLCtDQUErQztBQUMvQyxTQUFTVSxRQUFRTixJQUFJLEVBQUVDLE1BQU07SUFDekJWLGtEQUFNQSxDQUFDUyxLQUFLRixNQUFNLEtBQUssR0FBRyxrQkFBa0Isa0JBQWtCO1FBQzFEVyxRQUFRVDtRQUFNRixRQUFRO1FBQUdHLFFBQVE7SUFDckM7SUFDQSxNQUFNUyxjQUFjLENBQUNUO1FBQ2pCVixrREFBTUEsQ0FBQ1UsVUFBVUQsS0FBS0YsTUFBTSxFQUFFLGdDQUFnQyxrQkFBa0I7WUFDNUVXLFFBQVFUO1lBQU1GLFFBQVFFLEtBQUtGLE1BQU07WUFBRUc7UUFDdkM7SUFDSjtJQUNBLGlDQUFpQztJQUNqQyxJQUFJRCxJQUFJLENBQUNDLE9BQU8sSUFBSSxNQUFNO1FBQ3RCLE1BQU1VLGVBQWVYLElBQUksQ0FBQ0MsT0FBTyxHQUFHO1FBQ3BDUyxZQUFZVCxTQUFTLElBQUlVO1FBQ3pCLE1BQU1iLFNBQVNDLGtCQUFrQkMsTUFBTUMsU0FBUyxHQUFHVTtRQUNuREQsWUFBWVQsU0FBUyxJQUFJVSxlQUFlYjtRQUN4QyxPQUFPSyxnQkFBZ0JILE1BQU1DLFFBQVFBLFNBQVMsSUFBSVUsY0FBY0EsZUFBZWI7SUFDbkYsT0FDSyxJQUFJRSxJQUFJLENBQUNDLE9BQU8sSUFBSSxNQUFNO1FBQzNCLE1BQU1ILFNBQVNFLElBQUksQ0FBQ0MsT0FBTyxHQUFHO1FBQzlCUyxZQUFZVCxTQUFTLElBQUlIO1FBQ3pCLE9BQU9LLGdCQUFnQkgsTUFBTUMsUUFBUUEsU0FBUyxHQUFHSDtJQUNyRCxPQUNLLElBQUlFLElBQUksQ0FBQ0MsT0FBTyxJQUFJLE1BQU07UUFDM0IsTUFBTVUsZUFBZVgsSUFBSSxDQUFDQyxPQUFPLEdBQUc7UUFDcENTLFlBQVlULFNBQVMsSUFBSVU7UUFDekIsTUFBTWIsU0FBU0Msa0JBQWtCQyxNQUFNQyxTQUFTLEdBQUdVO1FBQ25ERCxZQUFZVCxTQUFTLElBQUlVLGVBQWViO1FBQ3hDLE1BQU1GLFNBQVNOLGlEQUFPQSxDQUFDVSxLQUFLWSxLQUFLLENBQUNYLFNBQVMsSUFBSVUsY0FBY1YsU0FBUyxJQUFJVSxlQUFlYjtRQUN6RixPQUFPO1lBQUVVLFVBQVcsSUFBSUcsZUFBZWI7WUFBU0YsUUFBUUE7UUFBTztJQUNuRSxPQUNLLElBQUlJLElBQUksQ0FBQ0MsT0FBTyxJQUFJLE1BQU07UUFDM0IsTUFBTUgsU0FBU0UsSUFBSSxDQUFDQyxPQUFPLEdBQUc7UUFDOUJTLFlBQVlULFNBQVMsSUFBSUg7UUFDekIsTUFBTUYsU0FBU04saURBQU9BLENBQUNVLEtBQUtZLEtBQUssQ0FBQ1gsU0FBUyxHQUFHQSxTQUFTLElBQUlIO1FBQzNELE9BQU87WUFBRVUsVUFBVyxJQUFJVjtZQUFTRixRQUFRQTtRQUFPO0lBQ3BEO0lBQ0EsT0FBTztRQUFFWSxVQUFVO1FBQUdaLFFBQVFGLFlBQVlNLElBQUksQ0FBQ0MsT0FBTztJQUFFO0FBQzVEO0FBQ0E7O0NBRUMsR0FDTSxTQUFTWSxVQUFVQyxLQUFLO0lBQzNCLE1BQU1kLE9BQU9QLGtEQUFRQSxDQUFDcUIsT0FBTztJQUM3QixNQUFNVCxVQUFVQyxRQUFRTixNQUFNO0lBQzlCUiwwREFBY0EsQ0FBQ2EsUUFBUUcsUUFBUSxLQUFLUixLQUFLRixNQUFNLEVBQUUscUNBQXFDLFFBQVFnQjtJQUM5RixPQUFPVCxRQUFRVCxNQUFNO0FBQ3pCLEVBQ0Esc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9ybHAtZGVjb2RlLmpzPzZlMzAiXSwic291cmNlc0NvbnRlbnQiOlsiLy9TZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvUkxQXG5pbXBvcnQgeyBoZXhsaWZ5IH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IHsgZ2V0Qnl0ZXMgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5mdW5jdGlvbiBoZXhsaWZ5Qnl0ZSh2YWx1ZSkge1xuICAgIGxldCByZXN1bHQgPSB2YWx1ZS50b1N0cmluZygxNik7XG4gICAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgcmVzdWx0O1xufVxuZnVuY3Rpb24gdW5hcnJheWlmeUludGVnZXIoZGF0YSwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCA9IChyZXN1bHQgKiAyNTYpICsgZGF0YVtvZmZzZXQgKyBpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIF9kZWNvZGVDaGlsZHJlbihkYXRhLCBvZmZzZXQsIGNoaWxkT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICB3aGlsZSAoY2hpbGRPZmZzZXQgPCBvZmZzZXQgKyAxICsgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSBfZGVjb2RlKGRhdGEsIGNoaWxkT2Zmc2V0KTtcbiAgICAgICAgcmVzdWx0LnB1c2goZGVjb2RlZC5yZXN1bHQpO1xuICAgICAgICBjaGlsZE9mZnNldCArPSBkZWNvZGVkLmNvbnN1bWVkO1xuICAgICAgICBhc3NlcnQoY2hpbGRPZmZzZXQgPD0gb2Zmc2V0ICsgMSArIGxlbmd0aCwgXCJjaGlsZCBkYXRhIHRvbyBzaG9ydFwiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHtcbiAgICAgICAgICAgIGJ1ZmZlcjogZGF0YSwgbGVuZ3RoLCBvZmZzZXRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aCksIHJlc3VsdDogcmVzdWx0IH07XG59XG4vLyByZXR1cm5zIHsgY29uc3VtZWQ6IG51bWJlciwgcmVzdWx0OiBPYmplY3QgfVxuZnVuY3Rpb24gX2RlY29kZShkYXRhLCBvZmZzZXQpIHtcbiAgICBhc3NlcnQoZGF0YS5sZW5ndGggIT09IDAsIFwiZGF0YSB0b28gc2hvcnRcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XG4gICAgICAgIGJ1ZmZlcjogZGF0YSwgbGVuZ3RoOiAwLCBvZmZzZXQ6IDFcbiAgICB9KTtcbiAgICBjb25zdCBjaGVja09mZnNldCA9IChvZmZzZXQpID0+IHtcbiAgICAgICAgYXNzZXJ0KG9mZnNldCA8PSBkYXRhLmxlbmd0aCwgXCJkYXRhIHNob3J0IHNlZ21lbnQgdG9vIHNob3J0XCIsIFwiQlVGRkVSX09WRVJSVU5cIiwge1xuICAgICAgICAgICAgYnVmZmVyOiBkYXRhLCBsZW5ndGg6IGRhdGEubGVuZ3RoLCBvZmZzZXRcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBBcnJheSB3aXRoIGV4dHJhIGxlbmd0aCBwcmVmaXhcbiAgICBpZiAoZGF0YVtvZmZzZXRdID49IDB4ZjgpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoTGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHhmNztcbiAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHVuYXJyYXlpZnlJbnRlZ2VyKGRhdGEsIG9mZnNldCArIDEsIGxlbmd0aExlbmd0aCk7XG4gICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGggKyBsZW5ndGgpO1xuICAgICAgICByZXR1cm4gX2RlY29kZUNoaWxkcmVuKGRhdGEsIG9mZnNldCwgb2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCwgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YVtvZmZzZXRdID49IDB4YzApIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHhjMDtcbiAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0ICsgMSArIGxlbmd0aCk7XG4gICAgICAgIHJldHVybiBfZGVjb2RlQ2hpbGRyZW4oZGF0YSwgb2Zmc2V0LCBvZmZzZXQgKyAxLCBsZW5ndGgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhW29mZnNldF0gPj0gMHhiOCkge1xuICAgICAgICBjb25zdCBsZW5ndGhMZW5ndGggPSBkYXRhW29mZnNldF0gLSAweGI3O1xuICAgICAgICBjaGVja09mZnNldChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdW5hcnJheWlmeUludGVnZXIoZGF0YSwgb2Zmc2V0ICsgMSwgbGVuZ3RoTGVuZ3RoKTtcbiAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCArIGxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGhleGxpZnkoZGF0YS5zbGljZShvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoLCBvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aExlbmd0aCArIGxlbmd0aCksIHJlc3VsdDogcmVzdWx0IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGFbb2Zmc2V0XSA+PSAweDgwKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGRhdGFbb2Zmc2V0XSAtIDB4ODA7XG4gICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCArIDEgKyBsZW5ndGgpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBoZXhsaWZ5KGRhdGEuc2xpY2Uob2Zmc2V0ICsgMSwgb2Zmc2V0ICsgMSArIGxlbmd0aCkpO1xuICAgICAgICByZXR1cm4geyBjb25zdW1lZDogKDEgKyBsZW5ndGgpLCByZXN1bHQ6IHJlc3VsdCB9O1xuICAgIH1cbiAgICByZXR1cm4geyBjb25zdW1lZDogMSwgcmVzdWx0OiBoZXhsaWZ5Qnl0ZShkYXRhW29mZnNldF0pIH07XG59XG4vKipcbiAqICBEZWNvZGVzICUlZGF0YSUlIGludG8gdGhlIHN0cnVjdHVyZWQgZGF0YSBpdCByZXByZXNlbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlUmxwKF9kYXRhKSB7XG4gICAgY29uc3QgZGF0YSA9IGdldEJ5dGVzKF9kYXRhLCBcImRhdGFcIik7XG4gICAgY29uc3QgZGVjb2RlZCA9IF9kZWNvZGUoZGF0YSwgMCk7XG4gICAgYXNzZXJ0QXJndW1lbnQoZGVjb2RlZC5jb25zdW1lZCA9PT0gZGF0YS5sZW5ndGgsIFwidW5leHBlY3RlZCBqdW5rIGFmdGVyIHJscCBwYXlsb2FkXCIsIFwiZGF0YVwiLCBfZGF0YSk7XG4gICAgcmV0dXJuIGRlY29kZWQucmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmxwLWRlY29kZS5qcy5tYXAiXSwibmFtZXMiOlsiaGV4bGlmeSIsImFzc2VydCIsImFzc2VydEFyZ3VtZW50IiwiZ2V0Qnl0ZXMiLCJoZXhsaWZ5Qnl0ZSIsInZhbHVlIiwicmVzdWx0IiwidG9TdHJpbmciLCJsZW5ndGgiLCJ1bmFycmF5aWZ5SW50ZWdlciIsImRhdGEiLCJvZmZzZXQiLCJpIiwiX2RlY29kZUNoaWxkcmVuIiwiY2hpbGRPZmZzZXQiLCJkZWNvZGVkIiwiX2RlY29kZSIsInB1c2giLCJjb25zdW1lZCIsImJ1ZmZlciIsImNoZWNrT2Zmc2V0IiwibGVuZ3RoTGVuZ3RoIiwic2xpY2UiLCJkZWNvZGVSbHAiLCJfZGF0YSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/utils/rlp-decode.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/utils/rlp-encode.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/rlp-encode.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeRlp: function() { return /* binding */ encodeRlp; }\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n//See: https://github.com/ethereum/wiki/wiki/RLP\n\nfunction arrayifyInteger(value) {\n    const result = [];\n    while(value){\n        result.unshift(value & 0xff);\n        value >>= 8;\n    }\n    return result;\n}\nfunction _encode(object) {\n    if (Array.isArray(object)) {\n        let payload = [];\n        object.forEach(function(child) {\n            payload = payload.concat(_encode(child));\n        });\n        if (payload.length <= 55) {\n            payload.unshift(0xc0 + payload.length);\n            return payload;\n        }\n        const length = arrayifyInteger(payload.length);\n        length.unshift(0xf7 + length.length);\n        return length.concat(payload);\n    }\n    const data = Array.prototype.slice.call((0,_data_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(object, \"object\"));\n    if (data.length === 1 && data[0] <= 0x7f) {\n        return data;\n    } else if (data.length <= 55) {\n        data.unshift(0x80 + data.length);\n        return data;\n    }\n    const length = arrayifyInteger(data.length);\n    length.unshift(0xb7 + length.length);\n    return length.concat(data);\n}\nconst nibbles = \"0123456789abcdef\";\n/**\n *  Encodes %%object%% as an RLP-encoded [[DataHexString]].\n */ function encodeRlp(object) {\n    let result = \"0x\";\n    for (const v of _encode(object)){\n        result += nibbles[v >> 4];\n        result += nibbles[v & 0xf];\n    }\n    return result;\n} //# sourceMappingURL=rlp-encode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9ybHAtZW5jb2RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsZ0RBQWdEO0FBQ1g7QUFDckMsU0FBU0MsZ0JBQWdCQyxLQUFLO0lBQzFCLE1BQU1DLFNBQVMsRUFBRTtJQUNqQixNQUFPRCxNQUFPO1FBQ1ZDLE9BQU9DLE9BQU8sQ0FBQ0YsUUFBUTtRQUN2QkEsVUFBVTtJQUNkO0lBQ0EsT0FBT0M7QUFDWDtBQUNBLFNBQVNFLFFBQVFDLE1BQU07SUFDbkIsSUFBSUMsTUFBTUMsT0FBTyxDQUFDRixTQUFTO1FBQ3ZCLElBQUlHLFVBQVUsRUFBRTtRQUNoQkgsT0FBT0ksT0FBTyxDQUFDLFNBQVVDLEtBQUs7WUFDMUJGLFVBQVVBLFFBQVFHLE1BQU0sQ0FBQ1AsUUFBUU07UUFDckM7UUFDQSxJQUFJRixRQUFRSSxNQUFNLElBQUksSUFBSTtZQUN0QkosUUFBUUwsT0FBTyxDQUFDLE9BQU9LLFFBQVFJLE1BQU07WUFDckMsT0FBT0o7UUFDWDtRQUNBLE1BQU1JLFNBQVNaLGdCQUFnQlEsUUFBUUksTUFBTTtRQUM3Q0EsT0FBT1QsT0FBTyxDQUFDLE9BQU9TLE9BQU9BLE1BQU07UUFDbkMsT0FBT0EsT0FBT0QsTUFBTSxDQUFDSDtJQUN6QjtJQUNBLE1BQU1LLE9BQU9QLE1BQU1RLFNBQVMsQ0FBQ0MsS0FBSyxDQUFDQyxJQUFJLENBQUNqQixrREFBUUEsQ0FBQ00sUUFBUTtJQUN6RCxJQUFJUSxLQUFLRCxNQUFNLEtBQUssS0FBS0MsSUFBSSxDQUFDLEVBQUUsSUFBSSxNQUFNO1FBQ3RDLE9BQU9BO0lBQ1gsT0FDSyxJQUFJQSxLQUFLRCxNQUFNLElBQUksSUFBSTtRQUN4QkMsS0FBS1YsT0FBTyxDQUFDLE9BQU9VLEtBQUtELE1BQU07UUFDL0IsT0FBT0M7SUFDWDtJQUNBLE1BQU1ELFNBQVNaLGdCQUFnQmEsS0FBS0QsTUFBTTtJQUMxQ0EsT0FBT1QsT0FBTyxDQUFDLE9BQU9TLE9BQU9BLE1BQU07SUFDbkMsT0FBT0EsT0FBT0QsTUFBTSxDQUFDRTtBQUN6QjtBQUNBLE1BQU1JLFVBQVU7QUFDaEI7O0NBRUMsR0FDTSxTQUFTQyxVQUFVYixNQUFNO0lBQzVCLElBQUlILFNBQVM7SUFDYixLQUFLLE1BQU1pQixLQUFLZixRQUFRQyxRQUFTO1FBQzdCSCxVQUFVZSxPQUFPLENBQUNFLEtBQUssRUFBRTtRQUN6QmpCLFVBQVVlLE9BQU8sQ0FBQ0UsSUFBSSxJQUFJO0lBQzlCO0lBQ0EsT0FBT2pCO0FBQ1gsRUFDQSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL3JscC1lbmNvZGUuanM/MDc4MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1NlZTogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9STFBcbmltcG9ydCB7IGdldEJ5dGVzIH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xuZnVuY3Rpb24gYXJyYXlpZnlJbnRlZ2VyKHZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgd2hpbGUgKHZhbHVlKSB7XG4gICAgICAgIHJlc3VsdC51bnNoaWZ0KHZhbHVlICYgMHhmZik7XG4gICAgICAgIHZhbHVlID4+PSA4O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gX2VuY29kZShvYmplY3QpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgIGxldCBwYXlsb2FkID0gW107XG4gICAgICAgIG9iamVjdC5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgcGF5bG9hZCA9IHBheWxvYWQuY29uY2F0KF9lbmNvZGUoY2hpbGQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwYXlsb2FkLmxlbmd0aCA8PSA1NSkge1xuICAgICAgICAgICAgcGF5bG9hZC51bnNoaWZ0KDB4YzAgKyBwYXlsb2FkLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW5ndGggPSBhcnJheWlmeUludGVnZXIocGF5bG9hZC5sZW5ndGgpO1xuICAgICAgICBsZW5ndGgudW5zaGlmdCgweGY3ICsgbGVuZ3RoLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBsZW5ndGguY29uY2F0KHBheWxvYWQpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZ2V0Qnl0ZXMob2JqZWN0LCBcIm9iamVjdFwiKSk7XG4gICAgaWYgKGRhdGEubGVuZ3RoID09PSAxICYmIGRhdGFbMF0gPD0gMHg3Zikge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YS5sZW5ndGggPD0gNTUpIHtcbiAgICAgICAgZGF0YS51bnNoaWZ0KDB4ODAgKyBkYXRhLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBjb25zdCBsZW5ndGggPSBhcnJheWlmeUludGVnZXIoZGF0YS5sZW5ndGgpO1xuICAgIGxlbmd0aC51bnNoaWZ0KDB4YjcgKyBsZW5ndGgubGVuZ3RoKTtcbiAgICByZXR1cm4gbGVuZ3RoLmNvbmNhdChkYXRhKTtcbn1cbmNvbnN0IG5pYmJsZXMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbi8qKlxuICogIEVuY29kZXMgJSVvYmplY3QlJSBhcyBhbiBSTFAtZW5jb2RlZCBbW0RhdGFIZXhTdHJpbmddXS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZVJscChvYmplY3QpIHtcbiAgICBsZXQgcmVzdWx0ID0gXCIweFwiO1xuICAgIGZvciAoY29uc3QgdiBvZiBfZW5jb2RlKG9iamVjdCkpIHtcbiAgICAgICAgcmVzdWx0ICs9IG5pYmJsZXNbdiA+PiA0XTtcbiAgICAgICAgcmVzdWx0ICs9IG5pYmJsZXNbdiAmIDB4Zl07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ybHAtZW5jb2RlLmpzLm1hcCJdLCJuYW1lcyI6WyJnZXRCeXRlcyIsImFycmF5aWZ5SW50ZWdlciIsInZhbHVlIiwicmVzdWx0IiwidW5zaGlmdCIsIl9lbmNvZGUiLCJvYmplY3QiLCJBcnJheSIsImlzQXJyYXkiLCJwYXlsb2FkIiwiZm9yRWFjaCIsImNoaWxkIiwiY29uY2F0IiwibGVuZ3RoIiwiZGF0YSIsInByb3RvdHlwZSIsInNsaWNlIiwiY2FsbCIsIm5pYmJsZXMiLCJlbmNvZGVSbHAiLCJ2Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/utils/rlp-encode.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/utils/utf8.js":
/*!***************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/utf8.js ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Utf8ErrorFuncs: function() { return /* binding */ Utf8ErrorFuncs; },\n/* harmony export */   toUtf8Bytes: function() { return /* binding */ toUtf8Bytes; },\n/* harmony export */   toUtf8CodePoints: function() { return /* binding */ toUtf8CodePoints; },\n/* harmony export */   toUtf8String: function() { return /* binding */ toUtf8String; }\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/**\n *  Using strings in Ethereum (or any security-basd system) requires\n *  additional care. These utilities attempt to mitigate some of the\n *  safety issues as well as provide the ability to recover and analyse\n *  strings.\n *\n *  @_subsection api/utils:Strings and UTF-8  [about-strings]\n */ \n\nfunction errorFunc(reason, offset, bytes, output, badCodepoint) {\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid codepoint at offset \".concat(offset, \"; \").concat(reason), \"bytes\", bytes);\n}\nfunction ignoreFunc(reason, offset, bytes, output, badCodepoint) {\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === \"BAD_PREFIX\" || reason === \"UNEXPECTED_CONTINUE\") {\n        let i = 0;\n        for(let o = offset + 1; o < bytes.length; o++){\n            if (bytes[o] >> 6 !== 0x02) {\n                break;\n            }\n            i++;\n        }\n        return i;\n    }\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === \"OVERRUN\") {\n        return bytes.length - offset - 1;\n    }\n    // Nothing to skip\n    return 0;\n}\nfunction replaceFunc(reason, offset, bytes, output, badCodepoint) {\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === \"OVERLONG\") {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof badCodepoint === \"number\", \"invalid bad code point for replacement\", \"badCodepoint\", badCodepoint);\n        output.push(badCodepoint);\n        return 0;\n    }\n    // Put the replacement character into the output\n    output.push(0xfffd);\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n/**\n *  A handful of popular, built-in UTF-8 error handling strategies.\n *\n *  **``\"error\"``** - throws on ANY illegal UTF-8 sequence or\n *  non-canonical (overlong) codepoints (this is the default)\n *\n *  **``\"ignore\"``** - silently drops any illegal UTF-8 sequence\n *  and accepts non-canonical (overlong) codepoints\n *\n *  **``\"replace\"``** - replace any illegal UTF-8 sequence with the\n *  UTF-8 replacement character (i.e. ``\"\\\\ufffd\"``) and accepts\n *  non-canonical (overlong) codepoints\n *\n *  @returns: Record<\"error\" | \"ignore\" | \"replace\", Utf8ErrorFunc>\n */ const Utf8ErrorFuncs = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(_bytes, onError) {\n    if (onError == null) {\n        onError = Utf8ErrorFuncs.error;\n    }\n    const bytes = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_bytes, \"bytes\");\n    const result = [];\n    let i = 0;\n    // Invalid bytes are ignored\n    while(i < bytes.length){\n        const c = bytes[i++];\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n        // 1110 xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n        // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n        } else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(\"UNEXPECTED_CONTINUE\", i - 1, bytes, result);\n            } else {\n                i += onError(\"BAD_PREFIX\", i - 1, bytes, result);\n            }\n            continue;\n        }\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(\"OVERRUN\", i - 1, bytes, result);\n            continue;\n        }\n        // Remove the length prefix from the char\n        let res = c & (1 << 8 - extraLength - 1) - 1;\n        for(let j = 0; j < extraLength; j++){\n            let nextChar = bytes[i];\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(\"MISSING_CONTINUE\", i, bytes, result);\n                res = null;\n                break;\n            }\n            ;\n            res = res << 6 | nextChar & 0x3f;\n            i++;\n        }\n        // See above loop for invalid continuation byte\n        if (res === null) {\n            continue;\n        }\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(\"OUT_OF_RANGE\", i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(\"UTF16_SURROGATE\", i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(\"OVERLONG\", i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        result.push(res);\n    }\n    return result;\n}\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\n/**\n *  Returns the UTF-8 byte representation of %%str%%.\n *\n *  If %%form%% is specified, the string is normalized.\n */ function toUtf8Bytes(str, form) {\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof str === \"string\", \"invalid string value\", \"str\", str);\n    if (form != null) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertNormalize)(form);\n        str = str.normalize(form);\n    }\n    let result = [];\n    for(let i = 0; i < str.length; i++){\n        const c = str.charCodeAt(i);\n        if (c < 0x80) {\n            result.push(c);\n        } else if (c < 0x800) {\n            result.push(c >> 6 | 0xc0);\n            result.push(c & 0x3f | 0x80);\n        } else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(i < str.length && (c2 & 0xfc00) === 0xdc00, \"invalid surrogate pair\", \"str\", str);\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push(pair >> 18 | 0xf0);\n            result.push(pair >> 12 & 0x3f | 0x80);\n            result.push(pair >> 6 & 0x3f | 0x80);\n            result.push(pair & 0x3f | 0x80);\n        } else {\n            result.push(c >> 12 | 0xe0);\n            result.push(c >> 6 & 0x3f | 0x80);\n            result.push(c & 0x3f | 0x80);\n        }\n    }\n    return new Uint8Array(result);\n}\n;\n//export \nfunction _toUtf8String(codePoints) {\n    return codePoints.map((codePoint)=>{\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode((codePoint >> 10 & 0x3ff) + 0xd800, (codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\");\n}\n/**\n *  Returns the string represented by the UTF-8 data %%bytes%%.\n *\n *  When %%onError%% function is specified, it is called on UTF-8\n *  errors allowing recovery using the [[Utf8ErrorFunc]] API.\n *  (default: [error](Utf8ErrorFuncs))\n */ function toUtf8String(bytes, onError) {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\n/**\n *  Returns the UTF-8 code-points for %%str%%.\n *\n *  If %%form%% is specified, the string is normalized.\n */ function toUtf8CodePoints(str, form) {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n} //# sourceMappingURL=utf8.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy91dGY4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7Ozs7O0NBT0MsR0FDb0M7QUFDeUI7QUFDOUQsU0FBU0csVUFBVUMsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUFFQyxZQUFZO0lBQzFEUCwwREFBY0EsQ0FBQyxPQUFPLCtCQUEwQ0csT0FBWEMsUUFBTyxNQUFXLE9BQVBELFNBQVUsU0FBU0U7QUFDdkY7QUFDQSxTQUFTRyxXQUFXTCxNQUFNLEVBQUVDLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxNQUFNLEVBQUVDLFlBQVk7SUFDM0QsdUdBQXVHO0lBQ3ZHLElBQUlKLFdBQVcsZ0JBQWdCQSxXQUFXLHVCQUF1QjtRQUM3RCxJQUFJTSxJQUFJO1FBQ1IsSUFBSyxJQUFJQyxJQUFJTixTQUFTLEdBQUdNLElBQUlMLE1BQU1NLE1BQU0sRUFBRUQsSUFBSztZQUM1QyxJQUFJTCxLQUFLLENBQUNLLEVBQUUsSUFBSSxNQUFNLE1BQU07Z0JBQ3hCO1lBQ0o7WUFDQUQ7UUFDSjtRQUNBLE9BQU9BO0lBQ1g7SUFDQSx3RUFBd0U7SUFDeEUsbUVBQW1FO0lBQ25FLElBQUlOLFdBQVcsV0FBVztRQUN0QixPQUFPRSxNQUFNTSxNQUFNLEdBQUdQLFNBQVM7SUFDbkM7SUFDQSxrQkFBa0I7SUFDbEIsT0FBTztBQUNYO0FBQ0EsU0FBU1EsWUFBWVQsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUFFQyxZQUFZO0lBQzVELHNGQUFzRjtJQUN0RixJQUFJSixXQUFXLFlBQVk7UUFDdkJILDBEQUFjQSxDQUFDLE9BQVFPLGlCQUFrQixVQUFVLDBDQUEwQyxnQkFBZ0JBO1FBQzdHRCxPQUFPTyxJQUFJLENBQUNOO1FBQ1osT0FBTztJQUNYO0lBQ0EsZ0RBQWdEO0lBQ2hERCxPQUFPTyxJQUFJLENBQUM7SUFDWiwyQ0FB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Q0o7SUFDQSxPQUFPLElBQUl3QixXQUFXZDtBQUMxQjs7QUFFQSxTQUFTO0FBQ1QsU0FBU2UsY0FBY0MsVUFBVTtJQUM3QixPQUFPQSxXQUFXQyxHQUFHLENBQUMsQ0FBQ0M7UUFDbkIsSUFBSUEsYUFBYSxRQUFRO1lBQ3JCLE9BQU9DLE9BQU9DLFlBQVksQ0FBQ0Y7UUFDL0I7UUFDQUEsYUFBYTtRQUNiLE9BQU9DLE9BQU9DLFlBQVksQ0FBRSxDQUFDLGFBQWMsS0FBTSxLQUFJLElBQUssUUFBVSxDQUFDRixZQUFZLEtBQUksSUFBSztJQUM5RixHQUFHRyxJQUFJLENBQUM7QUFDWjtBQUNBOzs7Ozs7Q0FNQyxHQUNNLFNBQVNDLGFBQWF4QyxLQUFLLEVBQUVpQixPQUFPO0lBQ3ZDLE9BQU9nQixjQUFjbEIsa0JBQWtCZixPQUFPaUI7QUFDbEQ7QUFDQTs7OztDQUlDLEdBQ00sU0FBU3dCLGlCQUFpQmYsR0FBRyxFQUFFQyxJQUFJO0lBQ3RDLE9BQU9aLGtCQUFrQlUsWUFBWUMsS0FBS0M7QUFDOUMsRUFDQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL3V0ZjguanM/MzJiYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBVc2luZyBzdHJpbmdzIGluIEV0aGVyZXVtIChvciBhbnkgc2VjdXJpdHktYmFzZCBzeXN0ZW0pIHJlcXVpcmVzXG4gKiAgYWRkaXRpb25hbCBjYXJlLiBUaGVzZSB1dGlsaXRpZXMgYXR0ZW1wdCB0byBtaXRpZ2F0ZSBzb21lIG9mIHRoZVxuICogIHNhZmV0eSBpc3N1ZXMgYXMgd2VsbCBhcyBwcm92aWRlIHRoZSBhYmlsaXR5IHRvIHJlY292ZXIgYW5kIGFuYWx5c2VcbiAqICBzdHJpbmdzLlxuICpcbiAqICBAX3N1YnNlY3Rpb24gYXBpL3V0aWxzOlN0cmluZ3MgYW5kIFVURi04ICBbYWJvdXQtc3RyaW5nc11cbiAqL1xuaW1wb3J0IHsgZ2V0Qnl0ZXMgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5pbXBvcnQgeyBhc3NlcnRBcmd1bWVudCwgYXNzZXJ0Tm9ybWFsaXplIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5mdW5jdGlvbiBlcnJvckZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCkge1xuICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgaW52YWxpZCBjb2RlcG9pbnQgYXQgb2Zmc2V0ICR7b2Zmc2V0fTsgJHtyZWFzb259YCwgXCJieXRlc1wiLCBieXRlcyk7XG59XG5mdW5jdGlvbiBpZ25vcmVGdW5jKHJlYXNvbiwgb2Zmc2V0LCBieXRlcywgb3V0cHV0LCBiYWRDb2RlcG9pbnQpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBpbnZhbGlkIHByZWZpeCAoaW5jbHVkaW5nIHN0cmF5IGNvbnRpbnVhdGlvbiksIHNraXAgYW55IGFkZGl0aW9uYWwgY29udGludWF0aW9uIGJ5dGVzXG4gICAgaWYgKHJlYXNvbiA9PT0gXCJCQURfUFJFRklYXCIgfHwgcmVhc29uID09PSBcIlVORVhQRUNURURfQ09OVElOVUVcIikge1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGZvciAobGV0IG8gPSBvZmZzZXQgKyAxOyBvIDwgYnl0ZXMubGVuZ3RoOyBvKyspIHtcbiAgICAgICAgICAgIGlmIChieXRlc1tvXSA+PiA2ICE9PSAweDAyKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIC8vIFRoaXMgYnl0ZSBydW5zIHVzIHBhc3QgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzbyBqdXN0IGp1bXAgdG8gdGhlIGVuZFxuICAgIC8vIChidXQgdGhlIGZpcnN0IGJ5dGUgd2FzIHJlYWQgYWxyZWFkeSByZWFkIGFuZCB0aGVyZWZvcmUgc2tpcHBlZClcbiAgICBpZiAocmVhc29uID09PSBcIk9WRVJSVU5cIikge1xuICAgICAgICByZXR1cm4gYnl0ZXMubGVuZ3RoIC0gb2Zmc2V0IC0gMTtcbiAgICB9XG4gICAgLy8gTm90aGluZyB0byBza2lwXG4gICAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiByZXBsYWNlRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KSB7XG4gICAgLy8gT3ZlcmxvbmcgcmVwcmVzZW50YXRpb25zIGFyZSBvdGhlcndpc2UgXCJ2YWxpZFwiIGNvZGUgcG9pbnRzOyBqdXN0IG5vbi1kZWlzdGluZ3Rpc2hlZFxuICAgIGlmIChyZWFzb24gPT09IFwiT1ZFUkxPTkdcIikge1xuICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKGJhZENvZGVwb2ludCkgPT09IFwibnVtYmVyXCIsIFwiaW52YWxpZCBiYWQgY29kZSBwb2ludCBmb3IgcmVwbGFjZW1lbnRcIiwgXCJiYWRDb2RlcG9pbnRcIiwgYmFkQ29kZXBvaW50KTtcbiAgICAgICAgb3V0cHV0LnB1c2goYmFkQ29kZXBvaW50KTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8vIFB1dCB0aGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGludG8gdGhlIG91dHB1dFxuICAgIG91dHB1dC5wdXNoKDB4ZmZmZCk7XG4gICAgLy8gT3RoZXJ3aXNlLCBwcm9jZXNzIGFzIGlmIGlnbm9yaW5nIGVycm9yc1xuICAgIHJldHVybiBpZ25vcmVGdW5jKHJlYXNvbiwgb2Zmc2V0LCBieXRlcywgb3V0cHV0LCBiYWRDb2RlcG9pbnQpO1xufVxuLyoqXG4gKiAgQSBoYW5kZnVsIG9mIHBvcHVsYXIsIGJ1aWx0LWluIFVURi04IGVycm9yIGhhbmRsaW5nIHN0cmF0ZWdpZXMuXG4gKlxuICogICoqYGBcImVycm9yXCJgYCoqIC0gdGhyb3dzIG9uIEFOWSBpbGxlZ2FsIFVURi04IHNlcXVlbmNlIG9yXG4gKiAgbm9uLWNhbm9uaWNhbCAob3ZlcmxvbmcpIGNvZGVwb2ludHMgKHRoaXMgaXMgdGhlIGRlZmF1bHQpXG4gKlxuICogICoqYGBcImlnbm9yZVwiYGAqKiAtIHNpbGVudGx5IGRyb3BzIGFueSBpbGxlZ2FsIFVURi04IHNlcXVlbmNlXG4gKiAgYW5kIGFjY2VwdHMgbm9uLWNhbm9uaWNhbCAob3ZlcmxvbmcpIGNvZGVwb2ludHNcbiAqXG4gKiAgKipgYFwicmVwbGFjZVwiYGAqKiAtIHJlcGxhY2UgYW55IGlsbGVnYWwgVVRGLTggc2VxdWVuY2Ugd2l0aCB0aGVcbiAqICBVVEYtOCByZXBsYWNlbWVudCBjaGFyYWN0ZXIgKGkuZS4gYGBcIlxcXFx1ZmZmZFwiYGApIGFuZCBhY2NlcHRzXG4gKiAgbm9uLWNhbm9uaWNhbCAob3ZlcmxvbmcpIGNvZGVwb2ludHNcbiAqXG4gKiAgQHJldHVybnM6IFJlY29yZDxcImVycm9yXCIgfCBcImlnbm9yZVwiIHwgXCJyZXBsYWNlXCIsIFV0ZjhFcnJvckZ1bmM+XG4gKi9cbmV4cG9ydCBjb25zdCBVdGY4RXJyb3JGdW5jcyA9IE9iamVjdC5mcmVlemUoe1xuICAgIGVycm9yOiBlcnJvckZ1bmMsXG4gICAgaWdub3JlOiBpZ25vcmVGdW5jLFxuICAgIHJlcGxhY2U6IHJlcGxhY2VGdW5jXG59KTtcbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTMzNTY0OTMvZGVjb2RlLXV0Zi04LXdpdGgtamF2YXNjcmlwdCMxMzY5MTQ5OVxuZnVuY3Rpb24gZ2V0VXRmOENvZGVQb2ludHMoX2J5dGVzLCBvbkVycm9yKSB7XG4gICAgaWYgKG9uRXJyb3IgPT0gbnVsbCkge1xuICAgICAgICBvbkVycm9yID0gVXRmOEVycm9yRnVuY3MuZXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoX2J5dGVzLCBcImJ5dGVzXCIpO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBpID0gMDtcbiAgICAvLyBJbnZhbGlkIGJ5dGVzIGFyZSBpZ25vcmVkXG4gICAgd2hpbGUgKGkgPCBieXRlcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgYyA9IGJ5dGVzW2krK107XG4gICAgICAgIC8vIDB4eHggeHh4eFxuICAgICAgICBpZiAoYyA+PiA3ID09PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChjKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE11bHRpYnl0ZTsgaG93IG1hbnkgYnl0ZXMgbGVmdCBmb3IgdGhpcyBjaGFyYWN0ZXI/XG4gICAgICAgIGxldCBleHRyYUxlbmd0aCA9IG51bGw7XG4gICAgICAgIGxldCBvdmVybG9uZ01hc2sgPSBudWxsO1xuICAgICAgICAvLyAxMTB4IHh4eHggMTB4eCB4eHh4XG4gICAgICAgIGlmICgoYyAmIDB4ZTApID09PSAweGMwKSB7XG4gICAgICAgICAgICBleHRyYUxlbmd0aCA9IDE7XG4gICAgICAgICAgICBvdmVybG9uZ01hc2sgPSAweDdmO1xuICAgICAgICAgICAgLy8gMTExMCB4eHh4IDEweHggeHh4eCAxMHh4IHh4eHhcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZjApID09PSAweGUwKSB7XG4gICAgICAgICAgICBleHRyYUxlbmd0aCA9IDI7XG4gICAgICAgICAgICBvdmVybG9uZ01hc2sgPSAweDdmZjtcbiAgICAgICAgICAgIC8vIDExMTEgMHh4eCAxMHh4IHh4eHggMTB4eCB4eHh4IDEweHggeHh4eFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChjICYgMHhmOCkgPT09IDB4ZjApIHtcbiAgICAgICAgICAgIGV4dHJhTGVuZ3RoID0gMztcbiAgICAgICAgICAgIG92ZXJsb25nTWFzayA9IDB4ZmZmZjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICgoYyAmIDB4YzApID09PSAweDgwKSB7XG4gICAgICAgICAgICAgICAgaSArPSBvbkVycm9yKFwiVU5FWFBFQ1RFRF9DT05USU5VRVwiLCBpIC0gMSwgYnl0ZXMsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpICs9IG9uRXJyb3IoXCJCQURfUFJFRklYXCIsIGkgLSAxLCBieXRlcywgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvIHdlIGhhdmUgZW5vdWdoIGJ5dGVzIGluIG91ciBkYXRhP1xuICAgICAgICBpZiAoaSAtIDEgKyBleHRyYUxlbmd0aCA+PSBieXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIk9WRVJSVU5cIiwgaSAtIDEsIGJ5dGVzLCByZXN1bHQpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBsZW5ndGggcHJlZml4IGZyb20gdGhlIGNoYXJcbiAgICAgICAgbGV0IHJlcyA9IGMgJiAoKDEgPDwgKDggLSBleHRyYUxlbmd0aCAtIDEpKSAtIDEpO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGV4dHJhTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGxldCBuZXh0Q2hhciA9IGJ5dGVzW2ldO1xuICAgICAgICAgICAgLy8gSW52YWxpZCBjb250aW51YXRpb24gYnl0ZVxuICAgICAgICAgICAgaWYgKChuZXh0Q2hhciAmIDB4YzApICE9IDB4ODApIHtcbiAgICAgICAgICAgICAgICBpICs9IG9uRXJyb3IoXCJNSVNTSU5HX0NPTlRJTlVFXCIsIGksIGJ5dGVzLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIHJlcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA7XG4gICAgICAgICAgICByZXMgPSAocmVzIDw8IDYpIHwgKG5leHRDaGFyICYgMHgzZik7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2VlIGFib3ZlIGxvb3AgZm9yIGludmFsaWQgY29udGludWF0aW9uIGJ5dGVcbiAgICAgICAgaWYgKHJlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWF4aW11bSBjb2RlIHBvaW50XG4gICAgICAgIGlmIChyZXMgPiAweDEwZmZmZikge1xuICAgICAgICAgICAgaSArPSBvbkVycm9yKFwiT1VUX09GX1JBTkdFXCIsIGkgLSAxIC0gZXh0cmFMZW5ndGgsIGJ5dGVzLCByZXN1bHQsIHJlcyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXNlcnZlZCBmb3IgVVRGLTE2IHN1cnJvZ2F0ZSBoYWx2ZXNcbiAgICAgICAgaWYgKHJlcyA+PSAweGQ4MDAgJiYgcmVzIDw9IDB4ZGZmZikge1xuICAgICAgICAgICAgaSArPSBvbkVycm9yKFwiVVRGMTZfU1VSUk9HQVRFXCIsIGkgLSAxIC0gZXh0cmFMZW5ndGgsIGJ5dGVzLCByZXN1bHQsIHJlcyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBmb3Igb3Zlcmxvbmcgc2VxdWVuY2VzIChtb3JlIGJ5dGVzIHRoYW4gbmVlZGVkKVxuICAgICAgICBpZiAocmVzIDw9IG92ZXJsb25nTWFzaykge1xuICAgICAgICAgICAgaSArPSBvbkVycm9yKFwiT1ZFUkxPTkdcIiwgaSAtIDEgLSBleHRyYUxlbmd0aCwgYnl0ZXMsIHJlc3VsdCwgcmVzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKHJlcyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE4NzI5NDA1L2hvdy10by1jb252ZXJ0LXV0Zjgtc3RyaW5nLXRvLWJ5dGUtYXJyYXlcbi8qKlxuICogIFJldHVybnMgdGhlIFVURi04IGJ5dGUgcmVwcmVzZW50YXRpb24gb2YgJSVzdHIlJS5cbiAqXG4gKiAgSWYgJSVmb3JtJSUgaXMgc3BlY2lmaWVkLCB0aGUgc3RyaW5nIGlzIG5vcm1hbGl6ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1V0ZjhCeXRlcyhzdHIsIGZvcm0pIHtcbiAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKHN0cikgPT09IFwic3RyaW5nXCIsIFwiaW52YWxpZCBzdHJpbmcgdmFsdWVcIiwgXCJzdHJcIiwgc3RyKTtcbiAgICBpZiAoZm9ybSAhPSBudWxsKSB7XG4gICAgICAgIGFzc2VydE5vcm1hbGl6ZShmb3JtKTtcbiAgICAgICAgc3RyID0gc3RyLm5vcm1hbGl6ZShmb3JtKTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjID4+IDYpIHwgMHhjMCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGMgJiAweGZjMDApID09IDB4ZDgwMCkge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgY29uc3QgYzIgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGkgPCBzdHIubGVuZ3RoICYmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApLCBcImludmFsaWQgc3Vycm9nYXRlIHBhaXJcIiwgXCJzdHJcIiwgc3RyKTtcbiAgICAgICAgICAgIC8vIFN1cnJvZ2F0ZSBQYWlyXG4gICAgICAgICAgICBjb25zdCBwYWlyID0gMHgxMDAwMCArICgoYyAmIDB4MDNmZikgPDwgMTApICsgKGMyICYgMHgwM2ZmKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChwYWlyID4+IDE4KSB8IDB4ZjApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKChwYWlyID4+IDEyKSAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoKHBhaXIgPj4gNikgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKHBhaXIgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGMgPj4gMTIpIHwgMHhlMCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoKGMgPj4gNikgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGMgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShyZXN1bHQpO1xufVxuO1xuLy9leHBvcnQgXG5mdW5jdGlvbiBfdG9VdGY4U3RyaW5nKGNvZGVQb2ludHMpIHtcbiAgICByZXR1cm4gY29kZVBvaW50cy5tYXAoKGNvZGVQb2ludCkgPT4ge1xuICAgICAgICBpZiAoY29kZVBvaW50IDw9IDB4ZmZmZikge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcbiAgICAgICAgfVxuICAgICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMDtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoKCgoY29kZVBvaW50ID4+IDEwKSAmIDB4M2ZmKSArIDB4ZDgwMCksICgoY29kZVBvaW50ICYgMHgzZmYpICsgMHhkYzAwKSk7XG4gICAgfSkuam9pbihcIlwiKTtcbn1cbi8qKlxuICogIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRlZCBieSB0aGUgVVRGLTggZGF0YSAlJWJ5dGVzJSUuXG4gKlxuICogIFdoZW4gJSVvbkVycm9yJSUgZnVuY3Rpb24gaXMgc3BlY2lmaWVkLCBpdCBpcyBjYWxsZWQgb24gVVRGLThcbiAqICBlcnJvcnMgYWxsb3dpbmcgcmVjb3ZlcnkgdXNpbmcgdGhlIFtbVXRmOEVycm9yRnVuY11dIEFQSS5cbiAqICAoZGVmYXVsdDogW2Vycm9yXShVdGY4RXJyb3JGdW5jcykpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1V0ZjhTdHJpbmcoYnl0ZXMsIG9uRXJyb3IpIHtcbiAgICByZXR1cm4gX3RvVXRmOFN0cmluZyhnZXRVdGY4Q29kZVBvaW50cyhieXRlcywgb25FcnJvcikpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgVVRGLTggY29kZS1wb2ludHMgZm9yICUlc3RyJSUuXG4gKlxuICogIElmICUlZm9ybSUlIGlzIHNwZWNpZmllZCwgdGhlIHN0cmluZyBpcyBub3JtYWxpemVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9VdGY4Q29kZVBvaW50cyhzdHIsIGZvcm0pIHtcbiAgICByZXR1cm4gZ2V0VXRmOENvZGVQb2ludHModG9VdGY4Qnl0ZXMoc3RyLCBmb3JtKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGY4LmpzLm1hcCJdLCJuYW1lcyI6WyJnZXRCeXRlcyIsImFzc2VydEFyZ3VtZW50IiwiYXNzZXJ0Tm9ybWFsaXplIiwiZXJyb3JGdW5jIiwicmVhc29uIiwib2Zmc2V0IiwiYnl0ZXMiLCJvdXRwdXQiLCJiYWRDb2RlcG9pbnQiLCJpZ25vcmVGdW5jIiwiaSIsIm8iLCJsZW5ndGgiLCJyZXBsYWNlRnVuYyIsInB1c2giLCJVdGY4RXJyb3JGdW5jcyIsIk9iamVjdCIsImZyZWV6ZSIsImVycm9yIiwiaWdub3JlIiwicmVwbGFjZSIsImdldFV0ZjhDb2RlUG9pbnRzIiwiX2J5dGVzIiwib25FcnJvciIsInJlc3VsdCIsImMiLCJleHRyYUxlbmd0aCIsIm92ZXJsb25nTWFzayIsInJlcyIsImoiLCJuZXh0Q2hhciIsInRvVXRmOEJ5dGVzIiwic3RyIiwiZm9ybSIsIm5vcm1hbGl6ZSIsImNoYXJDb2RlQXQiLCJjMiIsInBhaXIiLCJVaW50OEFycmF5IiwiX3RvVXRmOFN0cmluZyIsImNvZGVQb2ludHMiLCJtYXAiLCJjb2RlUG9pbnQiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJqb2luIiwidG9VdGY4U3RyaW5nIiwidG9VdGY4Q29kZVBvaW50cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/utils/utf8.js\n"));

/***/ })

});