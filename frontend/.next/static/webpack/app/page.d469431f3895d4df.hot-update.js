"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/services/web3.ts":
/*!******************************!*\
  !*** ./src/services/web3.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONTRACT_ABI: function() { return /* binding */ CONTRACT_ABI; },\n/* harmony export */   connectMetaMask: function() { return /* binding */ connectMetaMask; },\n/* harmony export */   getCurrentAccount: function() { return /* binding */ getCurrentAccount; },\n/* harmony export */   getFlightEventsFromChain: function() { return /* binding */ getFlightEventsFromChain; },\n/* harmony export */   isMetaMaskInstalled: function() { return /* binding */ isMetaMaskInstalled; },\n/* harmony export */   prepareRecordEventTransaction: function() { return /* binding */ prepareRecordEventTransaction; },\n/* harmony export */   recordEventViaMetaMask: function() { return /* binding */ recordEventViaMetaMask; },\n/* harmony export */   sendPreparedTransaction: function() { return /* binding */ sendPreparedTransaction; }\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/providers/provider-browser.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/contract/contract.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/**\n * Web3 Service - MetaMask Integration\n * \n * Handles blockchain interactions via MetaMask wallet.\n * Users sign and pay for their own transactions.\n */ \nconst API_URL = process.env.NEXT_PUBLIC_API_URL || \"http://localhost:8000/api\";\n// Contract ABI - must match FlightEventRegistry.sol\nconst CONTRACT_ABI = [\n    \"function recordEvent(string memory _flightId, string memory _eventType, uint256 _timestamp, string memory _actor, bytes32 _dataHash) external returns (uint256)\",\n    \"function getFlightEventIndices(string memory _flightId) external view returns (uint256[])\",\n    \"function getEvent(uint256 _index) external view returns (string memory flightId, string memory eventType, uint256 timestamp, string memory actor, bytes32 dataHash, uint256 blockNumber, uint256 recordedAt)\",\n    \"function getTotalEvents() external view returns (uint256)\",\n    \"function verifyHash(bytes32 _dataHash) external view returns (bool)\"\n];\n/**\n * Check if MetaMask is installed\n */ function isMetaMaskInstalled() {\n    return  true && typeof window.ethereum !== \"undefined\";\n}\n/**\n * Request account access from MetaMask\n */ async function connectMetaMask() {\n    if (!isMetaMaskInstalled()) {\n        throw new Error(\"MetaMask is not installed. Please install MetaMask to continue.\");\n    }\n    const provider = new ethers__WEBPACK_IMPORTED_MODULE_0__.BrowserProvider(window.ethereum);\n    const accounts = await provider.send(\"eth_requestAccounts\", []);\n    if (accounts.length === 0) {\n        throw new Error(\"No accounts found. Please unlock MetaMask.\");\n    }\n    return accounts[0];\n}\n/**\n * Get the current connected account\n */ async function getCurrentAccount() {\n    if (!isMetaMaskInstalled()) {\n        return null;\n    }\n    try {\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_0__.BrowserProvider(window.ethereum);\n        const accounts = await provider.listAccounts();\n        return accounts.length > 0 ? accounts[0].address : null;\n    } catch (e) {\n        return null;\n    }\n}\n/**\n * Get contract instance\n */ async function getContract(contractAddress) {\n    if (!isMetaMaskInstalled()) {\n        throw new Error(\"MetaMask is not installed\");\n    }\n    const provider = new ethers__WEBPACK_IMPORTED_MODULE_0__.BrowserProvider(window.ethereum);\n    const signer = await provider.getSigner();\n    return new ethers__WEBPACK_IMPORTED_MODULE_1__.Contract(contractAddress, CONTRACT_ABI, signer);\n}\n/**\n * Record a flight event on blockchain via MetaMask\n * \n * @param contractAddress - Address of the deployed FlightEventRegistry contract\n * @param flightId - Flight identifier (e.g., \"UA123\")\n * @param eventType - Type of event (e.g., \"DEPARTURE\")\n * @param timestamp - Unix timestamp\n * @param actor - Actor responsible (e.g., \"SYSTEM\")\n * @param dataHash - SHA256 hash of event data (0x-prefixed hex string)\n * @returns Transaction receipt\n */ async function recordEventViaMetaMask(contractAddress, flightId, eventType, timestamp, actor, dataHash) {\n    // Ensure account is connected\n    await connectMetaMask();\n    const contract = await getContract(contractAddress);\n    // Convert dataHash to bytes32 (ensure it's 32 bytes)\n    // ethers.js v6 handles hex strings directly, so we can use hexlify or ensure it's a hex string\n    let dataHashHex;\n    if (dataHash.startsWith(\"0x\")) {\n        dataHashHex = dataHash;\n    } else {\n        dataHashHex = \"0x\" + dataHash;\n    }\n    // Ensure it's exactly 66 characters (0x + 64 hex chars = 32 bytes)\n    if (dataHashHex.length !== 66) {\n        throw new Error(\"Data hash must be 32 bytes (64 hex characters)\");\n    }\n    // Convert to bytes32 format that ethers expects\n    const dataHashBytes32 = ethers__WEBPACK_IMPORTED_MODULE_2__.getBytes(dataHashHex);\n    // Estimate gas\n    const gasEstimate = await contract.recordEvent.estimateGas(flightId, eventType, timestamp, actor, dataHashBytes32);\n    // Send transaction (MetaMask will prompt user)\n    const tx = await contract.recordEvent(flightId, eventType, timestamp, actor, dataHashBytes32, {\n        gasLimit: gasEstimate * BigInt(120) / BigInt(100) // Add 20% buffer\n    });\n    // Wait for confirmation\n    const receipt = await tx.wait();\n    if (!receipt) {\n        throw new Error(\"Transaction receipt is null\");\n    }\n    return receipt;\n}\n/**\n * Read flight events from blockchain\n */ async function getFlightEventsFromChain(contractAddress, flightId) {\n    // Add timeout to prevent hanging\n    const timeout = 5000; // 5 seconds\n    try {\n        const providerPromise = isMetaMaskInstalled() ? new ethers__WEBPACK_IMPORTED_MODULE_0__.BrowserProvider(window.ethereum) : new ethers__WEBPACK_IMPORTED_MODULE_3__.JsonRpcProvider(process.env.NEXT_PUBLIC_GANACHE_URL || \"http://127.0.0.1:7545\");\n        const provider = await Promise.race([\n            providerPromise,\n            new Promise((_, reject)=>setTimeout(()=>reject(new Error(\"Provider connection timeout\")), timeout))\n        ]);\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_1__.Contract(contractAddress, CONTRACT_ABI, provider);\n        // Add timeout for contract calls\n        const indices = await Promise.race([\n            contract.getFlightEventIndices(flightId),\n            new Promise((_, reject)=>setTimeout(()=>reject(new Error(\"Contract call timeout\")), timeout))\n        ]);\n        if (!indices || indices.length === 0) {\n            return [];\n        }\n        const events = [];\n        for (const index of indices){\n            try {\n                // Call the getEvent function with the index\n                const eventData = await Promise.race([\n                    contract[\"getEvent\"](index),\n                    new Promise((_, reject)=>setTimeout(()=>reject(new Error(\"Event fetch timeout\")), timeout))\n                ]);\n                events.push({\n                    flightId: eventData[0],\n                    eventType: eventData[1],\n                    timestamp: Number(eventData[2]),\n                    actor: eventData[3],\n                    dataHash: eventData[4],\n                    blockNumber: Number(eventData[5]),\n                    recordedAt: Number(eventData[6])\n                });\n            } catch (error) {\n                console.warn(\"Failed to fetch event at index \".concat(index, \":\"), error);\n            // Continue with other events\n            }\n        }\n        return events;\n    } catch (error) {\n        console.error(\"Error fetching events from chain:\", error);\n        // Return empty array instead of throwing - allows flow to continue\n        return [];\n    }\n}\n/**\n * Prepare a transaction to record an event (without sending)\n */ async function prepareRecordEventTransaction(contractAddress, flightId, eventType, timestamp, actor, dataHash) {\n    const provider = new ethers__WEBPACK_IMPORTED_MODULE_3__.JsonRpcProvider(process.env.NEXT_PUBLIC_GANACHE_URL || \"http://127.0.0.1:8545\");\n    const contract = new ethers__WEBPACK_IMPORTED_MODULE_1__.Contract(contractAddress, CONTRACT_ABI, provider);\n    // Convert dataHash to bytes32\n    let dataHashHex;\n    if (dataHash.startsWith(\"0x\")) {\n        dataHashHex = dataHash;\n    } else {\n        dataHashHex = \"0x\" + dataHash;\n    }\n    // Ensure it's exactly 66 characters (0x + 64 hex chars = 32 bytes)\n    if (dataHashHex.length !== 66) {\n        throw new Error(\"Data hash must be 32 bytes (64 hex characters)\");\n    }\n    // Convert to bytes32 format\n    const dataHashBytes32 = ethers__WEBPACK_IMPORTED_MODULE_2__.getBytes(dataHashHex);\n    const data = contract.interface.encodeFunctionData(\"recordEvent\", [\n        flightId,\n        eventType,\n        timestamp,\n        actor,\n        dataHashBytes32\n    ]);\n    // Estimate gas\n    let gasEstimate;\n    try {\n        gasEstimate = await contract.recordEvent.estimateGas(flightId, eventType, timestamp, actor, dataHashBytes32);\n    } catch (e) {\n        gasEstimate = BigInt(300000); // Default fallback\n    }\n    return {\n        to: contractAddress,\n        data,\n        value: \"0x0\",\n        gas: \"0x\".concat(gasEstimate.toString(16))\n    };\n}\n/**\n * Send prepared transaction via MetaMask\n */ async function sendPreparedTransaction(transaction) {\n    if (!isMetaMaskInstalled()) {\n        throw new Error(\"MetaMask is not installed\");\n    }\n    await connectMetaMask();\n    const provider = new ethers__WEBPACK_IMPORTED_MODULE_0__.BrowserProvider(window.ethereum);\n    const signer = await provider.getSigner();\n    // MetaMask will prompt user for approval\n    const tx = await signer.sendTransaction({\n        to: transaction.to,\n        data: transaction.data,\n        value: transaction.value,\n        gasLimit: transaction.gas ? BigInt(transaction.gas) : undefined\n    });\n    const receipt = await tx.wait();\n    return receipt;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy93ZWIzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQUUrQjtBQUdoQyxNQUFNQyxVQUFVQyxPQUFPQSxDQUFDQyxHQUFHLENBQUNDLG1CQUFtQixJQUFJO0FBRW5ELG9EQUFvRDtBQUM3QyxNQUFNQyxlQUFlO0lBQ3hCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDSCxDQUFDO0FBRUY7O0NBRUMsR0FDTSxTQUFTQztJQUNaLE9BQU8sS0FBa0IsSUFBZSxPQUFPLE9BQWdCRSxRQUFRLEtBQUs7QUFDaEY7QUFFQTs7Q0FFQyxHQUNNLGVBQWVDO0lBQ2xCLElBQUksQ0FBQ0gsdUJBQXVCO1FBQ3hCLE1BQU0sSUFBSUksTUFBTTtJQUNwQjtJQUVBLE1BQU1DLFdBQVcsSUFBSVgsbURBQXNCLENBQUMsT0FBZ0JRLFFBQVE7SUFDcEUsTUFBTUssV0FBVyxNQUFNRixTQUFTRyxJQUFJLENBQUMsdUJBQXVCLEVBQUU7SUFFOUQsSUFBSUQsU0FBU0UsTUFBTSxLQUFLLEdBQUc7UUFDdkIsTUFBTSxJQUFJTCxNQUFNO0lBQ3BCO0lBRUEsT0FBT0csUUFBUSxDQUFDLEVBQUU7QUFDdEI7QUFFQTs7Q0FFQyxHQUNNLGVBQWVHO0lBQ2xCLElBQUksQ0FBQ1YsdUJBQXVCO1FBQ3hCLE9BQU87SUFDWDtJQUVBLElBQUk7UUFDQSxNQUFNSyxXQUFXLElBQUlYLG1EQUFzQixDQUFDLE9BQWdCUSxRQUFRO1FBQ3BFLE1BQU1LLFdBQVcsTUFBTUYsU0FBU00sWUFBWTtRQUM1QyxPQUFPSixTQUFTRSxNQUFNLEdBQUcsSUFBSUYsUUFBUSxDQUFDLEVBQUUsQ0FBQ0ssT0FBTyxHQUFHO0lBQ3ZELEVBQUUsVUFBTTtRQUNKLE9BQU87SUFDWDtBQUNKO0FBRUE7O0NBRUMsR0FDRCxlQUFlQyxZQUFZQyxlQUF1QjtJQUM5QyxJQUFJLENBQUNkLHVCQUF1QjtRQUN4QixNQUFNLElBQUlJLE1BQU07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UUFDQUM7UUFDQUs7S0FDSDtJQUVELGVBQWU7SUFDZixJQUFJRTtJQUNKLElBQUk7UUFDQUEsY0FBYyxNQUFNTCxTQUFTTSxXQUFXLENBQUNDLFdBQVcsQ0FDaERaLFVBQ0FDLFdBQ0FDLFdBQ0FDLE9BQ0FLO0lBRVIsRUFBRSxVQUFNO1FBQ0pFLGNBQWNLLE9BQU8sU0FBUyxtQkFBbUI7SUFDckQ7SUFFQSxPQUFPO1FBQ0g2QixJQUFJakQ7UUFDSjhDO1FBQ0FJLE9BQU87UUFDUEMsS0FBSyxLQUE4QixPQUF6QnBDLFlBQVlxQyxRQUFRLENBQUM7SUFDbkM7QUFDSjtBQUVBOztDQUVDLEdBQ00sZUFBZUMsd0JBQ2xCQyxXQUFnQztJQUVoQyxJQUFJLENBQUNwRSx1QkFBdUI7UUFDeEIsTUFBTSxJQUFJSSxNQUFNO0lBQ3BCO0lBRUEsTUFBTUQ7SUFFTixNQUFNRSxXQUFXLElBQUlYLG1EQUFzQixDQUFDLE9BQWdCUSxRQUFRO0lBQ3BFLE1BQU1hLFNBQVMsTUFBTVYsU0FBU1csU0FBUztJQUV2Qyx5Q0FBeUM7SUFDekMsTUFBTWdCLEtBQUssTUFBTWpCLE9BQU9zRCxlQUFlLENBQUM7UUFDcENOLElBQUlLLFlBQVlMLEVBQUU7UUFDbEJILE1BQU1RLFlBQVlSLElBQUk7UUFDdEJJLE9BQU9JLFlBQVlKLEtBQUs7UUFDeEIvQixVQUFVbUMsWUFBWUgsR0FBRyxHQUFHL0IsT0FBT2tDLFlBQVlILEdBQUcsSUFBSUs7SUFDMUQ7SUFFQSxNQUFNbkMsVUFBVSxNQUFNSCxHQUFHSSxJQUFJO0lBQzdCLE9BQU9EO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3NlcnZpY2VzL3dlYjMudHM/MTFiOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFdlYjMgU2VydmljZSAtIE1ldGFNYXNrIEludGVncmF0aW9uXG4gKiBcbiAqIEhhbmRsZXMgYmxvY2tjaGFpbiBpbnRlcmFjdGlvbnMgdmlhIE1ldGFNYXNrIHdhbGxldC5cbiAqIFVzZXJzIHNpZ24gYW5kIHBheSBmb3IgdGhlaXIgb3duIHRyYW5zYWN0aW9ucy5cbiAqL1xuXG5pbXBvcnQgeyBldGhlcnMgfSBmcm9tICdldGhlcnMnO1xuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcblxuY29uc3QgQVBJX1VSTCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwgfHwgJ2h0dHA6Ly9sb2NhbGhvc3Q6ODAwMC9hcGknO1xuXG4vLyBDb250cmFjdCBBQkkgLSBtdXN0IG1hdGNoIEZsaWdodEV2ZW50UmVnaXN0cnkuc29sXG5leHBvcnQgY29uc3QgQ09OVFJBQ1RfQUJJID0gW1xuICAgIFwiZnVuY3Rpb24gcmVjb3JkRXZlbnQoc3RyaW5nIG1lbW9yeSBfZmxpZ2h0SWQsIHN0cmluZyBtZW1vcnkgX2V2ZW50VHlwZSwgdWludDI1NiBfdGltZXN0YW1wLCBzdHJpbmcgbWVtb3J5IF9hY3RvciwgYnl0ZXMzMiBfZGF0YUhhc2gpIGV4dGVybmFsIHJldHVybnMgKHVpbnQyNTYpXCIsXG4gICAgXCJmdW5jdGlvbiBnZXRGbGlnaHRFdmVudEluZGljZXMoc3RyaW5nIG1lbW9yeSBfZmxpZ2h0SWQpIGV4dGVybmFsIHZpZXcgcmV0dXJucyAodWludDI1NltdKVwiLFxuICAgIFwiZnVuY3Rpb24gZ2V0RXZlbnQodWludDI1NiBfaW5kZXgpIGV4dGVybmFsIHZpZXcgcmV0dXJucyAoc3RyaW5nIG1lbW9yeSBmbGlnaHRJZCwgc3RyaW5nIG1lbW9yeSBldmVudFR5cGUsIHVpbnQyNTYgdGltZXN0YW1wLCBzdHJpbmcgbWVtb3J5IGFjdG9yLCBieXRlczMyIGRhdGFIYXNoLCB1aW50MjU2IGJsb2NrTnVtYmVyLCB1aW50MjU2IHJlY29yZGVkQXQpXCIsXG4gICAgXCJmdW5jdGlvbiBnZXRUb3RhbEV2ZW50cygpIGV4dGVybmFsIHZpZXcgcmV0dXJucyAodWludDI1NilcIixcbiAgICBcImZ1bmN0aW9uIHZlcmlmeUhhc2goYnl0ZXMzMiBfZGF0YUhhc2gpIGV4dGVybmFsIHZpZXcgcmV0dXJucyAoYm9vbClcIlxuXTtcblxuLyoqXG4gKiBDaGVjayBpZiBNZXRhTWFzayBpcyBpbnN0YWxsZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTWV0YU1hc2tJbnN0YWxsZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiAod2luZG93IGFzIGFueSkuZXRoZXJldW0gIT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIFJlcXVlc3QgYWNjb3VudCBhY2Nlc3MgZnJvbSBNZXRhTWFza1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29ubmVjdE1ldGFNYXNrKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgaWYgKCFpc01ldGFNYXNrSW5zdGFsbGVkKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRhTWFzayBpcyBub3QgaW5zdGFsbGVkLiBQbGVhc2UgaW5zdGFsbCBNZXRhTWFzayB0byBjb250aW51ZS4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBldGhlcnMuQnJvd3NlclByb3ZpZGVyKCh3aW5kb3cgYXMgYW55KS5ldGhlcmV1bSk7XG4gICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCBwcm92aWRlci5zZW5kKCdldGhfcmVxdWVzdEFjY291bnRzJywgW10pO1xuICAgIFxuICAgIGlmIChhY2NvdW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY2NvdW50cyBmb3VuZC4gUGxlYXNlIHVubG9jayBNZXRhTWFzay4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjb3VudHNbMF07XG59XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IGNvbm5lY3RlZCBhY2NvdW50XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDdXJyZW50QWNjb3VudCgpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcbiAgICBpZiAoIWlzTWV0YU1hc2tJbnN0YWxsZWQoKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IG5ldyBldGhlcnMuQnJvd3NlclByb3ZpZGVyKCh3aW5kb3cgYXMgYW55KS5ldGhlcmV1bSk7XG4gICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgcHJvdmlkZXIubGlzdEFjY291bnRzKCk7XG4gICAgICAgIHJldHVybiBhY2NvdW50cy5sZW5ndGggPiAwID8gYWNjb3VudHNbMF0uYWRkcmVzcyA6IG51bGw7XG4gICAgfSBjYXRjaCB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuLyoqXG4gKiBHZXQgY29udHJhY3QgaW5zdGFuY2VcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0Q29udHJhY3QoY29udHJhY3RBZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPGV0aGVycy5Db250cmFjdD4ge1xuICAgIGlmICghaXNNZXRhTWFza0luc3RhbGxlZCgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0YU1hc2sgaXMgbm90IGluc3RhbGxlZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IGV0aGVycy5Ccm93c2VyUHJvdmlkZXIoKHdpbmRvdyBhcyBhbnkpLmV0aGVyZXVtKTtcbiAgICBjb25zdCBzaWduZXIgPSBhd2FpdCBwcm92aWRlci5nZXRTaWduZXIoKTtcbiAgICByZXR1cm4gbmV3IGV0aGVycy5Db250cmFjdChjb250cmFjdEFkZHJlc3MsIENPTlRSQUNUX0FCSSwgc2lnbmVyKTtcbn1cblxuLyoqXG4gKiBSZWNvcmQgYSBmbGlnaHQgZXZlbnQgb24gYmxvY2tjaGFpbiB2aWEgTWV0YU1hc2tcbiAqIFxuICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyAtIEFkZHJlc3Mgb2YgdGhlIGRlcGxveWVkIEZsaWdodEV2ZW50UmVnaXN0cnkgY29udHJhY3RcbiAqIEBwYXJhbSBmbGlnaHRJZCAtIEZsaWdodCBpZGVudGlmaWVyIChlLmcuLCBcIlVBMTIzXCIpXG4gKiBAcGFyYW0gZXZlbnRUeXBlIC0gVHlwZSBvZiBldmVudCAoZS5nLiwgXCJERVBBUlRVUkVcIilcbiAqIEBwYXJhbSB0aW1lc3RhbXAgLSBVbml4IHRpbWVzdGFtcFxuICogQHBhcmFtIGFjdG9yIC0gQWN0b3IgcmVzcG9uc2libGUgKGUuZy4sIFwiU1lTVEVNXCIpXG4gKiBAcGFyYW0gZGF0YUhhc2ggLSBTSEEyNTYgaGFzaCBvZiBldmVudCBkYXRhICgweC1wcmVmaXhlZCBoZXggc3RyaW5nKVxuICogQHJldHVybnMgVHJhbnNhY3Rpb24gcmVjZWlwdFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVjb3JkRXZlbnRWaWFNZXRhTWFzayhcbiAgICBjb250cmFjdEFkZHJlc3M6IHN0cmluZyxcbiAgICBmbGlnaHRJZDogc3RyaW5nLFxuICAgIGV2ZW50VHlwZTogc3RyaW5nLFxuICAgIHRpbWVzdGFtcDogbnVtYmVyLFxuICAgIGFjdG9yOiBzdHJpbmcsXG4gICAgZGF0YUhhc2g6IHN0cmluZ1xuKTogUHJvbWlzZTxldGhlcnMuVHJhbnNhY3Rpb25SZWNlaXB0PiB7XG4gICAgLy8gRW5zdXJlIGFjY291bnQgaXMgY29ubmVjdGVkXG4gICAgYXdhaXQgY29ubmVjdE1ldGFNYXNrKCk7XG5cbiAgICBjb25zdCBjb250cmFjdCA9IGF3YWl0IGdldENvbnRyYWN0KGNvbnRyYWN0QWRkcmVzcyk7XG4gICAgXG4gICAgLy8gQ29udmVydCBkYXRhSGFzaCB0byBieXRlczMyIChlbnN1cmUgaXQncyAzMiBieXRlcylcbiAgICAvLyBldGhlcnMuanMgdjYgaGFuZGxlcyBoZXggc3RyaW5ncyBkaXJlY3RseSwgc28gd2UgY2FuIHVzZSBoZXhsaWZ5IG9yIGVuc3VyZSBpdCdzIGEgaGV4IHN0cmluZ1xuICAgIGxldCBkYXRhSGFzaEhleDogc3RyaW5nO1xuICAgIGlmIChkYXRhSGFzaC5zdGFydHNXaXRoKCcweCcpKSB7XG4gICAgICAgIGRhdGFIYXNoSGV4ID0gZGF0YUhhc2g7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YUhhc2hIZXggPSAnMHgnICsgZGF0YUhhc2g7XG4gICAgfVxuICAgIFxuICAgIC8vIEVuc3VyZSBpdCdzIGV4YWN0bHkgNjYgY2hhcmFjdGVycyAoMHggKyA2NCBoZXggY2hhcnMgPSAzMiBieXRlcylcbiAgICBpZiAoZGF0YUhhc2hIZXgubGVuZ3RoICE9PSA2Nikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgaGFzaCBtdXN0IGJlIDMyIGJ5dGVzICg2NCBoZXggY2hhcmFjdGVycyknKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ29udmVydCB0byBieXRlczMyIGZvcm1hdCB0aGF0IGV0aGVycyBleHBlY3RzXG4gICAgY29uc3QgZGF0YUhhc2hCeXRlczMyID0gZXRoZXJzLmdldEJ5dGVzKGRhdGFIYXNoSGV4KTtcbiAgICBcbiAgICAvLyBFc3RpbWF0ZSBnYXNcbiAgICBjb25zdCBnYXNFc3RpbWF0ZSA9IGF3YWl0IGNvbnRyYWN0LnJlY29yZEV2ZW50LmVzdGltYXRlR2FzKFxuICAgICAgICBmbGlnaHRJZCxcbiAgICAgICAgZXZlbnRUeXBlLFxuICAgICAgICB0aW1lc3RhbXAsXG4gICAgICAgIGFjdG9yLFxuICAgICAgICBkYXRhSGFzaEJ5dGVzMzJcbiAgICApO1xuXG4gICAgLy8gU2VuZCB0cmFuc2FjdGlvbiAoTWV0YU1hc2sgd2lsbCBwcm9tcHQgdXNlcilcbiAgICBjb25zdCB0eCA9IGF3YWl0IGNvbnRyYWN0LnJlY29yZEV2ZW50KFxuICAgICAgICBmbGlnaHRJZCxcbiAgICAgICAgZXZlbnRUeXBlLFxuICAgICAgICB0aW1lc3RhbXAsXG4gICAgICAgIGFjdG9yLFxuICAgICAgICBkYXRhSGFzaEJ5dGVzMzIsXG4gICAgICAgIHtcbiAgICAgICAgICAgIGdhc0xpbWl0OiBnYXNFc3RpbWF0ZSAqIEJpZ0ludCgxMjApIC8gQmlnSW50KDEwMCkgLy8gQWRkIDIwJSBidWZmZXJcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICAvLyBXYWl0IGZvciBjb25maXJtYXRpb25cbiAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdHgud2FpdCgpO1xuICAgIGlmICghcmVjZWlwdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zYWN0aW9uIHJlY2VpcHQgaXMgbnVsbCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVjZWlwdCBhcyBldGhlcnMuVHJhbnNhY3Rpb25SZWNlaXB0O1xufVxuXG4vKipcbiAqIFJlYWQgZmxpZ2h0IGV2ZW50cyBmcm9tIGJsb2NrY2hhaW5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEZsaWdodEV2ZW50c0Zyb21DaGFpbihcbiAgICBjb250cmFjdEFkZHJlc3M6IHN0cmluZyxcbiAgICBmbGlnaHRJZDogc3RyaW5nXG4pOiBQcm9taXNlPGFueVtdPiB7XG4gICAgLy8gQWRkIHRpbWVvdXQgdG8gcHJldmVudCBoYW5naW5nXG4gICAgY29uc3QgdGltZW91dCA9IDUwMDA7IC8vIDUgc2Vjb25kc1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyUHJvbWlzZSA9IGlzTWV0YU1hc2tJbnN0YWxsZWQoKVxuICAgICAgICAgICAgPyBuZXcgZXRoZXJzLkJyb3dzZXJQcm92aWRlcigod2luZG93IGFzIGFueSkuZXRoZXJldW0pXG4gICAgICAgICAgICA6IG5ldyBldGhlcnMuSnNvblJwY1Byb3ZpZGVyKFxuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0dBTkFDSEVfVVJMIHx8ICdodHRwOi8vMTI3LjAuMC4xOjc1NDUnXG4gICAgICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgIHByb3ZpZGVyUHJvbWlzZSxcbiAgICAgICAgICAgIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IFxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KG5ldyBFcnJvcignUHJvdmlkZXIgY29ubmVjdGlvbiB0aW1lb3V0JykpLCB0aW1lb3V0KVxuICAgICAgICAgICAgKVxuICAgICAgICBdKSBhcyBldGhlcnMuUHJvdmlkZXI7XG5cbiAgICAgICAgY29uc3QgY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KGNvbnRyYWN0QWRkcmVzcywgQ09OVFJBQ1RfQUJJLCBwcm92aWRlcik7XG4gICAgICAgIFxuICAgICAgICAvLyBBZGQgdGltZW91dCBmb3IgY29udHJhY3QgY2FsbHNcbiAgICAgICAgY29uc3QgaW5kaWNlcyA9IGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgICAgICBjb250cmFjdC5nZXRGbGlnaHRFdmVudEluZGljZXMoZmxpZ2h0SWQpLFxuICAgICAgICAgICAgbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4gXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiByZWplY3QobmV3IEVycm9yKCdDb250cmFjdCBjYWxsIHRpbWVvdXQnKSksIHRpbWVvdXQpXG4gICAgICAgICAgICApXG4gICAgICAgIF0pIGFzIGJpZ2ludFtdO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFpbmRpY2VzIHx8IGluZGljZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIGluZGljZXMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gQ2FsbCB0aGUgZ2V0RXZlbnQgZnVuY3Rpb24gd2l0aCB0aGUgaW5kZXhcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudERhdGEgPSBhd2FpdCBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgICAgICAgICAgICBjb250cmFjdFsnZ2V0RXZlbnQnXShpbmRleCksXG4gICAgICAgICAgICAgICAgICAgIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IFxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiByZWplY3QobmV3IEVycm9yKCdFdmVudCBmZXRjaCB0aW1lb3V0JykpLCB0aW1lb3V0KVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgXSkgYXMgYW55O1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgZmxpZ2h0SWQ6IGV2ZW50RGF0YVswXSxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRUeXBlOiBldmVudERhdGFbMV0sXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogTnVtYmVyKGV2ZW50RGF0YVsyXSksXG4gICAgICAgICAgICAgICAgICAgIGFjdG9yOiBldmVudERhdGFbM10sXG4gICAgICAgICAgICAgICAgICAgIGRhdGFIYXNoOiBldmVudERhdGFbNF0sXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBOdW1iZXIoZXZlbnREYXRhWzVdKSxcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkZWRBdDogTnVtYmVyKGV2ZW50RGF0YVs2XSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gZmV0Y2ggZXZlbnQgYXQgaW5kZXggJHtpbmRleH06YCwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIC8vIENvbnRpbnVlIHdpdGggb3RoZXIgZXZlbnRzXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBldmVudHM7XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBldmVudHMgZnJvbSBjaGFpbjonLCBlcnJvcik7XG4gICAgICAgIC8vIFJldHVybiBlbXB0eSBhcnJheSBpbnN0ZWFkIG9mIHRocm93aW5nIC0gYWxsb3dzIGZsb3cgdG8gY29udGludWVcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbn1cblxuLyoqXG4gKiBQcmVwYXJlIHRyYW5zYWN0aW9uIGRhdGEgZm9yIE1ldGFNYXNrXG4gKiBUaGlzIGlzIGNhbGxlZCBmcm9tIGJhY2tlbmQgdG8gcHJlcGFyZSB0aGUgdHJhbnNhY3Rpb24gd2l0aG91dCBleGVjdXRpbmcgaXRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQcmVwYXJlZFRyYW5zYWN0aW9uIHtcbiAgICB0bzogc3RyaW5nO1xuICAgIGRhdGE6IHN0cmluZztcbiAgICB2YWx1ZTogc3RyaW5nO1xuICAgIGdhcz86IHN0cmluZztcbn1cblxuLyoqXG4gKiBQcmVwYXJlIGEgdHJhbnNhY3Rpb24gdG8gcmVjb3JkIGFuIGV2ZW50ICh3aXRob3V0IHNlbmRpbmcpXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcmVwYXJlUmVjb3JkRXZlbnRUcmFuc2FjdGlvbihcbiAgICBjb250cmFjdEFkZHJlc3M6IHN0cmluZyxcbiAgICBmbGlnaHRJZDogc3RyaW5nLFxuICAgIGV2ZW50VHlwZTogc3RyaW5nLFxuICAgIHRpbWVzdGFtcDogbnVtYmVyLFxuICAgIGFjdG9yOiBzdHJpbmcsXG4gICAgZGF0YUhhc2g6IHN0cmluZ1xuKTogUHJvbWlzZTxQcmVwYXJlZFRyYW5zYWN0aW9uPiB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgZXRoZXJzLkpzb25ScGNQcm92aWRlcihcbiAgICAgICAgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfR0FOQUNIRV9VUkwgfHwgJ2h0dHA6Ly8xMjcuMC4wLjE6ODU0NSdcbiAgICApO1xuICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChjb250cmFjdEFkZHJlc3MsIENPTlRSQUNUX0FCSSwgcHJvdmlkZXIpO1xuICAgIFxuICAgIC8vIENvbnZlcnQgZGF0YUhhc2ggdG8gYnl0ZXMzMlxuICAgIGxldCBkYXRhSGFzaEhleDogc3RyaW5nO1xuICAgIGlmIChkYXRhSGFzaC5zdGFydHNXaXRoKCcweCcpKSB7XG4gICAgICAgIGRhdGFIYXNoSGV4ID0gZGF0YUhhc2g7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YUhhc2hIZXggPSAnMHgnICsgZGF0YUhhc2g7XG4gICAgfVxuICAgIFxuICAgIC8vIEVuc3VyZSBpdCdzIGV4YWN0bHkgNjYgY2hhcmFjdGVycyAoMHggKyA2NCBoZXggY2hhcnMgPSAzMiBieXRlcylcbiAgICBpZiAoZGF0YUhhc2hIZXgubGVuZ3RoICE9PSA2Nikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgaGFzaCBtdXN0IGJlIDMyIGJ5dGVzICg2NCBoZXggY2hhcmFjdGVycyknKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ29udmVydCB0byBieXRlczMyIGZvcm1hdFxuICAgIGNvbnN0IGRhdGFIYXNoQnl0ZXMzMiA9IGV0aGVycy5nZXRCeXRlcyhkYXRhSGFzaEhleCk7XG4gICAgXG4gICAgY29uc3QgZGF0YSA9IGNvbnRyYWN0LmludGVyZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEoJ3JlY29yZEV2ZW50JywgW1xuICAgICAgICBmbGlnaHRJZCxcbiAgICAgICAgZXZlbnRUeXBlLFxuICAgICAgICB0aW1lc3RhbXAsXG4gICAgICAgIGFjdG9yLFxuICAgICAgICBkYXRhSGFzaEJ5dGVzMzJcbiAgICBdKTtcblxuICAgIC8vIEVzdGltYXRlIGdhc1xuICAgIGxldCBnYXNFc3RpbWF0ZTogYmlnaW50O1xuICAgIHRyeSB7XG4gICAgICAgIGdhc0VzdGltYXRlID0gYXdhaXQgY29udHJhY3QucmVjb3JkRXZlbnQuZXN0aW1hdGVHYXMoXG4gICAgICAgICAgICBmbGlnaHRJZCxcbiAgICAgICAgICAgIGV2ZW50VHlwZSxcbiAgICAgICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgICAgIGFjdG9yLFxuICAgICAgICAgICAgZGF0YUhhc2hCeXRlczMyXG4gICAgICAgICk7XG4gICAgfSBjYXRjaCB7XG4gICAgICAgIGdhc0VzdGltYXRlID0gQmlnSW50KDMwMDAwMCk7IC8vIERlZmF1bHQgZmFsbGJhY2tcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0bzogY29udHJhY3RBZGRyZXNzLFxuICAgICAgICBkYXRhLFxuICAgICAgICB2YWx1ZTogJzB4MCcsXG4gICAgICAgIGdhczogYDB4JHtnYXNFc3RpbWF0ZS50b1N0cmluZygxNil9YFxuICAgIH07XG59XG5cbi8qKlxuICogU2VuZCBwcmVwYXJlZCB0cmFuc2FjdGlvbiB2aWEgTWV0YU1hc2tcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNlbmRQcmVwYXJlZFRyYW5zYWN0aW9uKFxuICAgIHRyYW5zYWN0aW9uOiBQcmVwYXJlZFRyYW5zYWN0aW9uXG4pOiBQcm9taXNlPGV0aGVycy5UcmFuc2FjdGlvblJlY2VpcHQ+IHtcbiAgICBpZiAoIWlzTWV0YU1hc2tJbnN0YWxsZWQoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGFNYXNrIGlzIG5vdCBpbnN0YWxsZWQnKTtcbiAgICB9XG5cbiAgICBhd2FpdCBjb25uZWN0TWV0YU1hc2soKTtcbiAgICBcbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBldGhlcnMuQnJvd3NlclByb3ZpZGVyKCh3aW5kb3cgYXMgYW55KS5ldGhlcmV1bSk7XG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgcHJvdmlkZXIuZ2V0U2lnbmVyKCk7XG4gICAgXG4gICAgLy8gTWV0YU1hc2sgd2lsbCBwcm9tcHQgdXNlciBmb3IgYXBwcm92YWxcbiAgICBjb25zdCB0eCA9IGF3YWl0IHNpZ25lci5zZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgICB0bzogdHJhbnNhY3Rpb24udG8sXG4gICAgICAgIGRhdGE6IHRyYW5zYWN0aW9uLmRhdGEsXG4gICAgICAgIHZhbHVlOiB0cmFuc2FjdGlvbi52YWx1ZSxcbiAgICAgICAgZ2FzTGltaXQ6IHRyYW5zYWN0aW9uLmdhcyA/IEJpZ0ludCh0cmFuc2FjdGlvbi5nYXMpIDogdW5kZWZpbmVkXG4gICAgfSk7XG5cbiAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdHgud2FpdCgpO1xuICAgIHJldHVybiByZWNlaXB0O1xufVxuIl0sIm5hbWVzIjpbImV0aGVycyIsIkFQSV9VUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCIsIkNPTlRSQUNUX0FCSSIsImlzTWV0YU1hc2tJbnN0YWxsZWQiLCJ3aW5kb3ciLCJldGhlcmV1bSIsImNvbm5lY3RNZXRhTWFzayIsIkVycm9yIiwicHJvdmlkZXIiLCJCcm93c2VyUHJvdmlkZXIiLCJhY2NvdW50cyIsInNlbmQiLCJsZW5ndGgiLCJnZXRDdXJyZW50QWNjb3VudCIsImxpc3RBY2NvdW50cyIsImFkZHJlc3MiLCJnZXRDb250cmFjdCIsImNvbnRyYWN0QWRkcmVzcyIsInNpZ25lciIsImdldFNpZ25lciIsIkNvbnRyYWN0IiwicmVjb3JkRXZlbnRWaWFNZXRhTWFzayIsImZsaWdodElkIiwiZXZlbnRUeXBlIiwidGltZXN0YW1wIiwiYWN0b3IiLCJkYXRhSGFzaCIsImNvbnRyYWN0IiwiZGF0YUhhc2hIZXgiLCJzdGFydHNXaXRoIiwiZGF0YUhhc2hCeXRlczMyIiwiZ2V0Qnl0ZXMiLCJnYXNFc3RpbWF0ZSIsInJlY29yZEV2ZW50IiwiZXN0aW1hdGVHYXMiLCJ0eCIsImdhc0xpbWl0IiwiQmlnSW50IiwicmVjZWlwdCIsIndhaXQiLCJnZXRGbGlnaHRFdmVudHNGcm9tQ2hhaW4iLCJ0aW1lb3V0IiwicHJvdmlkZXJQcm9taXNlIiwiSnNvblJwY1Byb3ZpZGVyIiwiTkVYVF9QVUJMSUNfR0FOQUNIRV9VUkwiLCJQcm9taXNlIiwicmFjZSIsIl8iLCJyZWplY3QiLCJzZXRUaW1lb3V0IiwiaW5kaWNlcyIsImdldEZsaWdodEV2ZW50SW5kaWNlcyIsImV2ZW50cyIsImluZGV4IiwiZXZlbnREYXRhIiwicHVzaCIsIk51bWJlciIsImJsb2NrTnVtYmVyIiwicmVjb3JkZWRBdCIsImVycm9yIiwiY29uc29sZSIsIndhcm4iLCJwcmVwYXJlUmVjb3JkRXZlbnRUcmFuc2FjdGlvbiIsImRhdGEiLCJpbnRlcmZhY2UiLCJlbmNvZGVGdW5jdGlvbkRhdGEiLCJ0byIsInZhbHVlIiwiZ2FzIiwidG9TdHJpbmciLCJzZW5kUHJlcGFyZWRUcmFuc2FjdGlvbiIsInRyYW5zYWN0aW9uIiwic2VuZFRyYW5zYWN0aW9uIiwidW5kZWZpbmVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/web3.ts\n"));

/***/ })

});