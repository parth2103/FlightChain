"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/services/web3.ts":
/*!******************************!*\
  !*** ./src/services/web3.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONTRACT_ABI: function() { return /* binding */ CONTRACT_ABI; },\n/* harmony export */   connectMetaMask: function() { return /* binding */ connectMetaMask; },\n/* harmony export */   getCurrentAccount: function() { return /* binding */ getCurrentAccount; },\n/* harmony export */   getFlightEventsFromChain: function() { return /* binding */ getFlightEventsFromChain; },\n/* harmony export */   isMetaMaskInstalled: function() { return /* binding */ isMetaMaskInstalled; },\n/* harmony export */   prepareRecordEventTransaction: function() { return /* binding */ prepareRecordEventTransaction; },\n/* harmony export */   recordEventViaMetaMask: function() { return /* binding */ recordEventViaMetaMask; },\n/* harmony export */   sendPreparedTransaction: function() { return /* binding */ sendPreparedTransaction; }\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/providers/provider-browser.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/contract/contract.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/**\n * Web3 Service - MetaMask Integration\n * \n * Handles blockchain interactions via MetaMask wallet.\n * Users sign and pay for their own transactions.\n */ \nconst API_URL = process.env.NEXT_PUBLIC_API_URL || \"http://localhost:8000/api\";\n// Contract ABI - must match FlightEventRegistry.sol\nconst CONTRACT_ABI = [\n    \"function recordEvent(string memory _flightId, string memory _eventType, uint256 _timestamp, string memory _actor, bytes32 _dataHash) external returns (uint256)\",\n    \"function getFlightEventIndices(string memory _flightId) external view returns (uint256[])\",\n    \"function getEvent(uint256 _index) external view returns (string memory flightId, string memory eventType, uint256 timestamp, string memory actor, bytes32 dataHash, uint256 blockNumber, uint256 recordedAt)\",\n    \"function getTotalEvents() external view returns (uint256)\",\n    \"function verifyHash(bytes32 _dataHash) external view returns (bool)\"\n];\n/**\n * Check if MetaMask is installed\n */ function isMetaMaskInstalled() {\n    return  true && typeof window.ethereum !== \"undefined\";\n}\n/**\n * Request account access from MetaMask\n */ async function connectMetaMask() {\n    if (!isMetaMaskInstalled()) {\n        throw new Error(\"MetaMask is not installed. Please install MetaMask to continue.\");\n    }\n    const provider = new ethers__WEBPACK_IMPORTED_MODULE_0__.BrowserProvider(window.ethereum);\n    const accounts = await provider.send(\"eth_requestAccounts\", []);\n    if (accounts.length === 0) {\n        throw new Error(\"No accounts found. Please unlock MetaMask.\");\n    }\n    return accounts[0];\n}\n/**\n * Get the current connected account\n */ async function getCurrentAccount() {\n    if (!isMetaMaskInstalled()) {\n        return null;\n    }\n    try {\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_0__.BrowserProvider(window.ethereum);\n        const accounts = await provider.listAccounts();\n        return accounts.length > 0 ? accounts[0].address : null;\n    } catch (e) {\n        return null;\n    }\n}\n/**\n * Get contract instance\n */ async function getContract(contractAddress) {\n    if (!isMetaMaskInstalled()) {\n        throw new Error(\"MetaMask is not installed\");\n    }\n    const provider = new ethers__WEBPACK_IMPORTED_MODULE_0__.BrowserProvider(window.ethereum);\n    const signer = await provider.getSigner();\n    return new ethers__WEBPACK_IMPORTED_MODULE_1__.Contract(contractAddress, CONTRACT_ABI, signer);\n}\n/**\n * Record a flight event on blockchain via MetaMask\n * \n * @param contractAddress - Address of the deployed FlightEventRegistry contract\n * @param flightId - Flight identifier (e.g., \"UA123\")\n * @param eventType - Type of event (e.g., \"DEPARTURE\")\n * @param timestamp - Unix timestamp\n * @param actor - Actor responsible (e.g., \"SYSTEM\")\n * @param dataHash - SHA256 hash of event data (0x-prefixed hex string)\n * @returns Transaction receipt\n */ async function recordEventViaMetaMask(contractAddress, flightId, eventType, timestamp, actor, dataHash) {\n    // Ensure account is connected\n    await connectMetaMask();\n    const contract = await getContract(contractAddress);\n    // Convert dataHash to bytes32 (ensure it's 32 bytes)\n    // ethers.js v6 handles hex strings directly, so we can use hexlify or ensure it's a hex string\n    let dataHashHex;\n    if (dataHash.startsWith(\"0x\")) {\n        dataHashHex = dataHash;\n    } else {\n        dataHashHex = \"0x\" + dataHash;\n    }\n    // Ensure it's exactly 66 characters (0x + 64 hex chars = 32 bytes)\n    if (dataHashHex.length !== 66) {\n        throw new Error(\"Data hash must be 32 bytes (64 hex characters)\");\n    }\n    // Convert to bytes32 format that ethers expects\n    const dataHashBytes32 = ethers__WEBPACK_IMPORTED_MODULE_2__.getBytes(dataHashHex);\n    // Estimate gas\n    const gasEstimate = await contract.recordEvent.estimateGas(flightId, eventType, timestamp, actor, dataHashBytes32);\n    // Send transaction (MetaMask will prompt user)\n    const tx = await contract.recordEvent(flightId, eventType, timestamp, actor, dataHashBytes32, {\n        gasLimit: gasEstimate * BigInt(120) / BigInt(100) // Add 20% buffer\n    });\n    // Wait for confirmation\n    const receipt = await tx.wait();\n    return receipt;\n}\n/**\n * Read flight events from blockchain\n */ async function getFlightEventsFromChain(contractAddress, flightId) {\n    // Add timeout to prevent hanging\n    const timeout = 5000; // 5 seconds\n    try {\n        const providerPromise = isMetaMaskInstalled() ? new ethers__WEBPACK_IMPORTED_MODULE_0__.BrowserProvider(window.ethereum) : new ethers__WEBPACK_IMPORTED_MODULE_3__.JsonRpcProvider(process.env.NEXT_PUBLIC_GANACHE_URL || \"http://127.0.0.1:7545\");\n        const provider = await Promise.race([\n            providerPromise,\n            new Promise((_, reject)=>setTimeout(()=>reject(new Error(\"Provider connection timeout\")), timeout))\n        ]);\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_1__.Contract(contractAddress, CONTRACT_ABI, provider);\n        // Add timeout for contract calls\n        const indices = await Promise.race([\n            contract.getFlightEventIndices(flightId),\n            new Promise((_, reject)=>setTimeout(()=>reject(new Error(\"Contract call timeout\")), timeout))\n        ]);\n        if (!indices || indices.length === 0) {\n            return [];\n        }\n        const events = [];\n        for (const index of indices){\n            try {\n                const event = await Promise.race([\n                    contract.getEvent(index),\n                    new Promise((_, reject)=>setTimeout(()=>reject(new Error(\"Event fetch timeout\")), timeout))\n                ]);\n                events.push({\n                    flightId: event.flightId,\n                    eventType: event.eventType,\n                    timestamp: Number(event.timestamp),\n                    actor: event.actor,\n                    dataHash: event.dataHash,\n                    blockNumber: Number(event.blockNumber),\n                    recordedAt: Number(event.recordedAt)\n                });\n            } catch (error) {\n                console.warn(\"Failed to fetch event at index \".concat(index, \":\"), error);\n            // Continue with other events\n            }\n        }\n        return events;\n    } catch (error) {\n        console.error(\"Error fetching events from chain:\", error);\n        // Return empty array instead of throwing - allows flow to continue\n        return [];\n    }\n}\n/**\n * Prepare a transaction to record an event (without sending)\n */ async function prepareRecordEventTransaction(contractAddress, flightId, eventType, timestamp, actor, dataHash) {\n    const provider = new ethers__WEBPACK_IMPORTED_MODULE_3__.JsonRpcProvider(process.env.NEXT_PUBLIC_GANACHE_URL || \"http://127.0.0.1:8545\");\n    const contract = new ethers__WEBPACK_IMPORTED_MODULE_1__.Contract(contractAddress, CONTRACT_ABI, provider);\n    // Convert dataHash to bytes32\n    let dataHashHex;\n    if (dataHash.startsWith(\"0x\")) {\n        dataHashHex = dataHash;\n    } else {\n        dataHashHex = \"0x\" + dataHash;\n    }\n    // Ensure it's exactly 66 characters (0x + 64 hex chars = 32 bytes)\n    if (dataHashHex.length !== 66) {\n        throw new Error(\"Data hash must be 32 bytes (64 hex characters)\");\n    }\n    // Convert to bytes32 format\n    const dataHashBytes32 = ethers__WEBPACK_IMPORTED_MODULE_2__.getBytes(dataHashHex);\n    const data = contract.interface.encodeFunctionData(\"recordEvent\", [\n        flightId,\n        eventType,\n        timestamp,\n        actor,\n        dataHashBytes32\n    ]);\n    // Estimate gas\n    let gasEstimate;\n    try {\n        gasEstimate = await contract.recordEvent.estimateGas(flightId, eventType, timestamp, actor, dataHashBytes32);\n    } catch (e) {\n        gasEstimate = BigInt(300000); // Default fallback\n    }\n    return {\n        to: contractAddress,\n        data,\n        value: \"0x0\",\n        gas: \"0x\".concat(gasEstimate.toString(16))\n    };\n}\n/**\n * Send prepared transaction via MetaMask\n */ async function sendPreparedTransaction(transaction) {\n    if (!isMetaMaskInstalled()) {\n        throw new Error(\"MetaMask is not installed\");\n    }\n    await connectMetaMask();\n    const provider = new ethers__WEBPACK_IMPORTED_MODULE_0__.BrowserProvider(window.ethereum);\n    const signer = await provider.getSigner();\n    // MetaMask will prompt user for approval\n    const tx = await signer.sendTransaction({\n        to: transaction.to,\n        data: transaction.data,\n        value: transaction.value,\n        gasLimit: transaction.gas ? BigInt(transaction.gas) : undefined\n    });\n    const receipt = await tx.wait();\n    return receipt;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy93ZWIzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQUUrQjtBQUdoQyxNQUFNQyxVQUFVQyxPQUFPQSxDQUFDQyxHQUFHLENBQUNDLG1CQUFtQixJQUFJO0FBRW5ELG9EQUFvRDtBQUM3QyxNQUFNQyxlQUFlO0lBQ3hCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDSCxDQUFDO0FBRUY7O0NBRUMsR0FDTSxTQUFTQztJQUNaLE9BQU8sS0FBa0IsSUFBZSxPQUFPLE9BQWdCRSxRQUFRLEtBQUs7QUFDaEY7QUFFQTs7Q0FFQyxHQUNNLGVBQWVDO0lBQ2xCLElBQUksQ0FBQ0gsdUJBQXVCO1FBQ3hCLE1BQU0sSUFBSUksTUFBTTtJQUNwQjtJQUVBLE1BQU1DLFdBQVcsSUFBSVgsbURBQXNCLENBQUMsT0FBZ0JRLFFBQVE7SUFDcEUsTUFBTUssV0FBVyxNQUFNRixTQUFTRyxJQUFJLENBQUMsdUJBQXVCLEVBQUU7SUFFOUQsSUFBSUQsU0FBU0UsTUFBTSxLQUFLLEdBQUc7UUFDdkIsTUFBTSxJQUFJTCxNQUFNO0lBQ3BCO0lBRUEsT0FBT0csUUFBUSxDQUFDLEVBQUU7QUFDdEI7QUFFQTs7Q0FFQyxHQUNNLGVBQWVHO0lBQ2xCLElBQUksQ0FBQ1YsdUJBQXVCO1FBQ3hCLE9BQU87SUFDWDtJQUVBLElBQUk7UUFDQSxNQUFNSyxXQUFXLElBQUlYLG1EQUFzQixDQUFDLE9BQWdCUSxRQUFRO1FBQ3BFLE1BQU1LLFdBQVcsTUFBTUYsU0FBU00sWUFBWTtRQUM1QyxPQUFPSixTQUFTRSxNQUFNLEdBQUcsSUFBSUYsUUFBUSxDQUFDLEVBQUUsQ0FBQ0ssT0FBTyxHQUFHO0lBQ3ZELEVBQUUsVUFBTTtRQUNKLE9BQU87SUFDWDtBQUNKO0FBRUE7O0NBRUMsR0FDRCxlQUFlQyxZQUFZQyxlQUF1QjtJQUM5QyxJQUFJLENBQUNkLHVCQUF1QjtRQUN4QixNQUFNLElBQUlJLE1BQU07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VUFDQUMsV0FDQUMsV0FDQUMsT0FDQUs7SUFFUixFQUFFLFVBQU07UUFDSkUsY0FBY0ssT0FBTyxTQUFTLG1CQUFtQjtJQUNyRDtJQUVBLE9BQU87UUFDSDhCLElBQUlsRDtRQUNKK0M7UUFDQUksT0FBTztRQUNQQyxLQUFLLEtBQThCLE9BQXpCckMsWUFBWXNDLFFBQVEsQ0FBQztJQUNuQztBQUNKO0FBRUE7O0NBRUMsR0FDTSxlQUFlQyx3QkFDbEJDLFdBQWdDO0lBRWhDLElBQUksQ0FBQ3JFLHVCQUF1QjtRQUN4QixNQUFNLElBQUlJLE1BQU07SUFDcEI7SUFFQSxNQUFNRDtJQUVOLE1BQU1FLFdBQVcsSUFBSVgsbURBQXNCLENBQUMsT0FBZ0JRLFFBQVE7SUFDcEUsTUFBTWEsU0FBUyxNQUFNVixTQUFTVyxTQUFTO0lBRXZDLHlDQUF5QztJQUN6QyxNQUFNZ0IsS0FBSyxNQUFNakIsT0FBT3VELGVBQWUsQ0FBQztRQUNwQ04sSUFBSUssWUFBWUwsRUFBRTtRQUNsQkgsTUFBTVEsWUFBWVIsSUFBSTtRQUN0QkksT0FBT0ksWUFBWUosS0FBSztRQUN4QmhDLFVBQVVvQyxZQUFZSCxHQUFHLEdBQUdoQyxPQUFPbUMsWUFBWUgsR0FBRyxJQUFJSztJQUMxRDtJQUVBLE1BQU1wQyxVQUFVLE1BQU1ILEdBQUdJLElBQUk7SUFDN0IsT0FBT0Q7QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc2VydmljZXMvd2ViMy50cz8xMWI4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogV2ViMyBTZXJ2aWNlIC0gTWV0YU1hc2sgSW50ZWdyYXRpb25cbiAqIFxuICogSGFuZGxlcyBibG9ja2NoYWluIGludGVyYWN0aW9ucyB2aWEgTWV0YU1hc2sgd2FsbGV0LlxuICogVXNlcnMgc2lnbiBhbmQgcGF5IGZvciB0aGVpciBvd24gdHJhbnNhY3Rpb25zLlxuICovXG5cbmltcG9ydCB7IGV0aGVycyB9IGZyb20gJ2V0aGVycyc7XG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xuXG5jb25zdCBBUElfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDo4MDAwL2FwaSc7XG5cbi8vIENvbnRyYWN0IEFCSSAtIG11c3QgbWF0Y2ggRmxpZ2h0RXZlbnRSZWdpc3RyeS5zb2xcbmV4cG9ydCBjb25zdCBDT05UUkFDVF9BQkkgPSBbXG4gICAgXCJmdW5jdGlvbiByZWNvcmRFdmVudChzdHJpbmcgbWVtb3J5IF9mbGlnaHRJZCwgc3RyaW5nIG1lbW9yeSBfZXZlbnRUeXBlLCB1aW50MjU2IF90aW1lc3RhbXAsIHN0cmluZyBtZW1vcnkgX2FjdG9yLCBieXRlczMyIF9kYXRhSGFzaCkgZXh0ZXJuYWwgcmV0dXJucyAodWludDI1NilcIixcbiAgICBcImZ1bmN0aW9uIGdldEZsaWdodEV2ZW50SW5kaWNlcyhzdHJpbmcgbWVtb3J5IF9mbGlnaHRJZCkgZXh0ZXJuYWwgdmlldyByZXR1cm5zICh1aW50MjU2W10pXCIsXG4gICAgXCJmdW5jdGlvbiBnZXRFdmVudCh1aW50MjU2IF9pbmRleCkgZXh0ZXJuYWwgdmlldyByZXR1cm5zIChzdHJpbmcgbWVtb3J5IGZsaWdodElkLCBzdHJpbmcgbWVtb3J5IGV2ZW50VHlwZSwgdWludDI1NiB0aW1lc3RhbXAsIHN0cmluZyBtZW1vcnkgYWN0b3IsIGJ5dGVzMzIgZGF0YUhhc2gsIHVpbnQyNTYgYmxvY2tOdW1iZXIsIHVpbnQyNTYgcmVjb3JkZWRBdClcIixcbiAgICBcImZ1bmN0aW9uIGdldFRvdGFsRXZlbnRzKCkgZXh0ZXJuYWwgdmlldyByZXR1cm5zICh1aW50MjU2KVwiLFxuICAgIFwiZnVuY3Rpb24gdmVyaWZ5SGFzaChieXRlczMyIF9kYXRhSGFzaCkgZXh0ZXJuYWwgdmlldyByZXR1cm5zIChib29sKVwiXG5dO1xuXG4vKipcbiAqIENoZWNrIGlmIE1ldGFNYXNrIGlzIGluc3RhbGxlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNNZXRhTWFza0luc3RhbGxlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mICh3aW5kb3cgYXMgYW55KS5ldGhlcmV1bSAhPT0gJ3VuZGVmaW5lZCc7XG59XG5cbi8qKlxuICogUmVxdWVzdCBhY2NvdW50IGFjY2VzcyBmcm9tIE1ldGFNYXNrXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb25uZWN0TWV0YU1hc2soKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBpZiAoIWlzTWV0YU1hc2tJbnN0YWxsZWQoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGFNYXNrIGlzIG5vdCBpbnN0YWxsZWQuIFBsZWFzZSBpbnN0YWxsIE1ldGFNYXNrIHRvIGNvbnRpbnVlLicpO1xuICAgIH1cblxuICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IGV0aGVycy5Ccm93c2VyUHJvdmlkZXIoKHdpbmRvdyBhcyBhbnkpLmV0aGVyZXVtKTtcbiAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHByb3ZpZGVyLnNlbmQoJ2V0aF9yZXF1ZXN0QWNjb3VudHMnLCBbXSk7XG4gICAgXG4gICAgaWYgKGFjY291bnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjY291bnRzIGZvdW5kLiBQbGVhc2UgdW5sb2NrIE1ldGFNYXNrLicpO1xuICAgIH1cblxuICAgIHJldHVybiBhY2NvdW50c1swXTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgY29ubmVjdGVkIGFjY291bnRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEN1cnJlbnRBY2NvdW50KCk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xuICAgIGlmICghaXNNZXRhTWFza0luc3RhbGxlZCgpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IGV0aGVycy5Ccm93c2VyUHJvdmlkZXIoKHdpbmRvdyBhcyBhbnkpLmV0aGVyZXVtKTtcbiAgICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCBwcm92aWRlci5saXN0QWNjb3VudHMoKTtcbiAgICAgICAgcmV0dXJuIGFjY291bnRzLmxlbmd0aCA+IDAgPyBhY2NvdW50c1swXS5hZGRyZXNzIDogbnVsbDtcbiAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG4vKipcbiAqIEdldCBjb250cmFjdCBpbnN0YW5jZVxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRDb250cmFjdChjb250cmFjdEFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8ZXRoZXJzLkNvbnRyYWN0PiB7XG4gICAgaWYgKCFpc01ldGFNYXNrSW5zdGFsbGVkKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRhTWFzayBpcyBub3QgaW5zdGFsbGVkJyk7XG4gICAgfVxuXG4gICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgZXRoZXJzLkJyb3dzZXJQcm92aWRlcigod2luZG93IGFzIGFueSkuZXRoZXJldW0pO1xuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpO1xuICAgIHJldHVybiBuZXcgZXRoZXJzLkNvbnRyYWN0KGNvbnRyYWN0QWRkcmVzcywgQ09OVFJBQ1RfQUJJLCBzaWduZXIpO1xufVxuXG4vKipcbiAqIFJlY29yZCBhIGZsaWdodCBldmVudCBvbiBibG9ja2NoYWluIHZpYSBNZXRhTWFza1xuICogXG4gKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIC0gQWRkcmVzcyBvZiB0aGUgZGVwbG95ZWQgRmxpZ2h0RXZlbnRSZWdpc3RyeSBjb250cmFjdFxuICogQHBhcmFtIGZsaWdodElkIC0gRmxpZ2h0IGlkZW50aWZpZXIgKGUuZy4sIFwiVUExMjNcIilcbiAqIEBwYXJhbSBldmVudFR5cGUgLSBUeXBlIG9mIGV2ZW50IChlLmcuLCBcIkRFUEFSVFVSRVwiKVxuICogQHBhcmFtIHRpbWVzdGFtcCAtIFVuaXggdGltZXN0YW1wXG4gKiBAcGFyYW0gYWN0b3IgLSBBY3RvciByZXNwb25zaWJsZSAoZS5nLiwgXCJTWVNURU1cIilcbiAqIEBwYXJhbSBkYXRhSGFzaCAtIFNIQTI1NiBoYXNoIG9mIGV2ZW50IGRhdGEgKDB4LXByZWZpeGVkIGhleCBzdHJpbmcpXG4gKiBAcmV0dXJucyBUcmFuc2FjdGlvbiByZWNlaXB0XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWNvcmRFdmVudFZpYU1ldGFNYXNrKFxuICAgIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICAgIGZsaWdodElkOiBzdHJpbmcsXG4gICAgZXZlbnRUeXBlOiBzdHJpbmcsXG4gICAgdGltZXN0YW1wOiBudW1iZXIsXG4gICAgYWN0b3I6IHN0cmluZyxcbiAgICBkYXRhSGFzaDogc3RyaW5nXG4pOiBQcm9taXNlPGV0aGVycy5UcmFuc2FjdGlvblJlY2VpcHQ+IHtcbiAgICAvLyBFbnN1cmUgYWNjb3VudCBpcyBjb25uZWN0ZWRcbiAgICBhd2FpdCBjb25uZWN0TWV0YU1hc2soKTtcblxuICAgIGNvbnN0IGNvbnRyYWN0ID0gYXdhaXQgZ2V0Q29udHJhY3QoY29udHJhY3RBZGRyZXNzKTtcbiAgICBcbiAgICAvLyBDb252ZXJ0IGRhdGFIYXNoIHRvIGJ5dGVzMzIgKGVuc3VyZSBpdCdzIDMyIGJ5dGVzKVxuICAgIC8vIGV0aGVycy5qcyB2NiBoYW5kbGVzIGhleCBzdHJpbmdzIGRpcmVjdGx5LCBzbyB3ZSBjYW4gdXNlIGhleGxpZnkgb3IgZW5zdXJlIGl0J3MgYSBoZXggc3RyaW5nXG4gICAgbGV0IGRhdGFIYXNoSGV4OiBzdHJpbmc7XG4gICAgaWYgKGRhdGFIYXNoLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgZGF0YUhhc2hIZXggPSBkYXRhSGFzaDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhSGFzaEhleCA9ICcweCcgKyBkYXRhSGFzaDtcbiAgICB9XG4gICAgXG4gICAgLy8gRW5zdXJlIGl0J3MgZXhhY3RseSA2NiBjaGFyYWN0ZXJzICgweCArIDY0IGhleCBjaGFycyA9IDMyIGJ5dGVzKVxuICAgIGlmIChkYXRhSGFzaEhleC5sZW5ndGggIT09IDY2KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBoYXNoIG11c3QgYmUgMzIgYnl0ZXMgKDY0IGhleCBjaGFyYWN0ZXJzKScpO1xuICAgIH1cbiAgICBcbiAgICAvLyBDb252ZXJ0IHRvIGJ5dGVzMzIgZm9ybWF0IHRoYXQgZXRoZXJzIGV4cGVjdHNcbiAgICBjb25zdCBkYXRhSGFzaEJ5dGVzMzIgPSBldGhlcnMuZ2V0Qnl0ZXMoZGF0YUhhc2hIZXgpO1xuICAgIFxuICAgIC8vIEVzdGltYXRlIGdhc1xuICAgIGNvbnN0IGdhc0VzdGltYXRlID0gYXdhaXQgY29udHJhY3QucmVjb3JkRXZlbnQuZXN0aW1hdGVHYXMoXG4gICAgICAgIGZsaWdodElkLFxuICAgICAgICBldmVudFR5cGUsXG4gICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgYWN0b3IsXG4gICAgICAgIGRhdGFIYXNoQnl0ZXMzMlxuICAgICk7XG5cbiAgICAvLyBTZW5kIHRyYW5zYWN0aW9uIChNZXRhTWFzayB3aWxsIHByb21wdCB1c2VyKVxuICAgIGNvbnN0IHR4ID0gYXdhaXQgY29udHJhY3QucmVjb3JkRXZlbnQoXG4gICAgICAgIGZsaWdodElkLFxuICAgICAgICBldmVudFR5cGUsXG4gICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgYWN0b3IsXG4gICAgICAgIGRhdGFIYXNoQnl0ZXMzMixcbiAgICAgICAge1xuICAgICAgICAgICAgZ2FzTGltaXQ6IGdhc0VzdGltYXRlICogQmlnSW50KDEyMCkgLyBCaWdJbnQoMTAwKSAvLyBBZGQgMjAlIGJ1ZmZlclxuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8vIFdhaXQgZm9yIGNvbmZpcm1hdGlvblxuICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0eC53YWl0KCk7XG4gICAgcmV0dXJuIHJlY2VpcHQ7XG59XG5cbi8qKlxuICogUmVhZCBmbGlnaHQgZXZlbnRzIGZyb20gYmxvY2tjaGFpblxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RmxpZ2h0RXZlbnRzRnJvbUNoYWluKFxuICAgIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICAgIGZsaWdodElkOiBzdHJpbmdcbik6IFByb21pc2U8YW55W10+IHtcbiAgICAvLyBBZGQgdGltZW91dCB0byBwcmV2ZW50IGhhbmdpbmdcbiAgICBjb25zdCB0aW1lb3V0ID0gNTAwMDsgLy8gNSBzZWNvbmRzXG4gICAgXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXJQcm9taXNlID0gaXNNZXRhTWFza0luc3RhbGxlZCgpXG4gICAgICAgICAgICA/IG5ldyBldGhlcnMuQnJvd3NlclByb3ZpZGVyKCh3aW5kb3cgYXMgYW55KS5ldGhlcmV1bSlcbiAgICAgICAgICAgIDogbmV3IGV0aGVycy5Kc29uUnBjUHJvdmlkZXIoXG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfR0FOQUNIRV9VUkwgfHwgJ2h0dHA6Ly8xMjcuMC4wLjE6NzU0NSdcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgICAgcHJvdmlkZXJQcm9taXNlLFxuICAgICAgICAgICAgbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4gXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiByZWplY3QobmV3IEVycm9yKCdQcm92aWRlciBjb25uZWN0aW9uIHRpbWVvdXQnKSksIHRpbWVvdXQpXG4gICAgICAgICAgICApXG4gICAgICAgIF0pIGFzIGV0aGVycy5Qcm92aWRlcjtcblxuICAgICAgICBjb25zdCBjb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoY29udHJhY3RBZGRyZXNzLCBDT05UUkFDVF9BQkksIHByb3ZpZGVyKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEFkZCB0aW1lb3V0IGZvciBjb250cmFjdCBjYWxsc1xuICAgICAgICBjb25zdCBpbmRpY2VzID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgIGNvbnRyYWN0LmdldEZsaWdodEV2ZW50SW5kaWNlcyhmbGlnaHRJZCksXG4gICAgICAgICAgICBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiBcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChuZXcgRXJyb3IoJ0NvbnRyYWN0IGNhbGwgdGltZW91dCcpKSwgdGltZW91dClcbiAgICAgICAgICAgIClcbiAgICAgICAgXSkgYXMgYmlnaW50W107XG4gICAgICAgIFxuICAgICAgICBpZiAoIWluZGljZXMgfHwgaW5kaWNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc3QgZXZlbnRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgaW5kZXggb2YgaW5kaWNlcykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudCA9IGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0LmdldEV2ZW50KGluZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4gXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChuZXcgRXJyb3IoJ0V2ZW50IGZldGNoIHRpbWVvdXQnKSksIHRpbWVvdXQpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBdKSBhcyBhbnk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBmbGlnaHRJZDogZXZlbnQuZmxpZ2h0SWQsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50VHlwZTogZXZlbnQuZXZlbnRUeXBlLFxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IE51bWJlcihldmVudC50aW1lc3RhbXApLFxuICAgICAgICAgICAgICAgICAgICBhY3RvcjogZXZlbnQuYWN0b3IsXG4gICAgICAgICAgICAgICAgICAgIGRhdGFIYXNoOiBldmVudC5kYXRhSGFzaCxcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXI6IE51bWJlcihldmVudC5ibG9ja051bWJlciksXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZGVkQXQ6IE51bWJlcihldmVudC5yZWNvcmRlZEF0KVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBmZXRjaCBldmVudCBhdCBpbmRleCAke2luZGV4fTpgLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgLy8gQ29udGludWUgd2l0aCBvdGhlciBldmVudHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGV2ZW50cztcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGV2ZW50cyBmcm9tIGNoYWluOicsIGVycm9yKTtcbiAgICAgICAgLy8gUmV0dXJuIGVtcHR5IGFycmF5IGluc3RlYWQgb2YgdGhyb3dpbmcgLSBhbGxvd3MgZmxvdyB0byBjb250aW51ZVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxufVxuXG4vKipcbiAqIFByZXBhcmUgdHJhbnNhY3Rpb24gZGF0YSBmb3IgTWV0YU1hc2tcbiAqIFRoaXMgaXMgY2FsbGVkIGZyb20gYmFja2VuZCB0byBwcmVwYXJlIHRoZSB0cmFuc2FjdGlvbiB3aXRob3V0IGV4ZWN1dGluZyBpdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFByZXBhcmVkVHJhbnNhY3Rpb24ge1xuICAgIHRvOiBzdHJpbmc7XG4gICAgZGF0YTogc3RyaW5nO1xuICAgIHZhbHVlOiBzdHJpbmc7XG4gICAgZ2FzPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIFByZXBhcmUgYSB0cmFuc2FjdGlvbiB0byByZWNvcmQgYW4gZXZlbnQgKHdpdGhvdXQgc2VuZGluZylcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByZXBhcmVSZWNvcmRFdmVudFRyYW5zYWN0aW9uKFxuICAgIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICAgIGZsaWdodElkOiBzdHJpbmcsXG4gICAgZXZlbnRUeXBlOiBzdHJpbmcsXG4gICAgdGltZXN0YW1wOiBudW1iZXIsXG4gICAgYWN0b3I6IHN0cmluZyxcbiAgICBkYXRhSGFzaDogc3RyaW5nXG4pOiBQcm9taXNlPFByZXBhcmVkVHJhbnNhY3Rpb24+IHtcbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBldGhlcnMuSnNvblJwY1Byb3ZpZGVyKFxuICAgICAgICBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19HQU5BQ0hFX1VSTCB8fCAnaHR0cDovLzEyNy4wLjAuMTo4NTQ1J1xuICAgICk7XG4gICAgY29uc3QgY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KGNvbnRyYWN0QWRkcmVzcywgQ09OVFJBQ1RfQUJJLCBwcm92aWRlcik7XG4gICAgXG4gICAgLy8gQ29udmVydCBkYXRhSGFzaCB0byBieXRlczMyXG4gICAgbGV0IGRhdGFIYXNoSGV4OiBzdHJpbmc7XG4gICAgaWYgKGRhdGFIYXNoLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgZGF0YUhhc2hIZXggPSBkYXRhSGFzaDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhSGFzaEhleCA9ICcweCcgKyBkYXRhSGFzaDtcbiAgICB9XG4gICAgXG4gICAgLy8gRW5zdXJlIGl0J3MgZXhhY3RseSA2NiBjaGFyYWN0ZXJzICgweCArIDY0IGhleCBjaGFycyA9IDMyIGJ5dGVzKVxuICAgIGlmIChkYXRhSGFzaEhleC5sZW5ndGggIT09IDY2KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBoYXNoIG11c3QgYmUgMzIgYnl0ZXMgKDY0IGhleCBjaGFyYWN0ZXJzKScpO1xuICAgIH1cbiAgICBcbiAgICAvLyBDb252ZXJ0IHRvIGJ5dGVzMzIgZm9ybWF0XG4gICAgY29uc3QgZGF0YUhhc2hCeXRlczMyID0gZXRoZXJzLmdldEJ5dGVzKGRhdGFIYXNoSGV4KTtcbiAgICBcbiAgICBjb25zdCBkYXRhID0gY29udHJhY3QuaW50ZXJmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YSgncmVjb3JkRXZlbnQnLCBbXG4gICAgICAgIGZsaWdodElkLFxuICAgICAgICBldmVudFR5cGUsXG4gICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgYWN0b3IsXG4gICAgICAgIGRhdGFIYXNoQnl0ZXMzMlxuICAgIF0pO1xuXG4gICAgLy8gRXN0aW1hdGUgZ2FzXG4gICAgbGV0IGdhc0VzdGltYXRlOiBiaWdpbnQ7XG4gICAgdHJ5IHtcbiAgICAgICAgZ2FzRXN0aW1hdGUgPSBhd2FpdCBjb250cmFjdC5yZWNvcmRFdmVudC5lc3RpbWF0ZUdhcyhcbiAgICAgICAgICAgIGZsaWdodElkLFxuICAgICAgICAgICAgZXZlbnRUeXBlLFxuICAgICAgICAgICAgdGltZXN0YW1wLFxuICAgICAgICAgICAgYWN0b3IsXG4gICAgICAgICAgICBkYXRhSGFzaEJ5dGVzMzJcbiAgICAgICAgKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgICAgZ2FzRXN0aW1hdGUgPSBCaWdJbnQoMzAwMDAwKTsgLy8gRGVmYXVsdCBmYWxsYmFja1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHRvOiBjb250cmFjdEFkZHJlc3MsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHZhbHVlOiAnMHgwJyxcbiAgICAgICAgZ2FzOiBgMHgke2dhc0VzdGltYXRlLnRvU3RyaW5nKDE2KX1gXG4gICAgfTtcbn1cblxuLyoqXG4gKiBTZW5kIHByZXBhcmVkIHRyYW5zYWN0aW9uIHZpYSBNZXRhTWFza1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2VuZFByZXBhcmVkVHJhbnNhY3Rpb24oXG4gICAgdHJhbnNhY3Rpb246IFByZXBhcmVkVHJhbnNhY3Rpb25cbik6IFByb21pc2U8ZXRoZXJzLlRyYW5zYWN0aW9uUmVjZWlwdD4ge1xuICAgIGlmICghaXNNZXRhTWFza0luc3RhbGxlZCgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0YU1hc2sgaXMgbm90IGluc3RhbGxlZCcpO1xuICAgIH1cblxuICAgIGF3YWl0IGNvbm5lY3RNZXRhTWFzaygpO1xuICAgIFxuICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IGV0aGVycy5Ccm93c2VyUHJvdmlkZXIoKHdpbmRvdyBhcyBhbnkpLmV0aGVyZXVtKTtcbiAgICBjb25zdCBzaWduZXIgPSBhd2FpdCBwcm92aWRlci5nZXRTaWduZXIoKTtcbiAgICBcbiAgICAvLyBNZXRhTWFzayB3aWxsIHByb21wdCB1c2VyIGZvciBhcHByb3ZhbFxuICAgIGNvbnN0IHR4ID0gYXdhaXQgc2lnbmVyLnNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgIHRvOiB0cmFuc2FjdGlvbi50byxcbiAgICAgICAgZGF0YTogdHJhbnNhY3Rpb24uZGF0YSxcbiAgICAgICAgdmFsdWU6IHRyYW5zYWN0aW9uLnZhbHVlLFxuICAgICAgICBnYXNMaW1pdDogdHJhbnNhY3Rpb24uZ2FzID8gQmlnSW50KHRyYW5zYWN0aW9uLmdhcykgOiB1bmRlZmluZWRcbiAgICB9KTtcblxuICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0eC53YWl0KCk7XG4gICAgcmV0dXJuIHJlY2VpcHQ7XG59XG4iXSwibmFtZXMiOlsiZXRoZXJzIiwiQVBJX1VSTCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfVVJMIiwiQ09OVFJBQ1RfQUJJIiwiaXNNZXRhTWFza0luc3RhbGxlZCIsIndpbmRvdyIsImV0aGVyZXVtIiwiY29ubmVjdE1ldGFNYXNrIiwiRXJyb3IiLCJwcm92aWRlciIsIkJyb3dzZXJQcm92aWRlciIsImFjY291bnRzIiwic2VuZCIsImxlbmd0aCIsImdldEN1cnJlbnRBY2NvdW50IiwibGlzdEFjY291bnRzIiwiYWRkcmVzcyIsImdldENvbnRyYWN0IiwiY29udHJhY3RBZGRyZXNzIiwic2lnbmVyIiwiZ2V0U2lnbmVyIiwiQ29udHJhY3QiLCJyZWNvcmRFdmVudFZpYU1ldGFNYXNrIiwiZmxpZ2h0SWQiLCJldmVudFR5cGUiLCJ0aW1lc3RhbXAiLCJhY3RvciIsImRhdGFIYXNoIiwiY29udHJhY3QiLCJkYXRhSGFzaEhleCIsInN0YXJ0c1dpdGgiLCJkYXRhSGFzaEJ5dGVzMzIiLCJnZXRCeXRlcyIsImdhc0VzdGltYXRlIiwicmVjb3JkRXZlbnQiLCJlc3RpbWF0ZUdhcyIsInR4IiwiZ2FzTGltaXQiLCJCaWdJbnQiLCJyZWNlaXB0Iiwid2FpdCIsImdldEZsaWdodEV2ZW50c0Zyb21DaGFpbiIsInRpbWVvdXQiLCJwcm92aWRlclByb21pc2UiLCJKc29uUnBjUHJvdmlkZXIiLCJORVhUX1BVQkxJQ19HQU5BQ0hFX1VSTCIsIlByb21pc2UiLCJyYWNlIiwiXyIsInJlamVjdCIsInNldFRpbWVvdXQiLCJpbmRpY2VzIiwiZ2V0RmxpZ2h0RXZlbnRJbmRpY2VzIiwiZXZlbnRzIiwiaW5kZXgiLCJldmVudCIsImdldEV2ZW50IiwicHVzaCIsIk51bWJlciIsImJsb2NrTnVtYmVyIiwicmVjb3JkZWRBdCIsImVycm9yIiwiY29uc29sZSIsIndhcm4iLCJwcmVwYXJlUmVjb3JkRXZlbnRUcmFuc2FjdGlvbiIsImRhdGEiLCJpbnRlcmZhY2UiLCJlbmNvZGVGdW5jdGlvbkRhdGEiLCJ0byIsInZhbHVlIiwiZ2FzIiwidG9TdHJpbmciLCJzZW5kUHJlcGFyZWRUcmFuc2FjdGlvbiIsInRyYW5zYWN0aW9uIiwic2VuZFRyYW5zYWN0aW9uIiwidW5kZWZpbmVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/web3.ts\n"));

/***/ })

});